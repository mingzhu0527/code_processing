{"Java-Python": {"ID": {"0": 237, "1": 1700, "2": 1636, "3": 680, "4": 1332, "5": 104, "6": 173, "7": 466, "8": 128, "9": 1704, "10": 343, "11": 153, "12": 65, "13": 674, "14": 34, "15": 1609, "16": 278, "17": 393, "18": 1774, "19": 643, "20": 421, "21": 210, "22": 1619, "23": 832, "24": 1346, "25": 1604, "26": 1752, "27": 334, "28": 583, "29": 650, "30": 690, "31": 1672, "32": 143, "33": 931, "34": 368, "35": 1371, "36": 436, "37": 132, "38": 319, "39": 1630, "40": 1344, "41": 973, "42": 134, "43": 282, "44": 1725, "45": 179, "46": 1029, "47": 374, "48": 279, "49": 306, "50": 38, "51": 95, "52": 1576, "53": 1300, "54": 70, "55": 1717, "56": 1323, "57": 289, "58": 1860, "59": 1759, "60": 1339, "61": 1367, "62": 692, "63": 67, "64": 230, "65": 45, "66": 525, "67": 149, "68": 765, "69": 1471, "70": 523, "71": 1437, "72": 1374, "73": 94, "74": 154, "75": 639, "76": 493, "77": 633, "78": 1920, "79": 1379, "80": 1493, "81": 1400, "82": 461, "83": 524, "84": 629, "85": 42, "86": 600, "87": 532, "88": 90, "89": 457, "90": 1807, "91": 1366, "92": 1720, "93": 116, "94": 714, "95": 675, "96": 206, "97": 881, "98": 58, "99": 1078, "100": 1455, "101": 4, "102": 659, "103": 468, "104": 1679, "105": 1732, "106": 165, "107": 1314, "108": 199, "109": 290, "110": 504, "111": 240, "112": 1408, "113": 242, "114": 1331, "115": 1287, "116": 204, "117": 849, "118": 350, "119": 1491, "120": 55, "121": 591, "122": 547, "123": 830, "124": 1360, "125": 260, "126": 1403, "127": 420, "128": 406, "129": 896, "130": 1685, "131": 17, "132": 96, "133": 414, "134": 735, "135": 1822, "136": 1325, "137": 649, "138": 33, "139": 704, "140": 417, "141": 997, "142": 1769, "143": 1502, "144": 1353, "145": 257, "146": 236, "147": 347, "148": 1189, "149": 205, "150": 167, "151": 688, "152": 403, "153": 129, "154": 698, "155": 1037, "156": 1392, "157": 957, "158": 977, "159": 1518, "160": 1601, "161": 1413, "162": 789, "163": 1362, "164": 1753, "165": 234, "166": 925, "167": 756, "168": 664, "169": 1090, "170": 1492, "171": 1541, "172": 415, "173": 37, "174": 1680, "175": 1796, "176": 164, "177": 59, "178": 1388, "179": 464, "180": 1657, "181": 299, "182": 399, "183": 1652, "184": 700, "185": 477, "186": 1207, "187": 1313, "188": 1664, "189": 718, "190": 292, "191": 365, "192": 102, "193": 712, "194": 13, "195": 784, "196": 1877, "197": 1217, "198": 993, "199": 87}, "Java": {"0": "public void deleteNode(ListNode node) {\n                        node.val = node.next.val;\n                        node.next = node.next.next;\n                }", "1": "public int countStudents(int[] students, int[] sandwiches) {\n                        Queue<Integer> studentsQueue = new LinkedList<>();\n                        Queue<Integer> sandwichesQueue = new LinkedList<>();\n                        for (int i = 0; i < sandwiches.length; i++) {\n                                studentsQueue.add(students[i]);\n                                sandwichesQueue.add(sandwiches[i]);\n                        }\n                        do {\n                                if (!studentsQueue.isEmpty()) {\n                                        if (studentsQueue.peek() == sandwichesQueue.peek()) {\n                                                studentsQueue.poll();\n                                                sandwichesQueue.poll();\n                                        } else {\n                                                if (!studentsQueue.contains(sandwichesQueue.peek())) {\n                                                        break;\n                                                }\n                                                studentsQueue.add(studentsQueue.poll());\n                                        }\n                                }\n                        } while (!studentsQueue.isEmpty());\n                        return studentsQueue.size();\n                }", "2": "public int[] frequencySort(int[] nums) {\n                        Map<Integer, Integer> count = new HashMap<>();\n                        for (int num : nums) {\n                                count.put(num, count.getOrDefault(num, 0) + 1);\n                        }\n                        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\n                        for (int num : count.keySet()) {\n                                int freq = count.get(num);\n                                if (!map.containsKey(freq)) {\n                                        map.put(freq, new ArrayList<>());\n                                }\n                                List<Integer> list = map.get(freq);\n                                list.add(num);\n                                map.put(freq, list);\n                        }\n                        int[] result = new int[nums.length];\n                        int i = 0;\n                        for (int num : map.keySet()) {\n                                List<Integer> list = map.get(num);\n                                Collections.sort(list, Collections.reverseOrder());\n                                int k = num;\n                                for (int j = 0; j < list.size(); j++, k = num) {\n                                        while (k-- > 0) {\n                                                result[i++] = list.get(j);\n                                        }\n                                }\n                        }\n                        return result;\n                }", "3": "public boolean validPalindrome(String s) {\n                        int left = 0;\n                        int right = s.length() - 1;\n                        int diff = 0;\n                        while (left < right) {\n                                if (s.charAt(left) != s.charAt(right)) {\n                                        left++;\n                                        diff++;\n                                        if (diff > 1) {\n                                                break;\n                                        }\n                                } else {\n                                        left++;\n                                        right--;\n                                }\n                        }\n                        if (diff < 2) {\n                                return true;\n                        }\n                        diff = 0;\n                        left = 0;\n                        right = s.length() - 1;\n                        while (left < right) {\n                                if (s.charAt(left) != s.charAt(right)) {\n                                        right--;\n                                        diff++;\n                                        if (diff > 1) {\n                                                break;\n                                        }\n                                } else {\n                                        left++;\n                                        right--;\n                                }\n                        }\n                        return diff < 2;\n                }", "4": "public int removePalindromeSub(String s) {\n                        if (s.isEmpty()) {\n                                return 0;\n                        }\n                        if (s.equals((new StringBuilder(s)).reverse().toString())) {\n                                return 1;\n                        }\n                        return 2;\n                }", "5": "public int maxDepth(TreeNode root) {\n                        if (root == null) {\n                                return 0;\n                        }\n                        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n                }", "6": "There is no code for this data point", "7": "public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n                        char[] s1chars = s1.toCharArray();\n                        char[] s2chars = s2.toCharArray();\n                        int i = 0;\n                        int j = 0;\n                        int count1 = 0;\n                        int count2 = 0;\n                        while (count1 < n1) {\n                                if (s1chars[i] == s2chars[j]) {\n                                        j++;\n                                        if (j == s2.length()) {\n                                                j = 0;\n                                                count2++;\n                                        }\n                                }\n                                i++;\n                                if (i == s1.length()) {\n                                        i = 0;\n                                        count1++;\n                                }\n                        }\n                        return count2 / n2;\n                }", "8": "public int longestConsecutive(int[] nums) {\n                        Map<Integer, Integer> map = new HashMap();\n                        UnionFind uf = new UnionFind(nums);\n                        for (int i = 0; i < nums.length; i++) {\n                                if (map.containsKey(nums[i])) {\n                                        continue;\n                                }\n                                map.put(nums[i], i);\n                                if (map.containsKey(nums[i] - 1)) {\n                                        uf.union(i, map.get(nums[i] - 1));\n                                }\n                                if (map.containsKey(nums[i] + 1)) {\n                                        uf.union(i, map.get(nums[i] + 1));\n                                }\n                        }\n                        return uf.maxUnion();\n                }", "9": "public boolean halvesAreAlike(String s) {\n                        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n                        int firstHalfVowelsCount = (int) IntStream.range(0, s.length() / 2).filter(i -> vowels.contains(s.charAt(i))).count();\n                        int secondHalfVowelsCount = (int) IntStream.range(s.length() / 2, s.length()).filter(i -> vowels.contains(s.charAt(i))).count();\n                        return firstHalfVowelsCount == secondHalfVowelsCount;\n                }", "10": "public int integerBreak(int n) {\n                        if (n == 2) {\n                                return 1;\n                        } else if (n == 3) {\n                                return 2;\n                        } else if (n % 3 == 0) {\n                                return (int) Math.pow(3, n / 3);\n                        } else if (n % 3 == 1) {\n                                return 2 * 2 * (int) Math.pow(3, (n - 4) / 3);\n                        } else {\n                                return 2 * (int) Math.pow(3, n / 3);\n                        }\n                }", "11": "public int findMin(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n        if (nums[left] < nums[right]) {\n                return nums[left];\n        }\n        int min = nums[0];\n        while (left + 1 < right) {\n                int mid = left + (right - left) / 2;\n                min = Math.min(min, nums[mid]);\n                if (nums[mid] > nums[left]) {\n                min = Math.min(nums[left], min);\n                left = mid + 1;\n                } else if (nums[mid] < nums[left]) {\n                right = mid - 1;\n                }\n        }\n        min = Math.min(min, Math.min(nums[left], nums[right]));\n        return min;\n        }", "12": "public boolean isNumber(String s) {\n                        s = s.trim();\n                        boolean pointSeen = false;\n                        boolean eSeen = false;\n                        boolean numberSeen = false;\n                        boolean numberAfterE = true;\n                        for (int i = 0; i < s.length(); i++) {\n                                if ('0' <= s.charAt(i) && s.charAt(i) <= '9') {\n                                        numberSeen = true;\n                                        numberAfterE = true;\n                                } else if (s.charAt(i) == '.') {\n                                        if (eSeen pointSeen) {\n                                                return false;\n                                        }\n                                        pointSeen = true;\n                                } else if (s.charAt(i) == 'e') {\n                                        if (eSeen !numberSeen) {\n                                                return false;\n                                        }\n                                        numberAfterE = false;\n                                        eSeen = true;\n                                } else if (s.charAt(i) == '-' || s.charAt(i) == '+') {\n                                        if (i != 0 && s.charAt(i - 1) != 'e') {\n                                                return false;\n                                        }\n                                } else {\n                                        return false;\n                                }\n                        }\n                        return numberSeen && numberAfterE;\n                }", "13": "public int findLengthOfLCIS(int[] nums) {\n                        int longest = 0;\n                        for (int i = 0; i < nums.length; i++) {\n                                int len = 1;\n                                for (int j = i + 1; j < nums.length; j++) {\n                                        if (nums[j - 1] < nums[j]) {\n                                                len++;\n                                                continue;\n                                        } else {\n                                                break;\n                                        }\n                                }\n                                longest = Math.max(longest, len);\n                        }\n                        return longest;\n                }", "14": "public int[] searchRange(int[] nums, int target) {\n                        int[] range = new int[2];\n                        range[0] = -1;\n                        range[1] = -1;\n                        if (nums == null nums.length == 0) {\n                                return range;\n                        }\n                        int start = 0;\n                        int end = nums.length - 1;\n                        while (start + 1 < end) {\n                                int mid = start + (end - start) / 2;\n                                if (nums[mid] == target) {\n                                        int left = mid;\n                                        while (left - 1 >= 0 && nums[left] == nums[left - 1]) {\n                                                left--;\n                                        }\n                                        range[0] = left;\n                                        int right = mid;\n                                        while (right + 1 < nums.length && nums[right] == nums[right + 1]) {\n                                                right++;\n                                        }\n                                        range[1] = right;\n                                        break;\n                                } else if (nums[mid] < target) {\n                                        start = mid;\n                                } else {\n                                        end = mid;\n                                }\n                        }\n                        if (nums[start] == target) {\n                                range[0] = start;\n                                while (start + 1 < nums.length && nums[start] == nums[start + 1]) {\n                                        start++;\n                                }\n                                range[1] = start;\n                        } else if (nums[end] == target) {\n                                range[1] = end;\n                                while (end - 1 >= 0 && nums[end] == nums[end - 1]) {\n                                        end--;\n                                }\n                                range[0] = end;\n                        }\n                        return range;\n                }", "15": "public boolean isEvenOddTree(TreeNode root) {\n                        Queue<TreeNode> queue = new LinkedList<>();\n                        queue.offer(root);\n                        int level = 0;\n                        while (!queue.isEmpty()) {\n                                int size = queue.size();\n                                List<Integer> list = new ArrayList<>();\n                                for (int i = 0; i < size; i++) {\n                                        TreeNode node = queue.poll();\n                                        list.add(node.val);\n                                        if (node.left != null) {\n                                                queue.add(node.left);\n                                        }\n                                        if (node.right != null) {\n                                                queue.add(node.right);\n                                        }\n                                }\n                                if (level % 2 == 0) {\n                                        for (int i = 0; i < list.size(); i++) {\n                                                if (list.get(i) % 2 == 0) {\n                                                        return false;\n                                                }\n                                                if (i < list.size() - 1 && list.get(i) >= list.get(i + 1)) {\n                                                        return false;\n                                                }\n                                        }\n                                } else {\n                                        for (int i = 0; i < list.size(); i++) {\n                                                if (list.get(i) % 2 != 0) {\n                                                        return false;\n                                                }\n                                                if (i < list.size() - 1 && list.get(i) <= list.get(i + 1)) {\n                                                        return false;\n                                                }\n                                        }\n                                }\n                                level++;\n                        }\n                        return true;\n                }", "16": "public int firstBadVersion(int n) {\n                        int left = 1;\n                        int right = n;\n                        while (left < right) {\n                                int mid = left + (right - left) / 2;\n                                if (isBadVersion(mid)) {\n                                        right = mid;\n                                } else {\n                                        left = mid + 1;\n                                }\n                        }\n                        return left;\n                }\nprivate boolean isBadVersion(int left) {\n                        return false;\n                }", "17": "public boolean validUtf8(int[] data) {\n                        int count = 0;\n                        for (int d : data) {\n                                if (count == 0) {\n                                        if ((d >> 5) == 0b110) {\n                                                count = 1;\n                                        } else if ((d >> 4) == 0b1110) {\n                                                count = 2;\n                                        } else if ((d >> 3) == 0b11110) {\n                                                count = 3;\n                                        } else if ((d >> 7) == 1) {\n                                                return false;\n                                        }\n                                } else {\n                                        if ((d >> 6) != 0b10) {\n                                                return false;\n                                        } else {\n                                                count--;\n                                        }\n                                }\n                        }\n                        return count == 0;\n                }", "18": "public int closestCost(int[] baseCosts, int[] toppingCosts, int target) {\n                        result = baseCosts[0];\n                        for (int i = 0; i < baseCosts.length; i++) {\n                                recursion(baseCosts[i], toppingCosts, 0, target);\n                        }\n                        return result;\n                }\nprivate void recursion(int currentCost, int[] toppingCosts, int index, int target) {\n                        if (Math.abs(currentCost - target) < Math.abs(result - target) || (Math.abs(currentCost - target) < Math.abs(result - target) && currentCost == result)) {\n                                result = currentCost;\n                        }\n                        if (index == toppingCosts.length currentCost == target) {\n                                return;\n                        }\n                        recursion(currentCost, toppingCosts, index + 1, target);\n                        recursion(currentCost + toppingCosts[index], toppingCosts, index + 1, target);\n                        recursion(currentCost + toppingCosts[index] * 2, toppingCosts, index + 1, target);\n                }", "19": "public double findMaxAverage(int[] nums, int k) {\n                        double sum = 0;\n                        double maxAve = Integer.MIN_VALUE;\n                        for (int i = 0; i < nums.length; i++) {\n                                if (k <= i) {\n                                        sum -= nums[i - k];\n                                }\n                                sum += nums[i];\n                                if ((i + 1) >= k) {\n                                        maxAve = Math.max(maxAve, sum / k);\n                                }\n                        }\n                        return maxAve;\n                }", "20": "public int findMaximumXOR(int[] nums) {\n                        int max = 0;\n                        int mask = 0;\n                        for (int i = 31; i >= 0; i--) {\n                                mask |= (1 << i);\n                                System.out.println(\"mask = \" + Integer.toBinaryString(mask));\n                                Set<Integer> set = new HashSet<>();\n                                for (int num : nums) {\n                                        System.out.println(\"num = \" + Integer.toBinaryString(num));\n                                        set.add(num & mask);\n                                        System.out.println(\"mask & num = \" + Integer.toBinaryString(mask & num));\n                                }\n                                int candidate = max | (1 << i);\n                                System.out.println(\"candidate = \" + Integer.toBinaryString(candidate));\n                                for (int prefix : set) {\n                                        System.out.println(\"candidate ^ prefix = \" + Integer.toBinaryString(candidate ^ prefix));\n                                        if (set.contains(candidate ^ prefix)) {\n                                                max = candidate;\n                                        }\n                                }\n                                System.out.println(\"max = \" + max);\n                                System.out.println(\"i = \" + i);\n                                System.out.println(\"===============================================\");\n                        }\n                        return max;\n                }", "21": "There is no code for this data point", "22": "public double trimMean(int[] arr) {\n                        Arrays.sort(arr);\n                        int n = arr.length;\n                        long sum = 0;\n                        for (int i = (int) Math.round(n * 0.05); i < (n - n * 0.05); i++) {\n                                sum += arr[i];\n                        }\n                        return sum / (n - n * 0.1);\n                }", "23": "public int[][] flipAndInvertImage(int[][] A) {\n                        int m = A.length;\n                        int n = A[0].length;\n                        int[][] result = new int[m][n];\n                        for (int i = 0; i < m; i++) {\n                                int[] flipped = (reverse(A[i]));\n                                result[i] = invert(flipped);\n                        }\n                        return result;\n                }\nprivate int[] invert(int[] flipped) {\n                        int[] result = new int[flipped.length];\n                        for (int i = 0; i < flipped.length; i++) {\n                                if (flipped[i] == 0) {\n                                        result[i] = 1;\n                                } else {\n                                        result[i] = 0;\n                                }\n                        }\n                        return result;\n                }\nprivate int[] reverse(int[] nums) {\n                        for (int i = 0, j = nums.length - 1; i < j; i++, j--) {\n                                int tmp = nums[i];\n                                nums[i] = nums[j];\n                                nums[j] = tmp;\n                        }\n                        return nums;\n                }", "24": "public boolean checkIfExist(int[] arr) {\n                        for (int i = 0; i < arr.length; i++) {\n                                for (int j = 0; j < arr.length; j++) {\n                                        if (i != j && (arr[i] * 2 == arr[j] arr[i] == arr[j] * 2)) {\n                                                return true;\n                                        }\n                                }\n                        }\n                        return false;\n                }", "25": "public List<String> alertNames(String[] keyName, String[] keyTime) {\n                        Map<String, List<String>> map = new HashMap<>();\n                        for (int i = 0; i < keyName.length; i++) {\n                                if (!map.containsKey(keyName[i])) {\n                                        map.put(keyName[i], new ArrayList<>());\n                                }\n                                map.get(keyName[i]).add(keyTime[i]);\n                        }\n                        List<String> people = new ArrayList<>();\n                        for (String person : map.keySet()) {\n                                List<String> times = map.get(person);\n                                List<Integer> minutes = new ArrayList<>();\n                                for (String time : times) {\n                                        String[] hourAndMin = time.split(\":\");\n                                        Integer minute = Integer.parseInt(hourAndMin[0]) * 60 + Integer.parseInt(hourAndMin[1]);\n                                        minutes.add(minute);\n                                }\n                                Collections.sort(minutes);\n                                for (int i = 0; i < minutes.size() - 2; i++) {\n                                        if (minutes.get(i + 2) - minutes.get(i) <= 60) {\n                                                people.add(person);\n                                                break;\n                                        }\n                                }\n                        }\n                        Collections.sort(people);\n                        return people;\n                }", "26": "public boolean check(int[] nums) {\n                        int[] copy = Arrays.copyOf(nums, nums.length);\n                        Arrays.sort(copy);\n                        for (int i = 1; i <= nums.length; i++) {\n                                int[] rotated = rotate(nums, i);\n                                if (Arrays.equals(rotated, copy)) {\n                                        return true;\n                                }\n                        }\n                        return false;\n                }\nprivate int[] rotate(int[] nums, int start) {\n                        int[] rotated = new int[nums.length];\n                        int j = 0;\n                        for (int i = start; i < nums.length; i++, j++) {\n                                rotated[j] = nums[i];\n                        }\n                        for (int i = 0; i < start; i++) {\n                                rotated[j++] = nums[i];\n                        }\n                        return rotated;\n                }", "27": "public boolean increasingTriplet(int[] nums) {\n                        if (nums == null nums.length == 0) {\n                                return false;\n                        }\n                        int small = nums[0];\n                        int medium = Integer.MAX_VALUE;\n                        for (int i = 1; i < nums.length; i++) {\n                                small = Math.min(small, nums[i - 1]);\n                                if (nums[i] > small) {\n                                        medium = Math.min(medium, nums[i]);\n                                        for (int j = i + 1; j < nums.length; j++) {\n                                                if (nums[j] > nums[i] nums[j] > medium) {\n                                                        return true;\n                                                }\n                                        }\n                                }\n                        }\n                        return false;\n                }", "28": "public int minDistance(String word1, String word2) {\n                        int m = word1.length();\n                        int n = word2.length();\n                        int[][] dp = new int[m + 1][n + 1];\n                        for (int i = 1; i <= m; i++) {\n                                for (int j = 1; j <= n; j++) {\n                                        dp[i][j] = word1.charAt(i - 1) == word2.charAt(j - 1) ? dp[i - 1][j - 1] + 1 : Math.max(dp[i - 1][j], dp[i][j - 1]);\n                                }\n                        }\n                        return m + n - 2 * dp[m][n];\n                }", "29": "public int minSteps(int n) {\n                        int[] dp = new int[n + 1];\n                        for (int i = 2; i <= n; i++) {\n                                dp[i] = i;\n                                for (int j = i - 1; j > 1; j--) {\n                                        if (i % j == 0) {\n                                                dp[i] = dp[j] + (i / j);\n                                                break;\n                                        }\n                                }\n                        }\n                        return dp[n];\n                }", "30": "public int getImportance(List<Employee> employees, int id) {\n                        Employee manager = employees.stream().filter(e -> e.id == id).collect(Collectors.toList()).get(0);\n                        total += manager.importance;\n                        manager.subordinates.forEach(subId -> getImportance(employees, subId));\n                        return total;\n                }", "31": "public int maximumWealth(int[][] accounts) {\n                        int m = accounts.length;\n                        int n = accounts[0].length;\n                        int max = 0;\n                        for (int i = 0; i < m; i++) {\n                                int sum = 0;\n                                for (int j = 0; j < n; j++) {\n                                        sum += accounts[i][j];\n                                }\n                                max = Math.max(max, sum);\n                        }\n                        return max;\n                }", "32": "public void reorderList(ListNode head) {\n                        if (head == null head.next == null) {\n                                return;\n                        }\n                        ListNode slowNode = head;\n                        ListNode fastNode = head;\n                        while (fastNode.next != null) {\n                                fastNode = fastNode.next;\n                                if (fastNode.next != null) {\n                                        fastNode = fastNode.next;\n                                } else {\n                                        break;\n                                }\n                                slowNode = slowNode.next;\n                        }\n                        ListNode head1 = head;\n                        ListNode head2 = slowNode.next;\n                        slowNode.next = null;\n                        ListNode cur = head2;\n                        ListNode post = cur.next;\n                        cur.next = null;\n                        while (post != null) {\n                                ListNode temp = post.next;\n                                post.next = cur;\n                                cur = post;\n                                post = temp;\n                        }\n                        head2 = cur;\n                        ListNode p = head1;\n                        ListNode q = head2;\n                        while (q != null) {\n                                ListNode temp1 = p.next;\n                                ListNode temp2 = q.next;\n                                p.next = q;\n                                q.next = temp1;\n                                p = temp1;\n                                q = temp2;\n                        }\n                }", "33": "public int minFallingPathSum(int[][] A) {\n                        int size = A.length;\n                        int[][] dp = new int[size][size];\n                        for (int i = 0; i < size; i++) {\n                                for (int j = 0; j < size; j++) {\n                                        if (i == 0) {\n                                                dp[i][j] = A[i][j];\n                                        } else {\n                                                int lastRow = dp[i - 1][j];\n                                                if (j - 1 >= 0) {\n                                                        lastRow = Math.min(dp[i - 1][j - 1], lastRow);\n                                                }\n                                                if (j + 1 < size) {\n                                                        lastRow = Math.min(dp[i - 1][j + 1], lastRow);\n                                                }\n                                                dp[i][j] = lastRow + A[i][j];\n                                        }\n                                }\n                        }\n                        int minSum = Integer.MAX_VALUE;\n                        for (int i = 0; i < size; i++) {\n                                minSum = Math.min(minSum, dp[size - 1][i]);\n                        }\n                        return minSum;\n                }", "34": "public List<Integer> largestDivisibleSubset(int[] nums) {\n                        int len = nums.length;\n                        int[] count = new int[len];\n                        int[] pre = new int[len];\n                        Arrays.sort(nums);\n                        int max = 0;\n                        int index = -1;\n                        for (int i = 0; i < len; i++) {\n                                count[i] = 1;\n                                pre[i] = -1;\n                                for (int j = i - 1; j >= 0; j--) {\n                                        if (nums[i] % nums[j] == 0) {\n                                                if (1 + count[j] > count[i]) {\n                                                        count[i] = count[j] + 1;\n                                                        pre[i] = j;\n                                                }\n                                        }\n                                }\n                                if (count[i] > max) {\n                                        max = count[i];\n                                        index = i;\n                                }\n                        }\n                        List<Integer> res = new ArrayList<>();\n                        while (index != -1) {\n                                res.add(nums[index]);\n                                index = pre[index];\n                        }\n                        return res;\n                }", "35": "public int findTheLongestSubstring(String s) {\n                        int max = 0;\n                        for (int i = 0; i < s.length(); i++) {\n                                Map<Character, Integer> map = setupMap();\n                                if (s.length() - i < max) {\n                                        return max;\n                                }\n                                for (int j = i; j < s.length(); j++) {\n                                        Character b = s.charAt(j);\n                                        if (map.containsKey(b)) {\n                                                map.put(b, map.get(b) + 1);\n                                        }\n                                        if (allEven(map)) {\n                                                max = Math.max(max, j - i + 1);\n                                        }\n                                }\n                        }\n                        return max;\n                }\nprivate Map<Character, Integer> setupMap() {\n                        Map<Character, Integer> map = new HashMap<>();\n                        map.put('a', 0);\n                        map.put('e', 0);\n                        map.put('i', 0);\n                        map.put('o', 0);\n                        map.put('u', 0);\n                        return map;\n                }\nprivate boolean allEven(Map<Character, Integer> map) {\n                        for (char c : map.keySet()) {\n                                if (map.get(c) % 2 != 0) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }", "36": "public int[] findRightInterval(int[][] intervals) {\n                        TreeMap<Integer, Integer> map = new TreeMap<>();\n                        int[] res = new int[intervals.length];\n                        for (int i = 0; i < intervals.length; i++) {\n                                map.put(intervals[i][0], i);\n                        }\n                        for (int i = 0; i < intervals.length; i++) {\n                                Integer key = map.ceilingKey(intervals[i][intervals[i].length - 1]);\n                                res[i] = key != null ? map.get(key) : -1;\n                        }\n                        return res;\n                }", "37": "public int minCut(String s) {\n                int n = s.length();\n                char[] c = s.toCharArray();\n                boolean[][] dp = new boolean[n][n];\n                int[] cut = new int[n];\n                for (int i = 0; i < n; i++) {\n                cut[i] = i;\n                for (int j = 0; j <= i; j++) {\n                        if (c[i] == c[j] && (j + 1 > i - 1 dp[j + 1][i - 1])) {\n                        dp[j][i] = true;\n                        if (j == 0) {\n                                cut[i] = 0;\n                        } else {\n                                cut[i] = (cut[i] < cut[j - 1] + 1) ? cut[i] : cut[j - 1] + 1;\n                        }\n                        }\n                }\n                }\n                return cut[n - 1];\n        }", "38": "public int bulbSwitch(int n) {\n                        if (n < 2) {\n                                return n;\n                        }\n                        return (int) Math.sqrt(n);\n                }", "39": "public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {\n                        List<Boolean> result = new ArrayList<>();\n                        for (int i = 0; i < l.length; i++) {\n                                if (isArithmetic(nums, l[i], r[i])) {\n                                        result.add(true);\n                                } else {\n                                        result.add(false);\n                                }\n                        }\n                        return result;\n                }\nprivate boolean isArithmetic(int[] nums, int start, int end) {\n                        List<Integer> list = new ArrayList<>();\n                        for (int i = start; i <= end; i++) {\n                                list.add(nums[i]);\n                        }\n                        Collections.sort(list);\n                        for (int i = 1; i < list.size(); i++) {\n                                if (list.get(i) - list.get(i - 1) != list.get(1) - list.get(0)) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }", "40": "public double angleClock(int hour, int minutes) {\n                        double minAngle = minutes * 360 / 60;\n                        double hourAnglePart1 = hour != 12 ? (hour * 360) / 12 : 0;\n                        double hourAnglePart2 = (double) (30 * minutes) / (double) 60;\n                        double hourAngle = hourAnglePart1 + hourAnglePart2;\n                        double preResult = Math.abs(minAngle - (hourAngle));\n                        return preResult > 180 ? 360 - preResult : preResult;\n                }", "41": "public int[][] kClosest(int[][] points, int K) {\n                        int[][] ans = new int[K][2];\n                        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> {\n                                double dist1 = getDistance(o1);\n                                double dist2 = getDistance(o2);\n                                if (dist1 > dist2) {\n                                        return 1;\n                                } else if (dist1 < dist2) { return -1; } else { return 0; } });\n                        for (int[] point : points) {\n                                pq.add(point);\n                        }\n                        for (int i = 0; i < K; i++) {\n                                ans[i] = pq.poll();\n                        }\n                        return ans;\n                }\nprivate double getDistance(int[] point) {\n                        return Math.sqrt(Math.pow(point[0], 2) + Math.pow(point[1], 2));\n                }", "42": "public int canCompleteCircuit(int[] gas, int[] cost) {\n        int start = gas.length - 1;\n        int end = 0;\n        int sum = gas[start] - cost[start];\n        while (start > end) {\n                if (sum >= 0) {\n                sum += gas[end] - cost[end];\n                end++;\n                } else {\n                start--;\n                sum += gas[start] - cost[start];\n                }\n        }\n        return sum >= 0 ? start : -1;\n        }", "43": "public List<String> addOperators(String num, int target) {\n                        List<String> res = new ArrayList<>();\n                        StringBuilder sb = new StringBuilder();\n                        dfs(res, sb, num, 0, target, 0, 0);\n                        return res;\n                }\nprivate void dfs(List<String> res, StringBuilder sb, String num, int pos, int target, long prev, long multi) {\n                        if (pos == num.length()) {\n                                if (target == prev) {\n                                        res.add(sb.toString());\n                                }\n                                return;\n                        }\n                        for (int i = pos; i < num.length(); i++) {\n                                if (num.charAt(pos) == '0' && i != pos) {\n                                        break;\n                                }\n                                long curr = Long.parseLong(num.substring(pos, i + 1));\n                                int len = sb.length();\n                                if (pos == 0) {\n                                        dfs(res, sb.append(curr), num, i + 1, target, curr, curr);\n                                        sb.setLength(len);\n                                } else {\n                                        dfs(res, sb.append(\"+\").append(curr), num, i + 1, target, prev + curr, curr);\n                                        sb.setLength(len);\n                                        dfs(res, sb.append(\"-\").append(curr), num, i + 1, target, prev - curr, -curr);\n                                        sb.setLength(len);\n                                        dfs(res, sb.append(\"*\").append(curr), num, i + 1, target, prev - multi + multi * curr, multi * curr);\n                                        sb.setLength(len);\n                                }\n                        }\n                }", "44": "public int countGoodRectangles(int[][] rectangles) {\n                        TreeMap<Integer, Integer> map = new TreeMap<>();\n                        for (int[] rec : rectangles) {\n                                int min = Math.min(rec[0], rec[1]);\n                                map.put(min, map.getOrDefault(min, 0) + 1);\n                        }\n                        return map.lastEntry().getValue();\n                }", "45": "public String largestNumber(int[] num) {\n        if (num.length == 0) {\n                return \"\";\n        }\n        if (num.length == 1) {\n                return Integer.toString(num[0]);\n        }\n        String[] str = new String[num.length];\n        for (int i = 0; i < num.length; i++) {\n                str[i] = Integer.toString(num[i]);\n        }\n        Arrays.sort(str, new StringComparator());\n        StringBuilder sb = new StringBuilder(\"\");\n        for (int i = num.length - 1; i >= 0; i--) {\n                sb.append(str[i]);\n        }\n        if (sb.charAt(0) == '0') {\n                return \"0\";\n        }\n        return sb.toString();\n        }\npublic int compare(String s1, String s2) {\n                if (s1.length() == 0 && s2.length() == 0) {\n                return 0;\n                }\n                if (s2.length() == 0) {\n                return 1;\n                }\n                if (s1.length() == 0) {\n                return -1;\n                }\n                for (int i = 0; i < s1.length() && i < s2.length(); i++) {\n                if (s1.charAt(i) > s2.charAt(i)) {\n                        return 1;\n                } else if (s1.charAt(i) < s2.charAt(i)) {\n                        return -1;\n                }\n                }\n                if (s1.length() == s2.length()) {\n                return 0;\n                }\n                if (s1.length() > s2.length()) {\n                if (s1.charAt(0) < s1.charAt(s2.length())) {\n                        return 1;\n                } else if (s1.charAt(0) > s1.charAt(s2.length())) {\n                        return -1;\n                } else {\n                        return compare(s1.substring(s2.length()), s2);\n                }\n                } else {\n                if (s2.charAt(0) < s2.charAt(s1.length())) {\n                        return -1;\n                } else if (s2.charAt(0) > s2.charAt(s1.length())) {\n                        return 1;\n                } else {\n                        return compare(s1, s2.substring(s1.length()));\n                }\n                }\n        }", "46": "public int twoCitySchedCost(int[][] costs) {\n                        Arrays.sort(costs, (a, b) -> (a[0] - a[1] - (b[0] - b[1])));\n                        int cost = 0;\n                        for (int i = 0; i < costs.length; i++) {\n                                if (i < costs.length / 2) {\n                                        cost += costs[i][0];\n                                } else {\n                                        cost += costs[i][1];\n                                }\n                        }\n                        return cost;\n                }", "47": "public int guessNumber(int n) {\n                        int left = 1;\n                        int right = n;\n                        while (left + 1 < right) {\n                                int mid = left + (right - left) / 2;\n                                int g = guess(mid);\n                                if (g == 0) {\n                                        return mid;\n                                } else if (g > 0) {\n                                        left = mid;\n                                } else {\n                                        right = mid;\n                                }\n                        }\n                        if (guess(left) == 0) {\n                                return left;\n                        }\n                        return right;\n                }\nprivate int guess(int num) {\n                        if (num > 6) {\n                                return -1;\n                        } else if (num < 6) {\n                                return 1;\n                        } else {\n                                return 0;\n                        }\n                }", "48": "public int numSquares(int n) {\n                        int result = n;\n                        int num = 2;\n                        while (num * num <= n) {\n                                int temp1 = n / (num * num);\n                                int temp2 = n % (num * num);\n                                result = Math.min(result, temp1 + numSquares(temp2));\n                                num++;\n                        }\n                        return result;\n                }", "49": "public boolean isAdditiveNumber(String num) {\n                        int n = num.length();\n                        for (int i = 1; i <= n / 2; ++i) {\n                                for (int j = 1; Math.max(j, i) <= n - i - j; ++j) {\n                                        if (isValid(i, j, num)) {\n                                                return true;\n                                        }\n                                }\n                        }\n                        return false;\n                }\nprivate boolean isValid(int i, int j, String num) {\n                        if (num.charAt(0) == '0' && i > 1) {\n                                return false;\n                        }\n                        if (num.charAt(i) == '0' && j > 1) {\n                                return false;\n                        }\n                        String sum;\n                        Long x1 = Long.parseLong(num.substring(0, i));\n                        Long x2 = Long.parseLong(num.substring(i, i + j));\n                        for (int start = i + j; start != num.length(); start += sum.length()) {\n                                x2 = x2 + x1;\n                                x1 = x2 - x1;\n                                sum = x2.toString();\n                                if (!num.startsWith(sum, start)) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }", "50": "public String countAndSay(int n) {\n                        StringBuilder curr = new StringBuilder(\"1\");\n                        StringBuilder prev;\n                        int count;\n                        char say;\n                        for (int i = 1; i < n; i++) {\n                                prev = curr;\n                                curr = new StringBuilder();\n                                count = 1;\n                                say = prev.charAt(0);\n                                for (int j = 1, len = prev.length(); j < len; j++) {\n                                        if (prev.charAt(j) != say) {\n                                                curr.append(count).append(say);\n                                                count = 1;\n                                                say = prev.charAt(j);\n                                        } else {\n                                                count++;\n                                        }\n                                }\n                                curr.append(count).append(say);\n                        }\n                        return curr.toString();\n                }", "51": "public List<TreeNode> generateTrees(int n) {\n                        List<TreeNode> result = new ArrayList();\n                        if (n == 0) {\n                                return result;\n                        }\n                        return generateTrees(1, n);\n                }\nprivate List<TreeNode> generateTrees(int start, int end) {\n                        List<TreeNode> result = new ArrayList();\n                        if (start > end) {\n                                result.add(null);\n                                return result;\n                        }\n                        if (start == end) {\n                                result.add(new TreeNode(start));\n                                return result;\n                        }\n                        for (int i = start; i <= end; i++) {\n                                List<TreeNode> leftList = generateTrees(start, i - 1);\n                                List<TreeNode> rightList = generateTrees(i + 1, end);\n                                for (TreeNode left : leftList) {\n                                        for (TreeNode right : rightList) {\n                                                TreeNode root = new TreeNode(i);\n                                                root.left = left;\n                                                root.right = right;\n                                                result.add(root);\n                                        }\n                                }\n                        }\n                        return result;\n                }", "52": "public String modifyString(String s) {\n                        char[] arr = s.toCharArray();\n                        for (int i = 0; i < arr.length; i++) {\n                                if (arr[i] == '?') {\n                                        for (int j = 0; j < 3; j++) {\n                                                if (i > 0 && arr[i - 1] == 'a' + j) {\n                                                        continue;\n                                                } else if (i < arr.length - 1 && arr[i + 1] == 'a' + j) {\n                                                        continue;\n                                                } else {\n                                                        arr[i] = (char) ('a' + j);\n                                                        break;\n                                                }\n                                        }\n                                }\n                        }\n                        return String.valueOf(arr);\n                }", "53": "public int findBestValue(int[] arr, int target) {\n                        int ave = target / arr.length;\n                        int min = findMin(arr);\n                        int max = findMax(arr);\n                        int closetDiff = findClosestDiffIfReplaceWithVal(arr, ave, target);\n                        int bestValue = ave;\n                        int candidateOnTheRight = ave;\n                        while (candidateOnTheRight <= max) {\n                                int thisOne = findClosestDiffIfReplaceWithVal(arr, ++candidateOnTheRight, target);\n                                if (thisOne >= closetDiff) {\n                                        break;\n                                } else {\n                                        closetDiff = thisOne;\n                                        bestValue = candidateOnTheRight;\n                                }\n                        }\n                        int candidateOnTheLeft = ave;\n                        while (candidateOnTheLeft >= min) {\n                                int thisOne = findClosestDiffIfReplaceWithVal(arr, --candidateOnTheLeft, target);\n                                if (thisOne >= closetDiff) {\n                                        break;\n                                } else {\n                                        closetDiff = thisOne;\n                                        bestValue = candidateOnTheLeft;\n                                }\n                        }\n                        return bestValue;\n                }\nprivate int findClosestDiffIfReplaceWithVal(int[] arr, int replaceValue, int target) {\n                        int sum = 0;\n                        for (int i = 0; i < arr.length; i++) {\n                                if (arr[i] > replaceValue) {\n                                        sum += replaceValue;\n                                } else {\n                                        sum += arr[i];\n                                }\n                        }\n                        return Math.abs(sum - target);\n                }\nprivate int findMax(int[] arr) {\n                        int max = arr[0];\n                        for (int i = 1; i < arr.length; i++) {\n                                max = Math.max(max, arr[i]);\n                        }\n                        return max;\n                }\nprivate int findMin(int[] arr) {\n                        int min = arr[0];\n                        for (int i = 1; i < arr.length; i++) {\n                                min = Math.min(min, arr[i]);\n                        }\n                        return min;\n                }", "54": "public int climbStairs(int n) {\n                        if (n == 1) {\n                                return n;\n                        }\n                        int[] dp = new int[n + 1];\n                        dp[1] = 1;\n                        dp[2] = 2;\n                        for (int i = 3; i <= n; i++) {\n                                dp[i] = dp[i - 1] + dp[i - 2];\n                        }\n                        return dp[n];\n                }", "55": "public int maximumGain(String s, int x, int y) {\n                        Stack<Character> stack1 = new Stack<>();\n                        int big = x > y ? x : y;\n                        int small = big == x ? y : x;\n                        char first = x == big ? 'a' : 'b';\n                        char second = first == 'a' ? 'b' : 'a';\n                        int maximumGain = 0;\n                        for (char c : s.toCharArray()) {\n                                if (c == second && !stack1.isEmpty() && stack1.peek() == first) {\n                                        stack1.pop();\n                                        maximumGain += big;\n                                } else {\n                                        stack1.push(c);\n                                }\n                        }\n                        Stack<Character> stack2 = new Stack<>();\n                        while (!stack1.isEmpty()) {\n                                char c = stack1.pop();\n                                if (c == second && !stack2.isEmpty() && stack2.peek() == first) {\n                                        stack2.pop();\n                                        maximumGain += small;\n                                } else {\n                                        stack2.push(c);\n                                }\n                        }\n                        return maximumGain;\n                }", "56": "public int maximum69Number(int num) {\n                        char[] chars = Integer.toString(num).toCharArray();\n                        IntStream.range(0, chars.length).filter(i -> chars[i] == '6').findFirst().ifPresent(i -> chars[i] = '9');\n                        return Integer.parseInt(new String(chars));\n                }", "57": "public void gameOfLife(int[][] board) {\n                        int height = board.length;\n                        int width = board[0].length;\n                        int[][] next = new int[height][width];\n                        int[][] directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};\n                        for (int i = 0; i < board.length; i++) {\n                                for (int j = 0; j < board[0].length; j++) {\n                                        int liveCellsCount = 0;\n                                        for (int[] dir : directions) {\n                                                int x = i + dir[0];\n                                                int y = j + dir[1];\n                                                if (x >= 0 && y >= 0 && x < height && y < width && board[x][y] == 1) {\n                                                        liveCellsCount++;\n                                                }\n                                        }\n                                        if (board[i][j] == 1) {\n                                                if (liveCellsCount <= 3 && liveCellsCount >= 2) {\n                                                        next[i][j] = 1;\n                                                }\n                                        } else if (board[i][j] == 0) {\n                                                if (liveCellsCount == 3) {\n                                                        next[i][j] = 1;\n                                                }\n                                        }\n                                }\n                        }\n                        for (int i = 0; i < board.length; i++) {\n                                for (int j = 0; j < board[0].length; j++) {\n                                        board[i][j] = next[i][j];\n                                }\n                        }\n                }", "58": "public int[] memLeak(int memory1, int memory2) {\n                        int time = 1;\n                        while (memory1 >= time memory2 >= time) {\n                                if (memory1 >= memory2) {\n                                        memory1 -= time;\n                                } else {\n                                        memory2 -= time;\n                                }\n                                time++;\n                        }\n                        return new int[]{time, memory1, memory2};\n                }", "59": "public int minOperations(String s) {\n                        int ops1 = 0;\n                        boolean isZero = true;\n                        for (int i = 0; i < s.length(); i++) {\n                                if (i % 2 == 0) {\n                                        if (s.charAt(i) != '0') {\n                                                ops1++;\n                                        }\n                                } else {\n                                        if (s.charAt(i) != '1') {\n                                                ops1++;\n                                        }\n                                }\n                        }\n                        int ops2 = 0;\n                        for (int i = 0; i < s.length(); i++) {\n                                if (i % 2 == 0) {\n                                        if (s.charAt(i) != '1') {\n                                                ops2++;\n                                        }\n                                } else {\n                                        if (s.charAt(i) != '0') {\n                                                ops2++;\n                                        }\n                                }\n                        }\n                        return Math.min(ops1, ops2);\n                }", "60": "public int maxProduct(TreeNode root) {\n                        Set<Long> set = new HashSet<>();\n                        int total = dfs(root, set);\n                        long result = 0L;\n                        for (long sum : set) {\n                                result = Math.max(result, sum * (total - sum));\n                        }\n                        return (int) (result % 1000000007);\n                }\nprivate int dfs(TreeNode root, Set<Long> set) {\n                        if (root == null) {\n                                return 0;\n                        }\n                        root.val += dfs(root.left, set);\n                        root.val += dfs(root.right, set);\n                        set.add((long) root.val);\n                        return root.val;\n                }", "61": "public boolean isSubPath(ListNode head, TreeNode root) {\n                        List<Integer> list = getList(head);\n                        findAllPaths(root, new ArrayList<>());\n                        for (List<Integer> path : paths) {\n                                if (path.size() >= list.size()) {\n                                        if (find(list, path)) {\n                                                return true;\n                                        }\n                                }\n                        }\n                        return false;\n                }\nprivate boolean find(List<Integer> list, List<Integer> path) {\n                        int i = 0;\n                        int j = 0;\n                        for (; i <= path.size() - list.size(); i++) {\n                                j = 0;\n                                int tmpI = i;\n                                while (j < list.size() && tmpI < path.size() && list.get(j) == path.get(tmpI)) {\n                                        tmpI++;\n                                        j++;\n                                }\n                                if (j >= list.size()) {\n                                        return true;\n                                }\n                        }\n                        return j >= list.size();\n                }\nprivate void findAllPaths(TreeNode root, List<Integer> path) {\n                        if (root == null) {\n                                return;\n                        }\n                        path.add(root.val);\n                        if (root.left == null && root.right == null) {\n                                paths.add(new ArrayList<>(path));\n                                path.remove(path.size() - 1);\n                                return;\n                        }\n                        findAllPaths(root.left, path);\n                        findAllPaths(root.right, path);\n                        path.remove(path.size() - 1);\n                }\nprivate List<Integer> getList(ListNode head) {\n                        List<Integer> list = new ArrayList<>();\n                        while (head != null) {\n                                list.add(head.val);\n                                head = head.next;\n                        }\n                        return list;\n                }", "62": "public List<String> topKFrequent(String[] words, int k) {\n                        Map<String, Integer> map = new HashMap<>();\n                        for (String word : words) {\n                                map.put(word, map.getOrDefault(word, 0) + 1);\n                        }\n                        SortedSet<Map.Entry<String, Integer>> sortedset = new TreeSet<>(\n                                        (e1, e2) -> {\n                                                if (e1.getValue() != e2.getValue()) {\n                                                        return e2.getValue() - e1.getValue();\n                                                } else {\n                                                        return e1.getKey().compareToIgnoreCase(e2.getKey()); } });\n                        sortedset.addAll(map.entrySet());\n                        List<String> result = new ArrayList<>();\n                        Iterator<Map.Entry<String, Integer>> iterator = sortedset.iterator();\n                        while (iterator.hasNext() && k-- > 0) {\n                                result.add(iterator.next().getKey());\n                        }\n                        return result;\n                }", "63": "public String addBinary(String a, String b) {\n                        int carry = 0;\n                        int i = a.length() - 1;\n                        int j = b.length() - 1;\n                        StringBuilder sb = new StringBuilder();\n                        while (i >= 0 j >= 0) {\n                                int sum = carry;\n                                if (i >= 0) {\n                                        sum += a.charAt(i--) - '0';\n                                }\n                                if (j >= 0) {\n                                        sum += b.charAt(j--) - '0';\n                                }\n                                sb.append(sum % 2);\n                                carry = sum / 2;\n                        }\n                        if (carry != 0) {\n                                sb.append(carry);\n                        }\n                        return sb.reverse().toString();\n                }", "64": "public int kthSmallest(TreeNode root, int k) {\n                        List<Integer> inorder = new ArrayList();\n                        dfs(root, inorder, k);\n                        return inorder.get(k - 1);\n                }\nprivate void dfs(TreeNode root, List<Integer> list, int k) {\n                        if (root == null) {\n                                return;\n                        }\n                        dfs(root.left, list, k);\n                        list.add(root.val);\n                        dfs(root.right, list, k);\n                        if (list.size() >= (k - 1)) {\n                                return;\n                        }\n                }", "65": "public int jump(int[] nums) {\n                        int jumps = 0;\n                        int lastJumpMax = 0;\n                        int currentJumpMax = 0;\n                        for (int i = 0; i < nums.length - 1; i++) {\n                                currentJumpMax = Math.max(currentJumpMax, i + nums[i]);\n                                if (i == lastJumpMax) {\n                                        jumps++;\n                                        lastJumpMax = currentJumpMax;\n                                }\n                                if (lastJumpMax >= nums.length) {\n                                        return jumps;\n                                }\n                        }\n                        return jumps;\n                }", "66": "public int findMaxLength(int[] nums) {\n                        if (nums == null nums.length == 0) {\n                                return 0;\n                        }\n                        int count = 0;\n                        int max = 0;\n                        Map<Integer, Integer> map = new HashMap();\n                        map.put(0, -1);\n                        for (int i = 0; i < nums.length; i++) {\n                                count += nums[i] == 1 ? 1 : -1;\n                                if (map.containsKey(count)) {\n                                        max = Math.max(i - map.get(count), max);\n                                } else {\n                                        map.put(count, i);\n                                }\n                        }\n                        return max;\n                }", "67": "public int maxPoints(int[][] points) {\n                        if (points.length < 3) {\n                                return points.length;\n                        }\n                        int max = 0;\n                        Map<Long, Integer> map = new HashMap<>();\n                        for (int i = 0; i < points.length; i++) {\n                                int dup = 1;\n                                map.clear();\n                                for (int j = i + 1; j < points.length; j++) {\n                                        int dx = points[j][0] - points[i][0];\n                                        int dy = points[j][1] - points[i][1];\n                                        if (dx == 0 && dy == 0) {\n                                                dup++;\n                                        } else {\n                                                int gcd = getGcd(dx, dy);\n                                                long slope = ((long) (dy / gcd) << 32) + (dx / gcd);\n                                                map.put(slope, map.getOrDefault(slope, 0) + 1);\n                                        }\n                                }\n                                max = Math.max(max, dup);\n                                for (Map.Entry<Long, Integer> entry : map.entrySet()) {\n                                        max = Math.max(max, entry.getValue() + dup);\n                                }\n                        }\n                        return max;\n                }\nint getGcd(int a, int b) {\n                        return b == 0 ? a : getGcd(b, a % b);\n                }", "68": "public int minSwapsCouples(int[] row) {\n                        int swaps = 0;\n                        for (int i = 0; i < row.length - 1; i += 2) {\n                                int coupleValue = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n                                if (row[i + 1] != coupleValue) {\n                                        swaps++;\n                                        int coupleIndex = findIndex(row, coupleValue);\n                                        swap(row, coupleIndex, i + 1);\n                                }\n                        }\n                        return swaps;\n                }\nprivate void swap(int[] row, int i, int j) {\n                        int tmp = row[i];\n                        row[i] = row[j];\n                        row[j] = tmp;\n                }\nprivate int findIndex(int[] row, int value) {\n                        for (int i = 0; i < row.length; i++) {\n                                if (row[i] == value) {\n                                        return i;\n                                }\n                        }\n                        return -1;\n                }", "69": "public int[] getStrongest(int[] arr, int k) {\n                        Arrays.sort(arr);\n                        int median = arr.length % 2 != 0 ? arr[arr.length / 2] : arr[arr.length / 2 - 1];\n                        TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>(Collections.reverseOrder());\n                        for (int num : arr) {\n                                int diff = Math.abs(num - median);\n                                if (!treeMap.containsKey(diff)) {\n                                        treeMap.put(diff, new ArrayList<>());\n                                }\n                                treeMap.get(diff).add(num);\n                        }\n                        List<Integer> sorted = new ArrayList<>();\n                        for (int key : treeMap.keySet()) {\n                                List<Integer> sort = treeMap.get(key);\n                                Collections.sort(sort, Collections.reverseOrder());\n                                sorted.addAll(sort);\n                        }\n                        int[] result = new int[k];\n                        for (int i = 0; i < k; i++) {\n                                result[i] = sorted.get(i);\n                        }\n                        return result;\n                }", "70": "public boolean checkSubarraySum(int[] nums, int k) {\n                        Map<Integer, Integer> map = new HashMap<>();\n                        map.put(0, -1);\n                        int sum = 0;\n                        for (int i = 0; i < nums.length; i++) {\n                                sum += nums[i];\n                                if (k != 0) {\n                                        sum %= k;\n                                }\n                                Integer prev = map.get(sum);\n                                if (prev != null) {\n                                        if (i - prev > 1) {\n                                                return true;\n                                        }\n                                } else {\n                                        map.put(sum, i);\n                                }\n                        }\n                        return false;\n                }", "71": "public boolean kLengthApart(int[] nums, int k) {\n                        int lastOneIndex = nums[0] == 1 ? 0 : -1;\n                        for (int i = 1; i < nums.length; i++) {\n                                if (nums[i] == 1) {\n                                        if (i - lastOneIndex <= k) {\n                                                return false;\n                                        } else {\n                                                lastOneIndex = i;\n                                        }\n                                }\n                        }\n                        return true;\n                }", "72": "public String generateTheString(int n) {\n                        StringBuilder sb = new StringBuilder();\n                        if (n > 1 && n % 2 == 0) {\n                                while (n-- > 1) {\n                                        sb.append(\"a\");\n                                }\n                        } else if (n > 1) {\n                                while (n-- > 2) {\n                                        sb.append(\"a\");\n                                }\n                                sb.append(\"b\");\n                        }\n                        sb.append(\"z\");\n                        return sb.toString();\n                }", "73": "public List<Integer> inorderTraversal(TreeNode root) {\n                        return inorder(root, new ArrayList());\n                }\nList<Integer> inorder(TreeNode root, List<Integer> result) {\n                        if (root == null) {\n                                return result;\n                        }\n                        inorder(root.left, result);\n                        result.add(root.val);\n                        return inorder(root.right, result);\n                }", "74": "public int findMin(int[] nums) {\n                        int left = 0;\n                        int right = nums.length - 1;\n                        if (nums[left] < nums[right]) {\n                                return nums[left];\n                        }\n                        int min = nums[0];\n                        while (left + 1 < right) {\n                                int mid = left + (right - left) / 2;\n                                min = Math.min(min, nums[mid]);\n                                if (nums[mid] > nums[left]) {\n                                        min = Math.min(nums[left], min);\n                                        left = mid + 1;\n                                } else if (nums[mid] < nums[left]) {\n                                        right = mid - 1;\n                                } else {\n                                        left++;\n                                }\n                        }\n                        min = Math.min(min, Math.min(nums[left], nums[right]));\n                        return min;\n                }", "75": "public int numDecodings(String s) {\n                        long[] dp = new long[s.length() + 1];\n                        dp[0] = 1;\n                        dp[1] = s.charAt(0) == '*' ? 9 : s.charAt(0) == '0' ? 0 : 1;\n                        for (int i = 1; i < s.length(); i++) {\n                                if (s.charAt(i) == '*') {\n                                        dp[i + 1] = 9 * dp[i];\n                                        if (s.charAt(i - 1) == '1') {\n                                                dp[i + 1] = (dp[i + 1] + 9 * dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '2') {\n                                                dp[i + 1] = (dp[i + 1] + 6 * dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '*') {\n                                                dp[i + 1] = (dp[i + 1] + 15 * dp[i - 1]) % m;\n                                        }\n                                } else {\n                                        dp[i + 1] = s.charAt(i) != '0' ? dp[i] : 0;\n                                        if (s.charAt(i - 1) == '1') {\n                                                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '2' && s.charAt(i) <= '6') {\n                                                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '*') {\n                                                dp[i + 1] = (dp[i + 1] + (s.charAt(i) <= '6' ? 2 : 1) * dp[i - 1]) % m;\n                                        }\n                                }\n                        }\n                        return (int) dp[s.length()];\n                }", "76": "public int reversePairs(int[] nums) {\n                        return mergeSort(nums, 0, nums.length - 1);\n                }\nprivate int mergeSort(int[] nums, int start, int end) {\n                        if (start >= end) {\n                                return 0;\n                        }\n                        int mid = start + (end - start) / 2;\n                        int cnt = mergeSort(nums, start, mid) + mergeSort(nums, mid + 1, end);\n                        for (int i = start, j = mid + 1; i <= mid; i++) {\n                                while (j <= end && nums[i] > nums[j] * 2.0) {\n                                        j++;\n                                }\n                                cnt += j - (mid + 1);\n                        }\n                        Arrays.sort(nums, start, end + 1);\n                        return cnt;\n                }", "77": "public boolean judgeSquareSum(int c) {\n                        if (c < 0) {\n                                return false;\n                        }\n                        int left = 0;\n                        int right = (int) (Math.sqrt(c));\n                        while (left <= right) {\n                                int curr = left * left + right * right;\n                                if (curr > c) {\n                                        right--;\n                                } else if (curr < c) {\n                                        left++;\n                                } else {\n                                        return true;\n                                }\n                        }\n                        return false;\n                }", "78": "public int[] buildArray(int[] nums) {\n                        int[] ans = new int[nums.length];\n                        for (int i = 0; i < nums.length; i++) {\n                                ans[i] = nums[nums[i]];\n                        }\n                        return ans;\n                }", "79": "public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\n                        if (original == null) {\n                                return null;\n                        }\n                        if (original.val == target.val) {\n                                return cloned;\n                        }\n                        TreeNode left = getTargetCopy(original.left, cloned.left, target);\n                        if (left != null && left.val == target.val) {\n                                return left;\n                        }\n                        return getTargetCopy(original.right, cloned.right, target);\n                }", "80": "public int longestSubarray(int[] nums) {\n                        List<int[]> brackets = new ArrayList<>();\n                        for (int i = 0; i < nums.length; i++) {\n                                if (nums[i] == 1) {\n                                        int right = i + 1;\n                                        while (right < nums.length && nums[right] == 1) {\n                                                right++;\n                                        }\n                                        if (right < nums.length && nums[right] == 1) {\n                                                brackets.add(new int[]{i, right});\n                                        } else {\n                                                brackets.add(new int[]{i, right - 1});\n                                        }\n                                        i = right;\n                                }\n                        }\n                        int longest = 0;\n                        for (int[] bracket : brackets) {\n                                if (bracket[1] == nums.length - 1 && bracket[0] == 0) {\n                                        return nums.length - 1;\n                                }\n                                longest = Math.max(bracket[1] - bracket[0] + 1, longest);\n                        }\n                        for (int i = 0; i < brackets.size() - 1; i++) {\n                                int[] first = brackets.get(i);\n                                int[] second = brackets.get(i + 1);\n                                if (first[1] + 2 == second[0]) {\n                                        int connected = (first[1] - first[0] + 1) + (second[1] - second[0] + 1);\n                                        longest = Math.max(longest, connected);\n                                }\n                        }\n                        return longest;\n                }", "81": "public boolean canConstruct(String s, int k) {\n                        if (s.length() < k) {\n                                return false;\n                        }\n                        Map<Character, Integer> map = new HashMap<>();\n                        for (char c : s.toCharArray()) {\n                                map.put(c, map.getOrDefault(c, 0) + 1);\n                        }\n                        int count = 0;\n                        for (char c : map.keySet()) {\n                                if (map.get(c) % 2 == 1) {\n                                        count++;\n                                }\n                        }\n                        return count <= k;\n                }", "82": "public int hammingDistance(int x, int y) {\n                        int n = x ^ y;\n                        int count = 0;\n                        while (n != 0) {\n                                count++;\n                                n &= (n - 1);\n                        }\n                        return count;\n                }", "83": "public String findLongestWord(String s, List<String> d) {\n                        Collections.sort(d, (a, b) -> a.length() == b.length() ? a.compareTo(b) : b.length() - a.length());\n                        for (String dictWord : d) {\n                                int i = 0;\n                                for (char c : s.toCharArray()) {\n                                        if (i < dictWord.length() && dictWord.charAt(i) == c) {\n                                                i++;\n                                        }\n                                }\n                                if (i == dictWord.length()) {\n                                        return dictWord;\n                                }\n                        }\n                        return \"\";\n                }", "84": "public int kInversePairs(int n, int k) {\n                        int mod = 1000000007;\n                        if (k > n * (n - 1) / 2 k < 0) {\n                                return 0;\n                        }\n                        if (k == 0 || k == n * (n - 1) / 2) {\n                                return 1;\n                        }\n                        long[][] dp = new long[n + 1][k + 1];\n                        dp[2][0] = 1;\n                        dp[2][1] = 1;\n                        for (int i = 3; i <= n; i++) {\n                                dp[i][0] = 1;\n                                for (int j = 1; j <= Math.min(k, i * (i - 1) / 2); j++) {\n                                        dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n                                        if (j >= i) {\n                                                dp[i][j] -= dp[i - 1][j - i];\n                                        }\n                                        dp[i][j] = (dp[i][j] + mod) % mod;\n                                }\n                        }\n                        return (int) dp[n][k];\n                }", "85": "public int trap(int[] height) {\n                        if (height == null height.length <= 2) {\n                                return 0;\n                        }\n                        int max = height[0];\n                        int maxIndex = 0;\n                        for (int i = 0; i < height.length; i++) {\n                                if (height[i] > max) {\n                                        max = height[i];\n                                        maxIndex = i;\n                                }\n                        }\n                        int water = 0;\n                        int leftMax = height[0];\n                        for (int i = 0; i < maxIndex; i++) {\n                                if (height[i] > leftMax) {\n                                        leftMax = height[i];\n                                } else {\n                                        water += leftMax - height[i];\n                                }\n                        }\n                        int rightMax = height[height.length - 1];\n                        for (int i = height.length - 1; i > maxIndex; i--) {\n                                if (height[i] > rightMax) {\n                                        rightMax = height[i];\n                                } else {\n                                        water += rightMax - height[i];\n                                }\n                        }\n                        return water;\n                }", "86": "public int findIntegers(int num) {\n                        int[] f = new int[32];\n                        f[0] = 1;\n                        f[1] = 2;\n                        for (int i = 2; i < f.length; i++) {\n                                f[i] = f[i - 1] + f[i - 2];\n                        }\n                        int i = 30;\n                        int sum = 0;\n                        int prevBit = 0;\n                        while (i >= 0) {\n                                if ((num & (1 << i)) != 0) {\n                                        sum += f[i];\n                                        if (prevBit == 1) {\n                                                sum--;\n                                                break;\n                                        }\n                                        prevBit = 1;\n                                } else {\n                                        prevBit = 0;\n                                }\n                                i--;\n                        }\n                        return sum + 1;\n                }", "87": "public int findPairs(int[] nums, int k) {\n                        if (nums == null nums.length == 0 k < 0) {\n                                return 0;\n                        }\n                        Map<Integer, Integer> map = new HashMap();\n                        for (int num : nums) {\n                                map.put(num, map.getOrDefault(num, 0) + 1);\n                        }\n                        int answer = 0;\n                        for (int key : map.keySet()) {\n                                if (k == 0) {\n                                        if (map.get(key) >= 2) {\n                                                answer++;\n                                        }\n                                } else {\n                                        if (map.containsKey(key + k)) {\n                                                answer++;\n                                        }\n                                }\n                        }\n                        return answer;\n                }", "88": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n                        List<List<Integer>> result = new ArrayList();\n                        List<Integer> empty = new ArrayList();\n                        result.add(empty);\n                        if (nums == null) {\n                                return result;\n                        }\n                        Arrays.sort(nums);\n                        for (int i = 0; i < nums.length; i++) {\n                                Set<List<Integer>> temp = new HashSet();\n                                for (List<Integer> list : result) {\n                                        List<Integer> newList = new ArrayList(list);\n                                        newList.add(nums[i]);\n                                        temp.add(newList);\n                                }\n                                result.addAll(temp);\n                        }\n                        Set<List<Integer>> resultSet = new HashSet();\n                        resultSet.addAll(result);\n                        result.clear();\n                        result.addAll(resultSet);\n                        return result;\n                }", "89": "public boolean circularArrayLoop(int[] nums) {\n                        int n = nums.length;\n                        for (int i = 0; i < n; i++) {\n                                if (nums[i] == 0) {\n                                        continue;\n                                }\n                                int j = i;\n                                int k = getIndex(i, nums);\n                                while (nums[k] * nums[i] > 0 && nums[getIndex(k, nums)] * nums[i] > 0) {\n                                        if (j == k) {\n                                                if (j == getIndex(j, nums)) {\n                                                        break;\n                                                }\n                                                return true;\n                                        }\n                                        j = getIndex(j, nums);\n                                        k = getIndex(getIndex(k, nums), nums);\n                                }\n                                j = i;\n                                int val = nums[i];\n                                while (nums[j] * val > 0) {\n                                        int next = getIndex(j, nums);\n                                        nums[j] = 0;\n                                        j = next;\n                                }\n                        }\n                        return false;\n                }\npublic int getIndex(int i, int[] nums) {\n                        int n = nums.length;\n                        return i + nums[i] >= 0 ? (i + nums[i]) % n : n + ((i + nums[i]) % n);\n                }", "90": "public String evaluate(String s, List<List<String>> knowledge) {\n                        Map<String, String> map = new HashMap<>();\n                        for (List<String> know : knowledge) {\n                                map.put(know.get(0), know.get(1));\n                        }\n                        StringBuilder sb = new StringBuilder();\n                        for (int i = 0; i < s.length(); i++) {\n                                if (s.charAt(i) == '(') {\n                                        int start = i;\n                                        while (i < s.length() && s.charAt(i) != ')') {\n                                                i++;\n                                        }\n                                        String key = s.substring(start + 1, i);\n                                        sb.append(map.getOrDefault(key, \"?\"));\n                                } else {\n                                        sb.append(s.charAt(i));\n                                }\n                        }\n                        return sb.toString();\n                }", "91": "public String rankTeams(String[] votes) {\n                        Node[] nodes = new Node[26];\n                        for (int i = 0; i < 26; i++) {\n                                nodes[i] = new Node((char) (i + 'A'));\n                        }\n                        for (String vote : votes) {\n                                for (int i = 0; i < vote.length(); i++) {\n                                        nodes[vote.charAt(i) - 'A'].count[i]++;\n                                }\n                        }\n                        Arrays.sort(nodes, new Comparator<Node>() {\n                                @Override\n                                public int compare(Node o1, Node o2) {\n                                        for (int i = 0; i < 26; i++) {\n                                                if (o1.count[i] != o2.count[i]) { return o2.count[i] - o1.count[i]; } } return o1.c - o2.c; } });\n                        StringBuilder sb = new StringBuilder();\n                        for (int i = 0; i < votes[0].length(); i++) {\n                                sb.append(nodes[i].c);\n                        }\n                        return sb.toString();\n                }\n@Override\n                                public int compare(Node o1, Node o2) {\n                                        for (int i = 0; i < 26; i++) {\n                                                if (o1.count[i] != o2.count[i]) { return o2.count[i] - o1.count[i]; } } return o1.c - o2.c; }", "92": "public int[] decode(int[] encoded, int first) {\n                        int[] arr = new int[encoded.length + 1];\n                        arr[0] = first;\n                        for (int i = 0; i < encoded.length; i++) {\n                                arr[i + 1] = encoded[i] ^ arr[i];\n                        }\n                        return arr;\n                }", "93": "public void connect(TreeLinkNode root) {\n                        TreeLinkNode head = null; \n                        TreeLinkNode prev = null; \n                        TreeLinkNode curr = root; \n                        while (curr != null) {\n                                while (curr != null) { \n                                        if (curr.left != null) {\n                                                if (prev != null) {\n                                                        prev.next = curr.left;\n                                                } else {\n                                                        head = curr.left;\n                                                }\n                                                prev = curr.left;\n                                        }\n                                        if (curr.right != null) {\n                                                if (prev != null) {\n                                                        prev.next = curr.right;\n                                                } else {\n                                                        head = curr.right;\n                                                }\n                                                prev = curr.right;\n                                        }\n                                        curr = curr.next;\n                                }\n                                curr = head;\n                                head = null;\n                                prev = null;\n                        }\n                }", "94": "public int maxProfit(int[] prices, int fee) {\n                        int n = prices.length;\n                        if (n < 2) {\n                                return 0;\n                        }\n                        int[] hold = new int[n];\n                        int[] sell = new int[n];\n                        hold[0] = -prices[0];\n                        for (int i = 1; i < prices.length; i++) {\n                                hold[i] = Math.max(hold[i - 1], sell[i - 1] - prices[i]);\n                                sell[i] = Math.max(sell[i - 1], hold[i - 1] - fee + prices[i]);\n                        }\n                        return sell[n - 1];\n                }", "95": "public int cutOffTree(List<List<Integer>> forest) {\n                        if (forest == null || forest.isEmpty() || forest.size() == 0 || forest.get(0).get(0) == 0) {\n                                return -1;\n                        }\n                        int m = forest.size();\n                        int n = forest.get(0).size();\n                        PriorityQueue<Tree> heap = new PriorityQueue<>((a, b) -> a.height - b.height);\n                        for (int i = 0; i < m; i++) {\n                                for (int j = 0; j < n; j++) {\n                                        if (forest.get(i).get(j) > 1) {\n                                                heap.offer(new Tree(i, j, forest.get(i).get(j)));\n                                        }\n                                }\n                        }\n                        int sum = 0;\n                        Tree start = new Tree();\n                        while (!heap.isEmpty()) {\n                                Tree curr = heap.poll();\n                                int step = bfs(forest, curr, start, m, n);\n                                if (step == -1) {\n                                        return -1;\n                                }\n                                sum += step;\n                                start = curr;\n                        }\n                        return sum;\n                }\nprivate int bfs(List<List<Integer>> forest, Tree target, Tree start, int m, int n) {\n                        int[] dirs = new int[]{0, 1, 0, -1, 0};\n                        boolean[][] visited = new boolean[m][n];\n                        Queue<Tree> queue = new LinkedList<>();\n                        queue.offer(start);\n                        visited[start.x][start.y] = true;\n                        int step = 0;\n                        while (!queue.isEmpty()) {\n                                int size = queue.size();\n                                for (int k = 0; k < size; k++) {\n                                        Tree tree = queue.poll();\n                                        if (tree.x == target.x && tree.y == target.y) {\n                                                return step;\n                                        }\n                                        for (int i = 0; i < 4; i++) {\n                                                int nextX = tree.x + dirs[i];\n                                                int nextY = tree.y + dirs[i + 1];\n                                                if (nextX < 0 || nextY < 0 || nextX >= m || nextY >= n || visited[nextX][nextY] || forest.get(nextX).get(nextY) == 0) {\n                                                        continue;\n                                                }\n                                                queue.offer(new Tree(nextX, nextY, forest.get(nextX).get(nextY)));\n                                                visited[nextX][nextY] = true;\n                                        }\n                                }\n                                step++;\n                        }\n                        return -1;\n                }", "96": "public ListNode reverseList(ListNode head) {\n                        ListNode newHead = null;\n                        while (head != null) {\n                                ListNode next = head.next;\n                                head.next = newHead;\n                                newHead = head;\n                                head = next;\n                        }\n                        return newHead;\n                }", "97": "public int numRescueBoats(int[] people, int limit) {\n                        TreeMap<Integer, Integer> map = new TreeMap<>();\n                        for (int w : people) {\n                                map.put(w, map.getOrDefault(w, 0) + 1);\n                        }\n                        int boats = 0;\n                        List<Integer> uniqWeights = new ArrayList(map.keySet());\n                        int left = 0;\n                        int right = uniqWeights.size() - 1;\n                        while (left < right) {\n                                int heavierWeight = uniqWeights.get(right);\n                                int lighterWeight = uniqWeights.get(left);\n                                if (heavierWeight + lighterWeight <= limit) {\n                                        int pairs = Math.min(map.get(heavierWeight), map.get(lighterWeight));\n                                        boats += pairs;\n                                        if (map.get(heavierWeight) == pairs && map.get(lighterWeight) == pairs) {\n                                                map.remove(heavierWeight);\n                                                map.remove(lighterWeight);\n                                                left++;\n                                                right--;\n                                        } else if (map.get(heavierWeight) == pairs) {\n                                                map.remove(heavierWeight);\n                                                map.put(lighterWeight, map.get(lighterWeight) - pairs);\n                                                right--;\n                                        } else {\n                                                map.remove(lighterWeight);\n                                                map.put(heavierWeight, map.get(heavierWeight) - pairs);\n                                                left++;\n                                        }\n                                } else {\n                                        boats += map.get(heavierWeight);\n                                        map.remove(heavierWeight);\n                                        right--;\n                                }\n                        }\n                        if (!map.isEmpty()) {\n                                int weight = uniqWeights.get(left);\n                                int remainingPeople = map.get(weight);\n                                if (remainingPeople == 1) {\n                                        boats++;\n                                } else {\n                                        if (weight * 2 <= limit) {\n                                                boats += (remainingPeople / 2 + ((remainingPeople % 2 == 0) ? 0 : 1));\n                                        } else {\n                                                boats += remainingPeople;\n                                        }\n                                }\n                        }\n                        return boats;\n                }", "98": "public int lengthOfLastWord(String s) {\n                        if (s == null || s.length() == 0) {\n                                return 0;\n                        }\n                        s = s.trim();\n                        int n = s.length() - 1;\n                        while (n >= 0 && s.charAt(n) != ' ') {\n                                n--;\n                        }\n                        return s.length() - n - 1;\n                }", "99": "public String[] findOcurrences(String text, String first, String second) {\n                        String[] words = text.split(\" \");\n                        return IntStream\n                                        .range(0, words.length - 2)\n                                        .filter(i -> words[i].equals(first) && words[i + 1].equals(second))\n                                        .mapToObj(i -> words[i + 2])\n                                        .collect(Collectors.toList())\n                                        .stream()\n                                        .toArray(String[]::new);\n                }", "100": "public int isPrefixOfWord(String sentence, String searchWord) {\n                        String[] words = sentence.split(\" \");\n                        for (int i = 0; i < words.length; i++) {\n                                if (words[i].startsWith(searchWord)) {\n                                        return i + 1;\n                                }\n                        }\n                        return -1;\n                }", "101": "public double findMedianSortedArrays(int[] A, int[] B) {\n                        int m = A.length;\n                        int n = B.length;\n                        int l = (m + n + 1) / 2;\n                        int r = (m + n + 2) / 2;\n                        return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0;\n                }\npublic double getkth(int[] A, int aStart, int[] B, int bStart, int k) {\n                        if (aStart > A.length - 1) {\n                                return B[bStart + k - 1];\n                        }\n                        if (bStart > B.length - 1) {\n                                return A[aStart + k - 1];\n                        }\n                        if (k == 1) {\n                                return Math.min(A[aStart], B[bStart]);\n                        }\n                        int aMid = Integer.MAX_VALUE;\n                        int bMid = Integer.MAX_VALUE;\n                        if (aStart + k / 2 - 1 < A.length) {\n                                aMid = A[aStart + k / 2 - 1];\n                        }\n                        if (bStart + k / 2 - 1 < B.length) {\n                                bMid = B[bStart + k / 2 - 1];\n                        }\n                        if (aMid < bMid) {\n                                return getkth(A, aStart + k / 2, B, bStart, k - k / 2);\n                        } else {\n                                return getkth(A, aStart, B, bStart + k / 2, k - k / 2);\n                        }\n                }", "102": "public boolean isPossible(int[] nums) {\n                        Map<Integer, Integer> freqMap = new HashMap<>();\n                        for (int i : nums) {\n                                freqMap.put(i, freqMap.getOrDefault(i, 0) + 1);\n                        }\n                        Map<Integer, Integer> appendFreqMap = new HashMap<>();\n                        for (int i : nums) {\n                                if (freqMap.get(i) == 0) {\n                                        continue;\n                                } else if (appendFreqMap.getOrDefault(i, 0) > 0) {\n                                        appendFreqMap.put(i, appendFreqMap.get(i) - 1);\n                                        appendFreqMap.put(i + 1, appendFreqMap.getOrDefault(i + 1, 0) + 1);\n                                } else if (freqMap.getOrDefault(i + 1, 0) > 0 && freqMap.getOrDefault(i + 2, 0) > 0) {\n                                        freqMap.put(i + 1, freqMap.get(i + 1) - 1);\n                                        freqMap.put(i + 2, freqMap.get(i + 2) - 1);\n                                        appendFreqMap.put(i + 3, appendFreqMap.getOrDefault(i + 3, 0) + 1);\n                                } else {\n                                        return false;\n                                }\n                                freqMap.put(i, freqMap.get(i) - 1);\n                        }\n                        return true;\n                }", "103": "public String validIPAddress(String IP) {\n                        if (IP.contains(\".\")) {\n                                return isValidIPv4(IP);\n                        } else if (IP.contains(\":\")) {\n                                return isValidIPv6(IP);\n                        } else {\n                                return NEITHER;\n                        }\n                }\nprivate String isValidIPv6(String IP) {\n                        if (getDelimiterCount(IP, ':') != 7) {\n                                return NEITHER;\n                        }\n                        String[] bytes = IP.split(\"\\\\:\");\n                        if (bytes.length != 8) {\n                                return NEITHER;\n                        }\n                        for (int i = 0; i < 8; i++) {\n                                if (hasInvalidIPV6Char(bytes[i])) {\n                                        return NEITHER;\n                                }\n                                try {\n                                        if (bytes[i].length() > 4) {\n                                                return NEITHER;\n                                        }\n                                        int intNum = Integer.parseInt(bytes[i], 16);\n                                        if (intNum < 0) {\n                                                return NEITHER;\n                                        }\n                                        if (i == 0 && intNum != 0 && bytes[i].charAt(0) == '0') {\n                                                return NEITHER;\n                                        }\n                                } catch (Exception e) {\n                                        return NEITHER;\n                                }\n                        }\n                        return \"IPv6\";\n                }\nprivate String isValidIPv4(String IP) {\n                        if (getDelimiterCount(IP, '.') != 3) {\n                                return NEITHER;\n                        }\n                        String[] bytes = IP.split(\"\\\\.\");\n                        if (bytes.length != 4) {\n                                return NEITHER;\n                        }\n                        for (String num : bytes) {\n                                try {\n                                        int intNum = Integer.parseInt(num);\n                                        if (intNum > 255 intNum < 0) {\n                                                return NEITHER;\n                                        }\n                                        if (intNum != 0) {\n                                                for (int i = 0; i < num.length(); i++) {\n                                                        if (num.charAt(i) == '0') {\n                                                                return NEITHER;\n                                                        } else {\n                                                                break;\n                                                        }\n                                                }\n                                        } else if (intNum == 0) {\n                                                if (num.length() != 1) {\n                                                        return NEITHER;\n                                                }\n                                        }\n                                } catch (Exception e) {\n                                        return NEITHER;\n                                }\n                        }\n                        return \"IPv4\";\n                }\nprivate boolean hasInvalidIPV6Char(String str) {\n                        Set<Character> set = new HashSet<>(Arrays.asList('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'));\n                        for (char c : str.toCharArray()) {\n                                if (!set.contains(c)) {\n                                        return true;\n                                }\n                        }\n                        return false;\n                }\nprivate int getDelimiterCount(String ip, char delimiter) {\n                        int count = 0;\n                        for (char c : ip.toCharArray()) {\n                                if (c == delimiter) {\n                                        count++;\n                                }\n                        }\n                        return count;\n                }", "104": "public int maxOperations(int[] nums, int k) {\n                        Map<Integer, Integer> map = new HashMap<>();\n                        int ops = 0;\n                        for (int num : nums) {\n                                if (map.containsKey(k - num)) {\n                                        map.put(k - num, map.get(k - num) - 1);\n                                        ops++;\n                                        if (map.get(k - num) == 0) {\n                                                map.remove(k - num);\n                                        }\n                                } else {\n                                        map.put(num, map.getOrDefault(num, 0) + 1);\n                                }\n                        }\n                        return ops;\n                }", "105": "public int largestAltitude(int[] gain) {\n                        int max = 0;\n                        int[] altitudes = new int[gain.length + 1];\n                        for (int i = 0; i < gain.length; i++) {\n                                altitudes[i + 1] = altitudes[i] + gain[i];\n                                max = Math.max(max, altitudes[i + 1]);\n                        }\n                        return max;\n                }", "106": "public int compareVersion(String version1, String version2) {\n                        String[] v1s = version1.split( \"\\\\.\");\n                        String[] v2s = version2.split(\"\\\\.\");\n                        int len = (v1s.length < v2s.length) ? v2s.length : v1s.length;\n                        for (int i = 0; i < len; i++) {\n                                if (v1s.length == i) {\n                                        while (i < len) {\n                                                if (Integer.parseInt(v2s[i]) > 0) {\n                                                        return -1;\n                                                }\n                                                i++;\n                                        }\n                                } else if (v2s.length == i) {\n                                        while (i < len) {\n                                                if (Integer.parseInt(v1s[i]) > 0) {\n                                                        return 1;\n                                                }\n                                                i++;\n                                        }\n                                } else {\n                                        if (Integer.parseInt(v1s[i]) > Integer.parseInt(v2s[i])) {\n                                                return 1;\n                                        } else if (Integer.parseInt(v2s[i]) > Integer.parseInt(v1s[i])) {\n                                                return -1;\n                                        }\n                                }\n                        }\n                        return 0;\n                }", "107": "public int[][] matrixBlockSum(int[][] mat, int K) {\n                        int m = mat.length;\n                        int n = mat[0].length;\n                        int[][] answer = new int[m][n];\n                        for (int i = 0; i < m; i++) {\n                                for (int j = 0; j < n; j++) {\n                                        List<Integer> iRange = findRange(i, K, m);\n                                        List<Integer> jRange = findRange(j, K, n);\n                                        int sum = 0;\n                                        for (int ii = 0; ii < iRange.size(); ii++) {\n                                                for (int jj = 0; jj < jRange.size(); jj++) {\n                                                        sum += mat[iRange.get(ii)][jRange.get(jj)];\n                                                }\n                                        }\n                                        answer[i][j] = sum;\n                                }\n                        }\n                        return answer;\n                }\nprivate List<Integer> findRange(int iOrJ, int k, int upper) {\n                        int min = (iOrJ - k) < 0 ? 0 : (iOrJ - k);\n                        int max = (iOrJ + k) >= upper ? (upper - 1) : (iOrJ + k);\n                        List<Integer> range = new ArrayList<>();\n                        for (int i = min; i <= max; i++) {\n                                range.add(i);\n                        }\n                        return range;\n                }", "108": "public List<Integer> rightSideView(TreeNode root) {\n                        List<Integer> result = new ArrayList<>();\n                        rightView(root, result, 0);\n                        return result;\n                }\nvoid rightView(TreeNode curr, List<Integer> result, int currDepth) {\n                        if (curr == null) {\n                                return;\n                        }\n                        if (currDepth == result.size()) {\n                                result.add(curr.val);\n                        }\n                        rightView(curr.right, result, currDepth + 1);\n                        rightView(curr.left, result, currDepth + 1);\n                }", "109": "public boolean wordPattern(String pattern, String str) {\n                        String[] words = str.split(\" \");\n                        char[] patterns = pattern.toCharArray();\n                        Map<Character, String> map = new HashMap();\n                        if (patterns.length != words.length) {\n                                return false;\n                        }\n                        for (int i = 0; i < patterns.length; i++) {\n                                if (map.containsKey(patterns[i])) {\n                                        if (!map.get(patterns[i]).equals(words[i])) {\n                                                return false;\n                                        }\n                                } else {\n                                        if (map.containsValue(words[i])) {\n                                                return false;\n                                        }\n                                        map.put(patterns[i], words[i]);\n                                }\n                        }\n                        return true;\n                }", "110": "public String convertToBase7(int num) {\n                        return String.valueOf(Integer.toString(num, 7));\n                }", "111": "public boolean searchMatrix(int[][] matrix, int target) {\n                        if (matrix == null matrix.length == 0) {\n                                return false;\n                        }\n                        int m = matrix.length;\n                        int n = matrix[0].length;\n                        int x = 0;\n                        int y = n - 1;\n                        while (x < m && y >= 0) {\n                                if (target == matrix[x][y]) {\n                                        return true;\n                                } else if (target > matrix[x][y]) {\n                                        x++;\n                                } else {\n                                        y--;\n                                }\n                        }\n                        return false;\n                }", "112": "public List<String> stringMatching(String[] words) {\n                        Set<String> set = new HashSet<>();\n                        for (String word : words) {\n                                for (int i = 0; i < words.length; i++) {\n                                        if (!word.equals(words[i]) && word.length() < words[i].length()) {\n                                                if (words[i].indexOf(word) != -1) {\n                                                        set.add(word);\n                                                }\n                                        }\n                                }\n                        }\n                        List<String> result = new ArrayList<>();\n                        for (String s : set) {\n                                result.add(s);\n                        }\n                        return result;\n                }", "113": "public boolean isAnagram(String s, String t) {\n                        char[] schar = s.toCharArray();\n                        char[] tchar = t.toCharArray();\n                        Arrays.sort(schar);\n                        Arrays.sort(tchar);\n                        return new String(schar).equals(new String(tchar));\n                }", "114": "public int[] arrayRankTransform(int[] arr) {\n                        TreeSet<Integer> set = new TreeSet<>();\n                        for (int i : arr) {\n                                set.add(i);\n                        }\n                        Map<Integer, Integer> map = new HashMap<>();\n                        int rank = 1;\n                        for (int num : set) {\n                                map.put(num, rank++);\n                        }\n                        int[] ranks = new int[arr.length];\n                        for (int i = 0; i < arr.length; i++) {\n                                ranks[i] = map.get(arr[i]);\n                        }\n                        return ranks;\n                }", "115": "public int findSpecialInteger(int[] arr) {\n                        int quarter = arr.length / 4;\n                        for (int i = 0; i < arr.length - quarter; i++) {\n                                if (arr[i] == arr[i + quarter]) {\n                                        return arr[i];\n                                }\n                        }\n                        return -1;\n                }", "116": "public int countPrimes(int n) {\n                        boolean[] notPrime = new boolean[n];\n                        int count = 0;\n                        for (int i = 2; i < n; i++) {\n                                if (!notPrime[i]) {\n                                        count++;\n                                        for (int j = 2; i * j < n; j++) {\n                                                notPrime[i * j] = true;\n                                        }\n                                }\n                        }\n                        return count;\n                }", "117": "public int maxDistToClosest(int[] seats) {\n                        for (int i = 0; i < seats.length; i++) {\n                                if (seats[i] == 0) {\n                                        extend(seats, i);\n                                }\n                        }\n                        return maxDist;\n                }\nprivate void extend(int[] seats, int position) {\n                        int left = position - 1;\n                        int right = position + 1;\n                        int leftMinDistance = 1;\n                        while (left >= 0) {\n                                if (seats[left] == 0) {\n                                        leftMinDistance++;\n                                        left--;\n                                } else {\n                                        break;\n                                }\n                        }\n                        int rightMinDistance = 1;\n                        while (right < seats.length) {\n                                if (seats[right] == 0) {\n                                        rightMinDistance++;\n                                        right++;\n                                } else {\n                                        break;\n                                }\n                        }\n                        int maxReach = 0;\n                        if (position == 0) {\n                                maxReach = rightMinDistance;\n                        } else if (position == seats.length - 1) {\n                                maxReach = leftMinDistance;\n                        } else {\n                                maxReach = Math.min(leftMinDistance, rightMinDistance);\n                        }\n                        maxDist = Math.max(maxDist, maxReach);\n                }", "118": "public int[] intersect(int[] nums1, int[] nums2) {\n                        Map<Integer, Integer> map = new HashMap();\n                        for (int i : nums1) {\n                                map.put(i, map.getOrDefault(i, 0) + 1);\n                        }\n                        List<Integer> list = new ArrayList();\n                        for (int i : nums2) {\n                                if (map.containsKey(i) && map.get(i) > 0) {\n                                        list.add(i);\n                                        map.put(i, map.get(i) - 1);\n                                }\n                        }\n                        return list.stream().mapToInt(i -> i).toArray();\n                }", "119": "public double average(int[] salary) {\n                        int max = salary[0];\n                        int min = salary[0];\n                        for (int i = 1; i < salary.length; i++) {\n                                max = Math.max(max, salary[i]);\n                                min = Math.min(min, salary[i]);\n                        }\n                        long total = 0;\n                        int count = 0;\n                        for (int i = 0; i < salary.length; i++) {\n                                if (salary[i] != max && salary[i] != min) {\n                                        total += salary[i];\n                                        count++;\n                                }\n                        }\n                        return (double) total / count;\n                }", "120": "public boolean canJump(int[] nums) {\n                        int furthestReach = nums[0];\n                        if (furthestReach >= nums.length - 1) {\n                                return true;\n                        }\n                        int i = 1;\n                        for (; i < nums.length; ) {\n                                int newFurthestReach = -1;\n                                while (i <= furthestReach) {\n                                        newFurthestReach = Math.max(newFurthestReach, nums[i] + i);\n                                        if (newFurthestReach >= nums.length) {\n                                                return true;\n                                        }\n                                        i++;\n                                }\n                                if (newFurthestReach <= furthestReach) {\n                                        return false;\n                                } else if (newFurthestReach >= nums.length - 1) {\n                                        return true;\n                                } else {\n                                        furthestReach = newFurthestReach;\n                                }\n                        }\n                        return false;\n                }", "121": "public boolean isValid(String code) {\n                        Deque<String> stack = new ArrayDeque<>();\n                        for (int i = 0; i < code.length(); ) {\n                                if (i > 0 && stack.isEmpty()) {\n                                        return false;\n                                }\n                                if (code.startsWith(\"<![CDATA[\", i)) { int j = i + 9; i = code.indexOf(\"]]>\", j);\n                                        if (i < 0) {\n                                                return false;\n                                        }\n                                        i += 3;\n                                } else if (code.startsWith(\"</\", i)) {\n                                        int j = i + 2;\n                                        i = code.indexOf(\">\", j);\n                                        if (i < 0 i == j i - j > 9) {\n                                                return false;\n                                        }\n                                        for (int k = j; k < i; k++) {\n                                                if (!Character.isUpperCase(code.charAt(k))) {\n                                                        return false;\n                                                }\n                                        }\n                                        String s = code.substring(j, i++);\n                                        if (stack.isEmpty() || !stack.pop().equals(s)) {\n                                                return false;\n                                        }\n                                } else if (code.startsWith(\"<\", i)) {\n                                        int j = i + 1;\n                                        i = code.indexOf(\">\", j);\n                                        if (i < 0 i == j i - j > 9) {\n                                                return false;\n                                        }\n                                        for (int k = j; k < i; k++) {\n                                                if (!Character.isUpperCase(code.charAt(k))) {\n                                                        return false;\n                                                }\n                                        }\n                                        String s = code.substring(j, i++);\n                                        stack.push(s);\n                                } else {\n                                        i++;\n                                }\n                        }\n                        return stack.isEmpty();\n                }", "122": "public int findCircleNum(int[][] M) {\n                        if (M == null M.length == 0 M[0].length == 0) {\n                                return 0;\n                        }\n                        int m = M.length;\n                        UnionFind unionFind = new UnionFind(m);\n                        for (int i = 0; i < m; i++) {\n                                for (int j = i + 1; j < m; j++) {\n                                        if (M[i][j] == 1) {\n                                                unionFind.union(i, j);\n                                        }\n                                }\n                        }\n                        return unionFind.count;\n                }\npublic void union(int i, int j) {\n                                int x = find(root, i);\n                                int y = find(root, j);\n                                if (x != y) {\n                                        count--;\n                                        root[x] = y;\n                                }\n                        }\npublic int find(int[] ids, int i) {\n                                if (ids[i] == i) {\n                                        return i;\n                                }\n                                return find(ids, ids[i]);\n                        }", "123": "public List<List<Integer>> largeGroupPositions(String S) {\n                        List<List<Integer>> result = new ArrayList<>();\n                        char[] chars = S.toCharArray();\n                        for (int i = 0; i < chars.length; ) {\n                                char first = chars[i];\n                                int j = i + 1;\n                                while (j < chars.length && first == chars[j]) {\n                                        j++;\n                                }\n                                if ((j - i) >= 3) {\n                                        result.add(Arrays.asList(i, j - 1));\n                                }\n                                i = j;\n                        }\n                        return result;\n                }", "124": "public int daysBetweenDates(String date1, String date2) {\n                        String[] strings1 = date1.split(\"-\");\n                        String[] strings2 = date2.split(\"-\");\n                        return Math.abs(julianDay(Integer.parseInt(strings1[0]), Integer.parseInt(strings1[1]), Integer.parseInt(strings1[2]))\n                                        - julianDay(Integer.parseInt(strings2[0]), Integer.parseInt(strings2[1]), Integer.parseInt(strings2[2])));\n                }\npublic int julianDay(int year, int month, int day) {\n                        int a = (14 - month) / 12;\n                        int y = year + 4800 - a;\n                        int m = month + 12 * a - 3;\n                        int jdn = day + (153 * m + 2) / 5 + 365 * y + y / 4 - y / 100 + y / 400 - 32045;\n                        return jdn;\n                }", "125": "public int[] singleNumber(int[] nums) {\n                        Map<Integer, Integer> map = new HashMap();\n                        for (int i : nums) {\n                                map.put(i, map.getOrDefault(i, 0) + 1);\n                        }\n                        int[] res = new int[2];\n                        int index = 0;\n                        for (int key : map.keySet()) {\n                                if (map.get(key) == 1) {\n                                        res[index++] = key;\n                                }\n                                if (index == 2) {\n                                        break;\n                                }\n                        }\n                        return res;\n                }", "126": "public List<Integer> minSubsequence(int[] nums) {\n                        List<Integer> list = Arrays.stream(nums)\n                                        .boxed()\n                                        .sorted(Collections.reverseOrder())\n                                        .collect(Collectors.toCollection(() -> new ArrayList<>(nums.length)));\n                        int sum = list.stream().mapToInt(num -> num).sum();\n                        int minSum = 0;\n                        List<Integer> result = new ArrayList<>();\n                        for (int i = 0; i < nums.length; i++) {\n                                if (minSum > (sum - minSum)) {\n                                        return result;\n                                }\n                                minSum += list.get(i);\n                                result.add(list.get(i));\n                        }\n                        return result;\n                }", "127": "public int strongPasswordChecker(String s) {\n                        int res = 0;\n                        int a = 1;\n                        int A = 1;\n                        int d = 1;\n                        char[] carr = s.toCharArray();\n                        int[] arr = new int[carr.length];\n                        for (int i = 0; i < arr.length; ) {\n                                if (Character.isLowerCase(carr[i])) {\n                                        a = 0;\n                                }\n                                if (Character.isUpperCase(carr[i])) {\n                                        A = 0;\n                                }\n                                if (Character.isDigit(carr[i])) {\n                                        d = 0;\n                                }\n                                int j = i;\n                                while (i < carr.length && carr[i] == carr[j]) {\n                                        i++;\n                                }\n                                arr[j] = i - j;\n                        }\n                        int totalMissing = (a + A + d);\n                        if (arr.length < 6) {\n                                res += totalMissing + Math.max(0, 6 - (arr.length + totalMissing));\n                        } else {\n                                int overLen = Math.max(arr.length - 20, 0);\n                                int leftOver = 0;\n                                res += overLen;\n                                for (int k = 1; k < 3; k++) {\n                                        for (int i = 0; i < arr.length && overLen > 0; i++) {\n                                                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) {\n                                                        continue;\n                                                }\n                                                arr[i] -= Math.min(overLen, k);\n                                                overLen -= k;\n                                        }\n                                }\n                                for (int i = 0; i < arr.length; i++) {\n                                        if (arr[i] >= 3 && overLen > 0) {\n                                                int need = arr[i] - 2;\n                                                arr[i] -= overLen;\n                                                overLen -= need;\n                                        }\n                                        if (arr[i] >= 3) {\n                                                leftOver += arr[i] / 3;\n                                        }\n                                }\n                                res += Math.max(totalMissing, leftOver);\n                        }\n                        return res;\n                }", "128": "public int[][] reconstructQueue(int[][] people) {\n                        Arrays.sort(people, new Comparator<int[]>() {\n                                public int compare(int[] p1, int[] p2) {\n                                        return p1[0] != p2[0] ? Integer.compare(p2[0], p1[0])\n                                                        : Integer.compare(p1[1], p2[1]); } });\n                        List<int[]> list = new LinkedList();\n                        for (int[] ppl : people) {\n                                list.add(ppl[1], ppl);\n                        }\n                        return list.toArray(new int[people.length][]);\n                }\npublic int compare(int[] p1, int[] p2) {\n                                        return p1[0] != p2[0] ? Integer.compare(p2[0], p1[0])\n                                                        : Integer.compare(p1[1], p2[1]); }", "129": "public boolean isMonotonic(int[] A) {\n                        int i = 0;\n                        for (; i < A.length - 1; i++) {\n                                if (A[i] <= A[i + 1]) {\n                                        continue;\n                                } else {\n                                        break;\n                                }\n                        }\n                        if (i == A.length - 1) {\n                                return true;\n                        }\n                        i = 0;\n                        for (; i < A.length - 1; i++) {\n                                if (A[i] >= A[i + 1]) {\n                                        continue;\n                                } else {\n                                        break;\n                                }\n                        }\n                        return i == A.length - 1;\n                }", "130": "public int[] getSumAbsoluteDifferences(int[] nums) {\n                        int len = nums.length;\n                        int[] preSums = new int[len];\n                        for (int i = 1; i < len; i++) {\n                                preSums[i] = preSums[i - 1] + nums[i - 1];\n                        }\n                        int[] postSums = new int[len];\n                        for (int i = len - 2; i >= 0; i--) {\n                                postSums[i] = postSums[i + 1] + nums[i + 1];\n                        }\n                        int[] result = new int[len];\n                        for (int i = 0; i < len; i++) {\n                                result[i] = nums[i] * i - preSums[i] + postSums[i] - nums[i] * (len - i - 1);\n                        }\n                        return result;\n                }", "131": "public List<String> letterCombinations(String digits) {\n                        List<String> result = new ArrayList();\n                        if (digits.length() == 0) {\n                                return result;\n                        }\n                        String[] digits2Letters = new String[]{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n                        result.add(\"\");\n                        for (int i = 0; i < digits.length(); i++) {\n                                result = combine(digits2Letters[digits.charAt(i) - '0'], result);\n                        }\n                        return result;\n                }\nList<String> combine(String letters, List<String> result) {\n                        List<String> newResult = new ArrayList();\n                        for (int i = 0; i < letters.length(); i++) {\n                                for (String str : result) {\n                                        newResult.add(str + letters.charAt(i));\n                                }\n                        }\n                        return newResult;\n                }", "132": "public int numTrees(int n) {\n                        int[] G = new int[n + 1];\n                        G[0] = G[1] = 1;\n                        for (int i = 2; i <= n; ++i) {\n                                for (int j = 1; j <= i; ++j) {\n                                        int temp = G[j - 1] * G[i - j];\n                                        G[i] = G[i] + temp;\n                                }\n                        }\n                        return G[n];\n                }", "133": "public int thirdMax(int[] nums) {\n                        long max1 = Long.MIN_VALUE;\n                        long max2 = Long.MIN_VALUE;\n                        long max3 = Long.MIN_VALUE;\n                        for (int i : nums) {\n                                max1 = Math.max(max1, i);\n                        }\n                        for (int i : nums) {\n                                if (i == max1) {\n                                        continue;\n                                }\n                                max2 = Math.max(max2, i);\n                        }\n                        for (int i : nums) {\n                                if (i == max1 i == max2) {\n                                        continue;\n                                }\n                                max3 = Math.max(max3, i);\n                        }\n                        return (int) (max3 == Long.MIN_VALUE ? max1 : max3);\n                }", "134": "public int[] asteroidCollision(int[] asteroids) {\n                        Stack<Integer> stack = new Stack();\n                        for (int i = 0; i < asteroids.length; i++) {\n                                if (!stack.isEmpty() && stack.peek() > 0 && asteroids[i] < 0) {\n                                        if (Math.abs(stack.peek()) < Math.abs(asteroids[i])) {\n                                                stack.pop();\n                                                stack.push(asteroids[i]);\n                                                collide(stack);\n                                        } else if (Math.abs(stack.peek()) == Math.abs(asteroids[i])) {\n                                                stack.pop();\n                                        }\n                                } else {\n                                        stack.push(asteroids[i]);\n                                }\n                        }\n                        int[] result = new int[stack.size()];\n                        int i = stack.size();\n                        while (!stack.isEmpty()) {\n                                result[--i] = stack.pop();\n                        }\n                        return result;\n                }\nprivate void collide(Stack<Integer> stack) {\n                        do {\n                                Integer top = stack.pop();\n                                if (!stack.isEmpty() && stack.peek() * top < 0) {\n                                        if (stack.peek() < Math.abs(top)) {\n                                                stack.pop();\n                                                stack.push(top);\n                                        } else if (stack.peek() == Math.abs(top)) {\n                                                stack.pop();\n                                                break;\n                                        } else {\n                                                break;\n                                        }\n                                } else if (stack.isEmpty() || stack.peek() * top > 0) {\n                                        stack.push(top);\n                                        break;\n                                }\n                        } while (!stack.isEmpty());\n                }", "135": "public int arraySign(int[] nums) {\n                        int negativeCount = 0;\n                        for (int num : nums) {\n                                if (num == 0) {\n                                        return 0;\n                                } else if (num < 0) {\n                                        negativeCount++;\n                                }\n                        }\n                        return negativeCount % 2 == 0 ? 1 : -1;\n                }", "136": "public TreeNode removeLeafNodes(TreeNode root, int target) {\n                        while (hasTargetLeafNodes(root, target)) {\n                                root = removeLeafNodes(target, root);\n                        }\n                        return root;\n                }\nprivate TreeNode removeLeafNodes(int target, TreeNode root) {\n                        if (root == null) {\n                                return root;\n                        }\n                        if (root.val == target && root.left == null && root.right == null) {\n                                root = null;\n                                return root;\n                        }\n                        if (root.left != null && root.left.val == target && root.left.left == null && root.left.right == null) {\n                                root.left = null;\n                        }\n                        if (root.right != null && root.right.val == target && root.right.left == null && root.right.right == null) {\n                                root.right = null;\n                        }\n                        removeLeafNodes(target, root.left);\n                        removeLeafNodes(target, root.right);\n                        return root;\n                }\nprivate boolean hasTargetLeafNodes(TreeNode root, int target) {\n                        if (root == null) {\n                                return false;\n                        }\n                        if (root.left == null && root.right == null && root.val == target) {\n                                return true;\n                        }\n                        return hasTargetLeafNodes(root.left, target) || hasTargetLeafNodes(root.right, target);\n                }", "137": "public String predictPartyVictory(String senate) {\n                        Queue<Integer> radiantQ = new LinkedList<>();\n                        Queue<Integer> direQ = new LinkedList<>();\n                        int len = senate.length();\n                        for (int i = 0; i < len; i++) {\n                                if (senate.charAt(i) == 'R') {\n                                        radiantQ.offer(i);\n                                } else {\n                                        direQ.offer(i);\n                                }\n                        }\n                        while (!radiantQ.isEmpty() && !direQ.isEmpty()) {\n                                int radiantIndex = radiantQ.poll();\n                                int direIndex = direQ.poll();\n                                if (radiantIndex < direIndex) {\n                                        radiantQ.offer(radiantIndex + len);\n                                } else {\n                                        direQ.offer(direIndex + len);\n                                }\n                        }\n                        return radiantQ.isEmpty() ? \"Dire\" : \"Radiant\";\n                }", "138": "public int search(int[] nums, int target) {\n                        if (nums == null nums.length == 0) {\n                                return -1;\n                        }\n                        int minIdx = findMinIdx(nums);\n                        if (target == nums[minIdx]) {\n                                return minIdx;\n                        }\n                        int m = nums.length;\n                        int start = (target <= nums[m - 1]) ? minIdx : 0;\n                        int end = (target > nums[m - 1]) ? minIdx : m - 1;\n                        while (start <= end) {\n                                int mid = start + (end - start) / 2;\n                                if (nums[mid] == target) {\n                                        return mid;\n                                } else if (target > nums[mid]) {\n                                        start = mid + 1;\n                                } else {\n                                        end = mid - 1;\n                                }\n                        }\n                        return -1;\n                }\nprivate int findMinIdx(int[] nums) {\n                        int start = 0;\n                        int end = nums.length - 1;\n                        while (start < end) {\n                                int mid = start + (end - start) / 2;\n                                if (nums[mid] > nums[end]) {\n                                        start = mid + 1;\n                                } else {\n                                        end = mid;\n                                }\n                        }\n                        return start;\n                }", "139": "public int search(int[] nums, int target) {\n                        int left = 0;\n                        int right = nums.length - 1;\n                        if (target < nums[left] target > nums[right]) {\n                                return -1;\n                        }\n                        if (nums[left] == target) {\n                                return left;\n                        } else if (nums[right] == target) {\n                                return right;\n                        }\n                        while (left <= right) {\n                                int mid = left + (right - left) / 2;\n                                if (target == nums[mid]) {\n                                        return mid;\n                                } else if (target > nums[mid]) {\n                                        left = mid + 1;\n                                } else {\n                                        right = mid - 1;\n                                }\n                        }\n                        return -1;\n                }", "140": "public List<int[]> pacificAtlantic(int[][] matrix) {\n                        List<int[]> result = new ArrayList();\n                        if (matrix == null matrix.length == 0 matrix[0].length == 0) {\n                                return result;\n                        }\n                        int m = matrix.length;\n                        int n = matrix[0].length;\n                        boolean[][] pacific = new boolean[m][n];\n                        boolean[][] atlantic = new boolean[m][n];\n                        for (int i = 0; i < m; i++) {\n                                dfs(matrix, pacific, Integer.MIN_VALUE, i, 0);\n                                dfs(matrix, atlantic, Integer.MIN_VALUE, i, n - 1);\n                        }\n                        for (int i = 0; i < n; i++) {\n                                dfs(matrix, pacific, Integer.MIN_VALUE, 0, i);\n                                dfs(matrix, atlantic, Integer.MIN_VALUE, m - 1, i);\n                        }\n                        for (int i = 0; i < m; i++) {\n                                for (int j = 0; j < n; j++) {\n                                        if (pacific[i][j] && atlantic[i][j]) {\n                                                result.add(new int[]{i, j});\n                                        }\n                                }\n                        }\n                        return result;\n                }\nvoid dfs(int[][] matrix, boolean[][] visited, int height, int x, int y) {\n                        int m = matrix.length;\n                        int n = matrix[0].length;\n                        if (x < 0 y < 0 x >= m y >= n matrix[x][y] < height visited[x][y]) {\n                                return;\n                        }\n                        visited[x][y] = true;\n                        dfs(matrix, visited, matrix[x][y], x + 1, y);\n                        dfs(matrix, visited, matrix[x][y], x, y + 1);\n                        dfs(matrix, visited, matrix[x][y], x - 1, y);\n                        dfs(matrix, visited, matrix[x][y], x, y - 1);\n                }", "141": "public int findJudge(int N, int[][] trust) {\n                        int[] trustPoints = new int[N];\n                        Set<Integer> trustOthers = new HashSet<>();\n                        for (int[] eachTrust : trust) {\n                                trustPoints[eachTrust[1] - 1]++;\n                                trustOthers.add(eachTrust[0]);\n                        }\n                        int judge = -1;\n                        for (int i = 0; i < trustPoints.length; i++) {\n                                if (trustPoints[i] == N - 1 && !trustOthers.contains(i + 1)) {\n                                        judge = i + 1;\n                                }\n                        }\n                        return judge;\n                }", "142": "public int[] minOperations(String boxes) {\n                        int[] box = new int[boxes.length()];\n                        for (int i = 0; i < boxes.length(); i++) {\n                                box[i] = boxes.charAt(i) - '0';\n                        }\n                        int[] result = new int[boxes.length()];\n                        for (int i = 0; i < boxes.length(); i++) {\n                                int ops = 0;\n                                for (int j = 0; j < boxes.length(); j++) {\n                                        if (i != j && box[j] == 1) {\n                                                ops += Math.abs(j - i);\n                                        }\n                                }\n                                result[i] = ops;\n                        }\n                        return result;\n                }", "143": "public boolean canMakeArithmeticProgression(int[] arr) {\n                        Arrays.sort(arr);\n                        for (int i = 0; i < arr.length - 2; i++) {\n                                if (arr[i + 1] - arr[i] != arr[i + 2] - arr[i + 1]) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }", "144": "public int maxEvents(int[][] events) {\n                        Arrays.sort(events, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\n                        PriorityQueue<Integer> heap = new PriorityQueue<>();\n                        int maxEvents = 0;\n                        int i = 0;\n                        for (int day = 1; day <= 100000; day++) {\n                                while (i < events.length && events[i][0] == day) {\n                                        heap.offer(events[i++][1]);\n                                }\n                                while (heap.size() > 0 && heap.peek() < day) {\n                                        heap.poll();\n                                }\n                                if (heap.size() > 0) {\n                                        heap.poll();\n                                        maxEvents++;\n                                }\n                        }\n                        return maxEvents;\n                }", "145": "public List<String> binaryTreePaths_more_concise(TreeNode root) {\n                        List<String> paths = new ArrayList<>();\n                        if (root == null) {\n                                return paths;\n                        }\n                        dfs(root, paths, \"\");\n                        return paths;\n                }\nprivate void dfs(TreeNode root, List<String> paths, String path) {\n                        if (root.left == null && root.right == null) {\n                                paths.add(path + root.val);\n                                return;\n                        }\n                        path += root.val + \"->\";\n                        if (root.left != null) {\n                                dfs(root.left, paths, path);\n                        }\n                        if (root.right != null) {\n                                dfs(root.right, paths, path);\n                        }\n                }", "146": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n                        if (root == null root == p root == q) {\n                                return root;\n                        }\n                        TreeNode left = lowestCommonAncestor(root.left, p, q);\n                        TreeNode right = lowestCommonAncestor(root.right, p, q);\n                        if (left != null && right != null) {\n                                return root;\n                        }\n                        return left != null ? left : right;\n                }", "147": "public int[] topKFrequent(int[] nums, int k) {\n                        Map<Integer, Integer> map = new HashMap();\n                        for (int i : nums) {\n                                map.put(i, map.getOrDefault(i, 0) + 1);\n                        }\n                        ArrayList[] bucket = new ArrayList[nums.length + 1];\n                        for (Entry<Integer, Integer> e : map.entrySet()) {\n                                int frequency = e.getValue();\n                                if (bucket[frequency] == null) {\n                                        bucket[frequency] = new ArrayList<Integer>();\n                                }\n                                bucket[frequency].add(e.getKey());\n                        }\n                        List<Integer> result = new ArrayList<>();\n                        for (int i = bucket.length - 1; i >= 0 && result.size() < k; i--) {\n                                if (bucket[i] != null) {\n                                        for (int j = 0; j < bucket[i].size(); j++) {\n                                                result.add((int) bucket[i].get(j));\n                                        }\n                                }\n                        }\n                        int[] arr = new int[result.size()];\n                        for (int i = 0; i < arr.length; i++) {\n                                arr[i] = result.get(i);\n                        }\n                        return arr;\n                }", "148": "public int maxNumberOfBalloons(String text) {\n                        int[] counts = new int[26];\n                        for (char c : text.toCharArray()) {\n                                counts[c - 'a']++;\n                        }\n                        return Math.min(counts[0], Math.min(counts[1], Math.min(counts[11] / 2, Math.min(counts[14] / 2, counts[13]))));\n                }", "149": "public boolean isIsomorphic(String s, String t) {\n                        if (s == null || s.length() == 0) {\n                                return (t == null || t.length() == 0);\n                        }\n                        if (t == null || t.length() == 0) {\n                                return (s == null || s.length() == 0);\n                        }\n                        char[] schar = s.toCharArray();\n                        char[] tchar = t.toCharArray();\n                        Map<Character, Character> map = new HashMap();\n                        if (s.length() != t.length()) {\n                                return false;\n                        }\n                        for (int i = 0; i < s.length(); i++) {\n                                if (map.containsKey(schar[i])) {\n                                        if (map.get(schar[i]) != tchar[i]) {\n                                                return false;\n                                        }\n                                } else {\n                                        if (map.containsValue(tchar[i])) {\n                                                return false;\n                                        }\n                                        map.put(schar[i], tchar[i]);\n                                }\n                        }\n                        return true;\n                }", "150": "public int[] twoSum(int[] numbers, int target) {\n                        int left = 0;\n                        int right = numbers.length - 1;\n                        while (left < right) {\n                                long sum = numbers[left] + numbers[right];\n                                if (sum > target) {\n                                        right--;\n                                } else if (sum < target) {\n                                        left++;\n                                } else {\n                                        return new int[]{left + 1, right + 1};\n                                }\n                        }\n                        return new int[]{-1, -1};\n                }", "151": "public double knightProbability(int N, int K, int r, int c) {\n                        int[][] directions = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\n                        Queue<int[]> queue = new LinkedList<>();\n                        queue.offer(new int[]{r, c});\n                        int level = K;\n                        while (level-- > 0) {\n                                int size = queue.size();\n                                for (int i = 0; i < size; i++) {\n                                        int[] curr = queue.poll();\n                                        for (int[] direction : directions) {\n                                                int x = curr[0] + direction[0];\n                                                int y = curr[1] + direction[1];\n                                                if (x >= 0 && x < N && y >= 0 && y < N) {\n                                                        queue.offer(new int[]{x, y});\n                                                }\n                                        }\n                                }\n                        }\n                        double prob = queue.size();\n                        for (int i = 0; i < K; i++) {\n                                prob /= 8;\n                        }\n                        return prob;\n                }", "152": "public boolean canCross(int[] stones) {\n                        if (stones.length == 0) {\n                                return true;\n                        }\n                        Map<Integer, Set<Integer>> map = new HashMap<>(stones.length);\n                        map.put(0, new HashSet<>());\n                        map.get(0).add(1);\n                        for (int i = 1; i < stones.length; i++) {\n                                map.put(stones[i], new HashSet<>());\n                        }\n                        for (int i = 0; i < stones.length; i++) {\n                                int stone = stones[i];\n                                for (int step : map.get(stone)) {\n                                        int reach = step + stone;\n                                        if (reach == stones[stones.length - 1]) {\n                                                return true;\n                                        }\n                                        Set<Integer> set = map.get(reach);\n                                        if (set != null) {\n                                                set.add(step);\n                                                if (step - 1 > 0) {\n                                                        set.add(step - 1);\n                                                }\n                                                set.add(step + 1);\n                                        }\n                                }\n                        }\n                        return false;\n                }", "153": "public int sumNumbers(TreeNode root) {\n                        if (root == null) {\n                                return 0;\n                        }\n                        List<Integer> allNumbers = new ArrayList();\n                        dfs(root, new StringBuilder(), allNumbers);\n                        int sum = 0;\n                        for (int i : allNumbers) {\n                                sum += i;\n                        }\n                        return sum;\n                }\nprivate void dfs(TreeNode root, StringBuilder sb, List<Integer> allNumbers) {\n                        sb.append(root.val);\n                        if (root.left != null) {\n                                dfs(root.left, sb, allNumbers);\n                        }\n                        if (root.right != null) {\n                                dfs(root.right, sb, allNumbers);\n                        }\n                        if (root.left == null && root.right == null) {\n                                allNumbers.add(Integer.parseInt(sb.toString()));\n                        }\n                        sb.deleteCharAt(sb.length() - 1);\n                }", "154": "public boolean canPartitionKSubsets(int[] nums, int k) {\n                        long sum = 0;\n                        for (int num : nums) {\n                                sum += num;\n                        }\n                        if (sum % k != 0) {\n                                return false;\n                        }\n                        int equalSum = (int) (sum / k);\n                        boolean[] visited = new boolean[nums.length];\n                        return canPartition(nums, visited, 0, k, 0, 0, equalSum);\n                }\nprivate boolean canPartition(int[] nums, boolean[] visited, int startIndex, int k, int currSum, int currNum, int target) {\n                        if (k == 1) {\n                                return true;\n                        }\n                        if (currSum == target && currNum > 0) {\n                                return canPartition(nums, visited, 0, k - 1, 0, 0, target);\n                        }\n                        for (int i = startIndex; i < nums.length; i++) {\n                                if (!visited[i]) {\n                                        visited[i] = true;\n                                        if (canPartition(nums, visited, i + 1, k, currSum + nums[i], currNum++, target)) {\n                                                return true;\n                                        }\n                                        visited[i] = false;\n                                }\n                        }\n                        return false;\n                }", "155": "public boolean isBoomerang(int[][] points) {\n                        return (points[1][1] - points[0][1]) * (points[2][0] - points[0][0]) != (points[2][1] - points[0][1]) * (points[1][0] - points[0][0]);\n                }", "156": "public String longestPrefix(String s) {\n                        int times = 2;\n                        long prefixHash = 0;\n                        long suffixHash = 0;\n                        long multiplier = 1;\n                        long len = 0;\n                        long mod = 1000000007;\n                        for (int i = 0; i < s.length() - 1; i++) {\n                                prefixHash = (prefixHash * times + s.charAt(i)) % mod;\n                                suffixHash = (multiplier * s.charAt(s.length() - i - 1) + suffixHash) % mod;\n                                if (prefixHash == suffixHash) {\n                                        len = i + 1;\n                                }\n                                multiplier = multiplier * times % mod;\n                        }\n                        return s.substring(0, (int) len);\n                }", "157": "public int[] prisonAfterNDays(int[] cells, int N) {\n                        Set<String> prisonStates = new HashSet<>();\n                        boolean hasCycle = false;\n                        int times = 0;\n                        for (int i = 0; i < N; i++) {\n                                int[] next = getNextDay(cells);\n                                String nextDayState = Arrays.toString(next);\n                                if (prisonStates.contains(nextDayState)) {\n                                        hasCycle = true;\n                                        break;\n                                } else {\n                                        prisonStates.add(nextDayState);\n                                        times++;\n                                }\n                                cells = next;\n                        }\n                        if (hasCycle) {\n                                N %= times;\n                                for (int i = 0; i < N; i++) {\n                                        cells = getNextDay(cells);\n                                }\n                        }\n                        return cells;\n                }\nprivate int[] getNextDay(int[] cells) {\n                        int[] nextDay = new int[cells.length];\n                        for (int i = 0; i < cells.length; i++) {\n                                if (i == 0 i == cells.length - 1) {\n                                        nextDay[i] = 0;\n                                } else {\n                                        nextDay[i] = (cells[i - 1] == cells[i + 1]) ? 1 : 0;\n                                }\n                        }\n                        return nextDay;\n                }", "158": "public int[] sortedSquares(int[] nums) {\n                        int[] result = new int[nums.length];\n                        for (int i = 0; i < nums.length; i++) {\n                                result[i] = (int) Math.pow(nums[i], 2);\n                        }\n                        Arrays.sort(result);\n                        return result;\n                }", "159": "public int numWaterBottles(int numBottles, int numExchange) {\n                        int drunk = numBottles;\n                        int emptyBottles = numBottles;\n                        while (emptyBottles >= numExchange) {\n                                int exchangedBottles = emptyBottles / numExchange;\n                                drunk += exchangedBottles;\n                                int unUsedEmptyBottles = emptyBottles % numExchange;\n                                emptyBottles = exchangedBottles + unUsedEmptyBottles;\n                        }\n                        return drunk;\n                }", "160": "public int maximumRequests(int n, int[][] requests) {\n                        helper(requests, 0, new int[n], 0);\n                        return max;\n                }\nprivate void helper(int[][] requests, int index, int[] count, int num) {\n                        if (index == requests.length) {\n                                for (int i : count) {\n                                        if (0 != i) {\n                                                return;\n                                        }\n                                }\n                                max = Math.max(max, num);\n                                return;\n                        }\n                        count[requests[index][0]]++;\n                        count[requests[index][1]]--;\n                        helper(requests, index + 1, count, num + 1);\n                        count[requests[index][0]]--;\n                        count[requests[index][1]]++;\n                        helper(requests, index + 1, count, num);\n                }", "161": "public int minStartValue(int[] nums) {\n                        int min = Integer.MAX_VALUE;\n                        int sum = 0;\n                        for (int num : nums) {\n                                sum += num;\n                                min = Math.min(sum, min);\n                        }\n                        return min > 0 ? 1 : Math.abs(min) + 1;\n                }", "162": "public boolean escapeGhosts(int[][] ghosts, int[] target) {\n                        int[] currPos = {0, 0};\n                        int selfDist = getDist(currPos, target);\n                        for (int[] ghost : ghosts) {\n                                int ghostDist = getDist(ghost, target);\n                                if (ghostDist <= selfDist) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }\nprivate int getDist(int[] p1, int[] p2) {\n                        return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);\n                }", "163": "public int[] closestDivisors(int num) {\n                        int sqrt = (int) Math.sqrt(num);\n                        int left = sqrt + 1;\n                        int right = sqrt + 1;\n                        long product = left * right;\n                        while (product != (long) (num + 1) && product != (long) (num + 2)) {\n                                if (product < (num + 1)) {\n                                        left++;\n                                } else if (product > (num + 2)) {\n                                        right--;\n                                }\n                                product = left * right;\n                        }\n                        return new int[]{left, right};\n                }", "164": "public int maximumScore(int a, int b, int c) {\n                        int[] nums = new int[]{a, b, c};\n                        Arrays.sort(nums);\n                        if (nums[0] + nums[1] < nums[2]) {\n                                return nums[0] + nums[1];\n                        } else {\n                                return (nums[0] + nums[1] + nums[2]) / 2;\n                        }\n                }", "165": "public boolean isPalindrome(ListNode head) {\n                        if (head == null) {\n                                return true;\n                        }\n                        ListNode slow = head;\n                        ListNode fast = head;\n                        while (fast.next != null && fast.next.next != null) {\n                                fast = fast.next.next;\n                                slow = slow.next;\n                        }\n                        ListNode secondHalfHead = reverse(slow.next);\n                        ListNode firstHalfHead = head;\n                        while (firstHalfHead != null && secondHalfHead != null) {\n                                if (firstHalfHead.val != secondHalfHead.val) {\n                                        return false;\n                                }\n                                firstHalfHead = firstHalfHead.next;\n                                secondHalfHead = secondHalfHead.next;\n                        }\n                        return true;\n                }\nprivate ListNode reverse(ListNode head) {\n                        ListNode newHead = null;\n                        while (head != null) {\n                                ListNode next = head.next;\n                                head.next = newHead;\n                                newHead = head;\n                                head = next;\n                        }\n                        return newHead;\n                }", "166": "public boolean isLongPressedName(String name, String typed) {\n                        int i = 0;\n                        for (int j = 0; i < name.length() && j < typed.length(); i++) {\n                                if (name.charAt(i) != typed.charAt(j)) {\n                                        return false;\n                                } else if (i < name.length() - 1 && name.charAt(i) != name.charAt(i + 1)) {\n                                        j++;\n                                        while (j < typed.length() && name.charAt(i) == typed.charAt(j)) {\n                                                j++;\n                                        }\n                                } else {\n                                        j++;\n                                }\n                        }\n                        return i == name.length();\n                }", "167": "public boolean pyramidTransition(String bottom, List<String> allowed) {\n                        Map<String, List<String>> map = new HashMap<>();\n                        for (String s : allowed) {\n                                String key = s.substring(0, 2);\n                                if (!map.containsKey(key)) {\n                                        map.put(key, new ArrayList<>());\n                                }\n                                map.get(key).add(s.substring(2));\n                        }\n                        return helper(bottom, map);\n                }\nprivate boolean helper(String bottom, Map<String, List<String>> map) {\n                        if (bottom.length() == 1) {\n                                return true;\n                        }\n                        for (int i = 0; i < bottom.length() - 1; i++) {\n                                if (!map.containsKey(bottom.substring(i, i + 2))) {\n                                        return false;\n                                }\n                        }\n                        List<String> ls = new ArrayList<>();\n                        getList(bottom, 0, new StringBuilder(), ls, map);\n                        for (String s : ls) {\n                                if (helper(s, map)) {\n                                        return true;\n                                }\n                        }\n                        return false;\n                }\nprivate void getList(String bottom, int idx, StringBuilder sb, List<String> ls, Map<String, List<String>> map) {\n                        if (idx == bottom.length() - 1) {\n                                ls.add(sb.toString());\n                                return;\n                        }\n                        for (String s : map.get(bottom.substring(idx, idx + 2))) {\n                                sb.append(s);\n                                getList(bottom, idx + 1, sb, ls, map);\n                                sb.deleteCharAt(sb.length() - 1);\n                        }\n                }", "168": "public int strangePrinter(String s) {\n                        int n = s.length();\n                        if (n == 0) {\n                                return 0;\n                        }\n                        int[][] dp = new int[101][101];\n                        for (int i = 0; i < n; i++) {\n                                dp[i][i] = 1;\n                        }\n                        for (int i = 1; i < n; i++) {\n                                for (int j = 0; j < n - i; j++) {\n                                        dp[j][j + i] = i + 1;\n                                        for (int k = j + 1; k <= j + i; k++) {\n                                                int temp = dp[j][k - 1] + dp[k][j + i];\n                                                if (s.charAt(k - 1) == s.charAt(j + i)) {\n                                                        temp--;\n                                                }\n                                                dp[j][j + i] = Math.min(dp[j][j + i], temp);\n                                        }\n                                }\n                        }\n                        return dp[0][n - 1];\n                }", "169": "public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {\n                        int[][] tuple = new int[values.length][2];\n                        for (int i = 0; i < values.length; i++) {\n                                tuple[i][0] = values[i];\n                                tuple[i][1] = labels[i];\n                        }\n                        Arrays.sort(tuple, (a, b) -> b[0] - a[0]);\n                        Map<Integer, Integer> labelUsedCountMap = new HashMap<>();\n                        int sum = 0;\n                        int numbersUsed = 0;\n                        for (int i = 0; i < values.length; i++) {\n                                int val = tuple[i][0];\n                                int usedCount = labelUsedCountMap.getOrDefault(tuple[i][1], 0);\n                                if (usedCount >= useLimit) {\n                                        continue;\n                                } else {\n                                        sum += val;\n                                        numbersUsed++;\n                                        labelUsedCountMap.put(tuple[i][1], usedCount + 1);\n                                }\n                                if (numbersUsed >= numWanted) {\n                                        break;\n                                }\n                        }\n                        return sum;\n                }", "170": "public int kthFactor(int n, int k) {\n                        List<Integer> list = new ArrayList<>();\n                        for (int i = 1; i <= n; i++) {\n                                if (n % i == 0) {\n                                        list.add(i);\n                                }\n                        }\n                        return list.size() >= k ? list.get(k - 1) : -1;\n                }", "171": "public int minInsertions(String s) {\n                        Stack<Character> stack = new Stack<>();\n                        int insertionsNeeded = 0;\n                        for (int i = 0; i < s.length(); i++) {\n                                char c = s.charAt(i);\n                                if (c == '(') {\n                                        if (stack.isEmpty()) {\n                                                stack.add(c);\n                                        } else {\n                                                if (stack.peek() == ')') {\n                                                        insertionsNeeded++;\n                                                        stack.pop();\n                                                        stack.pop();\n                                                        stack.add(c);\n                                                } else {\n                                                        stack.add(c);\n                                                }\n                                        }\n                                } else if (c == ')') {\n                                        if (stack.isEmpty()) {\n                                                insertionsNeeded++;\n                                                stack.add('(');\n                                                stack.add(c);\n                                        } else {\n                                                if (stack.peek() == ')') {\n                                                        stack.pop();\n                                                        stack.pop();\n                                                } else {\n                                                        stack.add(c);\n                                                }\n                                        }\n                                }\n                        }\n                        if (stack.isEmpty()) {\n                                return insertionsNeeded;\n                        } else {\n                                while (!stack.isEmpty()) {\n                                        char pop = stack.pop();\n                                        if (pop == '(') {\n                                                insertionsNeeded += 2;\n                                        } else {\n                                                insertionsNeeded++;\n                                                stack.pop();\n                                        }\n                                }\n                                return insertionsNeeded;\n                        }\n                }", "172": "public String addStrings(String num1, String num2) {\n                        if (num1 == null || num1.length() == 0) {\n                                return num2;\n                        } else if (num2 == null || num2.length() == 0) {\n                                return num1;\n                        }\n                        int i = num1.length() - 1;\n                        int j = num2.length() - 1;\n                        long carry = 0;\n                        long sum = 0;\n                        StringBuilder sb = new StringBuilder();\n                        char[] char1 = num1.toCharArray();\n                        char[] char2 = num2.toCharArray();\n                        while (i >= 0 j >= 0) {\n                                sum = carry;\n                                if (i >= 0) {\n                                        sum += Character.getNumericValue(char1[i--]);\n                                }\n                                if (j >= 0) {\n                                        sum += Character.getNumericValue(char2[j--]);\n                                }\n                                carry = sum / 10;\n                                sb.append(sum % 10);\n                        }\n                        if (carry != 0) {\n                                sb.append(carry);\n                        }\n                        return sb.reverse().toString();\n                }", "173": "public void solveSudoku(char[][] board) {\n                        if (board == null board.length == 0) {\n                                return;\n                        }\n                        solve(board);\n                }\nprivate boolean solve(char[][] board) {\n                        for (int i = 0; i < board.length; i++) {\n                                for (int j = 0; j < board[0].length; j++) {\n                                        if (board[i][j] == '.') {\n                                                for (char c = '1'; c <= '9'; c++) {\n                                                        if (isValid(board, i, j, c)) {\n                                                                board[i][j] = c;\n                                                                if (solve(board)) {\n                                                                        return true;\n                                                                } else {\n                                                                        board[i][j] = '.';\n                                                                }\n                                                        }\n                                                }\n                                                return false;\n                                        }\n                                }\n                        }\n                        return true;\n                }\nprivate boolean isValid(char[][] board, int row, int col, char c) {\n                        for (int i = 0; i < 9; i++) {\n                                if (board[i][col] != '.' && board[i][col] == c) {\n                                        return false;\n                                }\n                                if (board[row][i] != '.' && board[row][i] == c) {\n                                        return false;\n                                }\n                                if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] != '.' && board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) {\n                                        return false; \n                                }\n                        }\n                        return true;\n                }", "174": "public int concatenatedBinary(int n) {\n                        final int MOD = 1000000007;\n                        int result = 0;\n                        for (int i = 1; i <= n; i++) {\n                                String binary = Integer.toBinaryString(i);\n                                for (int j = 0; j < binary.length(); j++) {\n                                        result = (result * 2 + (binary.charAt(j) - '0')) % MOD;\n                                }\n                        }\n                        return result;\n                }", "175": "public int secondHighest(String s) {\n                        TreeSet<Integer> set = new TreeSet<>();\n                        for (char c : s.toCharArray()) {\n                                if (Character.isDigit(c)) {\n                                        set.add(Character.getNumericValue(c));\n                                }\n                        }\n                        if (set.isEmpty() || set.size() == 1) {\n                                return -1;\n                        }\n                        List<Integer> list = new ArrayList<>(set);\n                        return list.get(list.size() - 2);\n                }", "176": "public int maximumGap(int[] nums) {\n        if (nums.length < 2) {\n                return 0;\n        }\n        Arrays.sort(nums);\n        int max = Integer.MIN_VALUE;\n        for (int i = 1; i < nums.length; ) {\n                while (i < nums.length && nums[i] == nums[i - 1]) {\n                i++;\n                }\n                if (i == nums.length) {\n                i--;\n                max = (nums[i] - nums[i - 1] > max) ? nums[i] - nums[i - 1] : max;\n                break;\n                } else {\n                max = (nums[i] - nums[i - 1] > max) ? nums[i] - nums[i - 1] : max;\n                }\n                if (nums[i] != nums[i - 1]) {\n                i++;\n                }\n        }\n        return max;\n        }", "177": "public int[][] generateMatrix(int n) {\n                        int[][] matrix = new int[n][n];\n                        if (n == 0) {\n                                return matrix;\n                        }\n                        int value = 1;\n                        int top = 0;\n                        int bottom = n - 1;\n                        int left = 0;\n                        int right = n - 1;\n                        while (left <= right && top <= bottom) {\n                                for (int j = left; j <= right; j++) {\n                                        matrix[top][j] = value++;\n                                }\n                                top++;\n                                for (int i = top; i <= bottom; i++) {\n                                        matrix[i][right] = value++;\n                                }\n                                right--;\n                                for (int j = right; j >= left; j--) {\n                                        matrix[bottom][j] = value++;\n                                }\n                                bottom--;\n                                for (int i = bottom; i >= top; i--) {\n                                        matrix[i][left] = value++;\n                                }\n                                left++;\n                        }\n                        return matrix;\n                }", "178": "public int maxSizeSlices(int[] slices) {\n                        int n = slices.length;\n                        int[] b = Arrays.copyOf(slices, 2 * n);\n                        for (int i = 0; i < n; i++) {\n                                b[i + n] = slices[i];\n                        }\n                        int[][] dp = new int[2 * n][2 * n];\n                        for (int len = 3; len <= n; len += 3) {\n                                for (int i = 0; i + len - 1 < 2 * n; i++) {\n                                        int j = i + len - 1;\n                                        for (int k = i + 3; k <= j - 2; k += 3) {\n                                                dp[i][j] = Math.max(dp[i][j], dp[i][k - 1] + dp[k][j]);\n                                        }\n                                        for (int k = i + 1; k < j; k += 3) {\n                                                dp[i][j] = Math.max(dp[i][j],\n                                                                (i + 1 <= k - 1 ? dp[i + 1][k - 1] : 0)\n                                                                                + b[k] + (k + 1 <= j - 1 ? dp[k + 1][j - 1] : 0) );\n                                        }\n                                }\n                        }\n                        int ans = 0;\n                        for (int i = 0; i < n; i++) {\n                                ans = Math.max(ans, dp[i][i + n - 1]);\n                        }\n                        return ans;\n                }", "179": "public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n                        int sum = (1 + maxChoosableInteger) * maxChoosableInteger / 2;\n                        if (sum < desiredTotal) {\n                                return false;\n                        }\n                        if (desiredTotal <= 0) {\n                                return true;\n                        }\n                        map = new HashMap();\n                        used = new boolean[maxChoosableInteger + 1];\n                        return helper(desiredTotal);\n                }\npublic boolean helper(int desiredTotal) {\n                        if (desiredTotal <= 0) {\n                                return false;\n                        }\n                        int key = format(used);\n                        if (!map.containsKey(key)) {\n                                for (int i = 1; i < used.length; i++) {\n                                        if (!used[i]) {\n                                                used[i] = true;\n                                                if (!helper(desiredTotal - i)) {\n                                                        map.put(key, true);\n                                                        used[i] = false;\n                                                        return true;\n                                                }\n                                                used[i] = false;\n                                        }\n                                }\n                                map.put(key, false);\n                        }\n                        return map.get(key);\n                }\npublic int format(boolean[] used) {\n                        int num = 0;\n                        for (boolean b : used) {\n                                num <<= 1;\n                                if (b) {\n                                        num |= 1;\n                                }\n                        }\n                        return num;\n                }", "180": "public boolean closeStrings(String word1, String word2) {\n                        int[] counts1 = new int[26];\n                        int[] counts2 = new int[26];\n                        Set<Character> set1 = new HashSet<>();\n                        Set<Character> set2 = new HashSet<>();\n                        for (char c : word1.toCharArray()) {\n                                counts1[c - 'a']++;\n                                set1.add(c);\n                        }\n                        Arrays.sort(counts1);\n                        for (char c : word2.toCharArray()) {\n                                counts2[c - 'a']++;\n                                set2.add(c);\n                        }\n                        Arrays.sort(counts2);\n                        return set1.equals(set2) && Arrays.equals(counts1, counts2);\n                }", "181": "public String getHint(String secret, String guess) {\n                        int[] secretCows = new int[10];\n                        int[] guessCows = new int[10];\n                        int bulls = 0;\n                        for (int i = 0; i < secret.length(); i++) {\n                                if (guess.charAt(i) == secret.charAt(i)) {\n                                        bulls++;\n                                } else {\n                                        secretCows[Character.getNumericValue(secret.charAt(i))]++;\n                                        guessCows[Character.getNumericValue(guess.charAt(i))]++;\n                                }\n                        }\n                        int cows = 0;\n                        for (int i = 0; i < 10; i++) {\n                                cows += Math.min(secretCows[i], guessCows[i]);\n                        }\n                        return bulls + \"A\" + cows + \"B\";\n                }", "182": "public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n                        root = new HashMap<>();\n                        rate = new HashMap<>();\n                        int n = equations.size();\n                        for (int i = 0; i < n; ++i) {\n                                String X = equations.get(i).get(0);\n                                String Y = equations.get(i).get(1);\n                                root.put(X, X);\n                                root.put(Y, Y);\n                                rate.put(X, 1.0);\n                                rate.put(Y, 1.0);\n                        }\n                        for (int i = 0; i < n; ++i) {\n                                String X = equations.get(i).get(0);\n                                String Y = equations.get(i).get(1);\n                                union(X, Y, values[i]);\n                        }\n                        double[] result = new double[queries.size()];\n                        for (int i = 0; i < queries.size(); ++i) {\n                                String X = queries.get(i).get(0);\n                                String Y = queries.get(i).get(1);\n                                if (!root.containsKey(X) || !root.containsKey(Y)) {\n                                        result[i] = -1;\n                                        continue;\n                                }\n                                String rootx = findRoot(X, X, 1.0);\n                                String rooty = findRoot(Y, Y, 1.0);\n                                result[i] = rootx.equals(rooty) ? rate.get(X) / rate.get(Y) : -1.0;\n                        }\n                        return result;\n                }\nprivate void union(String X, String Y, double v) {\n                        String rootx = findRoot(X, X, 1.0);\n                        String rooty = findRoot(Y, Y, 1.0);\n                        root.put(rootx, rooty);\n                        double r1 = rate.get(X);\n                        double r2 = rate.get(Y);\n                        rate.put(rootx, v * r2 / r1);\n                }\nprivate String findRoot(String originalX, String X, double r) {\n                        if (root.get(X).equals(X)) {\n                                root.put(originalX, X);\n                                rate.put(originalX, r * rate.get(X));\n                                return X;\n                        }\n                        return findRoot(originalX, root.get(X), r * rate.get(X));\n                }", "183": "public int[] decrypt(int[] code, int k) {\n                        int[] result = new int[code.length];\n                        int len = code.length;\n                        if (k == 0) {\n                                for (int i = 0; i < code.length; i++) {\n                                        result[i] = 0;\n                                }\n                        } else if (k > 0) {\n                                int kSum = 0;\n                                for (int i = 1; i <= k; i++) {\n                                        kSum += code[i];\n                                }\n                                result[0] = kSum;\n                                for (int i = 1; i < len; i++) {\n                                        kSum -= code[i];\n                                        kSum += code[(i + k) % len];\n                                        result[i] = kSum;\n                                }\n                        } else {\n                                int kSum = 0;\n                                int kVal = Math.abs(k);\n                                for (int i = len - 1; i >= len - kVal; i--) {\n                                        kSum += code[i];\n                                }\n                                result[0] = kSum;\n                                for (int i = 1; i < len; i++) {\n                                        kSum -= code[(len - kVal + i - 1) % len];\n                                        kSum += code[i - 1];\n                                        result[i] = kSum;\n                                }\n                        }\n                        return result;\n                }", "184": "public TreeNode searchBST(TreeNode root, int val) {\n                        if (root == null) {\n                                return null;\n                        } else if (root.val == val) {\n                                return root;\n                        } else if (root.val > val) {\n                                return searchBST(root.left, val);\n                        } else {\n                                return searchBST(root.right, val);\n                        }\n                }", "185": "public int totalHammingDistance(int[] nums) {\n                        int r = 0;\n                        for (int i = 0; i < 32; i++) {\n                                int one = 0;\n                                int zero = 0;\n                                int bit = 1 << i;\n                                for (int n : nums) {\n                                        if ((n & bit) != 0) {\n                                                one++;\n                                        } else {\n                                                zero++;\n                                        }\n                                }\n                                r += one * zero;\n                        }\n                        return r;\n                }", "186": "public boolean uniqueOccurrences(int[] arr) {\n                        Map<Integer, Integer> map = new HashMap<>();\n                        Arrays.stream(arr).forEach(num -> {\n                                map.put(num, map.containsKey(num) ? map.get(num) + 1 : 1); });\n                        Set<Integer> set = new HashSet<>();\n                        return map.keySet().stream().mapToInt(key -> key).allMatch(key -> set.add(map.get(key)));\n                }", "187": "public int[] decompressRLElist(int[] nums) {\n                        List<Integer> list = new ArrayList<>();\n                        for (int i = 0; i < nums.length - 1; i += 2) {\n                                int count = nums[i];\n                                int value = nums[i + 1];\n                                while (count-- > 0) {\n                                        list.add(value);\n                                }\n                        }\n                        return list.stream().mapToInt(integer -> integer).toArray();\n                }", "188": "There is no code here", "189": "public int findLength(int[] nums1, int[] nums2) {\n                        int[] shorter = nums1.length < nums2.length ? nums1 : nums2;\n                        int[] longer = nums1.length < nums2.length ? nums2 : nums1;\n                        int maxLen = 0;\n                        for (int i = 0; i < shorter.length - 1; i++) {\n                                for (int j = shorter.length; j >= 0 && j > i && j - i > maxLen; j--) {\n                                        int[] candidate = Arrays.copyOfRange(shorter, i, j);\n                                        if (candidate.length > maxLen && isSubarray(candidate, longer)) {\n                                                maxLen = candidate.length;\n                                        }\n                                }\n                        }\n                        return maxLen;\n                }\nprivate boolean isSubarray(int[] candidate, int[] array) {\n                        for (int i = 0; i <= array.length - candidate.length; i++) {\n                                if (Arrays.equals(candidate, Arrays.copyOfRange(array, i, i + candidate.length))) {\n                                        return true;\n                                }\n                        }\n                        return false;\n                }", "190": "public boolean canWinNim(int n) {\n                        return n % 4 != 0;\n                }", "191": "public boolean canMeasureWater(int x, int y, int z) {\n                        if (x + y < z) {\n                                return false;\n                        }\n                        if (x == z y == z x + y == z) {\n                                return true;\n                        }\n                        return z % gcd(x, y) == 0;\n                }\nint gcd(int x, int y) {\n                        while (y != 0) {\n                                int temp = y;\n                                y = x % y;\n                                x = temp;\n                        }\n                        return x;\n                }", "192": "public List<List<Integer>> levelOrder(TreeNode root) {\n                        List<List<Integer>> result = new ArrayList<>();\n                        if (root == null) {\n                                return result;\n                        }\n                        Queue<TreeNode> queue = new LinkedList();\n                        queue.offer(root);\n                        while (!queue.isEmpty()) {\n                                List<Integer> thisLevel = new ArrayList();\n                                int size = queue.size();\n                                for (int i = 0; i < size; i++) {\n                                        TreeNode curr = queue.poll();\n                                        thisLevel.add(curr.val);\n                                        if (curr.left != null) {\n                                                queue.offer(curr.left);\n                                        }\n                                        if (curr.right != null) {\n                                                queue.offer(curr.right);\n                                        }\n                                }\n                                result.add(thisLevel);\n                        }\n                        return result;\n                }", "193": "public int minimumDeleteSum(String s1, String s2) {\n                        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\n                        for (int i = s1.length() - 1; i >= 0; i--) {\n                                dp[i][s2.length()] = dp[i + 1][s2.length()] + s1.codePointAt(i);\n                        }\n                        for (int j = s2.length() - 1; j >= 0; j--) {\n                                dp[s1.length()][j] = dp[s1.length()][j + 1] + s2.codePointAt(j);\n                        }\n                        for (int i = s1.length() - 1; i >= 0; i--) {\n                                for (int j = s2.length() - 1; j >= 0; j--) {\n                                        if (s1.charAt(i) == s2.charAt(j)) {\n                                                dp[i][j] = dp[i + 1][j + 1];\n                                        } else {\n                                                dp[i][j] = Math.min(dp[i + 1][j] + s1.codePointAt(i), dp[i][j + 1] + s2.codePointAt(j));\n                                        }\n                                }\n                        }\n                        return dp[0][0];\n                }", "194": "public int romanToInt(String s) {\n                        Map<Character, Integer> map = new HashMap();\n                        map.put('I', 1);\n                        map.put('V', 5);\n                        map.put('X', 10);\n                        map.put('L', 50);\n                        map.put('C', 100);\n                        map.put('D', 500);\n                        map.put('M', 1000);\n                        int result = 0;\n                        for (int i = 0; i < s.length(); i++) {\n                                if (i > 0 && map.get(s.charAt(i)) > map.get(s.charAt(i - 1))) {\n                                        result += map.get(s.charAt(i)) - 2 * map.get(s.charAt(i - 1));\n                                } else {\n                                        result += map.get(s.charAt(i));\n                                }\n                        }\n                        return result;\n                }", "195": "public List<String> letterCasePermutation(String S) {\n                        Set<String> result = new HashSet<>();\n                        result.add(S);\n                        for (int i = 0; i < S.length(); i++) {\n                                if (Character.isAlphabetic(S.charAt(i))) {\n                                        Set<String> newResult = new HashSet<>();\n                                        for (String word : result) {\n                                                if (Character.isUpperCase(word.charAt(i))) {\n                                                        StringBuilder sb = new StringBuilder();\n                                                        for (int j = 0; j < i; j++) {\n                                                                sb.append(word.charAt(j));\n                                                        }\n                                                        sb.append(Character.toLowerCase(word.charAt(i)));\n                                                        for (int j = i + 1; j < word.length(); j++) {\n                                                                sb.append(word.charAt(j));\n                                                        }\n                                                        newResult.add(sb.toString());\n                                                } else {\n                                                        StringBuilder sb = new StringBuilder();\n                                                        for (int j = 0; j < i; j++) {\n                                                                sb.append(word.charAt(j));\n                                                        }\n                                                        sb.append(Character.toUpperCase(word.charAt(i)));\n                                                        for (int j = i + 1; j < word.length(); j++) {\n                                                                sb.append(word.charAt(j));\n                                                        }\n                                                        newResult.add(sb.toString());\n                                                }\n                                        }\n                                        result.addAll(newResult);\n                                }\n                        }\n                        return new ArrayList<>(result);\n                }", "196": "public int minPairSum(int[] nums) {\n                        Arrays.sort(nums);\n                        int maxSum = 0;\n                        for (int left = 0, right = nums.length - 1; left < right; left++, right--) {\n                                maxSum = Math.max(maxSum, nums[left] + nums[right]);\n                        }\n                        return maxSum;\n                }", "197": "public int minCostToMoveChips(int[] position) {\n                        int chipsAtOddPosition = 0;\n                        int chipsAtEvenPosition = 0;\n                        for (int i = 0; i < position.length; i++) {\n                                if (position[i] % 2 == 0) {\n                                        chipsAtEvenPosition++;\n                                } else {\n                                        chipsAtOddPosition++;\n                                }\n                        }\n                        return chipsAtEvenPosition > chipsAtOddPosition ? chipsAtOddPosition : chipsAtEvenPosition;\n                }", "198": "public boolean isCousins(TreeNode root, int x, int y) {\n                        Queue<TreeNode> queue = new LinkedList<>();\n                        queue.offer(root);\n                        while (!queue.isEmpty()) {\n                                int size = queue.size();\n                                for (int i = 0; i < size; i++) {\n                                        TreeNode current = queue.poll();\n                                        if (current.left != null) {\n                                                queue.offer(current.left);\n                                        }\n                                        if (current.right != null) {\n                                                queue.offer(current.right);\n                                        }\n                                        if (current.left != null && current.right != null) {\n                                                if (current.left.val == x && current.right.val == y current.left.val == y && current.right.val == x) {\n                                                        return false;\n                                                }\n                                        }\n                                }\n                                if (checkQueue(queue, x, y)) {\n                                        return true;\n                                }\n                        }\n                        return false;\n                }\nprivate boolean checkQueue(Queue<TreeNode> queue, int x, int y) {\n                        Set<Integer> set = new HashSet<>();\n                        Queue<TreeNode> tmp = new LinkedList<>(queue);\n                        while (!tmp.isEmpty()) {\n                                set.add(tmp.poll().val);\n                        }\n                        return set.contains(x) && set.contains(y);\n                }", "199": "public boolean isScramble(String s1, String s2) {\n                        if (s1.equals(s2)) {\n                                return true;\n                        }\n                        if (s1.length() != s2.length()) {\n                                return false;\n                        }\n                        int[] letters = new int[26];\n                        for (int i = 0; i < s1.length(); i++) {\n                                letters[s1.charAt(i) - 'a']++;\n                                letters[s2.charAt(i) - 'a']--;\n                        }\n                        for (int i : letters) {\n                                if (i != 0) {\n                                        return false;\n                                }\n                        }\n                        for (int i = 1; i < s1.length(); i++) {\n                                if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(\n                                                s1.substring(i), s2.substring(i))) {\n                                        return true;\n                                }\n                                if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && isScramble(\n                                                s1.substring(i), s2.substring(0, s2.length() - i))) {\n                                        return true;\n                                }\n                        }\n                        return false;\n                }"}, "Python": {"0": "def deleteNode(node):\n    node.val = node.next.val\n    node.next = node.next.next", "1": "def countStudents(students, sandwiches):\n                        studentsQueue = []\n                        sandwichesQueue = []\n                        for i in range(len(sandwiches)):\n                                studentsQueue.append(students[i])\n                                sandwichesQueue.append(sandwiches[i])\n                        while True:\n                                if not studentsQueue:\n                                        break\n                                if studentsQueue[0] == sandwichesQueue[0]:\n                                        studentsQueue.pop(0)\n                                        sandwichesQueue.pop(0)\n                                else:\n                                        if sandwichesQueue[0] not in studentsQueue:\n                                                break\n                                        studentsQueue.append(studentsQueue.pop(0))\n                        return len(studentsQueue)", "2": "def frequencySort(nums):\n    count = {}\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n\n    map = {}\n\n    for num in count:\n        if count[num] not in map:\n            map[count[num]] = []\n        map[count[num]].append(num)\n\n    result = []\n    for num in sorted(map, reverse = True):\n        for j in range(len(map[num])):\n            for k in range(num):\n                result.append(map[num][j])\n\n    return result", "3": "def validPalindrome(s):\n        left = 0\n        right = len(s) - 1\n        diff = 0\n        while left < right:\n                if s[left] != s[right]:\n                        left += 1\n                        diff += 1\n                        if diff > 1:\n                                break\n                else:\n                        left += 1\n                        right -= 1\n        if diff < 2:\n                return True\n        diff = 0\n        left = 0\n        right = len(s) - 1\n        while left < right:\n                if s[left] != s[right]:\n                        right -= 1\n                        diff += 1\n                        if diff > 1:\n                                break\n                else:\n                        left += 1\n                        right -= 1\n        return diff < 2", "4": "def removePalindromeSub(self, s):\n        if s==\"\":\n                return 0\n        if s==s[::-1]:\n                return 1\n        return 2", "5": "def maxDepth(root):\n        if root == None:\n                return 0\n        return max(maxDepth(root.left), maxDepth(root.right)) + 1", "6": NaN, "7": "def getMaxRepetitions(s1, n1, s2, n2):\n    s1chars = list(s1)\n    s2chars = list(s2)\n    i = 0\n    j = 0\n    count1 = 0\n    count2 = 0\n    while count1 < n1:\n        if s1chars[i] == s2chars[j]:\n            j += 1\n            if j == len(s2):\n                j = 0\n                count2 += 1\n        i += 1\n        if i == len(s1):\n            i = 0\n            count1 += 1\n    return count2 // n2", "8": "def longestConsecutive(nums):\n                        map = {}\n                        uf = UnionFind(nums)\n                        for i in range(nums.length):\n                                if (nums[i] in map):\n                                        continue\n                                map[nums[i]] = i\n                                if (nums[i] - 1 in map):\n                                        uf.union(i, map.get(nums[i] - 1))\n                                if (nums[i] + 1 in map):\n                                        uf.union(i, map.get(nums[i] + 1))\n                        return uf.maxUnion()", "9": "def halvesAreAlike(s):\n    vowels = set(list('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'))\n    firstHalfVowelsCount = 0\n    secondHalfVowelsCount = 0\n    for i in range(0, len(s) / 2):\n        if s[i] in vowels:\n            firstHalfVowelsCount += 1\n    for i in range(len(s) / 2, len(s)):\n        if s[i] in vowels:\n            secondHalfVowelsCount += 1\n    return firstHalfVowelsCount == secondHalfVowelsCount", "10": "def integerBreak(n):\n        if n == 2:\n                return 1\n        elif n == 3:\n                return 2\n        elif n % 3 == 0:\n                return 3**(n/3)\n        elif n % 3 == 1:\n                return 2 * 2 * (3**((n-4)/3))\n        else:\n                return 2 * (3**(n/3))", "11": "def findMin(nums):\n        left = 0\n        right = len(nums) - 1\n        if nums[left] < nums[right]:\n                return nums[left]\n        min = nums[0]\n        while left + 1 < right:\n                mid = left + (right - left) // 2\n                min = min(min, nums[mid])\n                if nums[mid] > nums[left]:\n                        min = min(nums[left], min)\n                        left = mid + 1\n                elif nums[mid] < nums[left]:\n                        right = mid - 1\n        min = min(min, min(nums[left], nums[right]))\n        return min", "12": "def isNumber(s):\n    s = s.trim()\n    pointSeen = False\n    eSeen = False\n    numberSeen = False\n    numberAfterE = True\n\n    for i in range(len(s)):\n        if ('0' <= s[i] <= '9'):\n            numberSeen = True\n            numberAfterE = True\n        elif s[i] == '.':\n            if (eSeen or pointSeen):\n                return False\n            pointSeen = True\n        elif s[i] == 'e':\n            if (eSeen or not numberSeen):\n                return False\n            numberAfterE = False\n            eSeen = True\n        elif s[i] == '-' or s[i] == '+':\n            if (i != 0 and s[i-1] != 'e'):\n                return False\n        else:\n            return False\n\n    return numberSeen and numberAfterE", "13": "def findLengthOfLCIS(nums):\n                        longest = 0\n                        for i in range(len(nums)):\n                                len = 1\n                                for j in range(i + 1, len(nums)):\n                                        if nums[j - 1] < nums[j]:\n                                                len++\n                                                continue\n                                        else:\n                                                break\n                                longest = max(longest, len)\n                        return longest", "14": "def searchRange(nums, target) -> int[]:\n        range = [0,0]\n        if (nums == null or len(nums) == 0) {\n                return range\n        }\n        start = 0\n        end = len(nums) - 1\n        while start + 1 < end:\n                mid = start + (end - start) // 2\n                if (nums[mid] == target):\n                        left = mid\n                        while left - 1 >= 0 and nums[left] == nums[left - 1]:\n                                left--\n                        range[0] = left\n                        right = mid\n                        while right + 1 < len(nums) and nums[right] == nums[right + 1]:\n                                right++\n                        range[1] = right\n                        break\n                elif (nums[mid] < target):\n                        start = mid\n                else:\n                        end = mid\n        if (nums[start] == target):\n                range[0] = start\n                while (start + 1 < len(nums) and nums[start] == nums[start + 1]):\n                        start++\n                range[1] = start\n        elif (nums[end] == target):\n                range[1] = end\n                while (end - 1 >= 0 and nums[end] == nums[end - 1]):\n                        end--\n                range[0] = end\n        return range", "15": "def isEvenOddTree(root):\n                        queue = []\n                        queue.append(root)\n                        level = 0\n                        while (len(queue) != 0):\n                                size = len(queue)\n                                list = []\n                                for i in range(size):\n                                        node = queue.pop()\n                                        list.append(node.val)\n                                        if (node.left != None):\n                                                queue.append(node.left)\n                                        if (node.right != None):\n                                                queue.append(node.right)\n                                if (level % 2 == 0):\n                                        for i in range(len(list)):\n                                                if (list[i] % 2 == 0):\n                                                        return False\n                                                if (i < len(list) - 1 and list[i] >= list[i + 1]):\n                                                        return False\n                                else:\n                                        for i in range(len(list)):\n                                                if (list[i] % 2 != 0):\n                                                        return False\n                                                if (i < len(list) - 1 and list[i] <= list[i + 1]):\n                                                        return False\n                                level += 1\n                        return True", "16": "def firstBadVersion(n):\n        left = 1\n        right = n\n        while left < right:\n                mid = left + (right - left) // 2\n                if isBadVersion(mid):\n                        right = mid\n                else:\n                        left = mid + 1\n        return left\n\ndef isBadVersion(left):\n        return False", "17": "def validUtf8(data):\n        count = 0\n        for d in data:\n                if count == 0:\n                        if ((d >> 5) == 0b110):\n                                count = 1\n                        elif ((d >> 4) == 0b1110):\n                                count = 2\n                        elif ((d >> 3) == 0b11110):\n                                count = 3\n                        elif ((d >> 7) == 1):\n                                return False\n                else:\n                        if ((d >> 6) != 0b10):\n                                return False\n                        else:\n                                count -= 1\n        return count == 0", "18": "def closestCost(baseCosts, toppingCosts, target):\n            result = baseCosts[0]\n            for i in range(0, len(baseCosts)):\n                    recursion(baseCosts[i], toppingCosts, 0, target)\n            return result\n    \ndef recursion(currentCost, toppingCosts, index, target):\n            if (abs(currentCost - target) < abs(result - target) or (abs(currentCost - target) < abs(result - target) and currentCost == result)):\n                    result = currentCost\n            if (index == len(toppingCosts) or currentCost == target):\n                    return\n            recursion(currentCost, toppingCosts, index + 1, target)\n            recursion(currentCost + toppingCosts[index], toppingCosts, index + 1, target)\n            recursion(currentCost + toppingCosts[index] * 2, toppingCosts, index + 1, target)", "19": "def findMaxAverage(nums, k):\n\tsum = 0\n\tmaxAve = min\n\tfor i in range(0, len(nums)):\n\t\tif k <= i:\n\t\t\tsum -= nums[i - k]\n\t\tsum += nums[i]\n\t\tif ((i + 1) >= k):\n\t\t\tmaxAve = max(maxAve, sum / k)\n\treturn maxAve", "20": "def findMaximumXOR(nums):\n    max = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask = mask | 1 << i\n        print(\"mask = \", bin(mask))\n        set = set()\n        for num in nums:\n            print(\"num = \", bin(num))\n            set.add(num & mask)\n            print(\"mask & num = \", bin(mask & num))\n        candidate = max | 1 << i\n        print(\"candidate = \", bin(candidate))\n        for prefix in set:\n            print(\"candidate ^ prefix = \", bin(candidate ^ prefix))\n            if candidate ^ prefix in set:\n                max = candidate\n        print(\"max = \", max)\n        print(\"i = \", i)\n        print(\"===============================================\")\n    return max", "21": NaN, "22": "def trimMean(arr): \n        arr.sort()\n        n = len(arr)\n        sum = 0\n        for i in range(int(round(n * 0.05)), (n - (n * 0.05))):\n                sum += arr[i]\n        return sum / (n - (n * 0.1))", "23": "def flipAndInvertImage(A):\n    m = len(A)\n    n = len(A[0])\n    result = [[0] * n for _ in range(m)]\n    for i in range(m):\n        flipped = reverse(A[i])\n        result[i] = invert(flipped)\n    return result\n\ndef invert(flipped):\n    result = [0] * len(flipped)\n    for i in range(len(flipped)):\n        if flipped[i] == 0:\n            result[i] = 1\n        else:\n            result[i] = 0\n    return result\n\ndef reverse(nums):\n    for i in range(0, len(nums) // 2):\n        tmp = nums[i]\n        nums[i] = nums[len(nums) - i - 1]\n        nums[len(nums) - i - 1] = tmp\n    return nums", "24": "def checkIfExist(arr):\n\n                        for i in range(len(arr)):\n                                for j in range(len(arr)):\n                                        if i != j and (arr[i] * 2 == arr[j] arr[i] == arr[j] * 2):\n                                                return True\n                        return False", "25": "def alertNames(keyName, keyTime):\n    map = {}\n    for i in range(len(keyName)):\n        if keyName[i] not in map:\n            map[keyName[i]] = []\n        map[keyName[i]].append(keyTime[i])\n    people = []\n    for person in map.keys():\n        times = map.get(person)\n        minutes = []\n        for time in times:\n            hourAndMin = time.split(\":\")\n            minute = int(hourAndMin[0]) * 60 + int(hourAndMin[1])\n            minutes.append(minute)\n        minutes.sort()\n        for i in range(len(minutes) - 2):\n            if minutes.get(i + 2) - minutes.get(i) <= 60:\n                people.append(person)\n                break\n    people.sort()\n    return people", "26": "def check(nums):\n                        copy = nums[:]\n                        copy.sort()\n                        for i in range(1, len(nums)+1):\n                                rotated = rotate(nums, i)\n                                if rotated == copy:\n                                        return True\n                        return False\ndef rotate(nums, start):\n                        rotated = []\n                        j = 0\n                        for i in range(start, len(nums)):\n                                rotated.append(nums[i])\n                        for i in range(0, start):\n                                rotated.append(nums[i])\n                        return rotated", "27": "def increasingTriplet(nums):\n\n    if nums == null or len(nums) == 0:\n        return false\n\n    small = nums[0]\n    medium = Integer.MAX_VALUE\n\n    for i in range(1, len(nums)):\n        small = min(small, nums[i-1])\n\n        if nums[i] > small:\n            medium = min(medium, nums[i])\n\n            for j in range(i+1, len(nums)):\n                if nums[j] > nums[i] and nums[j] > medium:\n                    return true\n\n    return false", "28": "def min_distance(word1, word2):\n    m = len(word1)\n    n = len(word2)\n    dp = [[0]*(n+1) for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return m + n - 2 * dp[m][n]", "29": "def minSteps(n):\n        dp = [0] * (n + 1)\n        for i in range(2, n + 1):\n                dp[i] = i\n                for j in range(i - 1, 1, -1):\n                        if i % j == 0:\n                                dp[i] = dp[j] + (i / j)\n                                break\n        return dp[n]", "30": "def getImportance(employees, id):\n        manager = list(filter(lambda e: e.id == id, employees))[0]\n        total = manager.importance\n        for subId in manager.subordinates:\n                total += getImportance(employees, subId)\n        return total", "31": "def maximumWealth(accounts):\n                        m = len(accounts)\n                        n = len(accounts[0])\n                        max = 0\n                        for i in range(m):\n                                sum = 0\n                                for j in range(n):\n                                        sum += accounts[i][j]\n                                max = max(max, sum)\n                        return max", "32": "def reorderList(head):\n    if head == None or head.next == None:\n        return\n    slowNode = head\n    fastNode = head\n    while fastNode.next != None:\n        fastNode = fastNode.next\n        if fastNode.next != None:\n            fastNode = fastNode.next\n        else:\n            break\n        slowNode = slowNode.next\n    head1 = head\n    head2 = slowNode.next\n    slowNode.next = None\n    cur = head2\n    post = cur.next\n    cur.next = None\n    while post != None:\n        temp = post.next\n        post.next = cur\n        cur = post\n        post = temp\n    head2 = cur\n    p = head1\n    q = head2\n    while q != None:\n        temp1 = p.next\n        temp2 = q.next\n        p.next = q\n        q.next = temp1\n        p = temp1\n        q = temp2", "33": "def minFallingPathSum(A):\n        size = len(A)\n        dp = [[0 for i in range(size)] for j in range(size)]\n        for i in range(size):\n                for j in range(size):\n                        if (i == 0):\n                                dp[i][j] = A[i][j]\n                        else:\n                                lastRow = dp[i - 1][j]\n                                if (j - 1 >= 0):\n                                        lastRow = min(dp[i - 1][j - 1], lastRow)\n                                if (j + 1 < size):\n                                        lastRow = min(dp[i - 1][j + 1], lastRow)\n                                dp[i][j] = lastRow + A[i][j]\n        minSum = float(\"inf\")\n        for i in range(size):\n                minSum = min(minSum, dp[size - 1][i])\n        return minSum", "34": "def largestDivisibleSubset(nums):\n        len = len(nums)\n        count = [1] * len\n        pre = [-1] * len\n        nums.sort()\n        max = 0\n        index = -1\n        for i in range(len):\n                for j in range(i-1, -1, -1):\n                        if nums[i] % nums[j] == 0:\n                                if count[j] + 1 > count[i]:\n                                        count[i] = count[j] + 1\n                                        pre[i] = j\n                if count[i] > max:\n                        max = count[i]\n                        index = i\n        res = []\n        while index != -1:\n                res.append(nums[index])\n                index = pre[index]\n        return res", "35": "def findTheLongestSubstring(s):\n\n        max = 0\n\n        for i in range(0, len(s)):\n\n                map = setupMap()\n\n                if len(s) - i < max:\n                        return max\n\n                for j in range(i, len(s)):\n\n                        b = s.charAt(j)\n\n                        if b in map:\n                                map[b] = map[b] + 1\n\n                        if allEven(map):\n                                max = max(max, j - i + 1)\n\n        return max\n\ndef setupMap():\n\n        map = {\n                \"a\": 0,\n                \"e\": 0,\n                \"i\": 0,\n                \"o\": 0,\n                \"u\": 0\n        }\n\n        return map\n\ndef allEven(map):\n\n        for c in map:\n\n                if map[c] % 2 != 0:\n                        return False\n\n        return True", "36": "def findRightInterval(intervals):\n        map = TreeMap()\n        res = [0] * len(intervals)\n        for i in range(len(intervals)):\n                map[intervals[i][0]] = i\n        for i in range(len(intervals)):\n                key = map.ceilingKey(intervals[i][len(intervals[i]) - 1])\n                res[i] = key if key != None else -1\n        return res", "37": "def minCut(s):\n        n = len(s)\n        c = list(s)\n        dp = [[False] * n] * n\n        cut = [0] * n\n        for i in range(0, n):\n                cut[i] = i\n                for j in range(0, i):\n                        if c[i] == c[j] and (j + 1 > i - 1 or dp[j + 1][i - 1]):\n                                dp[j][i] = True\n                                if j == 0:\n                                        cut[i] = 0\n                                else:\n                                        cut[i] = (cut[i] < cut[j - 1] + 1) ? cut[i] : cut[j - 1] + 1\n        return cut[n - 1]", "38": "def bulbSwitch(n):\n    if (n < 2):\n        return n\n    return (int) (n**0.5)", "39": "def checkArithmeticSubarrays(nums, l, r):\n                        result = []\n                        for i in range(len(l)):\n                                if isArithmetic(nums, l[i], r[i]):\n                                        result.append(true)\n                                else:\n                                        result.append(false)\n                        return result\ndef isArithmetic(nums, start, end):\n                        list = []\n                        for i in range(start, end+1):\n                                list.append(nums[i])\n                        list.sort()\n                        for i in range(1, len(list)):\n                                if list[i] - list[i-1] != list[1] - list[0]:\n                                        return false\n                        return true", "40": "def angleClock(hour, minutes):\n    minAngle = minutes * 360 / 60\n    hourAnglePart1 = hour != 12 ? (hour * 360) / 12 : 0\n    hourAnglePart2 = (double) (30 * minutes) / (double) 60\n    hourAngle = hourAnglePart1 + hourAnglePart2\n    preResult = Math.abs(minAngle - (hourAngle))\n    return preResult > 180 ? 360 - preResult : preResult", "41": "def kClosest(points, K):\n    ans = new int[K][2]\n    pq = new PriorityQueue<>((o1, o2) => {\n            double dist1 = getDistance(o1);\n            double dist2 = getDistance(o2);\n            if (dist1 > dist2) {\n                    return 1;\n            } else if (dist1 < dist2) { return -1; } else { return 0; } })\n    for (int[] point : points) {\n            pq.add(point);\n    }\n    for (int i = 0; i < K; i++) {\n            ans[i] = pq.poll();\n    }\n    return ans\n\ndef getDistance(point):\n    return Math.sqrt(Math.pow(point[0], 2) + Math.pow(point[1], 2));", "42": "def canCompleteCircuit(gas, cost):\n        start = len(gas) - 1\n        end = 0\n        sum = gas[start] - cost[start]\n        while start > end:\n                if sum >= 0:\n                        sum += gas[end] - cost[end]\n                        end += 1\n                else:\n                        start -= 1\n                        sum += gas[start] - cost[start]\n        return start if sum >= 0 else -1", "43": "def addOperators(num, target):\n    res = []\n    sb = []\n    dfs(res, sb, num, 0, target, 0, 0)\n    return res\n\ndef dfs(res, sb, num, pos, target, prev, multi):\n    if pos == len(num):\n        if target == prev:\n            res.append(sb.toString())\n        return\n    \n    for i in range(pos, len(num)):\n        curr = num.substring(pos, i + 1)\n        if num.charAt(pos) == '0' && i != pos:\n            break\n        len = sb.length()\n        if pos == 0:\n            dfs(res, sb.append(curr), num, i + 1, target, curr, curr)\n            sb.setLength(len)\n        else:\n            dfs(res, sb.append(\"+\").append(curr), num, i + 1, target, prev + curr, curr)\n            sb.setLength(len)\n            dfs(res, sb.append(\"-\").append(curr), num, i + 1, target, prev - curr, -curr)\n            sb.setLength(len)\n            dfs(res, sb.append(\"*\").append(curr), num, i + 1, target, prev - multi + multi * curr, multi * curr)\n            sb.setLength(len)", "44": "def countGoodRectangles(rectangles): \n        map = {}\n        for rec in rectangles: \n                min = min(rec[0], rec[1])\n                if min in map: \n                        map[min] = map[min] + 1\n                else: \n                        map[min] = 1\n        return map[max(map)]", "45": "def largestNumber(num):\n        if len(num) == 0:\n                return \"\"\n        if len(num) == 1:\n                return str(num[0])\n        str = []\n        for i in range(len(num)):\n                str.append(str(num[i]))\n        str.sort(key=StringComparator)\n        sb = \"\"\n        for i in range(len(num) - 1, -1, -1):\n                sb += str[i]\n        if sb[0] == '0':\n                return \"0\"\n        return sb\n\ndef compare(s1, s2):\n        if len(s1) == 0 and len(s2) == 0:\n                return 0\n        if len(s2) == 0:\n                return 1\n        if len(s1) == 0:\n                return -1\n        for i in range(len(s1) and len(s2)):\n                if s1[i] > s2[i]:\n                        return 1\n                elif s1[i] < s2[i]:\n                        return -1\n        if len(s1) == len(s2):\n                return 0\n        if len(s1) > len(s2):\n                if s1[0] < s1[len(s2)]:\n                        return 1\n                elif s1[0] > s1[len(s2)]:\n                        return -1\n                else:\n                        return compare(s1[len(s2)], s2)\n        else:\n                if s2[0] < s2[len(s1)]:\n                        return -1\n                elif s2[0] > s2[len(s1)]:\n                        return 1\n                else:\n                        return compare(s1, s2[len(s1)])", "46": "def twoCitySchedCost(costs):\n                        costs.sort(key = lambda x: x[0] - x[1])\n                        cost = 0\n                        for i in range(len(costs)):\n                                if i < len(costs) / 2:\n                                        cost += costs[i][0]\n                                else:\n                                        cost += costs[i][1]\n                        return cost", "47": "def guessNumber(n):\n        left = 1\n        right = n\n        while left + 1 < right:\n                mid = left + (right - left) // 2\n                g = guess(mid)\n                if g == 0:\n                        return mid\n                elif g > 0:\n                        left = mid\n                else:\n                        right = mid\n        if guess(left) == 0:\n                return left\n        return right\n\n\ndef guess(num):\n        if num > 6:\n                return -1\n        elif num < 6:\n                return 1\n        else:\n                return 0", "48": "def numSquares(n):\n        result = n\n        num = 2\n        while (num * num <= n):\n                temp1 = n / (num * num)\n                temp2 = n % (num * num)\n                result = min(result, temp1 + numSquares(temp2))\n                num = num + 1\n        return result", "49": "def isAdditiveNumber(num):\n        n = len(num)\n        for i in range(1, int(n/2) + 1):\n                for j in range(1, max(j, i) + 1):\n                        if isValid(i, j, num):\n                                return True\n        return False\n\ndef isValid(i, j, num):\n        if num[0] == '0' and i > 1:\n                return False\n        if num[i] == '0' and j > 1:\n                return False\n        sum = \"\"\n        x1 = int(num[0:i])\n        x2 = int(num[i: i+j])\n        for start in range(i+j, len(num)):\n                x2 = x2 + x1\n                x1 = x2 - x1\n                sum = str(x2)\n                if not num.startswith(sum, start):\n                        return False\n        return True", "50": "def countAndSay(n):\n    curr = \"1\"\n    prev\n    count = 1\n    say = prev[0]\n    for i in range(1,n):\n        prev = curr\n        curr = \"\"\n        count = 1\n        say = prev[0]\n        for j in range(1,len(prev)):\n            if (prev[j] != say):\n                curr = curr + count + say\n                count = 1\n                say = prev[j]\n            else:\n                count = count + 1\n    curr = curr + count + say\n    return curr", "51": "def generateTrees(n):\n    result = []\n    if n == 0:\n        return result\n    return generateTrees(1, n)\n\ndef generateTrees(start, end):\n    result = []\n    if start > end:\n        result.append(None)\n        return result\n    if start == end:\n        result.append(TreeNode(start))\n        return result\n    for i in range(start, end+1):\n        leftList = generateTrees(start, i - 1)\n        rightList = generateTrees(i + 1, end)\n        for left in leftList:\n            for right in rightList:\n                root = TreeNode(i)\n                root.left = left\n                root.right = right\n                result.append(root)\n    return result", "52": "def modifyString(s):\n        arr = list(s)\n        for i in range(len(arr)):\n                if arr[i] == '?':\n                        for j in range(3):\n                                if i > 0 and arr[i - 1] == chr(ord('a') + j):\n                                        continue\n                                elif i < len(arr) - 1 and arr[i + 1] == chr(ord('a') + j):\n                                        continue\n                                else:\n                                        arr[i] = chr(ord('a') + j)\n                                        break\n        return \"\".join(arr)", "53": "def findBestValue(arr, target):\n        ave = target / arr.length\n        min = findMin(arr)\n        max = findMax(arr)\n        closetDiff = findClosestDiffIfReplaceWithVal(arr, ave, target)\n        bestValue = ave\n        candidateOnTheRight = ave\n        while (candidateOnTheRight <= max):\n                thisOne = findClosestDiffIfReplaceWithVal(arr, candidateOnTheRight + 1, target)\n                if (thisOne >= closetDiff):\n                        break\n                else:\n                        closetDiff = thisOne\n                        bestValue = candidateOnTheRight\n        candidateOnTheLeft = ave\n        while (candidateOnTheLeft >= min):\n                thisOne = findClosestDiffIfReplaceWithVal(arr, candidateOnTheLeft - 1, target)\n                if (thisOne >= closetDiff):\n                        break\n                else:\n                        closetDiff = thisOne\n                        bestValue = candidateOnTheLeft\n        return bestValue\n\ndef findClosestDiffIfReplaceWithVal(arr, replaceValue, target):\n        sum = 0\n        for i in range(0, len(arr)):\n                if (arr[i] > replaceValue):\n                        sum += replaceValue\n                else:\n                        sum += arr[i]\n        return abs(sum - target)\n\ndef findMax(arr):\n        max = arr[0]\n        for i in range(1, len(arr)):\n                max = max(max, arr[i])\n        return max\n\ndef findMin(arr):\n        min = arr[0]\n        for i in range(1, len(arr)):\n                min = min(min, arr[i])\n        return min", "54": "def climbStairs(n): \n    if (n == 1): \n        return n \n    dp = [0]*(n + 1) \n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n+1): \n        dp[i] = dp[i-1] + dp[i-2] \n    return dp[n]", "55": "def maximumGain(s, x, y):\n                        stack1 = []\n                        big = x if x > y else y\n                        small = y if y < x else x\n                        first = 'a' if x == big else 'b'\n                        second = 'b' if first == 'a' else 'a'\n                        maximumGain = 0\n                        for c in s:\n                                if c == second and len(stack1) != 0 and stack1[len(stack1) - 1] == first:\n                                        stack1.pop()\n                                        maximumGain += big\n                                else:\n                                        stack1.append(c)\n                        stack2 = []\n                        while len(stack1) != 0:\n                                c = stack1.pop()\n                                if c == second and len(stack2) != 0 and stack2[len(stack2) - 1] == first:\n                                        stack2.pop()\n                                        maximumGain += small\n                                else:\n                                        stack2.append(c)\n                        return maximumGain", "56": "def maximum69Number (num):\n        chars = str(num)\n        for i, c in enumerate(chars):\n                if c == '6':\n                        chars = chars[:i] + '9' + chars[i+1:]\n                        break\n        return int(chars)", "57": "def gameOfLife(board):\n    height = len(board)\n    width = len(board[0])\n    next = [[0] * width for _ in range(height)]\n    directions = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]]\n    for i in range(height):\n        for j in range(width):\n            liveCellsCount = 0\n            for dir in directions:\n                x = i + dir[0]\n                y = j + dir[1]\n                if x >= 0 and y >= 0 and x < height and y < width and board[x][y] == 1:\n                    liveCellsCount += 1\n            if board[i][j] == 1:\n                if liveCellsCount <= 3 and liveCellsCount >= 2:\n                    next[i][j] = 1\n            elif board[i][j] == 0:\n                if liveCellsCount == 3:\n                    next[i][j] = 1\n    for i in range(height):\n        for j in range(width):\n            board[i][j] = next[i][j]", "58": "def memLeak(memory1, memory2):\n                        time = 1\n                        while memory1 >= time and memory2 >= time:\n                                if memory1 >= memory2:\n                                        memory1 -= time\n                                else:\n                                        memory2 -= time\n                                time += 1\n                        return [time, memory1, memory2]", "59": "def minOperations(s):\n                        ops1 = 0\n                        isZero = True\n                        for i in range(len(s)):\n                                if i % 2 == 0:\n                                        if s[i] != '0':\n                                                ops1 += 1\n                                else:\n                                        if s[i] != '1':\n                                                ops1 += 1\n                        ops2 = 0\n                        for i in range(len(s)):\n                                if i % 2 == 0:\n                                        if s[i] != '1':\n                                                ops2 += 1\n                                else:\n                                        if s[i] != '0':\n                                                ops2 += 1\n                        return min(ops1, ops2)", "60": "def maxProduct(root: TreeNode) -> int:\n                        set = set()\n                        total = dfs(root, set)\n                        result = 0\n                        for sum in set:\n                                result = max(result, sum * (total - sum))\n                        return (int) (result % 1000000007)\ndef dfs(root: TreeNode, set: set) -> int:\n                        if root == None:\n                                return 0\n                        root.val += dfs(root.left, set)\n                        root.val += dfs(root.right, set)\n                        set.add((long) root.val)\n                        return root.val", "61": "def isSubPath(head, root):\n                        list = getList(head)\n                        findAllPaths(root, [])\n                        for path in paths:\n                                if len(path) >= len(list):\n                                        if find(list, path):\n                                                return True\n                        return False\ndef find(list, path):\n                        i = 0\n                        j = 0\n                        while i <= len(path) - len(list):\n                                j = 0\n                                tmpI = i\n                                while j < len(list) and tmpI < len(path) and list[j] == path[tmpI]:\n                                        tmpI += 1\n                                        j += 1\n                                if j >= len(list):\n                                        return True\n                        return j >= len(list)\ndef findAllPaths(root, path):\n                        if root == None:\n                                return\n                        path.append(root.val)\n                        if root.left == None and root.right == None:\n                                paths.append(path[:])\n                                path.pop()\n                                return\n                        findAllPaths(root.left, path)\n                        findAllPaths(root.right, path)\n                        path.pop()\ndef getList(head):\n                        list = []\n                        while head != None:\n                                list.append(head.val)\n                                head = head.next\n                        return list", "62": "def topKFrequent(words, k):\n    map = {}\n    for word in words:\n        map[word] = map.get(word,0) + 1\n\n    sortedset = sorted(map.items(), key = lambda x: (-x[1], x[0]))\n\n    result = []\n    for i in range(k):\n        result.append(sortedset[i][0])\n\n    return result", "63": "def addBinary(a, b): \n        carry = 0\n        i = len(a) - 1\n        j = len(b) - 1\n        sb = []\n        while (i >= 0) and (j >= 0): \n                sum = carry \n                if (i >= 0): \n                        sum += int(a[i]) - int('0')\n                if (j >= 0): \n                        sum += int(b[j]) - int('0')\n                sb.append(sum % 2)\n                carry = sum // 2\n        return ''.join(sb[::-1])", "64": "def kthSmallest(root, k):\n  inorder = []\n  dfs(root, inorder, k)\n  return inorder[k - 1]\n  \ndef dfs(root, list, k):\n  if root == null:\n    return\n  dfs(root.left, list, k)\n  list.append(root.val)\n  dfs(root.right, list, k)\n  if list.size() >= (k - 1):\n    return", "65": "def jump(nums):\n        jumps = 0\n        lastJumpMax = 0\n        currentJumpMax = 0\n        for i in range(len(nums) - 1):\n                currentJumpMax = max(currentJumpMax, i + nums[i])\n                if i == lastJumpMax:\n                        jumps++\n                        lastJumpMax = currentJumpMax\n                if lastJumpMax >= len(nums):\n                        return jumps\n        return jumps", "66": "def findMaxLength(nums):\n    if not nums or len(nums) == 0:\n        return 0\n    count = 0\n    max = 0\n    map = {0: -1}\n    for i in range(len(nums)):\n        count += 1 if nums[i] == 1 else -1\n        if count in map:\n            max = max(i - map[count], max)\n        else:\n            map[count] = i\n    return max", "67": "def maxPoints(self, points):\n                        if len(points) < 3:\n                                return len(points)\n                        max = 0\n                        map = {}\n                        for i in range(len(points)):\n                                dup = 1\n                                map.clear()\n                                for j in range(i + 1, len(points)):\n                                        dx = points[j][0] - points[i][0]\n                                        dy = points[j][1] - points[i][1]\n                                        if dx == 0 and dy == 0:\n                                                dup++\n                                        else:\n                                                gcd = getGcd(dx, dy)\n                                                slope = ((long)(dy / gcd) << 32) + (dx / gcd)\n                                                map[slope] = map.get(slope, 0) + 1\n                                max = max(max, dup)\n                                for entry in map.items():\n                                        max = max(max, entry[1] + dup)\n                        return max\n\ndef getGcd(self, a, b):\n                        return b == 0 ? a : getGcd(b, a % b)", "68": "def minSwapsCouples(row):\n        swaps = 0\n        for i in range(0, len(row)-1, 2):\n                coupleValue = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1\n                if row[i+1] != coupleValue:\n                        swaps += 1\n                        coupleIndex = findIndex(row, coupleValue)\n                        swap(row, coupleIndex, i+1)\n        return swaps\ndef swap(row, i, j):\n        tmp = row[i]\n        row[i] = row[j]\n        row[j] = tmp\ndef findIndex(row, value):\n        for i in range(0, len(row)):\n                if row[i] == value:\n                        return i\n        return -1", "69": "def getStrongest(arr, k):\n        arr.sort()\n        median = arr.length % 2 != 0 ? arr[arr.length / 2] : arr[arr.length / 2 - 1]\n        treeMap = TreeMap(Collections.reverseOrder())\n        for num in arr:\n                diff = Math.abs(num - median)\n                if not treeMap.containsKey(diff):\n                        treeMap.put(diff, new ArrayList<>())\n                treeMap.get(diff).add(num)\n        sorted = new ArrayList<>()\n        for key in treeMap.keySet():\n                sort = treeMap.get(key)\n                Collections.sort(sort, Collections.reverseOrder())\n                sorted.addAll(sort)\n        result = new int[k]\n        for i in range(0, k):\n                result[i] = sorted.get(i)\n        return result", "70": "def checkSubarraySum(nums, k):\n        map = {}\n        map[0] = -1\n        sum = 0\n        for i in range(0, len(nums)):\n                sum += nums[i]\n                if k != 0:\n                        sum %= k\n                prev = map.get(sum)\n                if prev != None:\n                        if i - prev > 1:\n                                return true\n                else:\n                        map[sum] = i\n        return false", "71": "def kLengthApart(nums, k):\n        lastOneIndex = 0 if nums[0] == 1 else -1\n        for i in range(1, len(nums)):\n                if nums[i] == 1:\n                        if i - lastOneIndex <= k:\n                                return False\n                        else:\n                                lastOneIndex = i\n        return True", "72": "def generateTheString(n):\n    sb = \"\"\n    if n > 1 and n % 2 == 0:\n        while n > 1:\n            sb += \"a\"\n            n -= 1\n    elif n > 1:\n        while n > 2:\n            sb += \"a\"\n            n -= 1\n        sb += \"b\"\n    sb += \"z\"\n    return sb", "73": "def inorderTraversal(self, root):\n        return self.inorder(root, [])\n\ndef inorder(self, root, result):\n        if root == null:\n                return result\n        self.inorder(root.left, result)\n        result.append(root.val)\n        return self.inorder(root.right, result)", "74": "def findMin(nums):\n        left = 0\n        right = len(nums) - 1\n        if nums[left] < nums[right]:\n                return nums[left]\n        min = nums[0]\n        while left + 1 < right:\n                mid = left + (right - left) / 2\n                min = min(min, nums[mid])\n                if nums[mid] > nums[left]:\n                        min = min(nums[left], min)\n                        left = mid + 1\n                elif nums[mid] < nums[left]:\n                        right = mid - 1\n                else:\n                        left += 1\n        min = min(min, min(nums[left], nums[right]))\n        return min", "75": "def numDecodings(s):\n        dp = [0]*(len(s)+1)\n        dp[0] = 1\n        dp[1] = 9 if s[0] == '*' else 0 if s[0] == '0' else 1\n        for i in range(1, len(s)):\n                if s[i] == '*':\n                        dp[i+1] = 9*dp[i]\n                        if s[i-1] == '1':\n                                dp[i+1] = (dp[i+1] + 9*dp[i-1])%m\n                        elif s[i-1] == '2':\n                                dp[i+1] = (dp[i+1] + 6*dp[i-1])%m\n                        elif s[i-1] == '*':\n                                dp[i+1] = (dp[i+1] + 15*dp[i-1])%m\n                else:\n                        dp[i+1] = dp[i] if s[i] != '0' else 0\n                        if s[i-1] == '1':\n                                dp[i+1] = (dp[i+1] + dp[i-1])%m\n                        elif s[i-1] == '2' and s[i] <= '6':\n                                dp[i+1] = (dp[i+1] + dp[i-1])%m\n                        elif s[i-1] == '*':\n                                dp[i+1] = (dp[i+1] + (2 if s[i] <= '6' else 1)*dp[i-1])%m\n        return dp[len(s)]", "76": "def reversePairs(nums):\n        return mergeSort(nums, 0, nums.length - 1)\n\ndef mergeSort(nums, start, end):\n        if start >= end:\n                return 0\n        mid = start + (end - start) / 2\n        cnt = mergeSort(nums, start, mid) + mergeSort(nums, mid + 1, end)\n        for i in range(start, mid):\n                while j <= end and nums[i] > nums[j] * 2.0:\n                        j += 1\n                cnt += j - (mid + 1)\n        Arrays.sort(nums, start, end + 1)\n        return cnt", "77": "def judgeSquareSum(c):\n        if c < 0:\n                return false\n        left = 0\n        right = (int) (math.sqrt(c))\n        while left <= right:\n                curr = left * left + right * right\n                if curr > c:\n                        right--\n                elif curr < c:\n                        left++\n                else:\n                        return true\n        return false", "78": "def buildArray(nums):\n        ans = [0] * len(nums)\n        for i in range(len(nums)):\n                ans[i] = nums[nums[i]]\n        return ans", "79": "def getTargetCopy(original, cloned, target):\n                        if original == None:\n                                return None\n                        if original.val == target.val:\n                                return cloned\n                        left = getTargetCopy(original.left, cloned.left, target)\n                        if left != None and left.val == target.val:\n                                return left\n                        return getTargetCopy(original.right, cloned.right, target)", "80": "def longestSubarray(nums):\n        brackets = []\n        for i in range(len(nums)):\n                if nums[i] == 1:\n                        right = i + 1\n                        while right < len(nums) and nums[right] == 1:\n                                right += 1\n                        if right < len(nums) and nums[right] == 1:\n                                brackets.append([i, right])\n                        else:\n                                brackets.append([i, right - 1])\n                        i = right\n        longest = 0\n        for bracket in brackets:\n                if bracket[1] == len(nums) - 1 and bracket[0] == 0:\n                        return len(nums) - 1\n                longest = max(bracket[1] - bracket[0] + 1, longest)\n        for i in range(len(brackets) - 1):\n                first = brackets[i]\n                second = brackets[i + 1]\n                if first[1] + 2 == second[0]:\n                        connected = (first[1] - first[0] + 1) + (second[1] - second[0] + 1)\n                        longest = max(longest, connected)\n        return longest", "81": "def canConstruct(s, k):\n                        if len(s) < k:\n                                return False\n                        map = {}\n                        for c in s:\n                                if c not in map:\n                                        map[c] = 1\n                                else:\n                                        map[c] += 1\n                        count = 0\n                        for c in map:\n                                if map[c] % 2 == 1:\n                                        count += 1\n                        return count <= k", "82": "def hammingDistance(x,y):\n        n = x ^ y\n        count = 0\n        while n != 0:\n                count += 1\n                n &= (n - 1)\n        return count", "83": "def findLongestWord(s, d):\n    d.sort(key = lambda a, b: a.length() == b.length() ? a.compareTo(b) : b.length() - a.length())\n    for dictWord in d:\n        i = 0\n        for c in s:\n            if i < len(dictWord) and dictWord[i] == c:\n                i = i + 1\n        if i == len(dictWord):\n            return dictWord\n    return \"\"", "84": "def kInversePairs(n, k):\n\n                        mod = 1000000007;\n                        if k > n * (n - 1) / 2 k < 0:\n                                return 0;\n                        if k == 0 or k == n * (n - 1) / 2:\n                                return 1;\n                        dp = [[0] * (k + 1) for i in range(n + 1)]\n                        dp[2][0] = 1;\n                        dp[2][1] = 1;\n                        for i in range(3, n + 1):\n                                dp[i][0] = 1;\n                                for j in range(1, min(k, i * (i - 1) / 2) + 1):\n                                        dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n                                        if j >= i:\n                                                dp[i][j] -= dp[i - 1][j - i];\n                                        dp[i][j] = (dp[i][j] + mod) % mod;\n                        return int(dp[n][k]);", "85": "def trap(height):\n        if (height == null or len(height) <= 2):\n                return 0\n        max = height[0]\n        maxIndex = 0\n        for i in range(len(height)):\n                if height[i] > max:\n                        max = height[i]\n                        maxIndex = i\n\n        water = 0\n        leftMax = height[0]\n        for i in range(maxIndex):\n                if height[i] > leftMax:\n                        leftMax = height[i]\n                else:\n                        water += leftMax - height[i]\n\n        rightMax = height[len(height) - 1]\n        for i in range(len(height) - 1, maxIndex, -1):\n                if height[i] > rightMax:\n                        rightMax = height[i]\n                else:\n                        water += rightMax - height[i]\n        return water", "86": "def findIntegers(num):\n                        f = [0] * 32\n                        f[0] = 1\n                        f[1] = 2\n                        for i in range(2, len(f)):\n                                f[i] = f[i - 1] + f[i - 2]\n                        i = 30\n                        sum = 0\n                        prevBit = 0\n                        while i >= 0:\n                                if ((num & (1 << i)) != 0):\n                                        sum += f[i]\n                                        if (prevBit == 1):\n                                                sum -= 1\n                                                break\n                                        prevBit = 1\n                                else:\n                                        prevBit = 0\n                                i -= 1\n                        return sum + 1", "87": "def findPairs(nums, k):\n        if (nums == null nums.length == 0 k < 0):\n                return 0\n        map = new HashMap()\n        for (num : nums):\n                map.put(num, map.getOrDefault(num, 0) + 1)\n        answer = 0\n        for (key : map.keySet()):\n                if (k == 0):\n                        if (map.get(key) >= 2):\n                                answer++\n                else:\n                        if (map.containsKey(key + k)):\n                                answer++\n        return answer", "88": "def subsetsWithDup(nums):\n        result = [[]]\n        if nums == None:\n                return result\n        Arrays.sort(nums)\n        for i in range(0, len(nums)):\n                Set<List<Integer>> temp = new HashSet()\n                for list in result:\n                        List<Integer> newList = list(list)\n                        newList.append(nums[i])\n                        temp.add(newList)\n                result.extend(temp)\n        Set<List<Integer>> resultSet = set(result)\n        result = []\n        result.extend(resultSet)\n        return result", "89": "def circular_array_loop(nums):\n    n = len(nums)\n    for i in range(n):\n        if nums[i] == 0:\n            continue\n        j = i\n        k = get_index(i, nums)\n        while nums[k] * nums[i] > 0 and nums[get_index(k, nums)] * nums[i] > 0:\n            if j == k:\n                if j == get_index(j, nums):\n                    break\n                return True\n            j = get_index(j, nums)\n            k = get_index(get_index(k, nums), nums)\n        j = i\n        val = nums[i]\n        while nums[j] * val > 0:\n            next = get_index(j, nums)\n            nums[j] = 0\n            j = next\n    return False\n\ndef get_index(i, nums):\n    n = len(nums)\n    return i + nums[i] >= 0 ? (i + nums[i]) % n : n + ((i + nums[i]) % n)", "90": "def evaluate(s, knowledge):\n        map = {}\n        for know in knowledge:\n                map[know[0]] = know[1]\n        sb = []\n        for i in range(len(s)):\n                if s[i] == '(':\n                        int start = i\n                        while i < len(s) and s[i] != ')':\n                                i++\n                        key = s[start + 1:i]\n                        sb.append(map.get(key, \"?\"))\n                else:\n                        sb.append(s[i])\n        return \"\".join(sb)", "91": "def rankTeams(self, votes):\n        ranks = {c: [0] * len(votes[0]) + [c] for c in votes[0]}\n        for vote in votes:\n            for i, v in enumerate(vote):\n                ranks[v][i] -= 1\n        return \"\".join(sorted(votes[0], key=ranks.get))", "92": "def decode(encoded, first):\n        arr = [0] * (len(encoded) + 1)\n        arr[0] = first\n        for i in range(0, len(encoded)):\n                arr[i + 1] = encoded[i] ^ arr[i]\n        return arr", "93": "def connect(root):\n        head = None\n        prev = None\n        curr = root\n        while curr != None:\n                while curr != None:\n                        if curr.left != None:\n                                if prev != None:\n                                        prev.next = curr.left\n                                else:\n                                        head = curr.left\n                                prev = curr.left\n                        if curr.right != None:\n                                if prev != None:\n                                        prev.next = curr.right\n                                else:\n                                        head = curr.right\n                                prev = curr.right\n                        curr = curr.next\n                curr = head\n                head = None\n                prev = None", "94": "def maxProfit(self, prices, fee):\n        n = len(prices)\n        if n < 2:\n            return 0\n        hold = [0] * n\n        sell = [0] * n\n        hold[0] = -prices[0]\n        for i in range(1, len(prices)):\n            hold[i] = max(hold[i - 1], sell[i - 1] - prices[i])\n            sell[i] = max(sell[i - 1], hold[i - 1] + prices[i] - fee)\n        return sell[n - 1]", "95": "def cutOffTree(self, forest):\n        if not forest or not Forest[0]:\n            return -1\n        m, n = len(Forest), len(Forest[0])\n        trees = sorted((v, r, c) for r, row in enumerate(Forest)\n                                 for c, v in enumerate(row) if v > 1)\n        sr = sc = ans = 0\n        for _, tr, tc in trees:\n            d = self.dist(sr, sc, tr, tc)\n            if d < 0: return -1\n            ans += d\n            sr, sc = tr, tc\n        return ans\n    \ndef dist(self, sr, sc, tr, tc):\n    R, C = len(Forest), len(Forest[0])\n    queue = collections.deque([(sr, sc, 0)])\n    seen = {(sr, sc)}\n    while queue:\n        r, c, d = queue.popleft()\n        if r == tr and c == tc:\n            return d\n        for nr, nc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):\n            if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in seen and Forest[nr][nc]:\n                seen.add((nr, nc))\n                queue.append((nr, nc, d+1))\n    return -1", "96": "def reverseList(head):\n    newHead = None\n    while (head != None):\n        next = head.next\n        head.next = newHead\n        newHead = head\n        head = next\n    return newHead", "97": "def numRescueBoats(people, limit):\n    \n    map = {}\n    \n    for w in people:\n        if w in map:\n            map[w] += 1\n        else:\n            map[w] = 1\n    \n    boats = 0\n    uniqWeights = map.keys()\n    left = 0\n    right = len(uniqWeights) - 1\n    \n    while left < right:\n        heavierWeight = uniqWeights[right]\n        lighterWeight = uniqWeights[left]\n        \n        if heavierWeight + lighterWeight <= limit:\n            pairs = min(map[heavierWeight], map[lighterWeight])\n            boats += pairs\n            \n            if map[heavierWeight] == pairs and map[lighterWeight] == pairs:\n                del map[heavierWeight]\n                del map[lighterWeight]\n                left += 1\n                right -= 1\n            elif map[heavierWeight] == pairs:\n                del map[heavierWeight]\n                map[lighterWeight] -= pairs\n                right -= 1\n            else:\n                del map[lighterWeight]\n                map[heavierWeight] -= pairs\n                left += 1\n        else:\n            boats += map[heavierWeight]\n            del map[heavierWeight]\n            right -= 1\n    \n    if map:\n        weight = uniqWeights[left]\n        remainingPeople = map[weight]\n        if remainingPeople == 1:\n            boats += 1\n        else:\n            if weight * 2 <= limit:\n                boats += (remainingPeople / 2 + ((remainingPeople % 2 == 0) ? 0 : 1))\n            else:\n                boats += remainingPeople\n    \n    return boats", "98": "def lengthOfLastWord(s):\n        if (s == null or s.length() == 0):\n                return 0\n        s = s.trim()\n        n = s.length() - 1\n        while (n >= 0 and s.charAt(n) != ' '):\n                n--\n        return s.length() - n - 1", "99": "def find_occurrences(text, first, second):\n                        words = text.split(\" \")\n                        return [words[i + 2] for i in range(0, len(words) - 2) if words[i].equals(first) && words[i + 1].equals(second)]", "100": "def isPrefixOfWord(sentence, searchWord):\n                        words = sentence.split(\" \")\n                        for i in range(0, len(words)):\n                                if words[i].startswith(searchWord):\n                                        return i + 1\n                        return -1", "101": "class Solution:\n    def findMedianSortedArrays(self, A: List[int], B: List[int]) -> float:\n        m = len(A)\n        n = len(B)\n        l = (m + n + 1) // 2\n        r = (m + n + 2) // 2\n        return (self.getkth(A, 0, B, 0, l) + self.getkth(A, 0, B, 0, r)) / 2.0\n\n    def getkth(self, A, aStart, B, bStart, k):\n        if aStart > len(A) - 1:\n            return B[bStart + k - 1]\n        if bStart > len(B) - 1:\n            return A[aStart + k - 1]\n        if k == 1:\n            return min(A[aStart], B[bStart])\n\n        aMid = B[len(B)-1]\n        bMid = B[len(B)-1]\n\n        if aStart + k // 2 - 1 < len(A):\n            aMid = A[aStart + k // 2 - 1]\n        if bStart + k // 2 - 1 < len(B):\n            bMid = B[bStart + k // 2 - 1]\n\n        if aMid < bMid:\n            return self.getkth(A, aStart + k // 2, B, bStart, k - k // 2)\n        else:\n            return self.getkth(A, aStart, B, bStart + k // 2, k - k // 2)", "102": "def isPossible(nums):\n                        freqMap = {}\n                        for i in nums:\n                                freqMap[i] = freqMap.get(i, 0) + 1\n                        appendFreqMap = {}\n                        for i in nums:\n                                if freqMap[i] == 0:\n                                        continue\n                                elif appendFreqMap.get(i, 0) > 0:\n                                        appendFreqMap[i] = appendFreqMap[i] - 1\n                                        appendFreqMap[i + 1] = appendFreqMap.get(i + 1, 0) + 1\n                                elif freqMap.get(i + 1, 0) > 0 and freqMap.get(i + 2, 0) > 0:\n                                        freqMap[i + 1] = freqMap[i + 1] - 1\n                                        freqMap[i + 2] = freqMap[i + 2] - 1\n                                        appendFreqMap[i + 3] = appendFreqMap.get(i + 3, 0) + 1\n                                else:\n                                        return False\n                                freqMap[i] = freqMap[i] - 1\n                        return True", "103": "def validIPAddress(IP):\n        if \".\" in IP:\n                return isValidIPv4(IP)\n        elif \":\" in IP:\n                return isValidIPv6(IP)\n        else:\n                return NEITHER\ndef isValidIPv6(IP):\n        if getDelimiterCount(IP, ':') != 7:\n                return NEITHER\n        bytes = IP.split(\":\")\n        if len(bytes) != 8:\n                return NEITHER\n        for i in range(8):\n                if hasInvalidIPV6Char(bytes[i]):\n                        return NEITHER\n                try:\n                        if len(bytes[i]) > 4:\n                                return NEITHER\n                        intNum = int(bytes[i], 16)\n                        if intNum < 0:\n                                return NEITHER\n                        if i == 0 and intNum != 0 and bytes[i][0] == '0':\n                                return NEITHER\n                except Exception:\n                        return NEITHER\n        return \"IPv6\"\ndef isValidIPv4(IP):\n        if getDelimiterCount(IP, '.') != 3:\n                return NEITHER\n        bytes = IP.split(\".\")\n        if len(bytes) != 4:\n                return NEITHER\n        for num in bytes:\n                try:\n                        intNum = int(num)\n                        if intNum > 255 intNum < 0:\n                                return NEITHER\n                        if intNum != 0:\n                                for i in range(len(num)):\n                                        if num[i] == '0':\n                                                return NEITHER\n                                        else:\n                                                break\n                        else if intNum == 0:\n                                if len(num) != 1:\n                                        return NEITHER\n                except Exception:\n                        return NEITHER\n        return \"IPv4\"\ndef hasInvalidIPV6Char(str):\n        set = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'}\n        for c in str:\n                if c not in set:\n                        return true\n        return false\ndef getDelimiterCount(ip, delimiter):\n        count = 0\n        for c in ip:\n                if c == delimiter:\n                        count += 1\n        return count", "104": "def maxOperations(nums, k):\n\n                        map = {}\n                        ops = 0\n                        for num in nums:\n                                if k-num in map:\n                                        map[k-num] -= 1\n                                        ops += 1\n                                        if map[k-num] == 0:\n                                                del map[k-num]\n                                else:\n                                        map[num] = map.get(num, 0) + 1\n                        return ops", "105": "def largestAltitude(gain):\n                        max = 0\n                        altitudes = new int[gain.length + 1]\n                        for i in range(0, gain.length):\n                                altitudes[i + 1] = altitudes[i] + gain[i]\n                                max = Math.max(max, altitudes[i + 1])\n                        return max", "106": "def compareVersion(version1, version2):\n    v1s = version1.split( \"\\\\.\");\n    v2s = version2.split(\"\\\\.\");\n    len = (v1s.length < v2s.length) ? v2s.length : v1s.length;\n    for i in len:\n        if v1s.length == i:\n            while i < len:\n                if Integer.parseInt(v2s[i]) > 0:\n                    return -1;\n                i++;\n        elif v2s.length == i:\n            while i < len:\n                if Integer.parseInt(v1s[i]) > 0:\n                    return 1;\n                i++;\n        else:\n            if Integer.parseInt(v1s[i]) > Integer.parseInt(v2s[i]):\n                return 1;\n            elif Integer.parseInt(v2s[i]) > Integer.parseInt(v1s[i]):\n                return -1;\n    return 0;", "107": "def matrixBlockSum(mat, K):\n        m = len(mat)\n        n = len(mat[0])\n        answer = [[0 for i in range(n)] for j in range(m)]\n        for i in range(m):\n                for j in range(n):\n                        iRange = findRange(i, K, m)\n                        jRange = findRange(j, K, n)\n                        sum = 0\n                        for ii in range(len(iRange)):\n                                for jj in range(len(jRange)):\n                                        sum += mat[iRange[ii]][jRange[jj]]\n                        answer[i][j] = sum\n        return answer\n\ndef findRange(iOrJ, k, upper):\n        min = (iOrJ - k) if (iOrJ - k) > 0 else 0\n        max = (iOrJ + k) if (iOrJ + k) < upper else (upper - 1)\n        range = []\n        for i in range(min, max + 1):\n                range.append(i)\n        return range", "108": "def rightSideView(root):\n        result = []\n        rightView(root, result, 0)\n        return result\ndef rightView(curr, result, currDepth):\n        if curr == None:\n                return\n        if currDepth == len(result):\n                result.append(curr.val)\n        rightView(curr.right, result, currDepth + 1)\n        rightView(curr.left, result, currDepth + 1)", "109": "def wordPattern(pattern, str):\n    words = str.split(\" \")\n    patterns = list(pattern)\n    map = {}\n    if len(patterns) != len(words):\n        return False\n    for i in range(len(patterns)):\n        if patterns[i] in map:\n            if map[patterns[i]] != words[i]:\n                return False\n        else:\n            if words[i] in map.values():\n                return False\n            map[patterns[i]] = words[i]\n    return True", "110": "def convertToBase7(num):\n                        return str(int(num, 7))", "111": "def search_matrix(matrix, target):\n        if matrix == null or len(matrix) == 0:\n                return false\n        m = len(matrix)\n        n = len(matrix[0])\n        x = 0\n        y = n - 1\n        while x < m and y >= 0:\n                if target == matrix[x][y]:\n                        return true\n                elif target > matrix[x][y]:\n                        x++\n                else:\n                        y--\n        return false", "112": "def stringMatching(words):\n        set = set()\n        for word in words:\n                for i in range(0, len(words)):\n                        if not word.equals(words[i]) and word.length() < words[i].length():\n                                if words[i].indexOf(word) != -1:\n                                        set.add(word)\n        result = list()\n        for s in set:\n                result.add(s)\n        return result", "113": "def isAnagram(s, t):\n  return sorted(s) == sorted(t)", "114": "def arrayRankTransform(arr):\n    set = TreeSet()\n    for i in arr:\n        set.add(i)\n    map = HashMap()\n    rank = 1\n    for num in set:\n        map.put(num,rank)\n        rank = rank + 1\n    ranks = int[arr.length]\n    for i in range(0,arr.length):\n        ranks[i] = map.get(arr[i])\n    return ranks", "115": "def findSpecialInteger(arr):\n                        quarter = len(arr) / 4\n                        for i in range(0, len(arr) - quarter):\n                                if arr[i] == arr[i + quarter]:\n                                        return arr[i]\n                        return -1", "116": "def countPrimes(n):\n                        notPrime = [False] * n\n                        count = 0\n                        for i in range(2, n):\n                                if not notPrime[i]:\n                                        count += 1\n                                        for j in range(2, i * j, n):\n                                                notPrime[i * j] = True\n                        return count", "117": "def maxDistToClosest(self, seats):\n        maxDist = 0\n        for i in range(len(seats)):\n                if seats[i] == 0:\n                        extend(seats, i)\n        return maxDist\n\ndef extend(self, seats, position):\n        left = position - 1\n        right = position + 1\n        leftMinDistance = 1\n        while left >= 0:\n                if seats[left] == 0:\n                        leftMinDistance++\n                        left--\n                else:\n                        break\n        rightMinDistance = 1\n        while right < len(seats):\n                if seats[right] == 0:\n                        rightMinDistance++\n                        right++\n                else:\n                        break\n        maxReach = 0\n        if position == 0:\n                maxReach = rightMinDistance\n        elif position == len(seats) - 1:\n                maxReach = leftMinDistance\n        else:\n                maxReach = min(leftMinDistance, rightMinDistance)\n        maxDist = max(maxDist, maxReach)", "118": "def intersect(nums1, nums2):\n                        map = {}\n                        for i in nums1:\n                                map[i] = map.get(i, 0) + 1\n                        list = []\n                        for i in nums2:\n                                if i in map and map[i] > 0:\n                                        list.append(i)\n                                        map[i] = map[i] - 1\n                        return list", "119": "def average(salary):\n                        max = salary[0]\n                        min = salary[0]\n                        for i in range(1, len(salary)):\n                                max = max(max, salary[i])\n                                min = min(min, salary[i])\n                        total = 0\n                        count = 0\n                        for i in range(0, len(salary)):\n                                if salary[i] != max and salary[i] != min:\n                                        total += salary[i]\n                                        count += 1\n                        return total / count", "120": "def canJump(self, nums):\n        furthestReach = nums[0]\n        if furthestReach >= len(nums) - 1:\n                return True\n        i = 1\n        while i <= furthestReach:\n                newFurthestReach = max(newFurthestReach, nums[i] + i)\n                if newFurthestReach >= len(nums):\n                        return True\n                i += 1\n        if newFurthestReach <= furthestReach:\n                return False\n        elif newFurthestReach >= len(nums) - 1:\n                return True\n        else:\n                furthestReach = newFurthestReach", "121": "def isValid(code):\n    stack = []\n    i = 0\n    while i < len(code):\n        if i > 0 and not stack:\n            return False\n        if code.startswith(\"<![CDATA[\", i):\n            j = i + 9\n            i = code.indexOf(\"]]>\", j)\n            if i < 0:\n                return False\n            i += 3\n        elif code.startswith(\"</\", i):\n            j = i + 2\n            i = code.indexOf(\">\", j)\n            if i < 0 or i == j or i - j > 9:\n                return False\n            for k in range(j, i):\n                if not code[k].isupper():\n                    return False\n            s = code[j:i]\n            i += 1\n            if not stack or stack.pop() != s:\n                return False\n        elif code.startswith(\"<\", i):\n            j = i + 1\n            i = code.indexOf(\">\", j)\n            if i < 0 or i == j or i - j > 9:\n                return False\n            for k in range(j, i):\n                if not code[k].isupper():\n                    return False\n            s = code[j:i]\n            stack.append(s)\n        else:\n            i += 1\n    return not stack", "122": "def isValid(code):\n    stack = []\n    i = 0\n    while i < len(code):\n        if i > 0 and not stack:\n            return False\n        if code.startswith(\"<![CDATA[\", i):\n            j = i + 9\n            i = code.indexOf(\"]]>\", j)\n            if i < 0:\n                return False\n            i += 3\n        elif code.startswith(\"</\", i):\n            j = i + 2\n            i = code.indexOf(\">\", j)\n            if i < 0 or i == j or i - j > 9:\n                return False\n            for k in range(j, i):\n                if not code[k].isupper():\n                    return False\n            s = code[j:i]\n            i += 1\n            if not stack or stack.pop() != s:\n                return False\n        elif code.startswith(\"<\", i):\n            j = i + 1\n            i = code.indexOf(\">\", j)\n            if i < 0 or i == j or i - j > 9:\n                return False\n            for k in range(j, i):\n                if not code[k].isupper():\n                    return False\n            s = code[j:i]\n            stack.append(s)\n        else:\n            i += 1\n    return not stack", "123": "def largeGroupPositions(S):\n        result = []\n        chars = list(S)\n        i = 0\n        while i < len(chars):\n                first = chars[i]\n                j = i + 1\n                while j < len(chars) and first == chars[j]:\n                        j += 1\n                if (j - i) >= 3:\n                        result.append([i, j - 1])\n                i = j\n        return result", "124": "def daysBetweenDates(date1, date2):\n                        strings1 = date1.split(\"-\")\n                        strings2 = date2.split(\"-\")\n                        return abs(julianDay(int(strings1[0]), int(strings1[1]), int(strings1[2]))\n                                        - julianDay(int(strings2[0]), int(strings2[1]), int(strings2[2])))\ndef julianDay(year, month, day):\n                        a = (14 - month) / 12\n                        y = year + 4800 - a\n                        m = month + 12 * a - 3\n                        jdn = day + (153 * m + 2) / 5 + 365 * y + y / 4 - y / 100 + y / 400 - 32045\n                        return jdn", "125": "def singleNumber(nums):\n        map = {}\n        for i in nums:\n                map[i] = map.getOrDefault(i, 0) + 1\n        res = [2]\n        index = 0\n        for key in map.keySet():\n                if map.get(key) == 1:\n                        res[index] = key\n                if index == 2:\n                        break\n        return res", "126": "def minSubsequence(nums):\n        list = sorted(nums, reverse=True)\n        sum = 0\n        for i in list:\n                sum += i\n        minSum = 0\n        result = []\n        for i in range(len(list)):\n                if minSum > (sum - minSum):\n                        return result\n                minSum += list[i]\n                result.append(list[i])\n        return result", "127": "def strongPasswordChecker(s):\n    res = 0\n    a = 1\n    A = 1\n    d = 1\n    carr = list(s)\n    arr = [0] * len(carr)\n    i = 0\n    while i < len(arr):\n        if carr[i].islower():\n            a = 0\n        if carr[i].isupper():\n            A = 0\n        if carr[i].isdigit():\n            d = 0\n        j = i\n        while i < len(carr) and carr[i] == carr[j]:\n            i += 1\n        arr[j] = i - j\n    totalMissing = (a + A + d)\n    if len(arr) < 6:\n        res += totalMissing + max(0, 6 - (len(arr) + totalMissing))\n    else:\n        overLen = max(len(arr) - 20, 0)\n        leftOver = 0\n        res += overLen\n        for k in range(1, 3):\n            i = 0\n            while i < len(arr) and overLen > 0:\n                if arr[i] < 3 or arr[i] % 3 != (k - 1):\n                    continue\n                arr[i] -= min(overLen, k)\n                overLen -= k\n            i += 1\n        i = 0\n        while i < len(arr):\n            if arr[i] >= 3 and overLen > 0:\n                need = arr[i] - 2\n                arr[i] -= overLen\n                overLen -= need\n            if arr[i] >= 3:\n                leftOver += arr[i] // 3\n            i += 1\n        res += max(totalMissing, leftOver)\n    return res", "128": "def reconstructQueue(people):\n                        people.sort(key = lambda p: (-p[0], p[1]))\n                        print(people)\n                        ans = []\n                        for p in people:\n                                ans.insert(p[1], p)\n                        return ans", "129": "def isMonotonic(A):\n                        i = 0\n                        for (; i < A.length - 1; i++) {\n                                if (A[i] <= A[i + 1]) {\n                                        continue;\n                                } else {\n                                        break;\n                                }\n                        }\n                        if (i == A.length - 1) {\n                                return true;\n                        }\n                        i = 0;\n                        for (; i < A.length - 1; i++) {\n                                if (A[i] >= A[i + 1]) {\n                                        continue;\n                                } else {\n                                        break;\n                                }\n                        }\n                        return i == A.length - 1;", "130": "def getSumAbsoluteDifferences(nums):\n        len = len(nums)\n        preSums = [0] * len\n        for i in range(1, len):\n                preSums[i] = preSums[i - 1] + nums[i - 1]\n        postSums = [0] * len\n        for i in range(len - 2, -1, -1):\n                postSums[i] = postSums[i + 1] + nums[i + 1]\n        result = [0] * len\n        for i in range(len):\n                result[i] = nums[i] * i - preSums[i] + postSums[i] - nums[i] * (len - i - 1)\n        return result", "131": "def letter_combinations(digits):\n        result = []\n        if len(digits) == 0:\n                return result\n        digits2Letters = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n        result.append(\"\")\n        for i in range(0, len(digits)):\n                result = combine(digits2Letters[int(digits[i]) - 0], result)\n        return result\n\ndef combine(letters, result):\n        newResult = []\n        for i in range(0, len(letters)):\n                for str in result:\n                        newResult.append(str + letters[i])\n        return newResult", "132": "def numTrees(n):\n\tG = [0]*(n+1)\n\tG[0] = G[1] = 1\n\tfor i in range(2,n+1):\n\t\tfor j in range(1,i+1):\n\t\t\ttemp = G[j-1]*G[i-j]\n\t\t\tG[i] = G[i] + temp\n\treturn G[n]", "133": "import sys\n\ndef thirdMax(nums):\n        max1 = -sys.maxint\n        max2 = -sys.maxint\n        max3 = -sys.maxint\n        for i in nums:\n                max1 = max(max1, i)\n        for i in nums:\n                if i == max1:\n                        continue\n                max2 = max(max2, i)\n        for i in nums:\n                if i == max1 or i == max2:\n                        continue\n                max3 = max(max3, i)\n        return (int) (max3 == -sys.maxint ? max1 : max3)", "134": "def asteroidCollision(asteroids):\n        stack = []\n        for i in range(asteroids.length):\n                if not stack.isEmpty() and stack.peek() > 0 and asteroids[i] < 0:\n                        if abs(stack.peek()) < abs(asteroids[i]):\n                                stack.pop()\n                                stack.push(asteroids[i])\n                                collide(stack)\n                        elif abs(stack.peek()) == abs(asteroids[i]):\n                                stack.pop()\n                else:\n                        stack.push(asteroids[i])\n        result = []\n        while not stack.isEmpty():\n                result.append(stack.pop())\n        return result\n\ndef collide(stack):\n        while not stack.isEmpty():\n                top = stack.pop()\n                if not stack.isEmpty() and stack.peek() * top < 0:\n                        if stack.peek() < abs(top):\n                                stack.pop()\n                                stack.push(top)\n                        elif stack.peek() == abs(top):\n                                stack.pop()\n                                break\n                        else:\n                                break\n                elif stack.isEmpty() or stack.peek() * top > 0:\n                        stack.push(top)\n                        break", "135": "def arraySign(nums):\n        negativeCount = 0\n        for num in nums:\n                if num == 0:\n                        return 0\n                elif num < 0:\n                        negativeCount++\n        return negativeCount % 2 == 0 ? 1 : -1", "136": "def removeLeafNodes(root, target):\n        while hasTargetLeafNodes(root, target):\n                root = removeLeafNodes(target, root)\n        return root\ndef removeLeafNodes(target, root):\n        if root == None:\n                return root\n        if root.val == target and root.left == None and root.right == None:\n                root = None\n                return root\n        if root.left != None and root.left.val == target and root.left.left == None and root.left.right == None:\n                root.left = None\n        if root.right != None and root.right.val == target and root.right.left == None and root.right.right == None:\n                root.right = None\n        removeLeafNodes(target, root.left)\n        removeLeafNodes(target, root.right)\n        return root\ndef hasTargetLeafNodes(root, target):\n        if root == None:\n                return False\n        if root.left == None and root.right == None and root.val == target:\n                return True\n        return hasTargetLeafNodes(root.left, target) or hasTargetLeafNodes(root.right, target)", "137": "from collections import deque\n\ndef predictPartyVictory(senate):\n                        radiantQ = deque()\n                        direQ = deque()\n                        len = len(senate)\n                        for i in range(len):\n                                if senate[i] == 'R':\n                                        radiantQ.append(i)\n                                else:\n                                        direQ.append(i)\n                        while radiantQ and direQ:\n                                radiantIndex = radiantQ.popleft()\n                                direIndex = direQ.popleft()\n                                if radiantIndex < direIndex:\n                                        radiantQ.append(radiantIndex + len)\n                                else:\n                                        direQ.append(direIndex + len)\n                        return \"Radiant\" if radiantQ else \"Dire\"", "138": "def search(nums, target):\n                        if not nums or len(nums) == 0:\n                                return -1\n                        minIdx = findMinIdx(nums)\n                        if target == nums[minIdx]:\n                                return minIdx\n                        m = len(nums)\n                        start = minIdx if target <= nums[m - 1] else 0\n                        end = m - 1 if target > nums[m - 1] else minIdx\n                        while start <= end:\n                                mid = start + (end - start) // 2\n                                if nums[mid] == target:\n                                        return mid\n                                elif target > nums[mid]:\n                                        start = mid + 1\n                                else:\n                                        end = mid - 1\n                        return -1\ndef findMinIdx(nums):\n                        start = 0\n                        end = len(nums) - 1\n                        while start < end:\n                                mid = start + (end - start) // 2\n                                if nums[mid] > nums[end]:\n                                        start = mid + 1\n                                else:\n                                        end = mid\n                        return start", "139": "def search(nums, target):\n        left = 0\n        right = len(nums) - 1\n        if target < nums[left] or target > nums[right]:\n                return -1\n        if nums[left] == target:\n                return left\n        elif nums[right] == target:\n                return right\n        while left <= right:\n                mid = left + (right - left) // 2\n                if target == nums[mid]:\n                        return mid\n                elif target > nums[mid]:\n                        left = mid + 1\n                else:\n                        right = mid - 1\n        return -1", "140": "def pacificAtlantic(matrix):\n\n        result = []\n        if matrix == None or len(matrix) == 0 or len(matrix[0]) == 0:\n                return result\n        m = len(matrix)\n        n = len(matrix[0])\n        pacific = [[False for i in range(n)] for j in range(m)]\n        atlantic = [[False for i in range(n)] for j in range(m)]\n\n        def dfs(matrix, visited, height, x, y):\n\n                if x < 0 or y < 0 or x >= m or y >= n or matrix[x][y] < height or visited[x][y]:\n                        return\n                visited[x][y] = True\n                dfs(matrix, visited, matrix[x][y], x + 1, y)\n                dfs(matrix, visited, matrix[x][y], x, y + 1)\n                dfs(matrix, visited, matrix[x][y], x - 1, y)\n                dfs(matrix, visited, matrix[x][y], x, y - 1)\n\n        for i in range(m):\n                dfs(matrix, pacific, float('-inf'), i, 0)\n                dfs(matrix, atlantic, float('-inf'), i, n - 1)\n\n        for i in range(n):\n                dfs(matrix, pacific, float('-inf'), 0, i)\n                dfs(matrix, atlantic, float('-inf'), m - 1, i)\n\n        for i in range(m):\n                for j in range(n):\n                        if pacific[i][j] and atlantic[i][j]:\n                                result.append([i, j])\n\n        return result", "141": "class Solution:\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\n        trustPoints = [0] * N\n        trustOthers = set()\n        for eachTrust in trust:\n            trustPoints[eachTrust[1] - 1] += 1\n            trustOthers.add(eachTrust[0])\n        judge = -1\n        for i in range(len(trustPoints)):\n            if trustPoints[i] == N - 1 and not i + 1 in trustOthers:\n                judge = i + 1\n        return judge", "142": "def minOperations(boxes):\n        box = [0]*len(boxes)\n        for i in range(len(boxes)):\n                box[i] = boxes[i] - '0'\n        result = [0]*len(boxes)\n        for i in range(len(boxes)):\n                ops = 0\n                for j in range(len(boxes)):\n                        if (i != j and box[j] == 1):\n                                ops += abs(j - i)\n                result[i] = ops\n        return result", "143": "def canMakeArithmeticProgression(arr):\n        arr.sort()\n        for i in range(0, len(arr) - 2):\n                if (arr[i + 1] - arr[i] != arr[i + 2] - arr[i + 1]):\n                        return False\n        return True", "144": "def maxEvents(events):\n        events.sort(key = lambda x: (x[0], x[1]))\n        heap = []\n        maxEvents = 0\n        i = 0\n        for day in range(1, 100001):\n                while i < len(events) and events[i][0] == day:\n                        heapq.heappush(heap, events[i][1])\n                        i += 1\n                while heap and heap[0] < day:\n                        heapq.heappop(heap)\n                if heap:\n                        heapq.heappop(heap)\n                        maxEvents += 1\n        return maxEvents", "145": "def binaryTreePaths_more_concise(root):\n        paths = []\n        if root == None:\n                return paths\n        dfs(root, paths, \"\")\n        return paths\ndef dfs(root, paths, path):\n        if root.left == None and root.right == None:\n                paths.append(path + root.val)\n                return\n        path += root.val + \"->\"\n        if root.left != None:\n                dfs(root.left, paths, path)\n        if root.right != None:\n                dfs(root.right, paths, path)", "146": "def lowestCommonAncestor(root, p, q):\n        if root == null root == p root == q:\n                return root\n        TreeNode left = lowestCommonAncestor(root.left, p, q)\n        TreeNode right = lowestCommonAncestor(root.right, p, q)\n        if left != null and right != null:\n                return root\n        return left != null ? left : right", "147": "def topKFrequent(nums, k):\n    map = {}\n    for i in nums:\n        map[i] = map.getOrDefault(i, 0) + 1\n\n    bucket = [None] * (len(nums) + 1)\n\n    for e in map.entrySet():\n        frequency = e.getValue()\n        if bucket[frequency] == null:\n            bucket[frequency] = []\n        bucket[frequency].append(e.getKey())\n\n    result = []\n\n    for i in range(len(bucket) - 1, -1, -1):\n        if len(result) < k:\n            if bucket[i] != null:\n                for j in range(0, len(bucket[i])):\n                    result.append(bucket[i][j])\n\n    arr = [0] * len(result)\n\n    for i in range(0, len(arr)):\n        arr[i] = result[i]\n\n    return arr", "148": "def maxNumberOfBalloons(text):\n        counts = [0] * 26\n        for c in text:\n                counts[ord(c) - ord('a')] += 1\n                \n        return min(counts[0], counts[1], counts[11] // 2, counts[14] // 2, counts[13])", "149": "def isIsomorphic(s, t):\n                        if s == null or len(s) == 0:\n                                return t == null or len(t) == 0\n                        if t == null or len(t) == 0:\n                                return s == null or len(s) == 0\n                        schar = list(s)\n                        tchar = list(t)\n                        map = dict()\n                        if len(s) != len(t):\n                                return false\n                        for i in range(len(s)):\n                                if schar[i] in map.keys():\n                                        if map.get(schar[i]) != tchar[i]:\n                                                return false\n                                else:\n                                        if tchar[i] in map.values():\n                                                return false\n                                        map[schar[i]] = tchar[i]\n                        return true", "150": "def twoSum(numbers, target):\n                        left = 0\n                        right = len(numbers) - 1\n                        while (left < right):\n                                sum = numbers[left] + numbers[right]\n                                if (sum > target):\n                                        right--\n                                elif (sum < target):\n                                        left++\n                                else:\n                                        return [left + 1, right + 1]\n                        return [-1, -1]", "151": "def knightProbability(N, K, r, c):\n    directions = [[-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2], [-2, -1]]\n    queue = []\n    queue.append([r, c])\n    level = K\n    while level > 0:\n        size = len(queue)\n        for i in range(size):\n            curr = queue.pop()\n            for direction in directions:\n                x = curr[0] + direction[0]\n                y = curr[1] + direction[1]\n                if x >= 0 and x < N and y >= 0 and y < N:\n                    queue.append([x, y])\n        level -= 1\n    prob = len(queue)\n    for i in range(K):\n        prob /= 8\n    return prob", "152": "def canCross(stones):\n        if len(stones) == 0:\n                return true\n        map = {}\n        map[0] = [1]\n        for i in stones[1:]:\n                map[i] = []\n        for i in stones:\n                for step in map[i]:\n                        reach = step + i\n                        if reach == stones[-1]:\n                                return True\n                        elif reach in map:\n                                map[reach] += [step, step + 1] if step > 0 else [step + 1]\n        return False", "153": "def sumNumbers(root):\n    if root == None:\n        return 0\n    allNumbers = []\n    dfs(root, \"\", allNumbers)\n    sum = 0\n    for i in allNumbers:\n        sum+=i\n    return sum\n\ndef dfs(root, sb, allNumbers):\n    sb+=str(root.val)\n    if root.left!=None:\n        dfs(root.left, sb, allNumbers)\n    if root.right!=None:\n        dfs(root.right, sb, allNumbers)\n    if root.left==None and root.right==None:\n        allNumbers.append(int(sb))\n    sb = sb[:-1]", "154": "def canPartitionKSubsets(nums, k):\n                        sum = 0\n                        for num in nums:\n                                sum += num\n                        if sum % k != 0:\n                                return false\n                        equalSum = sum / k\n                        visited = [false] * len(nums)\n                        return canPartition(nums, visited, 0, k, 0, 0, equalSum)\n                \ndef canPartition(nums, visited, startIndex, k, currSum, currNum, target):\n                        if k == 1:\n                                return true\n                        if currSum == target and currNum > 0:\n                                return canPartition(nums, visited, 0, k - 1, 0, 0, target)\n                        for i in range(startIndex, len(nums)):\n                                if not visited[i]:\n                                        visited[i] = true\n                                        if canPartition(nums, visited, i + 1, k, currSum + nums[i], currNum + 1, target):\n                                                return true\n                                        visited[i] = false\n                        return false", "155": "def isBoomerang(points):\n        return (points[1][1] - points[0][1]) * (points[2][0] - points[0][0]) != (points[2][1] - points[0][1]) * (points[1][0] - points[0][0])", "156": "def longestPrefix(s):\n        times = 2\n        prefixHash = 0\n        suffixHash = 0\n        multiplier = 1\n        len = 0\n        mod = 1000000007\n        for i in range(0, len(s) - 1):\n                prefixHash = (prefixHash * times + ord(s[i])) % mod\n                suffixHash = (multiplier * ord(s[len(s) - i - 1]) + suffixHash) % mod\n                if prefixHash == suffixHash:\n                        len = i + 1\n                multiplier = multiplier * times % mod\n        return s[0:int(len)]", "157": "def prisonAfterNDays(cells, N):\n    prisonStates = set()\n    hasCycle = False\n    times = 0\n    for i in range(N):\n        next = getNextDay(cells)\n        nextDayState = ''.join(str(next))\n        if nextDayState in prisonStates:\n            hasCycle = True\n            break\n        else:\n            prisonStates.add(nextDayState)\n            times += 1\n        cells = next\n    if hasCycle:\n        N %= times\n        for i in range(N):\n            cells = getNextDay(cells)\n    return cells\n\n\ndef getNextDay(cells):\n    nextDay = [0] * len(cells)\n    for i in range(len(cells)):\n        if i == 0 or i == len(cells) - 1:\n            nextDay[i] = 0\n        else:\n            nextDay[i] = (cells[i - 1] == cells[i + 1])\n    return nextDay", "158": "def sortedSquares(nums):\n        result = list(map(lambda x: x**2, nums))\n        result.sort()\n        return result", "159": "def numWaterBottles(numBottles, numExchange):\n                        drunk = numBottles\n                        emptyBottles = numBottles\n                        while (emptyBottles >= numExchange):\n                                exchangedBottles = emptyBottles // numExchange\n                                drunk += exchangedBottles\n                                unUsedEmptyBottles = emptyBottles % numExchange\n                                emptyBottles = exchangedBottles + unUsedEmptyBottles\n                        return drunk", "160": "def maximumRequests(n, requests):\n        helper(requests, 0, [0]*n, 0)\n        return max\ndef helper(requests, index, count, num):\n        if index == len(requests):\n                for i in count:\n                        if 0 != i:\n                                return\n                max = max(max, num)\n                return\n        count[requests[index][0]]+=1\n        count[requests[index][1]]-=1\n        helper(requests, index + 1, count, num + 1)\n        count[requests[index][0]]-=1\n        count[requests[index][1]]+=1\n        helper(requests, index + 1, count, num)", "161": "def minStartValue(nums):\n                        min = float('inf')\n                        sum = 0\n                        for num in nums:\n                                sum += num\n                                min = min(sum, min)\n                        return 1 if min > 0 else abs(min) + 1", "162": "def escapeGhosts(ghosts, target):\n        currPos = [0, 0]\n        selfDist = getDist(currPos, target)\n        for ghost in ghosts:\n                ghostDist = getDist(ghost, target)\n                if (ghostDist <= selfDist):\n                        return false\n        return true\n\ndef getDist(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])", "163": "def closestDivisors(num):\n    sqrt = int(math.sqrt(num))\n    left = sqrt + 1\n    right = sqrt + 1\n    product = left * right\n    while product != (num + 1) and product != (num + 2):\n        if product < (num + 1):\n            left += 1\n        elif product > (num + 2):\n            right -= 1\n        product = left * right\n    return [left, right]", "164": "def maximumScore(a, b, c):\n                        nums = [a, b, c]\n                        nums.sort()\n                        if nums[0] + nums[1] < nums[2]:\n                                return nums[0] + nums[1]\n                        else:\n                                return (nums[0] + nums[1] + nums[2]) / 2", "165": "def isPalindrome(head):\n        if head == None:\n                return True\n        slow = head\n        fast = head\n        while fast.next != None and fast.next.next != None:\n                fast = fast.next.next\n                slow = slow.next\n        secondHalfHead = reverse(slow.next)\n        firstHalfHead = head\n        while firstHalfHead != None and secondHalfHead != None:\n                if firstHalfHead.val != secondHalfHead.val:\n                        return False\n                firstHalfHead = firstHalfHead.next\n                secondHalfHead = secondHalfHead.next\n        return True\ndef reverse(head):\n        newHead = None\n        while head != None:\n                next = head.next\n                head.next = newHead\n                newHead = head\n                head = next\n        return newHead", "166": "def is_long_pressed_name(name, typed):\n\ti = 0\n\tfor j in range(0, len(typed)):\n\t\tif name[i] != typed[j]:\n\t\t\treturn False\n\t\telif i < len(name) - 1 and name[i] != name[i + 1]:\n\t\t\tj += 1\n\t\t\twhile j < len(typed) and name[i] == typed[j]:\n\t\t\t\tj += 1\n\t\telse:\n\t\t\tj += 1\n\t\ti += 1\n\treturn i == len(name)", "167": "def pyramidTransition(bottom, allowed):\n                        map = {}\n                        for s in allowed:\n                                key = s[:2]\n                                if key not in map:\n                                        map[key] = []\n                                map[key].append(s[2])\n                        return helper(bottom, map)\ndef helper(bottom, map):\n                        if len(bottom) == 1:\n                                return True\n                        for i in range(len(bottom) - 1):\n                                if bottom[i:i + 2] not in map:\n                                        return False\n                        ls = []\n                        getList(bottom, 0, \"\", ls, map)\n                        for s in ls:\n                                if helper(s, map):\n                                        return True\n                        return False\ndef getList(bottom, idx, sb, ls, map):\n                        if idx == len(bottom) - 1:\n                                ls.append(sb)\n                                return\n                        for s in map[bottom[idx:idx + 2]]:\n                                getList(bottom, idx + 1, sb + s, ls, map)", "168": "def strangePrinter(s):\n        n = len(s)\n        if n == 0:\n                return 0\n        dp = [[0 for x in range(101)] for y in range(101)] \n        for i in range(n):\n                dp[i][i] = 1\n        for i in range(1, n):\n                for j in range(0, n-i):\n                        dp[j][j+i] = i+1\n                        for k in range(j+1, j+i+1):\n                                temp = dp[j][k-1] + dp[k][j+i]\n                                if s[k-1] == s[j+i]:\n                                        temp -= 1\n                                dp[j][j+i] = min(dp[j][j+i], temp)\n        return dp[0][n-1]", "169": "def largestValsFromLabels(values, labels, numWanted, useLimit):\n                        tuple = [[values[i], labels[i]] for i in range(values.length)]\n                        tuple.sort(key = lambda x: x[0], reverse = True)\n                        labelUsedCountMap = {}\n                        sum = 0\n                        numbersUsed = 0\n                        for i in range(values.length):\n                                val = tuple[i][0]\n                                usedCount = labelUsedCountMap.get(tuple[i][1], 0)\n                                if usedCount >= useLimit:\n                                        continue\n                                else:\n                                        sum += val\n                                        numbersUsed += 1\n                                        labelUsedCountMap[tuple[i][1]] = usedCount + 1\n                                if numbersUsed >= numWanted:\n                                        break\n                        return sum", "170": "def kthFactor(n, k):\n        list = []\n        for i in range(1, n+1):\n                if n % i == 0:\n                        list.append(i)\n        return list[k-1] if len(list) >= k else -1", "171": "def minInsertions(s):\n                        stack = []\n                        insertionsNeeded = 0\n                        for i in range(len(s)):\n                                c = s[i]\n                                if c == '(':\n                                        if len(stack) == 0:\n                                                stack.append(c)\n                                        else:\n                                                if stack[len(stack)-1] == ')':\n                                                        insertionsNeeded += 1\n                                                        stack.pop()\n                                                        stack.pop()\n                                                        stack.append(c)\n                                                else:\n                                                        stack.append(c)\n                                elif c == ')':\n                                        if len(stack) == 0:\n                                                insertionsNeeded += 1\n                                                stack.append('(')\n                                                stack.append(c)\n                                        else:\n                                                if stack[len(stack)-1] == ')':\n                                                        stack.pop()\n                                                        stack.pop()\n                                                else:\n                                                        stack.append(c)\n                        if len(stack) == 0:\n                                return insertionsNeeded\n                        else:\n                                while len(stack) != 0:\n                                        pop = stack.pop()\n                                        if pop == '(':\n                                                insertionsNeeded += 2\n                                        else:\n                                                insertionsNeeded += 1\n                                                stack.pop()\n                                return insertionsNeeded", "172": "def addStrings(num1, num2):\n        if (num1 == null or len(num1) == 0):\n                return num2\n        elif (num2 == null or len(num2) == 0):\n                return num1\n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        sum = 0\n        sb = []\n        char1 = list(num1)\n        char2 = list(num2)\n        while (i >= 0 or j >= 0):\n                sum = carry\n                if (i >= 0):\n                        sum += int(char1[i])\n                        i -= 1\n                if (j >= 0):\n                        sum += int(char2[j])\n                        j -= 1\n                carry = int(sum / 10)\n                sb.append(sum % 10)\n        if (carry != 0):\n                sb.append(carry)\n        return ''.join(map(str, sb[::-1]))", "173": "def solveSudoku(board):\n                        if board == None board.length == 0:\n                                return\n                        solve(board)\ndef solve(board):\n                        for i in range(0, board.length):\n                                for j in range(0, board[0].length):\n                                        if board[i][j] == '.':\n                                                for c in range('1', '9'):\n                                                        if isValid(board, i, j, c):\n                                                                board[i][j] = c\n                                                                if solve(board):\n                                                                        return true\n                                                                else:\n                                                                        board[i][j] = '.'\n                                                return false\n                        return true\ndef isValid(board, row, col, c):\n                        for i in range(0, 9):\n                                if board[i][col] != '.' && board[i][col] == c:\n                                        return false\n                                if board[row][i] != '.' && board[row][i] == c:\n                                        return false\n                                if board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] != '.' && board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c:\n                                        return false\n                        return true", "174": "def concatenatedBinary(n):\n                        MOD = 1000000007\n                        result = 0\n                        for i in range(1,n+1):\n                                binary = str(bin(i))[2:]\n                                for j in range(len(binary)):\n                                        result = (result * 2 + (int(binary[j]) - '0')) % MOD\n                        return result", "175": "def secondHighest(s):\n        set = []\n        for c in s:\n                if c.isdigit():\n                        set.add(int(c))\n        if len(set) == 0 or len(set) == 1:\n                return -1\n        list = sorted(set)\n        return list[-2]", "176": "def maximumGap(nums):\n        if (len(nums) < 2):\n                return 0\n        nums.sort()\n        max = float(\"-inf\")\n        i = 1\n        while (i < len(nums)):\n                while (i < len(nums) and nums[i] == nums[i - 1]):\n                        i += 1\n                if (i == len(nums)):\n                        i -= 1\n                        max = nums[i] - nums[i - 1] if (nums[i] - nums[i - 1] > max) else max\n                        break\n                else:\n                        max = nums[i] - nums[i - 1] if (nums[i] - nums[i - 1] > max) else max\n                if (nums[i] != nums[i - 1]):\n                        i += 1\n        return max", "177": "def generateMatrix(n):\n    matrix = [[0 for i in range(n)] for j in range(n)]\n    value = 1\n    top = 0\n    bottom = n - 1\n    left = 0\n    right = n - 1\n    while left <= right and top <= bottom:\n        for j in range(left, right+1):\n            matrix[top][j] = value\n            value += 1\n        top += 1\n        for i in range(top, bottom+1):\n            matrix[i][right] = value\n            value += 1\n        right -= 1\n        for j in range(right, left-1, -1):\n            matrix[bottom][j] = value\n            value += 1\n        bottom -= 1\n        for i in range(bottom, top-1, -1):\n            matrix[i][left] = value\n            value += 1\n        left += 1\n    return matrix", "178": "def maxSizeSlices(slices):\n                        n = len(slices)\n                        b = slices.copy()\n                        for i in range(0, n):\n                                b[i + n] = slices[i]\n                        dp = [[0] * 2 * n] * (2 * n)\n                        for len in range(3, n):\n                                for i in range(0, 2 * n - len):\n                                        j = i + len - 1\n                                        for k in range(i + 3, j - 2):\n                                                dp[i][j] = max(dp[i][j], dp[i][k - 1] + dp[k][j])\n                                        for k in range(i + 1, j):\n                                                if (i + 1 <= k - 1):\n                                                        dp[i][j] = max(dp[i][j], dp[i + 1][k - 1] + b[k] + dp[k + 1][j - 1])\n                                ans = 0\n                                for i in range(0, n):\n                                        ans = max(ans, dp[i][i + n - 1])\n                        return ans", "179": "def canIWin(maxChoosableInteger, desiredTotal):\n    sum = (1 + maxChoosableInteger) * maxChoosableInteger / 2\n    if sum < desiredTotal:\n        return False\n    if desiredTotal <= 0:\n        return True\n    map = {}\n    used = [False] * (maxChoosableInteger + 1)\n    return helper(desiredTotal, map, used)\n\ndef helper(desiredTotal, map, used):\n    if desiredTotal <= 0:\n        return False\n    key = format(used)\n    if key not in map:\n        for i in range(1, len(used)):\n            if not used[i]:\n                used[i] = True\n                if not helper(desiredTotal - i, map, used):\n                    map[key] = True\n                    used[i] = False\n                    return True\n                used[i] = False\n        map[key] = False\n    return map[key]\n\ndef format(used):\n    num = 0\n    for b in used:\n        num <<= 1\n        if b:\n            num |= 1\n    return num", "180": "def closeStrings(word1, word2):\n                        counts1 = [0] * 26\n                        counts2 = [0] * 26\n                        set1 = set()\n                        set2 = set()\n                        for c in word1:\n                                counts1[ord(c) - ord('a')] += 1\n                                set1.add(c)\n                        for c in word2:\n                                counts2[ord(c) - ord('a')] += 1\n                                set2.add(c)\n                        return set1 == set2 and counts1 == counts2", "181": "def get_hint(secret, guess):\n\tsecret_cows = [0] * 10\n\tguess_cows = [0] * 10\n\tbulls = 0\n\tfor i in range(len(secret)):\n\t\tif guess[i] == secret[i]:\n\t\t\tbulls += 1\n\t\telse:\n\t\t\tsecret_cows[int(secret[i])] += 1\n\t\t\tguess_cows[int(guess[i])] += 1\n\tcows = 0\n\tfor i in range(10):\n\t\tcows += min(secret_cows[i], guess_cows[i])\n\treturn bulls + \"A\" + cows + \"B\"", "182": "def calcEquation(equations, values, queries):\n                        root = {}\n                        rate = {}\n                        n = len(equations)\n                        for i in range(n):\n                                X = equations[i][0]\n                                Y = equations[i][1]\n                                root[X] = X\n                                root[Y] = Y\n                                rate[X] = 1.0\n                                rate[Y] = 1.0\n                        for i in range(n):\n                                X = equations[i][0]\n                                Y = equations[i][1]\n                                union(X, Y, values[i])\n                        result = []\n                        for i in range(queries):\n                                X = queries[i][0]\n                                Y = queries[i][1]\n                                if not root.containsKey(X) or not root.containsKey(Y):\n                                        result.append(-1)\n                                        continue\n                                rootx = findRoot(X, X, 1.0)\n                                rooty = findRoot(Y, Y, 1.0)\n                                result.append(rootx.equals(rooty) ? rate[X] / rate[Y] : -1.0)\n                        return result\ndef union(X, Y, v):\n                        rootx = findRoot(X, X, 1.0)\n                        rooty = findRoot(Y, Y, 1.0)\n                        root[rootx] = rooty\n                        r1 = rate[X]\n                        r2 = rate[Y]\n                        rate[rootx] = v * r2 / r1\ndef findRoot(originalX, X, r):\n                        if root[X].equals(X):\n                                root[originalX] = X\n                                rate[originalX] = r * rate[X]\n                                return X\n                        return findRoot(originalX, root[X], r * rate[X])", "183": "def decrypt(code, k):\n        result = []\n        len = len(code)\n        if k == 0:\n                for i in range(0, len):\n                        result.append(0)\n        elif k > 0:\n                kSum = 0;\n                for i in range(1, k + 1):\n                        kSum += code[i]\n                result.append(kSum)\n                for i in range(1, len):\n                        kSum -= code[i]\n                        kSum += code[(i + k) % len]\n                        result.append(kSum)\n        else:\n                kSum = 0\n                kVal = abs(k)\n                for i in range(len - 1, len - kVal - 1, -1):\n                        kSum += code[i]\n                result.append(kSum)\n                for i in range(1, len):\n                        kSum -= code[(len - kVal + i - 1) % len]\n                        kSum += code[i - 1]\n                        result.append(kSum)\n        return result", "184": "def searchBST(root, val):\n                        if (root == null) {\n                                return null;\n                        } else if (root.val == val) {\n                                return root;\n                        } else if (root.val > val) {\n                                return searchBST(root.left, val);\n                        } else {\n                                return searchBST(root.right, val);\n                        }", "185": "def totalHammingDistance(nums):\n        r = 0\n        for i in range(32):\n                one = 0\n                zero = 0\n                bit = 1 << i\n                for n in nums:\n                        if (n & bit) != 0:\n                                one += 1\n                        else:\n                                zero += 1\n                r += one * zero\n        return r", "186": "def uniqueOccurrences(arr):\n        map = {}\n        Arrays.stream(arr).forEach(num -> {\n                map.put(num, map.containsKey(num) ? map.get(num) + 1 : 1); })\n        Set<Integer> set = new HashSet<>();\n        return map.keySet().stream().mapToInt(key -> key).allMatch(key -> set.add(map.get(key)));", "187": "def decompressRLElist(nums):\n        list = []\n        for i in range(0, len(nums) - 1, 2):\n                count = nums[i]\n                value = nums[i + 1]\n                while count > 0:\n                        list.append(value)\n                        count -= 1\n        return list", "188": NaN, "189": "def findLength(nums1, nums2):\n    shorter = None\n    longer = None\n    if len(nums1) < len(nums2):\n        shorter = nums1\n        longer = nums2\n    else:\n        shorter = nums2\n        longer = nums1\n    maxLen = 0\n\n    for i in range(0, len(shorter)-1):\n        for j in range(len(shorter), 0, -1):\n            if j <= i or j-i <= maxLen:\n                continue\n            candidate = shorter[i:j]\n            if len(candidate) > maxLen and isSubarray(candidate, longer):\n                maxLen = len(candidate)\n    return maxLen\n\ndef isSubarray(candidate, array):\n    for i in range(0, len(array)-len(candidate)+1):\n        if candidate == array[i:i+len(candidate)]:\n            return True\n    return False", "190": "def canWinNim(n):\n        return n % 4 != 0", "191": "def canMeasureWater(x, y, z):\n                        if (x + y < z):\n                                return False\n                        if (x == z and y == z and x + y == z):\n                                return True\n                        return z % gcd(x, y) == 0\nint gcd(int x, int y):\n                        while (y != 0):\n                                temp = y\n                                y = x % y\n                                x = temp\n                        return x", "192": "def levelOrder(root):\n        result = []\n        if root == None:\n                return result\n        queue = []\n        queue.append(root)\n        while(len(queue) > 0):\n                thisLevel = []\n                size = len(queue)\n                for i in range(size):\n                        curr = queue.pop(0)\n                        thisLevel.append(curr.val)\n                        if curr.left != None:\n                                queue.append(curr.left)\n                        if curr.right != None:\n                                queue.append(curr.right)\n                result.append(thisLevel)\n        return result", "193": "def minimumDeleteSum(s1, s2):\n    dp = [[0 for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n    for i in range(len(s1) - 1, -1, -1):\n        dp[i][len(s2)] = dp[i + 1][len(s2)] + ord(s1[i])\n    for j in range(len(s2) - 1, -1, -1):\n        dp[len(s1)][j] = dp[len(s1)][j + 1] + ord(s2[j])\n    for i in range(len(s1) - 1, -1, -1):\n        for j in range(len(s2) - 1, -1, -1):\n            if s1[i] == s2[j]:\n                dp[i][j] = dp[i + 1][j + 1]\n            else:\n                dp[i][j] = min(\n                    dp[i + 1][j] + ord(s1[i]), dp[i][j + 1] + ord(s2[j])\n                )\n    return dp[0][0]", "194": "def romanToInt(s):\n        map = {'I': 1,\n               'V': 5,\n               'X': 10,\n               'L': 50,\n               'C': 100,\n               'D': 500,\n               'M': 1000}\n        result = 0\n        for i in range(len(s)):\n                if i > 0 and map[s[i]] > map[s[i - 1]]:\n                        result += map[s[i]] - 2 * map[s[i - 1]]\n                else:\n                        result += map[s[i]]\n        return result", "195": "def letterCasePermutation(S):\n    result = set()\n    result.add(S)\n    for i in range(0, len(S)):\n        if (S[i].isalpha()):\n            newResult = set()\n            for word in result:\n                if (word[i].isupper()):\n                    newResult.add(word[:i] + word[i].lower() + word[i+1:])\n                else:\n                    newResult.add(word[:i] + word[i].upper() + word[i+1:])\n            result.addAll(newResult)\n    return result", "196": "def minPairSum(nums):\n                        nums.sort()\n                        maxSum = 0\n                        for left in range(0, len(nums)-1):\n                                maxSum = max(maxSum, nums[left] + nums[right])\n                        return maxSum", "197": "def minCostToMoveChips(position):\n    chipsAtOddPosition = 0\n    chipsAtEvenPosition = 0\n    for i in range(0, len(position)):\n        if position[i] % 2 == 0:\n            chipsAtEvenPosition += 1\n        else:\n            chipsAtOddPosition += 1\n    if chipsAtEvenPosition > chipsAtOddPosition:\n        return chipsAtOddPosition\n    else:\n        return chipsAtEvenPosition", "198": "def isCousins(root, x, y):\n        queue = []\n        queue.append(root)\n        while len(queue) > 0:\n                size = len(queue)\n                for i in range(0, size):\n                        current = queue.pop(0)\n                        if current.left != None:\n                                queue.append(current.left)\n                        if current.right != None:\n                                queue.append(current.right)\n                        if current.left != None and current.right != None:\n                                if current.left.val == x and current.right.val == y or current.left.val == y and current.right.val == x:\n                                        return False\n                if checkQueue(queue, x, y):\n                        return True\n        return False\n\ndef checkQueue(queue, x, y):\n        set = []\n        tmp = queue\n        while len(tmp) > 0:\n                set.append(tmp.pop(0).val)\n        return x in set and y in set", "199": "def isScramble(s1, s2):\n\tif s1 == s2:\n\t\treturn true\n\tif len(s1) != len(s2):\n\t\treturn false\n\tletters = [0] * 26\n\tfor i in range(len(s1)):\n\t\tletters[ord(s1[i]) - ord('a')] += 1\n\t\tletters[ord(s2[i]) - ord('a')] -= 1\n\tfor i in letters:\n\t\tif i != 0:\n\t\t\treturn false\n\tfor i in range(1, len(s1)):\n\t\tif isScramble(s1[0:i], s2[0:i]) and isScramble(s1[i:], s2[i:]):\n\t\t\treturn true\n\t\tif isScramble(s1[0:i], s2[len(s2) - i:]) and isScramble(s1[i:], s2[0:len(s2) - i]):\n\t\t\treturn true\n\treturn false"}}, "Python-Java": {"ID": {"0": 1000, "1": 1566, "2": 599, "3": 1856, "4": 1434, "5": 930, "6": 228, "7": 1691, "8": 977, "9": 236, "10": 833, "11": 227, "12": 404, "13": 1686, "14": 955, "15": 1563, "16": 1128, "17": 1780, "18": 796, "19": 567, "20": 909, "21": 153, "22": 1854, "23": 784, "24": 1018, "25": 1482, "26": 1117, "27": 1829, "28": 1524, "29": 840, "30": 1471, "31": 199, "32": 28, "33": 1642, "34": 1910, "35": 1888, "36": 406, "37": 859, "38": 1723, "39": 1391, "40": 815, "41": 766, "42": 787, "43": 1787, "44": 1737, "45": 917, "46": 233, "47": 111, "48": 658, "49": 1201, "50": 135, "51": 1632, "52": 783, "53": 414, "54": 560, "55": 173, "56": 1053, "57": 621, "58": 375, "59": 1721, "60": 91, "61": 844, "62": 2, "63": 1367, "64": 337, "65": 1827, "66": 1654, "67": 762, "68": 1832, "69": 1876, "70": 387, "71": 129, "72": 1247, "73": 1796, "74": 1585, "75": 824, "76": 50, "77": 1020, "78": 1904, "79": 1834, "80": 1695, "81": 740, "82": 1145, "83": 1913, "84": 961, "85": 230, "86": 1161, "87": 1025, "88": 1905, "89": 1234, "90": 47, "91": 1614, "92": 897, "93": 1458, "94": 514, "95": 1616, "96": 1021, "97": 690, "98": 1646, "99": 1863, "100": 605, "101": 1446, "102": 1706, "103": 1329, "104": 1753, "105": 241, "106": 416, "107": 1144, "108": 1754, "109": 1359, "110": 999, "111": 1576, "112": 997, "113": 1560, "114": 1590, "115": 278, "116": 867, "117": 1423, "118": 748, "119": 242, "120": 1615, "121": 289, "122": 671, "123": 594, "124": 1569, "125": 746, "126": 866, "127": 1268, "128": 730, "129": 1330, "130": 44, "131": 785, "132": 318, "133": 721, "134": 1443, "135": 237, "136": 219, "137": 581, "138": 1048, "139": 88, "140": 1589, "141": 231, "142": 1611, "143": 928, "144": 910, "145": 722, "146": 1744, "147": 1266, "148": 957, "149": 1738, "150": 647, "151": 765, "152": 1389, "153": 951, "154": 855, "155": 1626, "156": 257, "157": 1629, "158": 1681, "159": 852, "160": 1288, "161": 70, "162": 1160, "163": 978, "164": 171, "165": 1866, "166": 1239, "167": 1185, "168": 477, "169": 1326, "170": 472, "171": 162, "172": 126, "173": 388, "174": 835, "175": 424, "176": 1299, "177": 1203, "178": 857, "179": 1486, "180": 1551, "181": 1207, "182": 1453, "183": 1298, "184": 51, "185": 1742, "186": 1520, "187": 239, "188": 115, "189": 1620, "190": 292, "191": 1002, "192": 1593, "193": 96, "194": 98, "195": 911, "196": 847, "197": 393, "198": 1009, "199": 335}, "Python": {"0": "def mergeStones(self, stones, K):\n                if (len(stones)-1) % (K-1):\n                        return -1\n                prefix = [0]\n                for x in stones:\n                        prefix.append(prefix[-1]+x)\n                dp = [[0]*len(stones) for _ in xrange(len(stones))]\n                for l in xrange(K-1, len(stones)):\n                        for i in xrange(len(stones)-l):\n                                dp[i][i+l] = min(dp[i][j]+dp[j+1][i+l] for j in xrange(i, i+l, K-1))\n                                if l % (K-1) == 0:\n                                        dp[i][i+l] += prefix[i+l+1] - prefix[i]\n                return dp[0][len(stones)-1]", "1": "def containsPattern(self, arr, m, k):\n                cnt = 0\n                for i in xrange(len(arr)-m):\n                        if arr[i] != arr[i+m]:\n                                cnt = 0\n                                continue\n                        cnt += 1\n                        if cnt == (k-1)*m:\n                                return True\n                return False", "2": "def findRestaurant(self, list1, list2):\n                lookup = {}\n                for i, s in enumerate(list1):\n                        lookup[s] = i\n                result = []\n                min_sum = float(\"inf\")\n                for j, s in enumerate(list2):\n                        if j > min_sum:\n                                break\n                        if s in lookup:\n                                if j + lookup[s] < min_sum:\n                                        result = [s]\n                                        min_sum = j + lookup[s]\n                                elif j + lookup[s] == min_sum:\n                                        result.append(s)\n                return result", "3": "def maxSumMinProduct(self, nums):\n                MOD = 10**9+7\n                prefix = [0]*(len(nums)+1)\n                for i in xrange(len(nums)):\n                        prefix[i+1] = prefix[i]+nums[i]\n                stk, result = [-1], 0\n                for i in xrange(len(nums)+1):\n                        while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):\n                                result = max(result, nums[stk.pop()]*(prefix[(i-1)+1]-prefix[stk[-1]+1]))\n                        stk.append(i) \n                return result%MOD", "4": "def numberWays(self, hats):\n                MOD = 10**9 + 7\n                HAT_SIZE = 40\n                hat_to_people = [[] for _ in xrange(HAT_SIZE)]\n                for i in xrange(len(hats)):\n                        for h in hats[i]:\n                                hat_to_people[h-1].append(i)\n                dp = [0]*(1<<len(hats))\n                dp[0] = 1\n                for people in hat_to_people:\n                        for mask in reversed(xrange(len(dp))):\n                                for p in people:\n                                        if mask & (1<<p):\n                                                continue\n                                        dp[mask (1<<p)] += dp[mask]\n                                        dp[mask (1<<p)] %= MOD\n                return dp[-1]", "5": "def numSubarraysWithSum(self, A, S):\n                result = 0\n                left, right, sum_left, sum_right = 0, 0, 0, 0\n                for i, a in enumerate(A):\n                        sum_left += a\n                        while left < i and sum_left > S:\n                                sum_left -= A[left]\n                                left += 1\n                        sum_right += a\n                        while right < i and \\\n                                (sum_right > S or (sum_right == S and not A[right])):\n                                sum_right -= A[right]\n                                right += 1\n                        if sum_left == S:\n                                result += right-left+1\n                return result", "6": "def summaryRanges(self, nums):\n                ranges = []\n                if not nums:\n                        return ranges\n                start, end = nums[0], nums[0]\n                for i in xrange(1, len(nums) + 1):\n                        if i < len(nums) and nums[i] == end + 1:\n                                end = nums[i]\n                        else:\n                                interval = str(start)\n                                if start != end:\n                                        interval += \"->\" + str(end)\n                                ranges.append(interval)\n                                if i < len(nums):\n                                        start = end = nums[i]\n                return ranges", "7": "def maxHeight(self, cuboids):\n                for cuboid in cuboids:\n                        cuboid.sort()\n                cuboids.append([0, 0, 0])\n                cuboids.sort()\n                dp = [0]*len(cuboids)\n                for i in xrange(1, len(cuboids)):\n                        for j in xrange(i):\n                                if all(cuboids[j][k] <= cuboids[i][k] for k in xrange(3)):\n                                        dp[i] = max(dp[i], dp[j]+cuboids[i][2])\n                return max(dp)", "8": "def sortedSquares(self, A):\n                right = bisect.bisect_left(A, 0)\n                left = right-1\n                result = []\n                while 0 <= left or right < len(A):\n                        if right == len(A) or \\\n                        (0 <= left and A[left]**2 < A[right]**2):\n                                result.append(A[left]**2)\n                                left -= 1\n                        else:\n                                result.append(A[right]**2)\n                                right += 1\n                return result", "9": "def lowestCommonAncestor(self, root, p, q):\n                if root in (None, p, q):\n                        return root\n                left, right = [self.lowestCommonAncestor(child, p, q) \\ for child in (root.left, root.right)]\n                return root if left and right else left or right", "10": "def findReplaceString(self, S, indexes, sources, targets):\n                for i, s, t in sorted(zip(indexes, sources, targets), reverse=True):\n                        if S[i:i+len(s)] == s:\n                                S = S[:i] + t + S[i+len(s):]\n                return S", "11": "def calculate(self, s):\n                def compute(operands, operators):\n                        right, left = operands.pop(), operands.pop()\n                        operands.append(ops[operators.pop()](left, right))\n                ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n                precedence = {'+':0, '-':0, '*':1, '/':1}\n                operands, operators, operand = [], [], 0\n                for i in xrange(len(s)):\n                        if s[i].isdigit():\n                                operand = operand*10 + int(s[i])\n                                if i == len(s)-1 or not s[i+1].isdigit():\n                                        operands.append(operand)\n                                        operand = 0\n                        elif s[i] == '(':\n                                operators.append(s[i]) elif s[i] == ')':\n                                while operators[-1] != '(':\n                                        compute(operands, operators)\n                                operators.pop()\n                        elif s[i] in precedence:\n                                while operators and operators[-1] in precedence and \\\n                                        precedence[operators[-1]] >= precedence[s[i]]:\n                                        compute(operands, operators)\n                                operators.append(s[i])\n                while operators:\n                        compute(operands, operators)\n                return operands[-1]", "12": "def sumOfLeftLeaves(self, root):\n                def sumOfLeftLeavesHelper(root, is_left):\n                        if not root:\n                                return 0\n                        if not root.left and not root.right:\n                                return root.val if is_left else 0\n                        return sumOfLeftLeavesHelper(root.left, True) + \\\n                                sumOfLeftLeavesHelper(root.right, False)\n                return sumOfLeftLeavesHelper(root, False)\ndef sumOfLeftLeavesHelper(root, is_left):\n                        if not root:\n                                return 0\n                        if not root.left and not root.right:\n                                return root.val if is_left else 0\n                        return sumOfLeftLeavesHelper(root.left, True) + \\\n                                sumOfLeftLeavesHelper(root.right, False)", "13": "def stoneGameVI(self, aliceValues, bobValues):\n                sorted_vals = sorted(((a, b) for a, b in zip(aliceValues, bobValues)), key=sum, reverse=True)\n                return cmp(sum(a for a, _ in sorted_vals[::2]), sum(b for _, b in sorted_vals[1::2]))", "14": "def minDeletionSize(self, A):\n                result = 0\n                is_sorted = [False]*(len(A)-1)\n                for j in xrange(len(A[0])):\n                        tmp = is_sorted[:]\n                        for i in xrange(len(A)-1):\n                                if A[i][j] > A[i+1][j] and tmp[i] == False:\n                                        result += 1\n                                        break\n                                if A[i][j] < A[i+1][j]:\n                                        tmp[i] = True\n                        else:\n                                is_sorted = tmp\n                return result", "15": "def stoneGameV(self, stoneValue):\n                n = len(stoneValue)\n                prefix = [0]\n                for v in stoneValue:\n                        prefix.append(prefix[-1] + v)\n                mid = [[0]*n for _ in xrange(n)]\n                for l in xrange(1, n+1):\n                        for i in xrange(n-l+1):\n                                j = i+l-1\n                                p = i if l == 1 else mid[i][j-1]\n                                while prefix[p]-prefix[i] < prefix[j+1]-prefix[p]:\n                                        p += 1 \n                                mid[i][j] = p\n                rmq = [[0]*n for _ in xrange(n)]\n                for i in xrange(n):\n                        rmq[i][i] = stoneValue[i]\n                dp = [[0]*n for _ in xrange(n)]\n                for l in xrange(2, n+1):\n                        for i in xrange(n-l+1):\n                                j = i+l-1\n                                p = mid[i][j]\n                                max_score = 0\n                                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:\n                                        max_score = max(rmq[i][p-1], rmq[j][p])\n                                else:\n                                        if i <= p-2:\n                                                max_score = max(max_score, rmq[i][p-2])\n                                        if p <= j:\n                                                max_score = max(max_score, rmq[j][p])\n                                dp[i][j] = max_score\n                                rmq[i][j] = max(rmq[i][j-1], (prefix[j+1]-prefix[i]) + max_score)\n                                rmq[j][i] = max(rmq[j][i+1], (prefix[j+1]-prefix[i]) + max_score)\n                return dp[0][n-1]", "16": "def numEquivDominoPairs(self, dominoes):\n                counter = collections.Counter((min(x), max(x)) for x in dominoes)\n                return sum(v*(v-1)//2 for v in counter.itervalues())", "17": "def checkPowersOfThree(self, n):\n                while n > 0:\n                        if n%3 == 2:\n                                return False\n                        n //= 3\n                return True", "18": "def rotateString(self, A, B):\n                return len(A) == len(B) and B in A*2", "19": "def checkInclusion(self, s1, s2):\n                counts = collections.Counter(s1)\n                l = len(s1)\n                for i in xrange(len(s2)):\n                        if counts[s2[i]] > 0:\n                                l -= 1\n                        counts[s2[i]] -= 1\n                        if l == 0:\n                                return True\n                        start = i + 1 - len(s1)\n                        if start >= 0:\n                                counts[s2[start]] += 1\n                                if counts[s2[start]] > 0:\n                                        l += 1\n                return False", "20": "def snakesAndLadders(self, board):\n                def coordinate(n, s):\n                        a, b = divmod(s-1, n)\n                        r = n-1-a\n                        c = b if r%2 != n%2 else n-1-b\n                        return r, c\n                n = len(board)\n                lookup = {1: 0}\n                q = collections.deque([1])\n                while q:\n                        s = q.popleft()\n                        if s == n*n:\n                                return lookup[s]\n                        for s2 in xrange(s+1, min(s+6, n*n)+1):\n                                r, c = coordinate(n, s2)\n                                if board[r][c] != -1:\n                                        s2 = board[r][c]\n                                if s2 not in lookup:\n                                        lookup[s2] = lookup[s]+1\n                                        q.append(s2)\n                return -1\ndef coordinate(n, s):\n                        a, b = divmod(s-1, n)\n                        r = n-1-a\n                        c = b if r%2 != n%2 else n-1-b\n                        return r, c", "21": "def findMin(self, nums):\n                left, right = 0, len(nums) - 1\n                while left < right and nums[left] >= nums[right]:\n                        mid = left + (right - left) / 2\n                        if nums[mid] < nums[left]:\n                                right = mid\n                        else:\n                                left = mid + 1\n                return nums[left]", "22": "def maximumPopulation(self, logs):\n                MIN_YEAR, MAX_YEAR = 1950, 2050\n                years = [0]*(MAX_YEAR-MIN_YEAR+1)\n                for s, e in logs:\n                        years[s-MIN_YEAR] += 1\n                        years[e-MIN_YEAR] -= 1\n                result = 0\n                for i in xrange(len(years)):\n                        if i:\n                                years[i] += years[i-1]\n                        if years[i] > years[result]:\n                                result = i\n                return result+MIN_YEAR", "23": "def letterCasePermutation(self, S):\n                result = [[]]\n                for c in S:\n                        if c.isalpha():\n                                for i in xrange(len(result)):\n                                        result.append(result[i][:])\n                                        result[i].append(c.lower())\n                                        result[-1].append(c.upper())\n                        else:\n                                for s in result:\n                                        s.append(c)\n                return map(\"\".join, result)", "24": "def prefixesDivBy5(self, A):\n                for i in xrange(1, len(A)):\n                        A[i] += A[i-1] * 2 % 5\n                return [x % 5 == 0 for x in A]", "25": "def minDays(self, bloomDay, m, k):\n                def check(bloomDay, m, k, x):\n                        result = count = 0\n                        for d in bloomDay:\n                                count = count+1 if d <= x else 0\n                                if count == k:\n                                        count = 0\n                                        result += 1\n                                        if result == m:\n                                                break\n                        return result >= m\n                if m*k > len(bloomDay):\n                        return -1\n                left, right = 1, max(bloomDay)\n                while left <= right:\n                        mid = left + (right-left)//2\n                        if check(bloomDay, m, k, mid):\n                                right = mid-1\n                        else:\n                                left = mid+1\n                return left\ndef check(bloomDay, m, k, x):\n                        result = count = 0\n                        for d in bloomDay:\n                                count = count+1 if d <= x else 0\n                                if count == k:\n                                        count = 0\n                                        result += 1\n                                        if result == m:\n                                                break\n                        return result >= m", "26": "def __init__(self):\n                self.__l = threading.Lock()\n                self.__nH = 0\n                self.__nO = 0\n                self.__releaseHydrogen = None\n                self.__releaseOxygen = None\ndef hydrogen(self, releaseHydrogen):\n                with self.__l:\n                        self.__releaseHydrogen = releaseHydrogen\n                        self.__nH += 1\n                        self.__output()\ndef oxygen(self, releaseOxygen):\n                with self.__l:\n                        self.__releaseOxygen = releaseOxygen\n                        self.__nO += 1\n                        self.__output()\ndef __output(self):\n                while self.__nH >= 2 and \\\n                        self.__nO >= 1:\n                        self.__nH -= 2\n                        self.__nO -= 1\n                        self.__releaseHydrogen()\n                        self.__releaseHydrogen()\n                        self.__releaseOxygen()\ndef __init__(self):\n                self.__nH = 0\n                self.__nO = 0\n                self.__cv = threading.Condition()\ndef hydrogen(self, releaseHydrogen):\n                with self.__cv:\n                        while 2*(self.__nO+1) - self.__nH > 2:\n                                self.__cv.wait()\n                        self.__nO += 1\n                        releaseOxygen()\n                        self.__cv.notifyAll()", "27": "def getMaximumXor(self, nums, maximumBit):\n                result = [0]*len(nums)\n                mask = 2**maximumBit-1\n                for i in xrange(len(nums)):\n                        mask ^= nums[i]\n                        result[-1-i] = mask\n                return result", "28": "def numOfSubarrays(self, arr):\n                MOD = 10**9+7\n                result, accu = 0, 0\n                dp = [1, 0]\n                for x in arr:\n                        accu ^= x&1\n                        dp[accu] += 1\n                        result = (result + dp[accu^1]) % MOD\n                return result", "29": "def numMagicSquaresInside(self, grid):\n                def magic(grid, r, c):\n                        expect = k * (k**2+1) // 2\n                        nums = set()\n                        min_num = float(\"inf\")\n                        sum_diag, sum_anti = 0, 0\n                        for i in xrange(k):\n                                sum_diag += grid[r+i][c+i]\n                                sum_anti += grid[r+i][c+k-1-i]\n                                sum_r, sum_c = 0, 0\n                                for j in xrange(k):\n                                        min_num = min(min_num, grid[r+i][c+j])\n                                        nums.add(grid[r+i][c+j])\n                                        sum_r += grid[r+i][c+j]\n                                        sum_c += grid[r+j][c+i]\n                                if not (sum_r == sum_c == expect):\n                                        return False\n                        return sum_diag == sum_anti == expect and \\\n                                len(nums) == k**2 and \\\n                                min_num == 1\n                k = 3\n                result = 0\n                for r in xrange(len(grid)-k+1):\n                        for c in xrange(len(grid[r])-k+1):\n                                if magic(grid, r, c):\n                                        result += 1\n                return result\ndef magic(grid, r, c):\n                        expect = k * (k**2+1) // 2\n                        nums = set()\n                        min_num = float(\"inf\")\n                        sum_diag, sum_anti = 0, 0\n                        for i in xrange(k):\n                                sum_diag += grid[r+i][c+i]\n                                sum_anti += grid[r+i][c+k-1-i]\n                                sum_r, sum_c = 0, 0\n                                for j in xrange(k):\n                                        min_num = min(min_num, grid[r+i][c+j])\n                                        nums.add(grid[r+i][c+j])\n                                        sum_r += grid[r+i][c+j]\n                                        sum_c += grid[r+j][c+i]\n                                if not (sum_r == sum_c == expect):\n                                        return False\n                        return sum_diag == sum_anti == expect and \\\n                                len(nums) == k**2 and \\\n                                min_num == 1", "30": "def getStrongest(self, arr, k):\n                def nth_element(nums, n, compare=lambda a, b: a < b):\n                        def partition_around_pivot(left, right, pivot_idx, nums, compare):\n                                new_pivot_idx = left\n                                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                                for i in xrange(left, right):\n                                        if compare(nums[i], nums[right]):\n                                                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                                                new_pivot_idx += 1\n                                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                                return new_pivot_idx\n                        left, right = 0, len(nums) - 1\n                        while left <= right:\n                                pivot_idx = random.randint(left, right)\n                                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)\n                                if new_pivot_idx == n:\n                                        return\n                                elif new_pivot_idx > n:\n                                        right = new_pivot_idx - 1\n                                else: \n                                        left = new_pivot_idx + 1\n                nth_element(arr, (len(arr)-1)//2)\n                m = arr[(len(arr)-1)//2]\n                nth_element(arr, k, lambda a, b: abs(a-m) > abs(b-m) if abs(a-m) != abs(b-m) else a > b)\n                return arr[:k]\ndef nth_element(nums, n, compare=lambda a, b: a < b):\n                        def partition_around_pivot(left, right, pivot_idx, nums, compare):\n                                new_pivot_idx = left\n                                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                                for i in xrange(left, right):\n                                        if compare(nums[i], nums[right]):\n                                                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                                                new_pivot_idx += 1\n                                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                                return new_pivot_idx\n                        left, right = 0, len(nums) - 1\n                        while left <= right:\n                                pivot_idx = random.randint(left, right)\n                                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)\n                                if new_pivot_idx == n:\n                                        return\n                                elif new_pivot_idx > n:\n                                        right = new_pivot_idx - 1\n                                else: \n                                        left = new_pivot_idx + 1\ndef partition_around_pivot(left, right, pivot_idx, nums, compare):\n                                new_pivot_idx = left\n                                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                                for i in xrange(left, right):\n                                        if compare(nums[i], nums[right]):\n                                                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                                                new_pivot_idx += 1\n                                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                                return new_pivot_idx", "31": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef rightSideView(self, root):\n                result = []\n                self.rightSideViewDFS(root, 1, result)\n                return result\ndef rightSideViewDFS(self, node, depth, result):\n                if not node:\n                        return\n                if depth > len(result):\n                        result.append(node.val)\n                self.rightSideViewDFS(node.right, depth+1, result)\n                self.rightSideViewDFS(node.left, depth+1, result)", "32": "def strStr(self, haystack, needle):\n                for i in xrange(len(haystack) - len(needle) + 1):\n                        if haystack[i : i + len(needle)] == needle:\n                                return i\n                return -1", "33": "def furthestBuilding(self, heights, bricks, ladders):\n                min_heap = []\n                for i in xrange(len(heights)-1):\n                        diff = heights[i+1]-heights[i]\n                        if diff > 0:\n                                heapq.heappush(min_heap, diff)\n                        if len(min_heap) <= ladders: \n                                continue\n                        bricks -= heapq.heappop(min_heap) \n                        if bricks < 0: \n                                return i\n                return len(heights)-1", "34": "def removeOccurrences(self, s, part):\n                def getPrefix(pattern):\n                        prefix = [-1]*len(pattern)\n                        j = -1\n                        for i in xrange(1, len(pattern)):\n                                while j != -1 and pattern[j+1] != pattern[i]:\n                                        j = prefix[j]\n                                if pattern[j+1] == pattern[i]:\n                                        j += 1\n                                prefix[i] = j\n                        return prefix\n                prefix = getPrefix(part)\n                result, lookup = [], []\n                i = -1\n                for c in s:\n                        while i != -1 and part[i+1] != c:\n                                i = prefix[i]\n                        if part[i+1] == c:\n                                i += 1\n                        result.append(c)\n                        lookup.append(i)\n                        if i == len(part)-1:\n                                result[len(result)-len(part):] = []\n                                lookup[len(lookup)-len(part):] = []\n                                i = lookup[-1] if lookup else -1\n                return \"\".join(result)\ndef getPrefix(pattern):\n                        prefix = [-1]*len(pattern)\n                        j = -1\n                        for i in xrange(1, len(pattern)):\n                                while j != -1 and pattern[j+1] != pattern[i]:\n                                        j = prefix[j]\n                                if pattern[j+1] == pattern[i]:\n                                        j += 1\n                                prefix[i] = j\n                        return prefix", "35": "def minFlips(self, s):\n                result = float(\"inf\")\n                cnt1 = cnt2 = 0\n                for i in xrange(2*len(s)-1 if len(s)%2 else len(s)):\n                        if i >= len(s):\n                                cnt1 -= int(s[i%len(s)])^((i-len(s))%2)^0\n                                cnt2 -= int(s[i%len(s)])^((i-len(s))%2)^1\n                        cnt1 += int(s[i%len(s)])^(i%2)^0\n                        cnt2 += int(s[i%len(s)])^(i%2)^1\n                        if i >= len(s)-1:\n                                result = min(result, cnt1, cnt2)\n                return result", "36": "def reconstructQueue(self, people):\n                people.sort(key=lambda h_k1: (-h_k1[0], h_k1[1]))\n                result = []\n                for p in people:\n                        result.insert(p[1], p)\n                return result", "37": "def buddyStrings(self, A, B):\n                if len(A) != len(B):\n                        return False\n                diff = []\n                for a, b in itertools.izip(A, B):\n                        if a != b:\n                                diff.append((a, b))\n                                if len(diff) > 2:\n                                        return False\n                return (not diff and len(set(A)) < len(A)) or \\\n                        (len(diff) == 2 and diff[0] == diff[1][::-1])", "38": "def minimumTimeRequired(self, jobs, k):\n                def backtracking(jobs, i, counts, result):\n                        if i == len(jobs):\n                                result[0] = min(result[0], max(counts))\n                                return\n                        for j in xrange(len(counts)):\n                                if counts[j]+jobs[i] <= result[0]:\n                                        counts[j] += jobs[i]\n                                        backtracking(jobs, i+1, counts, result)\n                                        counts[j] -= jobs[i]\n                                if counts[j] == 0:\n                                        break\n                jobs.sort(reverse=False)\n                result = [sum(jobs)]\n                backtracking(jobs, 0, [0]*k, result)\n                return result[0]\ndef backtracking(jobs, i, counts, result):\n                        if i == len(jobs):\n                                result[0] = min(result[0], max(counts))\n                                return\n                        for j in xrange(len(counts)):\n                                if counts[j]+jobs[i] <= result[0]:\n                                        counts[j] += jobs[i]\n                                        backtracking(jobs, i+1, counts, result)\n                                        counts[j] -= jobs[i]\n                                if counts[j] == 0:\n                                        break", "39": "def hasValidPath(self, grid):\n                E, S, W, N = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n                directions = [\n                        [W, E], [N, S],\n                        [W, S], [S, E],\n                        [W, N], [N, E] ]\n                for r, c in directions[grid[0][0]-1]:\n                        if not (0 <= r < len(grid) and 0 <= c < len(grid[0])):\n                                continue\n                        pr, pc = 0, 0\n                        while r != len(grid)-1 or c != len(grid[0])-1:\n                                for dx, dy in directions[grid[r][c]-1]:\n                                        nr, nc = r+dx, c+dy\n                                        if (nr == pr and nc == pc) or \\\n                                        not(0 <= nr < len(grid) and 0 <= nc < len(grid[0])) or \\\n                                        (-dx, -dy) not in directions[grid[nr][nc]-1]:\n                                                continue\n                                        pr, pc, r, c = r, c, nr, nc\n                                        break\n                                else:\n                                        return False\n                        return True\n                return len(grid) == len(grid[0]) == 1", "40": "def numBusesToDestination(self, routes, S, T):\n                if S == T:\n                        return 0\n                to_route = collections.defaultdict(set)\n                for i, route in enumerate(routes):\n                        for stop in route:\n                                to_route[stop].add(i)\n                result = 1\n                q = [S]\n                lookup = set([S])\n                while q:\n                        next_q = []\n                        for stop in q:\n                                for i in to_route[stop]:\n                                        for next_stop in routes[i]:\n                                                if next_stop in lookup:\n                                                        continue\n                                                if next_stop == T:\n                                                        return result\n                                                next_q.append(next_stop)\n                                                to_route[next_stop].remove(i)\n                                                lookup.add(next_stop)\n                        q = next_q\n                        result += 1\n                return -1", "41": "def isToeplitzMatrix(self, matrix):\n                for row_index, row in enumerate(matrix):\n                        for digit_index, digit in enumerate(row):\n                                if not row_index or not digit_index:\n                                        continue\n                                if matrix[row_index - 1][digit_index - 1] != digit:\n                                        return False\n                return True", "42": "def findCheapestPrice(self, n, flights, src, dst, K):\n                adj = collections.defaultdict(list)\n                for u, v, w in flights:\n                        adj[u].append((v, w))\n                best = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\"inf\")))\n                best[src][K+1] = 0\n                min_heap = [(0, src, K+1)]\n                while min_heap:\n                        result, u, k = heapq.heappop(min_heap)\n                        if k < 0 or best[u][k] < result:\n                                continue\n                        if u == dst:\n                                return result\n                        for v, w in adj[u]:\n                                if result+w < best[v][k-1]:\n                                        best[v][k-1] = result+w                                        \n                                        heapq.heappush(min_heap, (result+w, v, k-1))\n                return -1", "43": "def minChanges(self, nums, k):\n                def one_are_not_from_nums(nums, cnts):\n                        mxs = [cnts[i].most_common(1)[0][1] for i in xrange(k)]\n                        return len(nums) - (sum(mxs)-min(mxs))\n                def all_are_from_nums(nums, cnts):\n                        dp = {0:0}\n                        for cnt in cnts:\n                                new_dp = collections.defaultdict(int)\n                                for x in dp.iterkeys():\n                                        for y in cnt.iterkeys():\n                                                new_dp[x^y] = max(new_dp[x^y], dp[x]+cnt[y])\n                                dp = new_dp\n                        return len(nums)-dp[0]\n                cnts = [collections.Counter(nums[j] for j in xrange(i, len(nums), k)) for i in xrange(k)]\n                return min(one_are_not_from_nums(nums, cnts), all_are_from_nums(nums, cnts))\ndef one_are_not_from_nums(nums, cnts):\n                        mxs = [cnts[i].most_common(1)[0][1] for i in xrange(k)]\n                        return len(nums) - (sum(mxs)-min(mxs))\ndef all_are_from_nums(nums, cnts):\n                        dp = {0:0}\n                        for cnt in cnts:\n                                new_dp = collections.defaultdict(int)\n                                for x in dp.iterkeys():\n                                        for y in cnt.iterkeys():\n                                                new_dp[x^y] = max(new_dp[x^y], dp[x]+cnt[y])\n                                dp = new_dp\n                        return len(nums)-dp[0]", "44": "def minCharacters(self, a, b):\n                count1 = collections.Counter(ord(c)-ord('a') for c in a)\n                count2 = collections.Counter(ord(c)-ord('a') for c in b)\n                result = len(a) + len(b) - max((count1+count2).itervalues()) \n                for i in xrange(26-1):\n                        if i > 0:\n                                count1[i] += count1[i-1]\n                                count2[i] += count2[i-1]\n                        result = min(result, len(a) - count1[i] + count2[i]) \n                        result = min(result, len(b) - count2[i] + count1[i]) \n                return result", "45": "def reverseOnlyLetters(self, S):\n                def getNext(S):\n                        for i in reversed(xrange(len(S))):\n                                if S[i].isalpha():\n                                        yield S[i]\n                result = []\n                letter = getNext(S)\n                for i in xrange(len(S)):\n                        if S[i].isalpha():\n                                result.append(letter.next())\n                        else:\n                                result.append(S[i])\n                return \"\".join(result)\ndef getNext(S):\n                        for i in reversed(xrange(len(S))):\n                                if S[i].isalpha():\n                                        yield S[i]", "46": "def countDigitOne(self, n):\n                DIGIT = 1\n                is_zero = int(DIGIT == 0)\n                result = is_zero\n                base = 1\n                while n >= base:\n                        result += (n//(10*base)-is_zero)*base + \\\n                                        min(base, max(n%(10*base) - DIGIT*base + 1, 0))\n                        base *= 10\n                return result", "47": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef minDepth(self, root):\n                if root is None:\n                        return 0\n                if root.left and root.right:\n                        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n                else:\n                        return max(self.minDepth(root.left), self.minDepth(root.right)) + 1", "48": "def findClosestElements(self, arr, k, x):\n                i = bisect.bisect_left(arr, x)\n                left, right = i-1, i\n                while k:\n                        if right >= len(arr) or \\\n                        (left >= 0 and abs(arr[left]-x) <= abs(arr[right]-x)):\n                                left -= 1\n                        else:\n                                right += 1\n                        k -= 1\n                return arr[left+1:right]", "49": "def nthUglyNumber(self, n, a, b, c):\n                def gcd(a, b):\n                        while b:\n                                a, b = b, a % b\n                        return a\n                def lcm(x, y):\n                        return x//gcd(x, y)*y\n                def count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):\n                        return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c\n                lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a)\n                lcm_a_b_c = lcm(lcm_a_b, lcm_b_c)\n                left, right = 1, 2*10**9\n                while left <= right:\n                        mid = left + (right-left)//2\n                        if count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n:\n                                right = mid-1\n                        else:\n                                left = mid+1\n                return left\ndef gcd(a, b):\n                        while b:\n                                a, b = b, a % b\n                        return a\ndef lcm(x, y):\n                        return x//gcd(x, y)*y\ndef count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):\n                        return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c", "50": "def candy(self, ratings):\n                candies = [1 for _ in xrange(len(ratings))]\n                for i in xrange(1, len(ratings)):\n                        if ratings[i] > ratings[i - 1]:\n                                candies[i] = candies[i - 1] + 1\n                for i in reversed(xrange(1, len(ratings))):\n                        if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]:\n                                candies[i - 1] = candies[i] + 1\n                return sum(candies)", "51": "def __init__(self, n, cb):\n                self.set = range(n)\n                self.rank = [0]*n\n                self.cb = cb\ndef find_set(self, x):\n                stk = []\n                while self.set[x] != x: \n                        stk.append(x)\n                        x = self.set[x]\n                while stk:\n                        self.set[stk.pop()] = x\n                return x\ndef union_set(self, x, y):\n                x_root, y_root = map(self.find_set, (x, y))\n                if x_root == y_root:\n                        return False\n                if self.rank[x_root] < self.rank[y_root]: \n                        self.set[x_root] = y_root\n                        self.cb(y_root, x_root, y_root)\n                elif self.rank[x_root] > self.rank[y_root]:\n                        self.set[y_root] = x_root\n                        self.cb(x_root, x_root, y_root)\n                else:\n                        self.set[y_root] = x_root\n                        self.rank[x_root] += 1\n                        self.cb(x_root, x_root, y_root)\n                return True\ndef matrixRankTransform(self, matrix):\n                def cb(x, y, z):\n                        new_rank[x] = max(new_rank[y], new_rank[z])\n                lookup = collections.defaultdict(list)\n                for i in xrange(len(matrix)):\n                        for j in xrange(len(matrix[0])):\n                                lookup[matrix[i][j]].append([i, j])\n                rank = [0]*(len(matrix)+len(matrix[0]))\n                for x in sorted(lookup):\n                        new_rank = rank[:]\n                        union_find = UnionFind(len(matrix)+len(matrix[0]), cb)\n                        for i, j in lookup[x]:\n                                union_find.union_set(i, j+len(matrix))\n                        for i, j in lookup[x]:\n                                matrix[i][j] = rank[i] = rank[j+len(matrix)] = new_rank[union_find.find_set(i)]+1\n                return matrix\ndef cb(x, y, z):\n                        new_rank[x] = max(new_rank[y], new_rank[z])", "52": "def minDiffInBST(self, root):\n                def dfs(node):\n                        if not node:\n                                return\n                        dfs(node.left)\n                        self.result = min(self.result, node.val-self.prev)\n                        self.prev = node.val\n                        dfs(node.right)\n                self.prev = float('-inf')\n                self.result = float('inf')\n                dfs(root)\n                return self.result\ndef dfs(node):\n                        if not node:\n                                return\n                        dfs(node.left)\n                        self.result = min(self.result, node.val-self.prev)\n                        self.prev = node.val\n                        dfs(node.right)", "53": "def thirdMax(self, nums):\n                count = 0\n                top = [float(\"-inf\")] * 3\n                for num in nums:\n                        if num > top[0]:\n                                top[0], top[1], top[2] = num, top[0], top[1]\n                                count += 1\n                        elif num != top[0] and num > top[1]:\n                                top[1], top[2] = num, top[1]\n                                count += 1\n                        elif num != top[0] and num != top[1] and num >= top[2]:\n                                top[2] = num\n                                count += 1\n                if count < 3:\n                        return top[0]\n                return top[2]", "54": "def subarraySum(self, nums, k):\n                result = 0\n                accumulated_sum = 0\n                lookup = collections.defaultdict(int)\n                lookup[0] += 1\n                for num in nums:\n                        accumulated_sum += num\n                        result += lookup[accumulated_sum - k]\n                        lookup[accumulated_sum] += 1\n                return result", "55": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef __init__(self, root):\n                self.__stk = []\n                self.__traversalLeft(root)\ndef hasNext(self):\n                return self.__stk\ndef next(self):\n                node = self.__stk.pop()\n                self.__traversalLeft(node.right)\n                return node.val\ndef __traversalLeft(self, node):\n                while node is not None:\n                        self.__stk.append(node)\n                        node = node.left", "56": "def prevPermOpt1(self, A):\n                for left in reversed(xrange(len(A)-1)):\n                        if A[left] > A[left+1]:\n                                break\n                else:\n                        return A\n                right = len(A)-1\n                while A[left] <= A[right]:\n                        right -= 1\n                while A[right-1] == A[right]:\n                        right -= 1\n                A[left], A[right] = A[right], A[left]\n                return A", "57": "def leastInterval(self, tasks, n):\n                counter = Counter(tasks)\n                _, max_count = counter.most_common(1)[0]\n                result = (max_count-1) * (n+1)\n                for count in counter.values():\n                        if count == max_count:\n                                result += 1\n                return max(result, len(tasks))", "58": "def getMoneyAmount(self, n):\n                pay = [[0] * n for _ in xrange(n+1)]\n                for i in reversed(xrange(n)):\n                        for j in xrange(i+1, n):\n                                pay[i][j] = min(k+1 + max(pay[i][k-1], pay[k+1][j]) \\\n                                                                for k in xrange(i, j+1))\n                return pay[0][n-1]", "59": "def __init__(self, val=0, next=None):\n                pass\ndef swapNodes(self, head, k):\n                left, right, curr = None, None, head\n                while curr:\n                        k -= 1\n                        if right:\n                                right = right.next\n                        if k == 0:\n                                left = curr\n                                right = head\n                        curr = curr.next\n                left.val, right.val = right.val, left.val\n                return head", "60": "def numDecodings(self, s):\n                if len(s) == 0 or s[0] == '0':\n                        return 0\n                prev, prev_prev = 1, 0\n                for i in xrange(len(s)):\n                        cur = 0\n                        if s[i] != '0':\n                                cur = prev\n                        if i > 0 and (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] <= '6')):\n                                cur += prev_prev\n                        prev, prev_prev = cur, prev\n                return prev", "61": "def backspaceCompare(self, S, T):\n                def findNextChar(S):\n                        skip = 0\n                        for i in reversed(xrange(len(S))):\n                                if S[i] == '\n                                        skip += 1\n                                elif skip:\n                                        skip -= 1\n                                else:\n                                        yield S[i]\n                return all(x == y for x, y in\n                                itertools.izip_longest(findNextChar(S), findNextChar(T)))\ndef findNextChar(S):\n                        skip = 0\n                        for i in reversed(xrange(len(S))):\n                                if S[i] == '\n                                        skip += 1\n                                elif skip:\n                                        skip -= 1\n                                else:\n                                        yield S[i]", "62": "def __init__(self, x):\n                self.val = x\n                self.next = None\ndef addTwoNumbers(self, l1, l2):\n                dummy = ListNode(0)\n                current, carry = dummy, 0\n                while l1 or l2:\n                        val = carry\n                        if l1:\n                                val += l1.val\n                                l1 = l1.next\n                        if l2:\n                                val += l2.val\n                                l2 = l2.next\n                        carry, val = divmod(val, 10)\n                        current.next = ListNode(val)\n                        current = current.next\n                if carry == 1:\n                        current.next = ListNode(1)\n                return dummy.next", "63": "def __init__(self, x):\n                self.val = x\n                self.next = None\ndef __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef isSubPath(self, head, root):\n                def dfs(head, root):\n                        if not head:\n                                return True\n                        if not root:\n                                return False\n                        return root.val == head.val and \\\n                                (dfs(head.next, root.left) or \n                                        dfs(head.next, root.right))\n                if not head:\n                        return True\n                if not root:\n                        return False\n                return dfs(head, root) or \\\n                        self.isSubPath(head, root.left) or \\\n                        self.isSubPath(head, root.right)\ndef dfs(head, root):\n                        if not head:\n                                return True\n                        if not root:\n                                return False\n                        return root.val == head.val and \\\n                                (dfs(head.next, root.left) or \n                                        dfs(head.next, root.right))", "64": "def rob(self, root):\n                def robHelper(root):\n                        if not root:\n                                return (0, 0)\n                        left, right = robHelper(root.left), robHelper(root.right)\n                        return (root.val + left[1] + right[1], max(left) + max(right))\n                return max(robHelper(root))\ndef robHelper(root):\n                        if not root:\n                                return (0, 0)\n                        left, right = robHelper(root.left), robHelper(root.right)\n                        return (root.val + left[1] + right[1], max(left) + max(right))", "65": "def minOperations(self, nums):\n                result = prev = 0\n                for curr in nums:\n                        if prev < curr:\n                                prev = curr\n                                continue\n                        prev += 1\n                        result += prev-curr                                \n                return result", "66": "def minimumJumps(self, forbidden, a, b, x):\n                max_f = max(forbidden)\n                max_val = x+b if a >= b else max(x, max_f)+a+(b+a) \n                lookup = set()        \n                for pos in forbidden:\n                        lookup.add((pos, True))\n                        lookup.add((pos, False))\n                result = 0\n                q = [(0, True)]\n                lookup.add((0, True))\n                while q:\n                        new_q = []\n                        for pos, can_back in q:\n                                if pos == x:\n                                        return result\n                                if pos+a <= max_val and (pos+a, True) not in lookup:\n                                        lookup.add((pos+a, True))\n                                        new_q.append((pos+a, True))\n                                if not can_back:\n                                        continue\n                                if pos-b >= 0 and (pos-b, False) not in lookup:\n                                        lookup.add((pos-b, False))\n                                        new_q.append((pos-b, False))\n                        q = new_q\n                        result += 1\n                return -1", "67": "def countPrimeSetBits(self, L, R):\n                def bitCount(n):\n                        result = 0\n                        while n:\n                                n &= n-1\n                                result += 1\n                        return result\n                primes = {2, 3, 5, 7, 11, 13, 17, 19}\n                return sum(bitCount(i) in primes\n                                for i in xrange(L, R+1))\ndef bitCount(n):\n                        result = 0\n                        while n:\n                                n &= n-1\n                                result += 1\n                        return result", "68": "def checkIfPangram(self, sentence):\n                return len(set(sentence)) == 26", "69": "def countGoodSubstrings(self, s):\n                K = 3\n                result = 0\n                count = collections.Counter()\n                for i in xrange(len(s)):\n                        if i >= K:\n                                count[s[i-K]] -= 1\n                                if not count[s[i-K]]:\n                                        del count[s[i-K]]\n                        count[s[i]] += 1\n                        if len(count) == K:\n                                result += 1\n                return result", "70": "def firstUniqChar(self, s):\n                lookup = defaultdict(int)\n                candidtates = set()\n                for i, c in enumerate(s):\n                        if lookup[c]:\n                                candidtates.discard(lookup[c])\n                        else:\n                                lookup[c] = i+1\n                                candidtates.add(i+1)\n                return min(candidtates)-1 if candidtates else -1", "71": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef sumNumbers(self, root):\n                return self.sumNumbersRecu(root, 0)\ndef sumNumbersRecu(self, root, num):\n                if root is None:\n                        return 0\n                if root.left is None and root.right is None:\n                        return num * 10 + root.val\n                return self.sumNumbersRecu(root.left, num * 10 + root.val) + self.sumNumbersRecu(root.right, num * 10 + root.val)", "72": "def minimumSwap(self, s1, s2):\n                x1, y1 = 0, 0\n                for i in xrange(len(s1)):\n                        if s1[i] == s2[i]:\n                                continue\n                        x1 += int(s1[i] == 'x')\n                        y1 += int(s1[i] == 'y')\n                if x1%2 != y1%2: \n                        return -1\n                return (x1//2 + y1//2) + (x1%2 + y1%2)", "73": "def secondHighest(self, s):\n                first = second = -1\n                for c in s:\n                        if not c.isdigit():\n                                continue\n                        d = int(c)\n                        if d > first:\n                                first, second = d, first\n                        elif first > d > second:\n                                second = d\n                return second", "74": "def isTransformable(self, s, t):\n                idxs = [[] for _ in xrange(10)]\n                for i in reversed(xrange(len(s))):\n                        idxs[int(s[i])].append(i)\n                for c in t:\n                        d = int(c)\n                        if not idxs[d]:\n                                return False\n                        for k in xrange(d): \n                                if idxs[k] and idxs[k][-1] < idxs[d][-1]:\n                                        return False\n                        idxs[d].pop()\n                return True", "75": "def toGoatLatin(self, S):\n                def convert(S):\n                        vowel = set('aeiouAEIOU')\n                        for i, word in enumerate(S.split(), 1):\n                                if word[0] not in vowel:\n                                        word = word[1:] + word[:1]\n                                yield word + 'ma' + 'a'*i\n                return \" \".join(convert(S))\ndef convert(S):\n                        vowel = set('aeiouAEIOU')\n                        for i, word in enumerate(S.split(), 1):\n                                if word[0] not in vowel:\n                                        word = word[1:] + word[:1]\n                                yield word + 'ma' + 'a'*i", "76": "def myPow(self, x, n):\n                if n < 0 and n != -n:\n                        return 1.0 / self.myPow(x, -n)\n                if n == 0:\n                        return 1\n                v = self.myPow(x, n / 2)\n                if n % 2 == 0:\n                        return v * v\n                else:\n                        return v * v * x", "77": "def numEnclaves(self, A):\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                def dfs(A, i, j):\n                        if not (0 <= i < len(A) and 0 <= j < len(A[0]) and A[i][j]):\n                                return\n                        A[i][j] = 0\n                        for d in directions:\n                                dfs(A, i+d[0], j+d[1])\n                for i in xrange(len(A)):\n                        dfs(A, i, 0)\n                        dfs(A, i, len(A[0])-1)\n                for j in xrange(1, len(A[0])-1):\n                        dfs(A, 0, j)\n                        dfs(A, len(A)-1, j)\n                return sum(sum(row) for row in A)\ndef dfs(A, i, j):\n                        if not (0 <= i < len(A) and 0 <= j < len(A[0]) and A[i][j]):\n                                return\n                        A[i][j] = 0\n                        for d in directions:\n                                dfs(A, i+d[0], j+d[1])", "78": "def numberOfRounds(self, startTime, finishTime):\n                h1, m1 = map(int, startTime.split(\":\"))\n                h2, m2 = map(int, finishTime.split(\":\"))\n                if m1 > m2:\n                        h2 -= 1\n                        m2 += 60\n                return max((h2-h1)%24*4 + m2//15 - (m1+15-1)//15, 0)", "79": "def getOrder(self, tasks):\n                idx = range(len(tasks))\n                idx.sort(key=lambda x: tasks[x][0])\n                result, min_heap = [], []\n                i, time = 0, tasks[idx[0]][0]\n                while i < len(idx) or min_heap:\n                        while i < len(idx) and tasks[idx[i]][0] <= time:\n                                heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i]))\n                                i += 1\n                        if not min_heap:\n                                time = tasks[idx[i]][0]\n                                continue\n                        t, j = heapq.heappop(min_heap)\n                        time += t\n                        result.append(j)\n                return result", "80": "def maximumUniqueSubarray(self, nums):\n                lookup = {}\n                prefix = [0]*(len(nums)+1)\n                result, left = 0, 0\n                for right, num in enumerate(nums):\n                        prefix[right+1] = prefix[right]+num\n                        if num in lookup:\n                                left = max(left, lookup[num]+1)\n                        lookup[num] = right\n                        result = max(result, prefix[right+1]-prefix[left])\n                return result", "81": "def deleteAndEarn(self, nums):\n                vals = [0] * 10001\n                for num in nums:\n                        vals[num] += num\n                val_i, val_i_1 = vals[0], 0\n                for i in xrange(1, len(vals)):\n                        val_i_1, val_i_2 = val_i, val_i_1\n                        val_i = max(vals[i] + val_i_2, val_i_1)\n                return val_i", "82": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef btreeGameWinningMove(self, root, n, x):\n                def count(node, x, left_right):\n                        if not node:\n                                return 0\n                        left, right = count(node.left, x, left_right), count(node.right, x, left_right)\n                        if node.val == x:\n                                left_right[0], left_right[1] = left, right\n                        return left + right + 1\n                left_right = [0, 0]\n                count(root, x, left_right)\n                blue = max(max(left_right), n-(sum(left_right)+1))\n                return blue > n-blue\ndef count(node, x, left_right):\n                        if not node:\n                                return 0\n                        left, right = count(node.left, x, left_right), count(node.right, x, left_right)\n                        if node.val == x:\n                                left_right[0], left_right[1] = left, right\n                        return left + right + 1", "83": "def maxProductDifference(self, nums):\n                largest, smallest = [0]*2, [float(\"inf\")]*2\n                for x in nums:\n                        if x >= largest[0]:\n                                largest[:] = [x, largest[0]]\n                        elif x > largest[1]:\n                                largest[1] =x\n                        if x <= smallest[0]:\n                                smallest[:] = [x, smallest[0]]\n                        elif x < smallest[1]:\n                                smallest[1] = x\n                return largest[0]*largest[1] - smallest[0]*smallest[1]", "84": "def repeatedNTimes(self, A):\n                for i in xrange(2, len(A)):\n                        if A[i-1] == A[i] or A[i-2] == A[i]:\n                                return A[i]\n                return A[0]", "85": "def kthSmallest(self, root, k):\n                s, cur, rank = [], root, 0\n                while s or cur:\n                        if cur:\n                                s.append(cur)\n                                cur = cur.left\n                        else:\n                                cur = s.pop()\n                                rank += 1\n                                if rank == k:\n                                        return cur.val\n                                cur = cur.right\n                return float(\"-inf\")", "86": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef maxLevelSum(self, root):\n                result, level, max_total = 0, 1, float(\"-inf\")\n                q = collections.deque([root])\n                while q:\n                        total = 0\n                        for _ in xrange(len(q)):\n                                node = q.popleft()\n                                total += node.val\n                                if node.left:\n                                        q.append(node.left)\n                                if node.right:\n                                        q.append(node.right)\n                        if total > max_total:\n                                result, max_total = level, total\n                        level += 1\n                return result", "87": "def divisorGame(self, N):\n                def memoization(N, dp):\n                        if N == 1:\n                                return False\n                        if N not in dp:\n                                result = False\n                                for i in xrange(1, N+1):\n                                        if i*i > N:\n                                                break\n                                        if N % i == 0:\n                                                if not memoization(N-i, dp):\n                                                        result = True\n                                                        break\n                                dp[N] = result\n                        return dp[N]\n                return memoization(N, {})\ndef memoization(N, dp):\n                        if N == 1:\n                                return False\n                        if N not in dp:\n                                result = False\n                                for i in xrange(1, N+1):\n                                        if i*i > N:\n                                                break\n                                        if N % i == 0:\n                                                if not memoization(N-i, dp):\n                                                        result = True\n                                                        break\n                                dp[N] = result\n                        return dp[N]", "88": "def countSubIslands(self, grid1, grid2):\n                directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n                def dfs(grid1, grid2, i, j):\n                        if not (0 <= i < len(grid2) and\n                                        0 <= j < len(grid2[0]) and grid2[i][j] == 1):\n                                return 1\n                        grid2[i][j] = 0\n                        result = grid1[i][j]\n                        for di, dj in directions:\n                                result &= dfs(grid1, grid2, i+di, j+dj)\n                        return result\n                return sum(dfs(grid1, grid2, i, j) for i in xrange(len(grid2)) for j in xrange(len(grid2[0])) if grid2[i][j])\ndef dfs(grid1, grid2, i, j):\n                        if not (0 <= i < len(grid2) and\n                                        0 <= j < len(grid2[0]) and grid2[i][j] == 1):\n                                return 1\n                        grid2[i][j] = 0\n                        result = grid1[i][j]\n                        for di, dj in directions:\n                                result &= dfs(grid1, grid2, i+di, j+dj)\n                        return result", "89": "def balancedString(self, s):\n                count = collections.Counter(s)\n                result = len(s) \n                left = 0\n                for right in xrange(len(s)):\n                        count[s[right]] -= 1\n                        while left < len(s) and \\\n                                all(v <= len(s)//4 for v in count.itervalues()):\n                                result = min(result, right-left+1)\n                                count[s[left]] += 1\n                                left += 1\n                return result", "90": "def permuteUnique(self, nums):\n                nums.sort()\n                result = []\n                used = [False] * len(nums)\n                self.permuteUniqueRecu(result, used, [], nums)\n                return result\ndef permuteUniqueRecu(self, result, used, cur, nums):\n                if len(cur) == len(nums):\n                        result.append(cur + [])\n                        return\n                for i in xrange(len(nums)):\n                        if used[i] or (i > 0 and nums[i-1] == nums[i] and not used[i-1]):\n                                continue\n                        used[i] = True\n                        cur.append(nums[i])\n                        self.permuteUniqueRecu(result, used, cur, nums)\n                        cur.pop()\n                        used[i] = False", "91": "def maxDepth(self, s):\n                result = curr = 0\n                for c in s:\n                        if c == '(':\n                                curr += 1\n                                result = max(result, curr) elif c == ')':\n                                curr -= 1\n                return result", "92": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef increasingBST(self, root):\n                def increasingBSTHelper(root, tail):\n                        if not root:\n                                return tail\n                        result = increasingBSTHelper(root.left, root)\n                        root.left = None\n                        root.right = increasingBSTHelper(root.right, tail)\n                        return result\n                return increasingBSTHelper(root, None)\ndef increasingBSTHelper(root, tail):\n                        if not root:\n                                return tail\n                        result = increasingBSTHelper(root.left, root)\n                        root.left = None\n                        root.right = increasingBSTHelper(root.right, tail)\n                        return result", "93": "def maxDotProduct(self, nums1, nums2):\n                if len(nums1) < len(nums2):\n                        return self.maxDotProduct(nums2, nums1)\n                dp = [[0]*len(nums2) for i in xrange(2)]\n                for i in xrange(len(nums1)):\n                        for j in xrange(len(nums2)):\n                                dp[i%2][j] = nums1[i]*nums2[j]\n                                if i and j:\n                                        dp[i%2][j] += max(dp[(i-1)%2][j-1], 0)\n                                if i:\n                                        dp[i%2][j] = max(dp[i%2][j], dp[(i-1)%2][j])\n                                if j:\n                                        dp[i%2][j] = max(dp[i%2][j], dp[i%2][j-1])\n                return dp[(len(nums1)-1)%2][-1]", "94": "def findRotateSteps(self, ring, key):\n                lookup = collections.defaultdict(list)\n                for i in xrange(len(ring)):\n                        lookup[ring[i]].append(i)\n                dp = [[0] * len(ring) for _ in xrange(2)]\n                prev = [0]\n                for i in xrange(1, len(key)+1):\n                        dp[i%2] = [float(\"inf\")] * len(ring)\n                        for j in lookup[key[i-1]]:\n                                for k in prev:\n                                        dp[i%2][j] = min(dp[i%2][j],\n                                                                        min((k+len(ring)-j) % len(ring), \\\n                                                                                (j+len(ring)-k) % len(ring)) + \\\n                                                                        dp[(i-1) % 2][k])\n                        prev = lookup[key[i-1]]\n                return min(dp[len(key)%2]) + len(key)", "95": "def checkPalindromeFormation(self, a, b):\n                def is_palindrome(s, i, j):\n                        while i < j:\n                                if s[i] != s[j]:\n                                        return False\n                                i += 1\n                                j -= 1\n                        return True\n                def check(a, b):\n                        i, j = 0, len(b)-1\n                        while i < j:\n                                if a[i] != b[j]:\n                                        return is_palindrome(a, i, j) or is_palindrome(b, i, j)\n                                i += 1\n                                j -= 1\n                        return True\n                return check(a, b) or check(b, a)\ndef is_palindrome(s, i, j):\n                        while i < j:\n                                if s[i] != s[j]:\n                                        return False\n                                i += 1\n                                j -= 1\n                        return True\ndef check(a, b):\n                        i, j = 0, len(b)-1\n                        while i < j:\n                                if a[i] != b[j]:\n                                        return is_palindrome(a, i, j) or is_palindrome(b, i, j)\n                                i += 1\n                                j -= 1\n                        return True", "96": "This data point has no code", "97": "This data point has no code", "98": "def getMaximumGenerated(self, n):\n                if n == 0:\n                        return 0\n                nums = [0]*(n+1)\n                nums[1] = 1\n                result = 1\n                for i in xrange(2, n+1):\n                        if i%2 == 0:\n                                nums[i] = nums[i//2]\n                        else:\n                                nums[i] = nums[i//2] + nums[i//2+1]\n                        result = max(result, nums[i])\n                return result", "99": "def subsetXORSum(self, nums):\n                result = 0\n                for x in nums:\n                        result |= x\n                return result * 2**(len(nums)-1)", "100": "def canPlaceFlowers(self, flowerbed, n):\n                for i in xrange(len(flowerbed)):\n                        if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and \\\n                                (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\n                                flowerbed[i] = 1\n                                n -= 1\n                        if n <= 0:\n                                return True\n                return False", "101": "def maxPower(self, s):\n                result, count = 1, 1\n                for i in xrange(1, len(s)):\n                        if s[i] == s[i-1]:\n                                count += 1\n                        else:\n                                count = 1\n                        result = max(result, count)\n                return result", "102": "def findBall(self, grid):\n                result = []\n                for c in xrange(len(grid[0])):\n                        for r in xrange(len(grid)):\n                                nc = c+grid[r][c]\n                                if not (0 <= nc < len(grid[0]) and grid[r][nc] == grid[r][c]):\n                                        c = -1\n                                        break\n                                c = nc\n                        result.append(c)\n                return result", "103": "def diagonalSort(self, mat):\n                lookup = collections.defaultdict(list)\n                for i in xrange(len(mat)):\n                        for j in xrange(len(mat[0])):\n                                lookup[i-j].append(mat[i][j])\n                for v in lookup.itervalues():\n                        v.sort()\n                for i in reversed(xrange(len(mat))):\n                        for j in reversed(xrange(len(mat[0]))):\n                                mat[i][j] = lookup[i-j].pop()\n                return mat", "104": "def maximumScore(self, a, b, c):\n                return min((a+b+c)//2, a+b+c - max(a, b, c))", "105": "def diffWaysToCompute(self, input):\n                tokens = re.split('(\\D)', input)\n                nums = map(int, tokens[::2])\n                ops = map({'+': operator.add, '-': operator.sub, '*': operator.mul}.get, tokens[1::2])\n                lookup = [[None for _ in xrange(len(nums))] for _ in xrange(len(nums))]\n                def diffWaysToComputeRecu(left, right):\n                        if left == right:\n                                return [nums[left]]\n                        if lookup[left][right]:\n                                return lookup[left][right]\n                        lookup[left][right] = [ops[i](x, y) for i in xrange(left, right) for x in diffWaysToComputeRecu(left, i) for y in diffWaysToComputeRecu(i + 1, right)]\n                        return lookup[left][right]\n                return diffWaysToComputeRecu(0, len(nums) - 1)", "106": "def canPartition(self, nums):\n                s = sum(nums)\n                if s % 2:\n                        return False\n                dp = [False] * (s/2 + 1)\n                dp[0] = True\n                for num in nums:\n                        for i in reversed(xrange(1, len(dp))):\n                                if num <= i:\n                                        dp[i] = dp[i] or dp[i - num]\n                return dp[-1]", "107": "def movesToMakeZigzag(self, nums):\n                result = [0, 0]\n                for i in xrange(len(nums)):\n                        left = nums[i-1] if i-1 >= 0 else float(\"inf\")\n                        right = nums[i+1] if i+1 < len(nums) else float(\"inf\")\n                        result[i%2] += max(nums[i] - min(left, right) + 1, 0)\n                return min(result)", "108": "def largestMerge(self, word1, word2):\n                q1 = collections.deque(word1)\n                q2 = collections.deque(word2)\n                result = []\n                while q1 or q2:\n                        if q1 > q2:\n                                result.append(q1.popleft())\n                        else:\n                                result.append(q2.popleft())\n                return \"\".join(result)", "109": "def countOrders(self, n):\n                MOD = 10**9+7\n                result = 1\n                for i in reversed(xrange(2, 2*n+1, 2)):\n                        result = result * i*(i-1)//2 % MOD\n                return result", "110": "def numRookCaptures(self, board):\n                directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n                r, c = None, None\n                for i in xrange(8):\n                        if r is not None:\n                                break\n                        for j in xrange(8):\n                                if board[i][j] == 'R':\n                                        r, c = i, j\n                                        break\n                result = 0\n                for d in directions:\n                        nr, nc = r+d[0], c+d[1]\n                        while 0 <= nr < 8 and 0 <= nc < 8:\n                                if board[nr][nc] == 'p':\n                                        result += 1\n                                if board[nr][nc] != '.':\n                                        break\n                                nr, nc= nr+d[0], nc+d[1]\n                return result", "111": "def modifyString(self, s):\n                s = list(s)\n                for i in xrange(len(s)):\n                        if s[i] != '?':\n                                continue\n                        for c in ('a', 'b', 'c'):\n                                if (i == 0 or s[i-1] != c) and (i == len(s)-1 or c != s[i+1]):\n                                        break\n                        s[i] = c\n                return \"\".join(s)", "112": "def findJudge(self, N, trust):\n                degrees = [0]*N\n                for i, j in trust:\n                        degrees[i-1] -= 1\n                        degrees[j-1] += 1\n                for i in xrange(len(degrees)):\n                        if degrees[i] == N-1:\n                                return i+1\n                return -1", "113": "def mostVisited(self, n, rounds):\n                return range(rounds[0], rounds[-1]+1) or \\\n                        range(1, rounds[-1]+1) + range(rounds[0], n+1)", "114": "def minSubarray(self, nums, p):\n                residue = sum(nums) % p\n                if not residue:\n                        return 0\n                result = len(nums)\n                curr, lookup = 0, {0: -1}\n                for i, num in enumerate(nums):\n                        curr = (curr+num) % p\n                        lookup[curr] = i\n                        if (curr-residue) % p in lookup:\n                                result = min(result, i-lookup[(curr-residue)%p])\n                return result if result < len(nums) else -1", "115": "def firstBadVersion(self, n):\n                left, right = 1, n\n                while left <= right:\n                        mid = left + (right - left) / 2\n                        if isBadVersion(mid): \n                                right = mid - 1\n                        else:\n                                left = mid + 1\n                return left", "116": "def transpose(self, A):\n                return zip(*A)", "117": "def maxScore(self, cardPoints, k):\n                result, total, curr, left = float(\"inf\"), 0, 0, 0\n                for right, point in enumerate(cardPoints):\n                        total += point\n                        curr += point\n                        if right-left+1 > len(cardPoints)-k:\n                                curr -= cardPoints[left]\n                                left += 1\n                        if right-left+1 == len(cardPoints)-k:\n                                result = min(result, curr)\n                return total-result", "118": "def shortestCompletingWord(self, licensePlate, words):\n                def contains(counter1, w2):\n                        c2 = collections.Counter(w2.lower())\n                        c2.subtract(counter1)\n                        return all(map(lambda x: x >= 0, c2.values()))\n                result = None\n                counter = collections.Counter(c.lower() for c in licensePlate if c.isalpha())\n                for word in words:\n                        if (result is None or (len(word) < len(result))) and \\\n                        contains(counter, word):\n                                result = word\n                return result\ndef contains(counter1, w2):\n                        c2 = collections.Counter(w2.lower())\n                        c2.subtract(counter1)\n                        return all(map(lambda x: x >= 0, c2.values()))", "119": "def isAnagram(self, s, t):\n                return sorted(s) == sorted(t)", "120": "def maximalNetworkRank(self, n, roads):\n                degree = [0]*n\n                adj = collections.defaultdict(set)\n                for a, b in roads:\n                        degree[a] += 1\n                        degree[b] += 1\n                        adj[a].add(b)\n                        adj[b].add(a)\n                result = 0\n                for i in xrange(n-1):\n                        for j in xrange(i+1, n):\n                                result = max(result, degree[i]+degree[j]-int(i in adj and j in adj[i]))\n                return result", "121": "def gameOfLife(self, board):\n                m = len(board)\n                n = len(board[0]) if m else 0\n                for i in xrange(m):\n                        for j in xrange(n):\n                                count = 0\n                                for I in xrange(max(i-1, 0), min(i+2, m)):\n                                        for J in xrange(max(j-1, 0), min(j+2, n)):\n                                                count += board[I][J] & 1\n                                if (count == 4 and board[i][j]) or count == 3:\n                                        board[i][j] |= 2 \n                for i in xrange(m):\n                        for j in xrange(n):\n                                board[i][j] >>= 1", "122": "def findSecondMinimumValue(self, root):\n                def findSecondMinimumValueHelper(root, max_heap, lookup):\n                        if not root:\n                                return\n                        if root.val not in lookup:\n                                heapq.heappush(max_heap, -root.val)\n                                lookup.add(root.val)\n                                if len(max_heap) > 2:\n                                        lookup.remove(-heapq.heappop(max_heap))\n                        findSecondMinimumValueHelper(root.left, max_heap, lookup)\n                        findSecondMinimumValueHelper(root.right, max_heap, lookup)\n                max_heap, lookup = [], set()\n                findSecondMinimumValueHelper(root, max_heap, lookup)\n                if len(max_heap) < 2:\n                        return -1\n                return -max_heap[0]\ndef findSecondMinimumValueHelper(root, max_heap, lookup):\n                        if not root:\n                                return\n                        if root.val not in lookup:\n                                heapq.heappush(max_heap, -root.val)\n                                lookup.add(root.val)\n                                if len(max_heap) > 2:\n                                        lookup.remove(-heapq.heappop(max_heap))\n                        findSecondMinimumValueHelper(root.left, max_heap, lookup)\n                        findSecondMinimumValueHelper(root.right, max_heap, lookup)", "123": "def findLHS(self, nums):\n                lookup = collections.defaultdict(int)\n                result = 0\n                for num in nums:\n                        lookup[num] += 1\n                        for diff in [-1, 1]:\n                                if (num + diff) in lookup:\n                                        result = max(result, lookup[num] + lookup[num + diff])\n                return result", "124": "def containsPattern(self, arr, m, k):\n                cnt = 0\n                for i in xrange(len(arr)-m):\n                        if arr[i] != arr[i+m]:\n                                cnt = 0\n                                continue\n                        cnt += 1\n                        if cnt == (k-1)*m:\n                                return True\n                return False", "125": "def minCostClimbingStairs(self, cost):\n                dp = [0] * 3\n                for i in reversed(xrange(len(cost))):\n                        dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3])\n                return min(dp[0], dp[1])", "126": "def primePalindrome(self, N):\n                def is_prime(n):\n                        if n < 2 or n % 2 == 0:\n                                return n == 2\n                        return all(n % d for d in xrange(3, int(n**.5) + 1, 2))\n                if 8 <= N <= 11:\n                        return 11\n                for i in xrange(10**(len(str(N))//2), 10**5):\n                        j = int(str(i) + str(i)[-2::-1])\n                        if j >= N and is_prime(j):\n                                return j\ndef is_prime(n):\n                        if n < 2 or n % 2 == 0:\n                                return n == 2\n                        return all(n % d for d in xrange(3, int(n**.5) + 1, 2))", "127": "def __init__(self):\n                self.__TOP_COUNT = 3\n                self.leaves = collections.defaultdict(TrieNode)\n                self.infos = []\ndef insert(self, words, i):\n                curr = self\n                for c in words[i]:\n                        curr = curr.leaves[c]\n                        curr.add_info(words, i)\ndef add_info(self, words, i):\n                self.infos.append(i)\n                self.infos.sort(key=lambda x: words[x])\n                if len(self.infos) > self.__TOP_COUNT:\n                        self.infos.pop()\ndef suggestedProducts(self, products, searchWord):\n                products.sort() \n                result = []\n                prefix = \"\"\n                for i, c in enumerate(searchWord): \n                        prefix += c\n                        start = bisect.bisect_left(products, prefix) \n                        new_products = []\n                        for j in xrange(start, len(products)): \n                                if not (i < len(products[j]) and products[j][i] == c):\n                                        break\n                                new_products.append(products[j])\n                        products = new_products\n                        result.append(products[:3])\n                return result", "128": "def countPalindromicSubsequences(self, S):\n                def dp(i, j, prv, nxt, lookup):\n                        if lookup[i][j] is not None:\n                                return lookup[i][j]\n                        result = 1\n                        if i <= j:\n                                for x in xrange(4):\n                                        i0 = nxt[i][x]\n                                        j0 = prv[j][x]\n                                        if i <= i0 <= j:\n                                                result = (result + 1) % P\n                                        if None < i0 < j0:\n                                                result = (result + dp(i0+1, j0-1, prv, nxt, lookup)) % P\n                        result %= P\n                        lookup[i][j] = result\n                        return result\n                prv = [None] * len(S)\n                nxt = [None] * len(S)\n                last = [None] * 4\n                for i in xrange(len(S)):\n                        last[ord(S[i])-ord('a')] = i\n                        prv[i] = tuple(last)\n                last = [None] * 4\n                for i in reversed(xrange(len(S))):\n                        last[ord(S[i])-ord('a')] = i\n                        nxt[i] = tuple(last)\n                P = 10**9 + 7\n                lookup = [[None] * len(S) for _ in xrange(len(S))]\n                return dp(0, len(S)-1, prv, nxt, lookup) - 1\ndef dp(i, j, prv, nxt, lookup):\n                        if lookup[i][j] is not None:\n                                return lookup[i][j]\n                        result = 1\n                        if i <= j:\n                                for x in xrange(4):\n                                        i0 = nxt[i][x]\n                                        j0 = prv[j][x]\n                                        if i <= i0 <= j:\n                                                result = (result + 1) % P\n                                        if None < i0 < j0:\n                                                result = (result + dp(i0+1, j0-1, prv, nxt, lookup)) % P\n                        result %= P\n                        lookup[i][j] = result\n                        return result", "129": "def maxValueAfterReverse(self, nums):\n                result, add, max_pair, min_pair = 0, 0, float(\"-inf\"), float(\"inf\")\n                for i in xrange(1, len(nums)):\n                        result += abs(nums[i-1]-nums[i])\n                        add = max(add,\n                                        abs(nums[0]-nums[i]) - abs(nums[i-1]-nums[i]),\n                                        abs(nums[-1]-nums[i-1]) - abs(nums[i-1]-nums[i]))\n                        min_pair = min(min_pair, max(nums[i-1], nums[i]))\n                        max_pair = max(max_pair, min(nums[i-1], nums[i]))\n                return result + max(add, (max_pair-min_pair)*2)", "130": "def isMatch(self, s, p):\n                count = 0 \n                p_ptr, s_ptr, last_s_ptr, last_p_ptr = 0, 0, -1, -1\n                while s_ptr < len(s):\n                        if p_ptr < len(p) and (s[s_ptr] == p[p_ptr] or p[p_ptr] == '?'):\n                                s_ptr += 1\n                                p_ptr += 1\n                        elif p_ptr < len(p) and p[p_ptr] == '*':\n                                p_ptr += 1\n                                last_s_ptr = s_ptr\n                                last_p_ptr = p_ptr\n                        elif last_p_ptr != -1:\n                                last_s_ptr += 1\n                                s_ptr = last_s_ptr\n                                p_ptr = last_p_ptr\n                        else:\n                                assert(count <= (len(p)+1) * (len(s)+1))\n                                return False\n                        count += 1 \n                while p_ptr < len(p) and p[p_ptr] == '*':\n                        p_ptr += 1\n                        count += 1 \n                assert(count <= (len(p)+1) * (len(s)+1))\n                return p_ptr == len(p)", "131": "def isBipartite(self, graph):\n                color = {}\n                for node in xrange(len(graph)):\n                        if node in color:\n                                continue\n                        stack = [node]\n                        color[node] = 0\n                        while stack:\n                                curr = stack.pop()\n                                for neighbor in graph[curr]:\n                                        if neighbor not in color:\n                                                stack.append(neighbor)\n                                                color[neighbor] = color[curr] ^ 1\n                                        elif color[neighbor] == color[curr]:\n                                                return False\n                return True", "132": "def maxProduct(self, words):\n                words.sort(key=lambda x: len(x), reverse=True)\n                bits = [0] * len(words)\n                for i, word in enumerate(words):\n                        for c in word:\n                                bits[i] |= (1 << (ord(c) - ord('a')))\n                max_product = 0\n                for i in xrange(len(words) - 1):\n                        if len(words[i]) ** 2 <= max_product:\n                                break\n                        for j in xrange(i + 1, len(words)):\n                                if len(words[i]) * len(words[j]) <= max_product:\n                                        break\n                                if not (bits[i] & bits[j]):\n                                        max_product = len(words[i]) * len(words[j])\n                return max_product", "133": "def __init__(self):\n                self.set = []\ndef get_id(self):\n                self.set.append(len(self.set))\n                return len(self.set)-1\ndef find_set(self, x):\n                if self.set[x] != x:\n                        self.set[x] = self.find_set(self.set[x]) \n                return self.set[x]\ndef union_set(self, x, y):\n                x_root, y_root = map(self.find_set, (x, y))\n                if x_root != y_root:\n                        self.set[min(x_root, y_root)] = max(x_root, y_root)\ndef accountsMerge(self, accounts):\n                union_find = UnionFind()\n                email_to_name = {}\n                email_to_id = {}\n                for account in accounts:\n                        name = account[0]\n                        for i in xrange(1, len(account)):\n                                if account[i] not in email_to_id:\n                                        email_to_name[account[i]] = name\n                                        email_to_id[account[i]] = union_find.get_id()\n                                union_find.union_set(email_to_id[account[1]], email_to_id[account[i]])\n                result = collections.defaultdict(list)\n                for email in email_to_name.keys():\n                        result[union_find.find_set(email_to_id[email])].append(email)\n                for emails in result.values():\n                        emails.sort()\n                return [[email_to_name[emails[0]]] + emails for emails in result.values()]", "134": "def minTime(self, n, edges, hasApple):\n                def dfs(graph, par, node, has_subtree):\n                        result, extra = 0, int(hasApple[node])\n                        for nei in graph[node]:\n                                if nei == par:\n                                        continue\n                                count = dfs(graph, node, nei, hasApple)\n                                result += count\n                                extra |= bool(count)\n                        return result+extra\n                graph = collections.defaultdict(list)\n                for u, v in edges:\n                        graph[u].append(v)\n                        graph[v].append(u)\n                return 2*max(dfs(graph, -1, 0, hasApple)-1, 0)\ndef dfs(graph, par, node, has_subtree):\n                        result, extra = 0, int(hasApple[node])\n                        for nei in graph[node]:\n                                if nei == par:\n                                        continue\n                                count = dfs(graph, node, nei, hasApple)\n                                result += count\n                                extra |= bool(count)\n                        return result+extra", "135": "There is no code here", "136": "def containsNearbyDuplicate(self, nums, k):\n                lookup = {}\n                for i, num in enumerate(nums):\n                        if num not in lookup:\n                                lookup[num] = i\n                        else:\n                                if i - lookup[num] <= k:\n                                        return True\n                                lookup[num] = i\n                return False", "137": "def findUnsortedSubarray(self, nums):\n                a = sorted(nums) \n                left, right = 0, len(nums) -1 \n                while (nums[left] == a[left] or nums[right] == a[right]):\n                        if right - left <= 1:\n                                return 0\n                        if nums[left] == a[left]:\n                                left += 1\n                        if nums[right] == a[right]:\n                                right -= 1\n                return right - left + 1", "138": "def longestStrChain(self, words):\n                words.sort(key=len)\n                dp = collections.defaultdict(int)\n                for w in words:\n                        for i in xrange(len(w)):\n                                dp[w] = max(dp[w], dp[w[:i]+w[i+1:]]+1)\n                return max(dp.itervalues())", "139": "def merge(self, A, m, B, n):\n                last, i, j = m + n - 1, m - 1, n - 1\n                while i >= 0 and j >= 0:\n                        if A[i] > B[j]:\n                                A[last] = A[i]\n                                last, i = last - 1, i - 1\n                        else:\n                                A[last] = B[j]\n                                last, j = last - 1, j - 1\n                while j >= 0:\n                                A[last] = B[j]\n                                last, j = last - 1, j - 1", "140": "def maxSumRangeQuery(self, nums, requests):\n                def addmod(a, b, mod): \n                        a %= mod\n                        b %= mod\n                        if mod-a <= b:\n                                b -= mod\n                        return a+b\n                def mulmod(a, b, mod): \n                        a %= mod\n                        b %= mod\n                        if a < b:\n                                a, b = b, a\n                        result = 0\n                        while b > 0:\n                                if b%2 == 1:\n                                        result = addmod(result, a, mod)\n                                a = addmod(a, a, mod)\n                                b //= 2\n                        return result\n                MOD = 10**9+7\n                count = [0]*len(nums)\n                for start, end in requests:\n                        count[start] += 1\n                        if end+1 < len(count):\n                                count[end+1] -= 1\n                for i in xrange(1, len(count)):\n                        count[i] += count[i-1]\n                nums.sort()\n                count.sort()\n                result = 0\n                for i, (num, c) in enumerate(itertools.izip(nums, count)):\n                        result = (result+num*c)%MOD\n                return result\ndef addmod(a, b, mod): \n                        a %= mod\n                        b %= mod\n                        if mod-a <= b:\n                                b -= mod\n                        return a+b\ndef mulmod(a, b, mod): \n                        a %= mod\n                        b %= mod\n                        if a < b:\n                                a, b = b, a\n                        result = 0\n                        while b > 0:\n                                if b%2 == 1:\n                                        result = addmod(result, a, mod)\n                                a = addmod(a, a, mod)\n                                b //= 2\n                        return result", "141": "def isPowerOfTwo(self, n):\n                return n > 0 and (n & (n - 1)) == 0", "142": "def minimumOneBitOperations(self, n):\n                result = 0\n                while n:\n                        result = -result - (n^(n-1)) \n                        n &= n-1\n                return abs(result)", "143": "def __init__(self, n):\n                self.set = range(n)\ndef find_set(self, x):\n                if self.set[x] != x:\n                        self.set[x] = self.find_set(self.set[x]) \n                return self.set[x]\ndef union_set(self, x, y):\n                x_root, y_root = map(self.find_set, (x, y))\n                if x_root == y_root:\n                        return False\n                self.set[min(x_root, y_root)] = max(x_root, y_root)\n                return True\ndef minMalwareSpread(self, graph, initial):\n                initial_set = set(initial)\n                clean = [i for i in xrange(len(graph)) if i not in initial_set]\n                union_find = UnionFind(len(graph))\n                for i in xrange(len(clean)):\n                        for j in xrange(i+1, len(clean)):\n                                if graph[clean[i]][clean[j]] == 1:\n                                        union_find.union_set(clean[i], clean[j])\n                union_size = collections.Counter(union_find.find_set(i) for i in xrange(len(graph)))\n                shared_union = collections.defaultdict(set)\n                for i in initial:\n                        for j in clean:                                \n                                if graph[i][j] == 1:\n                                        x = union_find.find_set(j)\n                                        shared_union[x].add(i)\n                result, total = float(\"inf\"), float(\"-inf\")\n                for i in initial:\n                        lookup = set()\n                        curr = 0\n                        for j in clean:                                \n                                if graph[i][j] == 1:\n                                        x = union_find.find_set(j)\n                                        if len(shared_union[x]) == 1 and \\\n                                        x not in lookup:\n                                                curr += union_size[x]\n                                                lookup.add(x)\n                        if curr > total or \\\n                        (curr == total and i < result):\n                                total = curr\n                                result = i\n                return result", "144": "def smallestRangeII(self, A, K):\n                A.sort()\n                result = A[-1]-A[0]\n                for i in xrange(len(A)-1):\n                        result = min(result,\n                                                max(A[-1]-K, A[i]+K) -\n                                                min(A[0]+K, A[i+1]-K))\n                return result", "145": "def removeComments(self, source):\n                in_block = False\n                result, newline = [], []\n                for line in source:\n                        i = 0\n                        while i < len(line):\n                                if not in_block and i+1 < len(line) and line[i:i+2] == '/*':\n                                        in_block = True\n                                        i += 1\n                                elif in_block and i+1 < len(line) and line[i:i+2] == '*/':\n                                        in_block = False\n                                        i += 1\n                                elif not in_block and i+1 < len(line) and line[i:i+2] == '//':\n                                        break\n                                elif not in_block:\n                                        newline.append(line[i])\n                                i += 1\n                        if newline and not in_block:\n                                result.append(\"\".join(newline))\n                                newline = []\n                return result", "146": "def canEat(self, candiesCount, queries):\n                prefix = [0]*(len(candiesCount)+1)\n                for i, c in enumerate(candiesCount):\n                        prefix[i+1] = prefix[i]+c\n                return [prefix[t]//c < d+1 <= prefix[t+1]//1 for t, d, c in queries]", "147": "def minTimeToVisitAllPoints(self, points):\n                return sum(max(abs(points[i+1][0] - points[i][0]),\n                                        abs(points[i+1][1] - points[i][1]))\n                                for i in xrange(len(points)-1))", "148": "def prisonAfterNDays(self, cells, N):\n                cells = tuple(cells)\n                lookup = {}\n                while N:\n                        lookup[cells] = N\n                        N -= 1\n                        cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in xrange(1, 7)] + [0])\n                        if cells in lookup:\n                                assert(lookup[cells] - N in (1, 7, 14))\n                                N %= lookup[cells] - N\n                                break\n                while N:\n                        N -= 1\n                        cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in xrange(1, 7)] + [0])\n                return list(cells)", "149": "def kthLargestValue(self, matrix, k):\n                def nth_element(nums, n, compare=lambda a, b: a < b):\n                        def tri_partition(nums, left, right, target, compare):\n                                mid = left\n                                while mid <= right:\n                                        if nums[mid] == target:\n                                                mid += 1\n                                        elif compare(nums[mid], target):\n                                                nums[left], nums[mid] = nums[mid], nums[left]\n                                                left += 1\n                                                mid += 1\n                                        else:\n                                                nums[mid], nums[right] = nums[right], nums[mid]\n                                                right -= 1\n                                return left, right\n                        left, right = 0, len(nums)-1\n                        while left <= right:\n                                pivot_idx = random.randint(left, right)\n                                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                                if pivot_left <= n <= pivot_right:\n                                        return\n                                elif pivot_left > n:\n                                        right = pivot_left-1\n                                else: \n                                        left = pivot_right+1\n                vals = []\n                for r in xrange(len(matrix)):\n                        curr = 0\n                        for c in xrange(len(matrix[0])):\n                                curr = curr^matrix[r][c]\n                                if r == 0:\n                                        matrix[r][c] = curr\n                                else:\n                                        matrix[r][c] = curr^matrix[r-1][c]\n                                vals.append(matrix[r][c])\n                nth_element(vals, k-1, compare=lambda a, b: a > b)\n                return vals[k-1]\ndef nth_element(nums, n, compare=lambda a, b: a < b):\n                        def tri_partition(nums, left, right, target, compare):\n                                mid = left\n                                while mid <= right:\n                                        if nums[mid] == target:\n                                                mid += 1\n                                        elif compare(nums[mid], target):\n                                                nums[left], nums[mid] = nums[mid], nums[left]\n                                                left += 1\n                                                mid += 1\n                                        else:\n                                                nums[mid], nums[right] = nums[right], nums[mid]\n                                                right -= 1\n                                return left, right\n                        left, right = 0, len(nums)-1\n                        while left <= right:\n                                pivot_idx = random.randint(left, right)\n                                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                                if pivot_left <= n <= pivot_right:\n                                        return\n                                elif pivot_left > n:\n                                        right = pivot_left-1\n                                else: \n                                        left = pivot_right+1\ndef tri_partition(nums, left, right, target, compare):\n                                mid = left\n                                while mid <= right:\n                                        if nums[mid] == target:\n                                                mid += 1\n                                        elif compare(nums[mid], target):\n                                                nums[left], nums[mid] = nums[mid], nums[left]\n                                                left += 1\n                                                mid += 1\n                                        else:\n                                                nums[mid], nums[right] = nums[right], nums[mid]\n                                                right -= 1\n                                return left, right", "150": "def countSubstrings(self, s):\n                def manacher(s):\n                        s = '^\n                        P = [0] * len(s)\n                        C, R = 0, 0\n                        for i in xrange(1, len(s) - 1):\n                                i_mirror = 2*C-i\n                                if R > i:\n                                        P[i] = min(R-i, P[i_mirror])\n                                while s[i+1+P[i]] == s[i-1-P[i]]:\n                                        P[i] += 1\n                                if i+P[i] > R:\n                                        C, R = i, i+P[i]\n                        return P\n                return sum((max_len+1)//2 for max_len in manacher(s))\ndef manacher(s):\n                        s = '^\n                        P = [0] * len(s)\n                        C, R = 0, 0\n                        for i in xrange(1, len(s) - 1):\n                                i_mirror = 2*C-i\n                                if R > i:\n                                        P[i] = min(R-i, P[i_mirror])\n                                while s[i+1+P[i]] == s[i-1-P[i]]:\n                                        P[i] += 1\n                                if i+P[i] > R:\n                                        C, R = i, i+P[i]\n                        return P", "151": "def minSwapsCouples(self, row):\n                N = len(row)//2\n                couples = [[] for _ in xrange(N)]\n                for seat, num in enumerate(row):\n                        couples[num//2].append(seat//2)\n                adj = [[] for _ in xrange(N)]\n                for couch1, couch2 in couples:\n                        adj[couch1].append(couch2)\n                        adj[couch2].append(couch1)\n                result = 0\n                for couch in xrange(N):\n                        if not adj[couch]: continue\n                        couch1, couch2 = couch, adj[couch].pop()\n                        while couch2 != couch:\n                                result += 1\n                                adj[couch2].remove(couch1)\n                                couch1, couch2 = couch2, adj[couch2].pop()\n                return result", "152": "def createTargetArray(self, nums, index):\n                result = []\n                for i, x in itertools.izip(index, nums):\n                        result.insert(i, x)\n                return result", "153": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef flipEquiv(self, root1, root2):\n                if not root1 and not root2:\n                        return True\n                if not root1 or not root2 or root1.val != root2.val:\n                        return False\n                return (self.flipEquiv(root1.left, root2.left) and\n                                self.flipEquiv(root1.right, root2.right) or\n                                self.flipEquiv(root1.left, root2.right) and\n                                self.flipEquiv(root1.right, root2.left))", "154": "def __init__(self, N):\n                left, right = self.__seats[p]\n                self.__seats.pop(p)\n                self.__seats[left][1] = right\n                self.__seats[right][0] = left\n                heapq.heappush(self.__max_heap, (-self.__distance((left, right)), left, right))\ndef __distance(self, segment):\n                return segment[1]-segment[0]-1 if segment[0] == -1 or segment[1] == self.__num \\\n                        else (segment[1]-segment[0]) // 2", "155": "def __init__(self, N,\n                                build_fn=lambda x, y: [y]*(2*x),\n                                query_fn=lambda x, y: y if x is None else max(x, y), update_fn=lambda x, y: y, default_val=0):\n                self.N = N\n                self.H = (N-1).bit_length()\n                self.query_fn = query_fn\n                self.update_fn = update_fn\n                self.default_val = default_val\n                self.tree = build_fn(N, default_val)\n                self.lazy = [None]*N\ndef __apply(self, x, val):\n                self.tree[x] = self.update_fn(self.tree[x], val)\n                if x < self.N:\n                        self.lazy[x] = self.update_fn(self.lazy[x], val)\ndef update(self, L, R, h): \n                def pull(x):\n                        while x > 1:\n                                x //= 2\n                                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                                if self.lazy[x] is not None:\n                                        self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n                L += self.N\n                R += self.N\n                L0, R0 = L, R\n                while L <= R:\n                        if L & 1: \n                                self.__apply(L, h) \n                                L += 1\n                        if R & 1 == 0: \n                                self.__apply(R, h)\n                                R -= 1\n                        L //= 2\n                        R //= 2\n                pull(L0)\n                pull(R0)\ndef query(self, L, R): \n                def push(x):\n                        n = 2**self.H\n                        while n != 1:\n                                y = x // n\n                                if self.lazy[y] is not None:\n                                        self.__apply(y*2, self.lazy[y])\n                                        self.__apply(y*2 + 1, self.lazy[y])\n                                        self.lazy[y] = None\n                                n //= 2\n                result = None\n                if L > R:\n                        return result\n                L += self.N\n                R += self.N\n                push(L)\n                push(R)\n                while L <= R:\n                        if L & 1: \n                                result = self.query_fn(result, self.tree[L])\n                                L += 1\n                        if R & 1 == 0: \n                                result = self.query_fn(result, self.tree[R])\n                                R -= 1\n                        L //= 2\n                        R //= 2\n                return result\ndef __str__(self):\n                showList = []\n                for i in xrange(self.N):\n                        showList.append(self.query(i, i))\n                return \",\".join(map(str, showList))\ndef bestTeamScore(self, scores, ages):\n                players = sorted(zip(ages, scores))\n                dp = [0]*len(players)\n                result = 0\n                for i in xrange(len(players)):\n                        dp[i] = players[i][1]\n                        for j in xrange(i):\n                                if players[j][1] <= players[i][1]:\n                                        dp[i] = max(dp[i], dp[j] + players[i][1])\n                        result = max(result, dp[i])\n                return result\ndef pull(x):\n                        while x > 1:\n                                x //= 2\n                                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                                if self.lazy[x] is not None:\n                                        self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\ndef push(x):\n                        n = 2**self.H\n                        while n != 1:\n                                y = x // n\n                                if self.lazy[y] is not None:\n                                        self.__apply(y*2, self.lazy[y])\n                                        self.__apply(y*2 + 1, self.lazy[y])\n                                        self.lazy[y] = None\n                                n //= 2", "156": "def binaryTreePaths(self, root):\n                result, path = [], []\n                self.binaryTreePathsRecu(root, path, result)\n                return result\ndef binaryTreePathsRecu(self, node, path, result):\n                if node is None:\n                        return\n                if node.left is node.right is None:\n                        ans = \"\"\n                        for n in path:\n                                ans += str(n.val) + \"->\"\n                        result.append(ans + str(node.val))\n                if node.left:\n                        path.append(node)\n                        self.binaryTreePathsRecu(node.left, path, result)\n                        path.pop()\n                if node.right:\n                        path.append(node)\n                        self.binaryTreePathsRecu(node.right, path, result)\n                        path.pop()", "157": "def slowestKey(self, releaseTimes, keysPressed):\n                result, lookup = 'a', collections.Counter()\n                for i, c in enumerate(keysPressed):\n                        lookup[c] = max(lookup[c], releaseTimes[i]-(releaseTimes[i-1] if i > 0 else 0))\n                        if lookup[c] > lookup[result] or lookup[c] == lookup[result] and c > result:\n                                result = c\n                return result", "158": "def minimumIncompatibility(self, nums, k):\n                def greedy(nums, k, is_reversed):\n                        count = collections.Counter(nums)\n                        if max(count.itervalues()) > k:\n                                return -1\n                        sorted_keys = sorted(count.keys(), reverse=is_reversed)\n                        stks = [[] for _ in xrange(k)] \n                        curr, remain = 0, len(nums)\n                        while remain: \n                                for x in sorted_keys: \n                                        if count[x] != len(stks)-curr:\n                                                continue\n                                        for i in xrange(curr, len(stks)):\n                                                stks[i].append(x)\n                                        remain -= count[x]\n                                        count[x] = 0\n                                for x in sorted_keys:\n                                        if not count[x]:\n                                                continue\n                                        stks[curr].append(x)\n                                        remain -= 1\n                                        count[x] -= 1\n                                        if len(stks[curr]) == len(nums)//k:\n                                                curr += 1\n                                                break\n                        return sum([max(stk)-min(stk) for stk in stks])\n                return min(greedy(nums, k, False), greedy(nums, k, True))\ndef greedy(nums, k, is_reversed):\n                        count = collections.Counter(nums)\n                        if max(count.itervalues()) > k:\n                                return -1\n                        sorted_keys = sorted(count.keys(), reverse=is_reversed)\n                        stks = [[] for _ in xrange(k)] \n                        curr, remain = 0, len(nums)\n                        while remain: \n                                for x in sorted_keys: \n                                        if count[x] != len(stks)-curr:\n                                                continue\n                                        for i in xrange(curr, len(stks)):\n                                                stks[i].append(x)\n                                        remain -= count[x]\n                                        count[x] = 0\n                                for x in sorted_keys:\n                                        if not count[x]:\n                                                continue\n                                        stks[curr].append(x)\n                                        remain -= 1\n                                        count[x] -= 1\n                                        if len(stks[curr]) == len(nums)//k:\n                                                curr += 1\n                                                break\n                        return sum([max(stk)-min(stk) for stk in stks])", "159": "def peakIndexInMountainArray(self, arr):\n                left, right = 0, len(arr)-1\n                while left <= right:\n                        mid = left + (right-left)//2\n                        if arr[mid] > arr[mid+1]:\n                                right = mid-1\n                        else:\n                                left = mid+1\n                return left", "160": "def removeCoveredIntervals(self, intervals):\n                intervals.sort(key=lambda x: [x[0], -x[1]])\n                result, max_right = 0, 0\n                for left, right in intervals:\n                        result += int(right > max_right)\n                        max_right = max(max_right, right)\n                return result", "161": "def climbStairs(self, n):\n                prev, current = 0, 1\n                for i in xrange(n):\n                        prev, current = current, prev + current,\n                return current", "162": "def countCharacters(self, words, chars):\n                def check(word, chars, count):\n                        if len(word) > len(chars):\n                                return False\n                        curr_count = collections.Counter()\n                        for c in word:\n                                curr_count[c] += 1\n                                if c not in count or count[c] < curr_count[c]:\n                                        return False\n                        return True\n                count = collections.Counter(chars)\n                return sum(len(word) for word in words if check(word, chars, count))\ndef check(word, chars, count):\n                        if len(word) > len(chars):\n                                return False\n                        curr_count = collections.Counter()\n                        for c in word:\n                                curr_count[c] += 1\n                                if c not in count or count[c] < curr_count[c]:\n                                        return False\n                        return True", "163": "def maxTurbulenceSize(self, A):\n                result = 1\n                start = 0\n                for i in xrange(1, len(A)):\n                        if i == len(A)-1 or \\\n                        cmp(A[i-1], A[i]) * cmp(A[i], A[i+1]) != -1:\n                                result = max(result, i-start+1)\n                                start = i\n                return result", "164": "def titleToNumber(self, s):\n                result = 0\n                for i in xrange(len(s)):\n                        result *= 26\n                        result += ord(s[i]) - ord('A') + 1\n                return result", "165": "def rearrangeSticks(self, n, k):\n                MOD = 10**9+7\n                dp = [[0 for _ in xrange(k+1)] for _ in xrange(2)]\n                dp[1][1] = 1\n                for i in xrange(2, n+1):\n                        for j in xrange(1, min(i, k)+1):\n                                dp[i%2][j] = (dp[(i-1)%2][j-1]+(i-1)*dp[(i-1)%2][j]) % MOD \n                return dp[n%2][k]", "166": "def maxLength(self, arr):\n                def bitset(s):\n                        result = 0\n                        for c in s:\n                                if result & power[ord(c)-ord('a')]:\n                                        return 0\n                                result |= power[ord(c)-ord('a')]\n                        return result\n                bitsets = [bitset(x) for x in arr]\n                result = 0\n                for i in xrange(power[len(arr)]):\n                        curr_bitset, curr_len = 0, 0\n                        while i:\n                                j = i & -i \n                                i ^= j\n                                j = log2[j] \n                                if not bitsets[j] or (curr_bitset & bitsets[j]):\n                                        break\n                                curr_bitset |= bitsets[j]\n                                curr_len += len(arr[j])\n                        else:\n                                result = max(result, curr_len)\n                return result\ndef bitset(s):\n                        result = 0\n                        for c in s:\n                                if result & power[ord(c)-ord('a')]:\n                                        return 0\n                                result |= power[ord(c)-ord('a')]\n                        return result", "167": "def dayOfTheWeek(self, day, month, year):\n                DAYS = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \\ \"Thursday\", \"Friday\", \"Saturday\"]\n                if month < 3:\n                        month += 12\n                        year -= 1\n                c, y = divmod(year, 100)\n                w = (c//4 - 2*c + y + y//4 + 13*(month+1)//5 + day - 1) % 7\n                return DAYS[w]", "168": "def totalHammingDistance(self, nums):\n                result = 0\n                for i in xrange(32):\n                        counts = [0] * 2\n                        for num in nums:\n                                counts[(num >> i) & 1] += 1\n                        result += counts[0] * counts[1]\n                return result", "169": "def minTaps(self, n, ranges):\n                def jump_game(A):\n                        jump_count, reachable, curr_reachable = 0, 0, 0\n                        for i, length in enumerate(A):\n                                if i > reachable:\n                                        return -1\n                                if i > curr_reachable:\n                                        curr_reachable = reachable\n                                        jump_count += 1\n                                reachable = max(reachable, i+length)\n                        return jump_count\n                max_range = [0]*(n+1)\n                for i, r in enumerate(ranges):\n                        left, right = max(i-r, 0), min(i+r, n)\n                        max_range[left] = max(max_range[left], right-left)\n                return jump_game(max_range)\ndef jump_game(A):\n                        jump_count, reachable, curr_reachable = 0, 0, 0\n                        for i, length in enumerate(A):\n                                if i > reachable:\n                                        return -1\n                                if i > curr_reachable:\n                                        curr_reachable = reachable\n                                        jump_count += 1\n                                reachable = max(reachable, i+length)\n                        return jump_count", "170": "def findAllConcatenatedWordsInADict(self, words):\n                lookup = set(words)\n                result = []\n                for word in words:\n                        dp = [False] * (len(word)+1)\n                        dp[0] = True\n                        for i in xrange(len(word)):\n                                if not dp[i]:\n                                        continue\n                                for j in xrange(i+1, len(word)+1):\n                                        if j - i < len(word) and word[i:j] in lookup:\n                                                dp[j] = True\n                                if dp[len(word)]:\n                                        result.append(word)\n                                        break\n                return result", "171": "def findPeakElement(self, nums):\n                left, right = 0, len(nums) - 1\n                while left < right:\n                        mid = left + (right - left) / 2\n                        if nums[mid] > nums[mid + 1]:\n                                right = mid\n                        else:\n                                left = mid + 1\n                return left", "172": "def findLadders(self, beginWord, endWord, wordList):\n                dictionary = set(wordList)\n                result, cur, visited, found, trace = [], [beginWord], set([beginWord]), False, defaultdict(list)\n                while cur and not found:\n                        for word in cur:\n                                visited.add(word)\n                        next = set()\n                        for word in cur:\n                                for i in xrange(len(word)):\n                                        for c in ascii_lowercase:\n                                                candidate = word[:i] + c + word[i + 1:]\n                                                if candidate not in visited and candidate in dictionary:\n                                                        if candidate == endWord:\n                                                                found = True\n                                                        next.add(candidate)\n                                                        trace[candidate].append(word)\n                        cur = next\n                if found:\n                        self.backtrack(result, trace, [], endWord)\n                return result\ndef backtrack(self, result, trace, path, word):\n                if not trace[word]:\n                        path.append(word)\n                        result.append(path[::-1])\n                        path.pop()\n                else:\n                        for prev in trace[word]:\n                                path.append(word)\n                                self.backtrack(result, trace, path, prev)\n                                path.pop()", "173": "def lengthLongestPath(self, input):\n                def split_iter(s, tok):\n                        start = 0\n                        for i in xrange(len(s)):\n                                if s[i] == tok:\n                                        yield s[start:i]\n                                        start = i + 1\n                        yield s[start:]\n                max_len = 0\n                path_len = {0: 0}\n                for line in split_iter(input, '\\n'):\n                        name = line.lstrip('\\t')\n                        depth = len(line) - len(name)\n                        if '.' in name:\n                                max_len = max(max_len, path_len[depth] + len(name))\n                        else:\n                                path_len[depth + 1] = path_len[depth] + len(name) + 1\n                return max_len\ndef split_iter(s, tok):\n                        start = 0\n                        for i in xrange(len(s)):\n                                if s[i] == tok:\n                                        yield s[start:i]\n                                        start = i + 1\n                        yield s[start:]", "174": "def largestOverlap(self, A, B):\n                count = [0] * (2*len(A)-1)**2\n                for i, row in enumerate(A):\n                        for j, v in enumerate(row):\n                                if not v:\n                                        continue\n                                for i2, row2 in enumerate(B):\n                                        for j2, v2 in enumerate(row2):\n                                                if not v2:\n                                                        continue\n                                                count[(len(A)-1+i-i2)*(2*len(A)-1) + len(A)-1+j-j2] += 1\n                return max(count)", "175": "def characterReplacement(self, s, k):\n                result, max_count = 0, 0\n                count = collections.Counter()\n                for i in xrange(len(s)):\n                        count[s[i]] += 1\n                        max_count = max(max_count, count[s[i]])\n                        if result - max_count >= k:\n                                count[s[i-result]] -= 1\n                        else:\n                                result += 1\n                return result", "176": "def replaceElements(self, arr):\n                curr_max = -1\n                for i in reversed(xrange(len(arr))):\n                        arr[i], curr_max = curr_max, max(curr_max, arr[i])\n                return arr", "177": "def __init__(self):\n                self.__nodes = set()\n                self.__in_degree = collections.defaultdict(set)\n                self.__out_degree = collections.defaultdict(set)\ndef add_node(self, node):\n                self.__nodes.add(node)\ndef add_edge(self, src, dst):\n                self.add_node(src), self.add_node(dst)\n                self.__in_degree[dst].add(src)\n                self.__out_degree[src].add(dst)\ndef sort(self):\n                q = collections.deque()\n                result = []\n                for node in self.__nodes:\n                        if node not in self.__in_degree:\n                                q.append(node)\n                while q:\n                        node = q.popleft()\n                        result.append(node)\n                        for nei in self.__out_degree[node]:\n                                self.__in_degree[nei].remove(node)\n                                if not self.__in_degree[nei]:\n                                        self.__in_degree.pop(nei)\n                                        q.append(nei)\n                if len(result) < len(self.__nodes):\n                        return\n                return result\ndef sortItems(self, n, m, group, beforeItems):\n                for i in xrange(n):\n                        if group[i] == -1:\n                                group[i] = m\n                                m += 1        \n                global_group = Topo()\n                for i in xrange(m):\n                        global_group.add_node(i)\n                local_groups = collections.defaultdict(Topo)\n                for i in xrange(n):\n                        local_groups[group[i]].add_node(i)\n                for i in xrange(n):\n                        for j in beforeItems[i]:\n                                if group[i] == group[j]:\n                                        local_groups[group[i]].add_edge(j, i)\n                                else:\n                                        global_group.add_edge\n                        if local_order is None:\n                                return []\n                        for x in local_order:\n                                result.append(x)\n                return result", "178": "def mincostToHireWorkers(self, quality, wage, K):\n                result, qsum = float(\"inf\"), 0\n                max_heap = []\n                for r, q in sorted([float(w)/q, q] for w, q in itertools.izip(wage, quality)):\n                        qsum += q\n                        heapq.heappush(max_heap, -q)\n                        if len(max_heap) > K:\n                                qsum -= -heapq.heappop(max_heap)\n                        if len(max_heap) == K:\n                                result = min(result, qsum*r)\n                return result", "179": "def xorOperation(self, n, start):\n                return reduce(operator.xor, (i for i in xrange(start, start+2*n, 2)))", "180": "def minOperations(self, n):\n                return (n//2)*((n+1)//2)", "181": "def uniqueOccurrences(self, arr):\n                count = collections.Counter(arr)\n                return len(count) == len(set(count.itervalues()))", "182": "def numPoints(self, points, r):\n                def count_points(points, r, i):\n                        angles = []\n                        for j in xrange(len(points)):\n                                if i == j:\n                                        continue\n                                dx, dy = points[i][0]-points[j][0], points[i][1]-points[j][1]\n                                d = math.sqrt(dx**2 + dy**2)\n                                if d > 2*r:\n                                        continue\n                                delta, angle = math.acos(d/(2*r)), math.atan2(dy, dx)\n                                angles.append((angle-delta, 0)), angles.append((angle+delta, 1))\n                        angles.sort()\n                        result, count = 1, 1\n                        for _, is_closed in angles: \n                                if not is_closed:\n                                        count += 1\n                                else:\n                                        count -= 1\n                                result = max(result, count)\n                        return result\n                return max(count_points(points, r, i) for i in xrange(len(points)))\ndef count_points(points, r, i):\n                        angles = []\n                        for j in xrange(len(points)):\n                                if i == j:\n                                        continue\n                                dx, dy = points[i][0]-points[j][0], points[i][1]-points[j][1]\n                                d = math.sqrt(dx**2 + dy**2)\n                                if d > 2*r:\n                                        continue\n                                delta, angle = math.acos(d/(2*r)), math.atan2(dy, dx)\n                                angles.append((angle-delta, 0)), angles.append((angle+delta, 1))\n                        angles.sort()\n                        result, count = 1, 1\n                        for _, is_closed in angles: \n                                if not is_closed:\n                                        count += 1\n                                else:\n                                        count -= 1\n                                result = max(result, count)\n                        return result", "183": "def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n                result = 0\n                q = collections.deque(initialBoxes)\n                while q:\n                        changed = False\n                        for _ in xrange(len(q)):\n                                box = q.popleft()\n                                if not status[box]:\n                                        q.append(box)\n                                        continue\n                                changed = True\n                                result += candies[box]\n                                for contained_key in keys[box]:\n                                        status[contained_key] = 1\n                                for contained_box in containedBoxes[box]:\n                                        q.append(contained_box)\n                        if not changed:\n                                break\n                return result", "184": "def solveNQueens(self, n):\n                def dfs(col_per_row, xy_diff, xy_sum):\n                        cur_row = len(col_per_row)\n                        if cur_row == n:\n                                ress.append(col_per_row)\n                        for col in range(n):\n                                if col not in col_per_row and cur_row-col not in xy_diff and cur_row+col not in xy_sum:\n                                        dfs(col_per_row+[col], xy_diff+[cur_row-col], xy_sum+[cur_row+col])\n                ress = []\n                dfs([], [], [])\n                return [['.'*i + 'Q' + '.'*(n-i-1) for i in res] for res in ress]\ndef dfs(col_per_row, xy_diff, xy_sum):\n                        cur_row = len(col_per_row)\n                        if cur_row == n:\n                                ress.append(col_per_row)\n                        for col in range(n):\n                                if col not in col_per_row and cur_row-col not in xy_diff and cur_row+col not in xy_sum:\n                                        dfs(col_per_row+[col], xy_diff+[cur_row-col], xy_sum+[cur_row+col])", "185": "def countBalls(self, lowLimit, highLimit):\n                count = collections.Counter()\n                for i in xrange(lowLimit, highLimit+1):\n                        count[sum(itertools.imap(int, str(i)))] += 1\n                return max(count.itervalues())", "186": "def maxNumOfSubstrings(self, s):\n                def find_right_from_left(s, first, last, left):\n                        right, i = last[ord(s[left])-ord('a')], left\n                        while i <= right:\n                                if first[ord(s[i])-ord('a')] < left:\n                                        return -1\n                                right = max(right, last[ord(s[i])-ord('a')])\n                                i += 1\n                        return right\n                first, last = [float(\"inf\")]*26, [float(\"-inf\")]*26\n                for i, c in enumerate(s):\n                        first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)\n                        last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)\n                intervals = []\n                for c in xrange(len(first)):\n                        if first[c] == float(\"inf\"):\n                                continue\n                        left, right = first[c], find_right_from_left(s, first, last, first[c])\n                        if right != -1:\n                                intervals.append((right, left))\n                intervals.sort() \n                result, prev = [], -1\n                for right, left in intervals:\n                        if left <= prev:\n                                continue\n                        result.append(s[left:right+1])\n                        prev = right\n                return result\ndef find_right_from_left(s, first, last, left):\n                        right, i = last[ord(s[left])-ord('a')], left\n                        while i <= right:\n                                if first[ord(s[i])-ord('a')] < left:\n                                        return -1\n                                right = max(right, last[ord(s[i])-ord('a')])\n                                i += 1\n                        return right", "187": "def maxSlidingWindow(self, nums, k):\n                result, dq = [], deque()\n                for i in xrange(len(nums)):\n                        if dq and i-dq[0] == k:\n                                dq.popleft()\n                        while dq and nums[dq[-1]] <= nums[i]:\n                                dq.pop()\n                        dq.append(i)\n                        if i >= k-1:\n                                result.append(nums[dq[0]])\n                return result", "188": "def numDistinct(self, S, T):\n                ways = [0 for _ in xrange(len(T) + 1)]\n                ways[0] = 1\n                for S_char in S:\n                        for j, T_char in reversed(list(enumerate(T))):\n                                if S_char == T_char:\n                                        ways[j + 1] += ways[j]\n                return ways[len(T)]", "189": "def bestCoordinate(self, towers, radius):\n                min_x = min(towers, key=lambda x:x[0])[0]\n                max_x = max(towers, key=lambda x:x[0])[0]\n                min_y = min(towers, key=lambda x:x[1])[1]\n                max_y = max(towers, key=lambda x:x[1])[1]\n                max_quality = 0\n                for x in xrange(min_x, max_x+1):\n                        for y in xrange(min_y, max_y+1):\n                                q = 0\n                                for nx, ny, nq in towers:\n                                        d = ((nx-x)**2+(ny-y)**2)**0.5\n                                        if d <= radius:\n                                                q += int(nq/(1+d))\n                                if q > max_quality:\n                                        max_quality = q\n                                        result = x, y\n                return result", "190": "def canWinNim(self, n):\n                return n % 4 != 0", "191": "def commonChars(self, A):\n                result = collections.Counter(A[0])\n                for a in A:\n                        result &= collections.Counter(a)\n                return list(result.elements())", "192": "def maxUniqueSplit(self, s):\n                def popcount(n):\n                        count = 0\n                        while n:\n                                n &= n-1\n                                count += 1\n                        return count\n                result = 1\n                total = 2**(len(s)-1)\n                mask = 0\n                while mask < total:\n                        if popcount(mask) < result:\n                                mask += 1\n                                continue\n                        lookup, curr, base = set(), [], total//2\n                        for i in xrange(len(s)):\n                                curr.append(s[i])\n                                if (mask&base) or base == 0:\n                                        if \"\".join(curr) in lookup:\n                                                mask = (mask | (base-1)) + 1 if base else mask+1 \n                                                break\n                                        lookup.add(\"\".join(curr))\n                                        curr = []\n                                base >>= 1\n                        else:\n                                result = max(result, len(lookup))\n                                mask += 1\n                return result\ndef popcount(n):\n                        count = 0\n                        while n:\n                                n &= n-1\n                                count += 1\n                        return count", "193": "def numTrees(self, n):\n                if n == 0:\n                        return 1\n                def combination(n, k):\n                        count = 1\n                        for i in xrange(1, k + 1):\n                                count = count * (n - i + 1) / i\n                        return count\n                return combination(2 * n, n) - combination(2 * n, n - 1)", "194": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef isValidBST(self, root):\n                prev, cur = None, root\n                while cur:\n                        if cur.left is None:\n                                if prev and prev.val >= cur.val:\n                                        return False\n                                prev = cur\n                                cur = cur.right\n                        else:\n                                node = cur.left\n                                while node.right and node.right != cur:\n                                        node = node.right\n                                if node.right is None:\n                                        node.right = cur\n                                        cur = cur.left\n                                else:\n                                        if prev and prev.val >= cur.val:\n                                                return False\n                                        node.right = None\n                                        prev = cur\n                                        cur = cur.right\n                return True", "195": "def __init__(self, persons, times):\n                return self.__lookup[bisect.bisect(self.__lookup, (t, float(\"inf\")))-1][1]", "196": "def shortestPathLength(self, graph):\n                dp = [[float(\"inf\")]*(len(graph)) for _ in xrange(1 << len(graph))]\n                q = collections.deque()\n                for i in xrange(len(graph)):\n                        dp[1 << i][i] = 0\n                        q.append((1 << i, i))\n                while q:\n                        state, node = q.popleft()\n                        steps = dp[state][node]\n                        for nei in graph[node]:\n                                new_state = state | (1 << nei)\n                                if dp[new_state][nei] == float(\"inf\"):\n                                        dp[new_state][nei] = steps+1\n                                        q.append((new_state, nei))\n                return min(dp[-1])", "197": "def validUtf8(self, data):\n                count = 0\n                for c in data:\n                        if count == 0:\n                                if (c >> 5) == 0b110:\n                                        count = 1\n                                elif (c >> 4) == 0b1110:\n                                        count = 2\n                                elif (c >> 3) == 0b11110:\n                                        count = 3\n                                elif (c >> 7):\n                                        return False\n                        else:\n                                if (c >> 6) != 0b10:\n                                        return False\n                                count -= 1\n                return count == 0", "198": "def bitwiseComplement(self, N):\n                mask = 1\n                while N > mask:\n                        mask = mask*2+1\n                return mask-N", "199": "def isSelfCrossing(self, x):\n                if len(x) >= 5 and x[3] == x[1] and x[4] + x[0] >= x[2]:\n                        return True\n                for i in xrange(3, len(x)):\n                        if x[i] >= x[i - 2] and x[i - 3] >= x[i - 1]:\n                                return True\n                        elif i >= 5 and x[i - 4] <= x[i - 2] and x[i] + x[i - 4] >= x[i - 2] and \\\n                                                        x[i - 1] <= x[i - 3] and x[i - 5] + x[i - 1] >= x[i - 3]:\n                                return True\n                return False"}, "Java": {"0": "public int mergeStones(int[] stones, int K) {\n        if ((stones.length-1) % (K-1)) {\n                return -1;\n        }\n        int[] prefix = new int[stones.length+1];\n        for (int x : stones) {\n                prefix[x] = prefix[x-1]+x;\n        }\n        int[][] dp = new int[stones.length][stones.length];\n        for (int l = K-1; l < stones.length; l++) {\n                for (int i = 0; i < stones.length-l; i++) {\n                        dp[i][i+l] = Integer.MAX_VALUE;\n                        for (int j = i; j < i+l; j += K-1) {\n                                dp[i][i+l] = Math.min(dp[i][i+l], dp[i][j]+dp[j+1][i+l]);\n                        }\n                        if (l % (K-1) == 0) {\n                                dp[i][i+l] += prefix[i+l+1] - prefix[i];\n                        }\n                }\n        }\n        return dp[0][stones.length-1];\n}", "1": "public boolean containsPattern(int[] arr, int m, int k) {\n        int cnt = 0;\n        for (int i = 0; i < arr.length - m; i++) {\n                if (arr[i] != arr[i + m]) {\n                        cnt = 0;\n                        continue;\n                }\n                cnt += 1;\n                if (cnt == (k - 1) * m) {\n                        return true;\n                }\n        }\n        return false;\n}", "2": "public String[] findRestaurant(String[] list1, String[] list2) {\n        Map<String, Integer> map = new HashMap<>();\n        List<String> res = new LinkedList<>();\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < list1.length; i++) map.put(list1[i], i);\n        for (int i = 0; i < list2.length && i <= min; i++) {\n                if (map.containsKey(list2[i])) {\n                        if (i + map.get(list2[i]) == min) res.add(list2[i]);\n                        else if (i + map.get(list2[i]) < min) {\n                                res = new ArrayList<>();\n                                res.add(list2[i]);\n                                min = i + map.get(list2[i]);\n                        }\n                }\n        }\n        return res.toArray(new String[res.size()]);\n}", "3": "public class MaxSumMinProduct {\n    public static int maxSumMinProduct(int[] nums) {\n        int MOD = 10^9+7;\n        int[] prefix = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefix[i+1] = prefix[i] + nums[i];\n        }\n        ArrayList<Integer> stk = new ArrayList<Integer>();\n        stk.add(-1);\n        int result = 0;\n        for (int i = 0; i < nums.length+1; i++) {\n            while (stk.get(stk.size()-1) != -1 && (i == nums.length || nums[stk.get(stk.size()-1)] >= nums[i])) {\n                result = Math.max(result, nums[stk.remove(stk.size()-1)] * (prefix[(i-1)+1] - prefix[stk.get(stk.size()-1)+1]));\n            }\n            stk.add(i);\n        }\n        return result%MOD;\n    }\n}", "4": "public class Main {\n    public static final int MOD = 10**9 + 7;\n    public static final int HAT_SIZE = 40;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        List<Integer>[] hats = new List[n];\n        for(int hats_i = 0; hats_i < n; hats_i++){\n            hats[hats_i] = new ArrayList<Integer>();\n            int m = in.nextInt();\n            for(int hats_j = 0; hats_j < m; hats_j++){\n                int h = in.nextInt();\n                hats[hats_i].add(h);\n            }\n        }\n\n        List<Integer> hatToPeople = new ArrayList<Integer>[HAT_SIZE];\n        for(int i = 0; i < n; i++) {\n            for(int h : hats[i]) {\n                hatToPeople[h - 1].add(i);\n            }\n        }\n\n        long[] dp = new long[1 << n];\n        dp[0] = 1;\n        for(List<Integer> people : hatToPeople) {\n            for(int mask = (1 << n) - 1; mask >= 0; mask--) {\n                for(int p : people) {\n                    if((mask & (1 << p)) != 0) {\n                        continue;\n                    }\n                    dp[mask | (1 << p)] += dp[mask];\n                    dp[mask | (1 << p)] %= MOD;\n                }\n            }\n        }\n        System.out.println(dp[(1 << n) - 1]);\n    }\n}", "5": "public int numSubarraysWithSum(int[] A, int S) {\n        int result = 0;\n        int left = 0, right = 0, sumLeft = 0, sumRight = 0;\n        for (int i = 0; i < A.length; i++) {\n                sumLeft += A[i];\n                while (left < i && sumLeft > S) {\n                        sumLeft -= A[left];\n                        left++;\n                }\n                sumRight += A[i];\n                while (right < i && (sumRight > S || (sumRight == S && A[right] == 0))) {\n                        sumRight -= A[right];\n                        right++;\n                }\n                if (sumLeft == S) {\n                        result += right - left + 1;\n                }\n        }\n        return result;\n}", "6": "public List<String> summaryRanges(int[] nums) {\n        List<String> ranges = new ArrayList<String>();\n        if (nums.length == 0) {\n                return ranges;\n        }\n        int start = nums[0];\n        int end = nums[0];\n        for (int i = 1; i <= nums.length; i++) {\n                if (i < nums.length && nums[i] == end + 1) {\n                        end = nums[i];\n                } else {\n                        String interval = String.valueOf(start);\n                        if (start != end) {\n                                interval += \"->\" + String.valueOf(end);\n                        }\n                        ranges.add(interval);\n                        if (i < nums.length) {\n                                start = end = nums[i];\n                        }\n                }\n        }\n        return ranges;\n}", "7": "public int maxHeight(List<List<Integer>> cuboids) {\n        for (List<Integer> cuboid : cuboids) {\n                Collections.sort(cuboid);\n        }\n        cuboids.add(Arrays.asList(0, 0, 0));\n        Collections.sort(cuboids, new Comparator<List<Integer>>() {\n                @Override\n                public int compare(List<Integer> a, List<Integer> b) {\n                        for (int i = 0; i < 3; i++) {\n                                if (!a.get(i).equals(b.get(i))) {\n                                        return a.get(i) - b.get(i);\n                                }\n                        }\n                        return 0;\n                }\n        });\n        int[] dp = new int[cuboids.size()];\n        for (int i = 1; i < cuboids.size(); i++) {\n                for (int j = 0; j < i; j++) {\n                        if (isValid(cuboids.get(j), cuboids.get(i))) {\n                                dp[i] = Math.max(dp[i], dp[j] + cuboids.get(i).get(2));\n                        }\n                }\n        }\n        return Arrays.stream(dp).max().getAsInt();\n}\n\nprivate boolean isValid(List<Integer> a, List<Integer> b) {\n        for (int i = 0; i < 3; i++) {\n                if (a.get(i) > b.get(i)) {\n                        return false;\n                }\n        }\n        return true;\n}", "8": "public int[] sortedSquares(int[] A) {\n        int right = bisect.bisect_left(A, 0);\n        int left = right-1;\n        int[] result = new int[A.length];\n        while (0 <= left || right < A.length) {\n                if (right == A.length || (0 <= left && A[left] * A[left] < A[right] * A[right])) {\n                        result[left] = A[left] * A[left];\n                        left -= 1;\n                } else {\n                        result[right] = A[right] * A[right];\n                        right += 1;\n                }\n        }\n        return result;\n}", "9": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) return root;\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q); \n        return root == null ? root : (left != null && right != null ? root : (left != null ? left : right));\n}", "10": "public class Solution {\n    public String findReplaceString(String S, int[] indexes, String[] sources, String[] targets) {\n        for (int i = indexes.length - 1; i >= 0; i--) {\n            int j = indexes[i];\n            if (S.substring(j, j + sources[i].length()).equals(sources[i])) {\n                S = S.substring(0, j) + targets[i] + S.substring(j + sources[i].length());\n            }\n        }\n        return S;\n    }\n}", "11": "public class Main {\n    public static int calculate(String s) {\n        Map<Character, Integer> precedence = new HashMap<Character, Integer>(){\n            {\n                put('+', 0);\n                put('-', 0);\n                put('*', 1);\n                put('/', 1);\n            }\n        };\n\n        Map<String, BiFunction<Integer, Integer, Integer>> ops = new HashMap<String, BiFunction<Integer, Integer, Integer>>(){\n            {\n                put(\"+\", (a, b) -> a + b);\n                put(\"-\", (a, b) -> a - b);\n                put(\"*\", (a, b) -> a * b);\n                put(\"/\", (a, b) -> a / b);\n            }\n        };\n\n        List<Integer> operands = new ArrayList<Integer>();\n        List<Character> operators = new ArrayList<Character>();\n        int operand = 0;\n\n        for(int i = 0; i < s.length(); i++) {\n            if(Character.isDigit(s.charAt(i))) {\n                operand = operand * 10 + Character.getNumericValue(s.charAt(i));\n                if(i == s.length() - 1 || !Character.isDigit(s.charAt(i + 1))) {\n                    operands.add(operand);\n                    operand = 0;\n                }\n            } else if(s.charAt(i) == '(') {\n                operators.add(s.charAt(i));\n            } else if(s.charAt(i) == ')') {\n                while(operators.get(operators.size() - 1) != '(') {\n                    compute(operands, operators);\n                }\n                operators.remove(operators.size() - 1);\n            } else if(precedence.containsKey(s.charAt(i))) {\n                while(!operators.isEmpty() && precedence.containsKey(operators.get(operators.size() - 1)) &&\n                        precedence.get(operators.get(operators.size() - 1)) >= precedence.get(s.charAt(i))) {\n                    compute(operands, operators);\n                }\n                operators.add(s.charAt(i));\n            }\n        }\n\n        while(!operators.isEmpty()) {\n            compute(operands, operators);\n        }\n\n        return operands.get(operands.size() - 1);\n    }\n\n    public static void compute(List<Integer> operands, List<Character> operators) {\n        int right = operands.remove(operands.size() - 1);\n        int left = operands.remove(operands.size() - 1);\n        operands.add(ops.get(Character.toString(operators.remove(operators.size() - 1))).apply(left, right));\n    }\n\n    public static void main(String[] args) {\n        String s = \"2*3+5/6*3+15\";\n        System.out.println(calculate(s));\n    }\n}", "12": "public int sumOfLeftLeaves(TreeNode root) {\n        return sumOfLeftLeavesHelper(root, false);\n}\n\npublic int sumOfLeftLeavesHelper(TreeNode root, boolean isLeft) {\n        if (root == null) {\n                return 0;\n        }\n        if (root.left == null && root.right == null) {\n                return root.val * (isLeft ? 1 : 0);\n        }\n        return sumOfLeftLeavesHelper(root.left, true) + sumOfLeftLeavesHelper(root.right, false);", "13": "public int stoneGameVI(int[] aliceValues, int[] bobValues) {\n  int[][] sorted_vals = new int[aliceValues.length][2];\n  for (int i = 0; i < aliceValues.length; i++) {\n    sorted_vals[i][0] = aliceValues[i];\n    sorted_vals[i][1] = bobValues[i];\n  }\n  Arrays.sort(sorted_vals, new Comparator<int[]>() {\n    public int compare(int[] a, int[] b) {\n      return Integer.compare(a[0] + a[1], b[0] + b[1]);\n    }\n  });\n\n  int alice_score = 0;\n  int bob_score = 0;\n  for (int i = 0; i < sorted_vals.length; i++) {\n    if (i % 2 == 0) {\n      alice_score += sorted_vals[i][0];\n    } else {\n      bob_score += sorted_vals[i][1];\n    }\n  }\n  return Integer.compare(alice_score, bob_score);\n}", "14": "public int minDeletionSize(String[] A) {\n        int result = 0;\n        boolean[] is_sorted = new boolean[A.length - 1];\n        for (int j = 0; j < A[0].length(); j++) {\n                boolean[] tmp = is_sorted.clone();\n                for (int i = 0; i < A.length - 1; i++) {\n                        if (A[i][j] > A[i + 1][j] && tmp[i] == false) {\n                                result += 1;\n                                break;\n                        }\n                        if (A[i][j] < A[i + 1][j]) {\n                                tmp[i] = true;\n                        }\n                } else {\n                        is_sorted = tmp;\n                }\n        }\n        return result;\n}", "15": "public static int stoneGameV(int[] stoneValue) {\n                int n = stoneValue.length;\n                int[] prefix = new int[n + 1];\n                for (int v : stoneValue) {\n                        prefix[+] = prefix[-1] + v;\n                }\n                int[][] mid = new int[n][n];\n                for (int l = 1; l <= n; ++l) {\n                        for (int i = 0; i <= n - l; ++i) {\n                                int j = i + l - 1;\n                                int p = i if (l == 1) else mid[i][j-1];\n                                while (prefix[p]-prefix[i] < prefix[j+1]-prefix[p]) {\n                                        p++; \n                                }\n                                mid[i][j] = p;\n                        }\n                }\n                int[][] rmq = new int[n][n];\n                for (int i = 0; i < n; ++i) {\n                        rmq[i][i] = stoneValue[i];\n                }\n                int[][] dp = new int[n][n];\n                for (int l = 2; l <= n; ++l) {\n                        for (int i = 0; i <= n - l; ++i) {\n                                int j = i + l - 1;\n                                int p = mid[i][j];\n                                int max_score = 0;\n                                if (prefix[p]-prefix[i] == prefix[j+1]-prefix[p]) {\n                                        max_score = Math.max(rmq[i][p-1], rmq[j][p]);\n                                } else {\n                                        if (i <= p-2) {\n                                                max_score = Math.max(max_score, rmq[i][p-2]);\n                                        }\n                                        if (p <= j) {\n                                                max_score = Math.max(max_score, rmq[j][p]);\n                                        }\n                                }\n                                dp[i][j] = max_score;\n                                rmq[i][j] = Math.max(rmq[i][j-1], (prefix[j+1]-prefix[i]) + max_score);\n                                rmq[j][i] = Math.max(rmq[j][i+1], (prefix[j+1]-prefix[i]) + max_score);\n                        }\n                }\n                return dp[0][n-1];\n        }", "16": "public int numEquivDominoPairs(int[][] dominoes) {\n                Counter counter = new Counter((min(x), max(x)) for x in dominoes)\n                return sum(v*(v-1)//2 for v in counter.values())\n}", "17": "public class Main {\n\npublic static boolean checkPowersOfThree(int n) {\n        while (n > 0) {\n                if (n%3 == 2) {\n                        return false;\n                }\n                n /= 3;\n        }\n        return true;\n}\n\n}", "18": "public boolean rotateString(String A, String B) {\n        return A.length() == B.length() && (B + B).indexOf(A) != -1;\n    }", "19": "public boolean checkInclusion(String s1, String s2) {\n        Map<Character, Integer> counts = new HashMap<>();\n        for (char c : s1.toCharArray()) {\n                counts.put(c, counts.getOrDefault(c, 0) + 1);\n        }\n        int l = s1.length();\n        for (int i = 0; i < s2.length(); i++) {\n                if (counts.getOrDefault(s2.charAt(i), 0) > 0) {\n                        l--;\n                }\n                counts.put(s2.charAt(i), counts.getOrDefault(s2.charAt(i), 0) - 1);\n                if (l == 0) {\n                        return true;\n                }\n                int start = i + 1 - s1.length();\n                if (start >= 0) {\n                        counts.put(s2.charAt(start), counts.getOrDefault(s2.charAt(start), 0) + 1);\n                        if (counts.getOrDefault(s2.charAt(start), 0) > 0) {\n                                l++;\n                        }\n                }\n        }\n        return false;\n}", "20": "public class snakesAndLadders {\n    public int snakesAndLadders(int[][] board) {\n        int n = board.length;\n        Map<Integer, Integer> lookup = new HashMap<>();\n        lookup.put(1, 0);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(1);\n        while (!q.isEmpty()) {\n            int s = q.poll();\n            if (s == n * n)\n                return lookup.get(s);\n            for (int s2 = s + 1; s2 <= Math.min(s + 6, n * n); s2++) {\n                int[] rc = coordinate(n, s2);\n                int r = rc[0], c = rc[1];\n                if (board[r][c] != -1)\n                    s2 = board[r][c];\n                if (!lookup.containsKey(s2)) {\n                    lookup.put(s2, lookup.get(s) + 1);\n                    q.add(s2);\n                }\n            }\n        }\n        return -1;\n    }\n}", "21": "public class Solution {\n    public int findMin(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right && nums[left] >= nums[right]) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < nums[left]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return nums[left];\n    }\n}", "22": "public int maximumPopulation(List<int[]> logs) {\n        int MIN_YEAR = 1950;\n        int MAX_YEAR = 2050;\n        int[] years = new int[MAX_YEAR-MIN_YEAR+1];\n        for (int[] log : logs) {\n                years[log[0]-MIN_YEAR] += 1;\n                years[log[1]-MIN_YEAR] -= 1;\n        }\n        int result = 0;\n        for (int i = 0; i < years.length; i++) {\n                if (i > 0) {\n                        years[i] += years[i-1];\n                }\n                if (years[i] > years[result]) {\n                        result = i;\n                }\n        }\n        return result+MIN_YEAR;\n}", "23": "public ArrayList<String> letterCasePermutation(String S) {\n        ArrayList<String> result = new ArrayList<String>();\n        result.add(\"\");\n        for(char c : S.toCharArray()){\n                if(Character.isLetter(c)){\n                        int n = result.size();\n                        for(int i = 0; i < n; i++){\n                                result.add(result.get(i));\n                                result.get(i).append(Character.toLowerCase(c));\n                                result.get(n).append(Character.toUpperCase(c));\n                        }\n                }else{\n                        for(String s : result){\n                                s.append(c);\n                        }\n                }\n        }\n        return result;\n}", "24": "public boolean[] prefixesDivBy5(int[] A) {\n        for (int i = 1; i < A.length; i++) {\n                A[i] += A[i-1] * 2 % 5;\n        }\n        boolean[] ans = new boolean[A.length];\n        for (int i = 0; i < A.length; i++) {\n                ans[i] = (A[i] % 5 == 0);\n        }\n        return ans;\n}", "25": "public static boolean check(int[] bloomDay, int m, int k, int x){\n        int result = 0;\n        int count = 0;\n        for(int d : bloomDay){\n                count = count + 1 if d <= x else 0;\n                if(count == k){\n                        count = 0;\n                        result += 1;\n                        if(result == m){\n                                break;\n                        }\n                }\n        }\n        return result >= m;\n}\n\npublic static int minDays(int[] bloomDay, int m, int k){\n        if(m * k > bloomDay.length){\n                return -1;\n        }\n        int left = 1;\n        int right = 0;\n        for(int day : bloomDay){\n                right = Math.max(right, day);\n        }\n        while(left <= right){\n                int mid = left + (right - left) / 2;\n                if(check(bloomDay, m, k, mid)){\n                        right = mid - 1;\n                }\n                else{\n                        left = mid + 1;\n                }\n        }\n        return left;\n}", "26": "public class H2O {\n    private int nH;\n    private int nO;\n    private Condition cv;\n \n    public H2O() {\n        nH = 0;\n        nO = 0;\n        cv = new Condition();\n    }\n \n    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {\n        cv.lock();\n        try {\n            while (2 * (nO + 1) - nH > 2)\n                cv.await();\n            nH++;\n            releaseOxygen.run();\n            cv.signalAll();\n        } finally {\n            cv.unlock();\n        }\n    }\n \n    public void oxygen(Runnable releaseOxygen) throws InterruptedException {\n        cv.lock();\n        try {\n            while (2 * (nO + 1) - nH > 2)\n                cv.await();\n            nO++;\n            releaseOxygen.run();\n            cv.signalAll();\n        } finally {\n            cv.unlock();\n        }\n    }\n}", "27": "public static int[] getMaximumXor(int[] nums, int maximumBit) {\n                int[] result = new int[nums.length];\n                int mask = 2^maximumBit-1;\n                for (int i = 0; i < nums.length; i++) {\n                        mask ^= nums[i];\n                        result[nums.length-1-i] = mask;\n                }\n                return result;\n}", "28": "public static int numOfSubarrays(int[] arr) {\n        int MOD = 10^9+7;\n        int result = 0;\n        int accu = 0;\n        int[] dp = {1, 0};\n        for (int x : arr) {\n                accu ^= x&1;\n                dp[accu] += 1;\n                result = (result + dp[accu^1]) % MOD;\n        }\n        return result;\n}", "29": "public static int numMagicSquaresInside(int[][] grid) {\n                int k = 3;\n                int result = 0;\n                for (int r = 0; r <= len(grid)-k+1; r++) {\n                        for (int c = 0; c <= len(grid[r])-k+1; c++) {\n                                if (magic(grid, r, c)) {\n                                        result += 1;\n                                }\n                        }\n                }\n                return result;\n        }", "30": "public static int[] getStrongest(int[] arr, int k) {\n                int n = arr.length;\n                Arrays.sort(arr);\n                int m = arr[(n - 1) / 2];\n                Arrays.sort(arr, new Comparator<Integer>() {\n                        @Override\n                        public int compare(Integer a, Integer b) {\n                                int diff1 = Math.abs(a - m);\n                                int diff2 = Math.abs(b - m);\n                                if (diff1 != diff2)\n                                        return Integer.compare(diff2, diff1);\n                                else\n                                        return Integer.compare(b, a);\n                        }\n                });\n                return Arrays.copyOfRange(arr, 0, k);\n        }", "31": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic List<Integer> rightSideView(TreeNode root) {\n        List<Integer> result = new ArrayList<Integer>();\n        rightSideViewDFS(root, 1, result);\n        return result;\n}\n\npublic void rightSideViewDFS(TreeNode node, int depth, List<Integer> result) {\n        if (node == null) {\n                return;\n        }\n        if (depth > result.size()) {\n                result.add(node.val);\n        }\n        rightSideViewDFS(node.right, depth + 1, result);\n        rightSideViewDFS(node.left, depth + 1, result);\n}", "32": "public int strStr(String haystack, String needle) {\n        for (int i = 0; i < haystack.length() - needle.length() + 1; i++) {\n            if (haystack.substring(i, i + needle.length()).equals(needle)) {\n                return i;\n            }\n        }\n        return -1;\n    }", "33": "public static int furthestBuilding (int[] heights, int bricks, int ladders) {\n        PriorityQueue<Integer> min_heap = new PriorityQueue<Integer>();\n        for (int i = 0; i < heights.length-1; i++) {\n                int diff = heights[i+1]-heights[i];\n                if (diff > 0) {\n                        min_heap.add(diff);\n                }\n                if (min_heap.size() <= ladders) {\n                        continue;\n                }\n                bricks -= min_heap.remove(); \n                if (bricks < 0) {\n                        return i;\n                }\n        }\n        return heights.length-1;\n}", "34": "public class RemoveOccurences { \n  \n    public static void main(String[] args) \n    { \n        String text = \"this is the text\"; \n  \n        String part = \"the\"; \n  \n        System.out.println(removeOccurences(text, part)); \n    } \n  \n    public static String removeOccurences(String text, String part) \n    { \n        StringBuilder sb = new StringBuilder(); \n  \n        int[] prefix = getPrefix(part); \n        int j = 0; \n  \n        for (int i = 0; i < text.length(); i++) { \n            while (j > 0 && part.charAt(j) != text.charAt(i)) { \n                j = prefix[j - 1]; \n            } \n\n            if (part.charAt(j) == text.charAt(i)) { \n                j++; \n            } \n  \n            if (j == part.length()) { \n                j = prefix[j - 1]; \n            } else { \n                sb.append(text.charAt(i)); \n            } \n        } \n        return sb.toString(); \n    } \n}", "35": "public int minFlips(String s) {\n        int result = Integer.MAX_VALUE;\n        int cnt1 = cnt2 = 0;\n        for (int i = 0; i < ((2 * s.length()) - 1) && (s.length() % 2 == 0); i++) {\n                if (i >= s.length()) {\n                        cnt1 -= Integer.parseInt(s.charAt(i % s.length())) ^ ((i - s.length()) % 2) ^ 0;\n                        cnt2 -= Integer.parseInt(s.charAt(i % s.length())) ^ ((i - s.length()) % 2) ^ 1;\n                }\n                cnt1 += Integer.parseInt(s.charAt(i % s.length())) ^ (i % 2) ^ 0;\n                cnt2 += Integer.parseInt(s.charAt(i % s.length())) ^ (i % 2) ^ 1;\n                if (i >= s.length() - 1) {\n                        result = Math.min(result, cnt1, cnt2);\n                }\n        }\n        return result;\n}", "36": "public List<int[]> reconstructQueue(int[][] people) {\n        Arrays.sort(people, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return o1[0]!=o2[0]?-o1[0]+o2[0]:o1[1]-o2[1];\n            }\n        });\n        List<int[]> ans=new ArrayList<>();\n        for(int[] cur:people){\n            ans.add(cur[1],cur);\n        }\n        return ans;\n}", "37": "public boolean buddyStrings(String A, String B) {\n        if (A.length() != B.length())\n                return false;\n        List<Character> diff = new ArrayList<>();\n        for (int i = 0; i < A.length(); i++) {\n                if (A.charAt(i) != B.charAt(i))\n                        diff.add(A.charAt(i));\n                        diff.add(B.charAt(i));\n                        if (diff.size() > 4)\n                                return false;\n        }\n        return (diff.isEmpty() && A.length() > new HashSet<Character>(A).size()) ||\n                (diff.size() == 4 && diff.get(0) == diff.get(3) && diff.get(1) == diff.get(2));\n}", "38": "public static void minimumTimeRequired(int[] jobs, int k){\n                int[] result = new int[1];\n                result[0] = sum(jobs);\n                backtracking(jobs, 0, new int[k], result);\n                return result[0];\n}\n\n\npublic static void backtracking(int[] jobs, int i, int[] counts, int[] result){\n                        if (i == jobs.length){\n                                result[0] = min(result[0], max(counts));\n                                return;\n                        }\n                        for (int j = 0; j < counts.length; j++){\n                                if (counts[j] + jobs[i] <= result[0]){\n                                        counts[j] += jobs[i];\n                                        backtracking(jobs, i+1, counts, result);\n                                        counts[j] -= jobs[i];\n                                }\n                                if (counts[j] == 0){\n                                        break;\n                                }\n                        }\n}", "39": "public boolean hasValidPath(int[][] grid) {\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{0, 0});\n        int m = grid.length, n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        visited[0][0] = true;\n        while (!queue.isEmpty()) {\n                int[] cur = queue.poll();\n                int r = cur[0], c = cur[1];\n                if (r == m - 1 && c == n - 1) {\n                        return true;\n                }\n                for (int i = 0; i < dirs.length; i++) {\n                        int nr = r + dirs[i][0];\n                        int nc = c + dirs[i][1];\n                        if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) {\n                                continue;\n                        }\n                        if (i == 0) {\n                                if (grid[r][c] == 1 || grid[r][c] == 6) {\n                                        queue.add(new int[]{nr, nc});\n                                        visited[nr][nc] = true;\n                                }\n                        } else if (i == 1) {\n                                if (grid[r][c] == 2 || grid[r][c] == 5 || grid[r][c] == 6) {\n                                        queue.add(new int[]{nr, nc});\n                                        visited[nr][nc] = true;\n                                }\n                        } else if (i == 2) {\n                                if (grid[r][c] == 3 || grid[r][c] == 4 || grid[r][c] == 5) {\n                                        queue.add(new int[]{nr, nc});\n                                        visited[nr][nc] = true;\n                                }\n                        } else {\n                                if (grid[r][c] == 3 || grid[r][c] == 4 || grid[r][c] == 6) {\n                                        queue.add(new int[]{nr, nc});\n                                        visited[nr][nc] = true;\n                                }\n                        }\n                }\n        }\n        return false;\n}", "40": "public int numBusesToDestination(int[][] routes, int S, int T) {\n        if (S == T)\n                return 0;\n        Map<Integer, Set<Integer>> toRoute = new HashMap<>();\n\n        for (int i = 0; i < routes.length; i++) {\n                for (int stop : routes[i]) {\n                        toRoute.computeIfAbsent(stop, k -> new HashSet<>()).add(i);\n                }\n        }\n\n        int result = 1;\n        Queue<Integer> q = new LinkedList<>();\n        q.add(S);\n        Set<Integer> lookup = new HashSet<>();\n        lookup.add(S);\n\n        while (!q.isEmpty()) {\n                int size = q.size();\n\n                for (int i = 0; i < size; i++) {\n                        int curr = q.poll();\n\n                        for (int j : toRoute.get(curr)) {\n                                for (int nextStop : routes[j]) {\n                                        if (lookup.contains(nextStop))\n                                                continue;\n                                        if (nextStop == T)\n                                                return result;\n                                        q.add(nextStop);\n                                        toRoute.get(nextStop).remove(j);\n                                        lookup.add(nextStop);\n                                }\n                        }\n                }\n                result++;\n        }\n        return -1;\n}", "41": "public boolean isToeplitzMatrix(int[][] matrix) {\n        for (int row_index = 0; row_index < matrix.length; row_index++) {\n                for (int digit_index = 0; digit_index < matrix[0].length; digit_index++) {\n                        if (row_index == 0 || digit_index == 0) {\n                                continue;\n                        }\n                        if (matrix[row_index - 1][digit_index - 1] != matrix[row_index][digit_index]) {\n                                return false;\n                        }\n                }\n        }\n        return true;\n}", "42": "public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n        Map<Integer, List<int[]>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n                map.put(i, new ArrayList<>());\n        }\n        for (int[] a : flights) {\n                map.get(a[0]).add(new int[] { a[1], a[2] });\n        }\n        Queue<int[]> heap = new PriorityQueue<>(\n                (info1, info2) -> info1[0] - info2[0]);\n\n        heap.add(new int[] { 0, src, K + 1 });\n\n        while (!heap.isEmpty()) {\n                int[] info = heap.poll();\n                int price = info[0], place = info[1], stops = info[2];\n                if (place == dst)\n                        return price;\n                if (stops > 0) {\n                        List<int[]> adj = map.get(place);\n                        for (int[] a : adj) {\n                                heap.add(new int[] { price + a[1], a[0], stops - 1 });\n                        }\n                }\n        }\n        return -1;\n}", "43": "def minChanges(self, nums, k):\n                def one_are_not_from_nums(nums, cnts):\n                        mxs = [cnts[i].most_common(1)[0][1] for i in xrange(k)]\n                        return len(nums) - (sum(mxs)-min(mxs))\n                def all_are_from_nums(nums, cnts):\n                        dp = {0:0}\n                        for cnt in cnts:\n                                new_dp = collections.defaultdict(int)\n                                for x in dp.iterkeys():\n                                        for y in cnt.iterkeys():\n                                                new_dp[x^y] = max(new_dp[x^y], dp[x]+cnt[y])\n                                dp = new_dp\n                        return len(nums)-dp[0]\n                cnts = [collections.Counter(nums[j] for j in xrange(i, len(nums), k)) for i in xrange(k)]\n                return min(one_are_not_from_nums(nums, cnts), all_are_from_nums(nums, cnts))", "44": "public class Main {\n    \n    public static int minCharacters(String a, String b) {\n                int[] count1 = new int[26];\n                int[] count2 = new int[26];\n                \n                for(int i = 0; i < a.length(); i++) {\n                    count1[a.charAt(i) - 'a']++;\n                }\n                for(int j = 0; j < b.length(); j++) {\n                    count2[b.charAt(j) - 'a']++;\n                }\n                int result = a.length() + b.length();\n                for(int k = 0; k < 26; k++) {\n                    result -= Math.max(count1[k], count2[k]);\n                }\n                \n                for(int i = 1; i < 26; i++) {\n                    count1[i] += count1[i-1];\n                    count2[i] += count2[i-1];\n                }\n                \n                for(int i = 0; i < 26; i++) {\n                    result = Math.min(result, a.length() - count1[i] + count2[i]);\n                    result = Math.min(result, b.length() - count2[i] + count1[i]);\n                }\n                return result;\n            }\n\n    \n    \n    public static void main(String[] args) {\n        String a = \"abc\";\n        String b = \"def\";\n        System.out.println(minCharacters(a, b));\n        \n    }\n}", "45": "def reverseOnlyLetters(S):\n                result = []\n                letter = getNext(S)\n                for i in xrange(len(S)):\n                        if S[i].isalpha():\n                                result.append(letter.next())\n                        else:\n                                result.append(S[i])\n                return \"\".join(result)", "46": "public class Solution {\n    public int countDigitOne(int n) {\n        final int DIGIT = 1;\n        int is_zero = DIGIT == 0 ? 1 : 0;\n        int result = is_zero;\n        int base = 1;\n        while (n >= base) {\n            result += (n / (10 * base) - is_zero) * base +\n                      Math.min(base, Math.max(n % (10 * base) - DIGIT * base + 1, 0));\n            base *= 10;\n        }\n        return result;\n    }\n}", "47": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic int minDepth(TreeNode root) {\n        if (root == null) {\n                return 0;\n        }\n        if (root.left != null && root.right != null) {\n                return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n        } else {\n                return Math.max(minDepth(root.left), minDepth(root.right)) + 1;\n        }\n}", "48": "class Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        int i = Arrays.binarySearch(arr, x);\n        if (i < 0) {\n            i = -(i + 1);\n        }\n        int left = i - 1, right = i;\n        while (k-- > 0) {\n            if (right >= arr.length || (left >= 0 && Math.abs(arr[left] - x) <= Math.abs(arr[right] - x))) {\n                left--;\n            } else {\n                right++;\n            }\n        }\n        return Arrays.asList(Arrays.copyOfRange(arr, left + 1, right));\n    }\n}", "49": "public class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        int c = scanner.nextInt();\n\n        System.out.println(nthUglyNumber(n, a, b, c));\n    }\n\n    private static int nthUglyNumber(int n, int a, int b, int c) {\n        int lcm_a_b = lcm(a, b);\n        int lcm_b_c = lcm(b, c);\n        int lcm_c_a = lcm(c, a);\n        int lcm_a_b_c = lcm(lcm_a_b, lcm_b_c);\n\n        int left = 1;\n        int right = 2 * 1000000000;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\n    private static int gcd(int a, int b) {\n        while (b > 0) {\n            a %= b;\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        return a;\n    }\n\n    private static int lcm(int a, int b) {\n        return a * b / gcd(a, b);\n    }\n\n    private static int count(int x, int a, int b, int c, int lcm_a_b, int lcm_b_c, int lcm_c_a, int lcm_a_b_c) {\n        return x / a + x / b + x / c - x / lcm_a_b - x / lcm_b_c - x / lcm_c_a + x / lcm_a_b_c;\n    }\n}", "50": "public int candy(int[] ratings) {\n        int[] candies = new int[ratings.length];\n        Arrays.fill(candies, 1);\n        for (int i = 1; i < ratings.length; i++) {\n                if (ratings[i] > ratings[i - 1]) {\n                        candies[i] = candies[i - 1] + 1;\n                }\n        }\n        for (int i = ratings.length - 2; i >= 0; i--) {\n                if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\n                        candies[i] = candies[i + 1] + 1;\n                }\n        }\n        int sum = 0;\n        for (int candy : candies) {\n                sum += candy;\n        }\n        return sum;\n}", "51": "class UnionFind {\n    private int[] set;\n    private int[] rank;\n    private cb;\n\n    public UnionFind(int n, cb) {\n        set = new int[n];\n        rank = new int[n];\n        this.cb = cb;\n        for (int i = 0; i < n; i++) {\n            set[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int find_set(int x) {\n        Stack<Integer> stk = new Stack<Integer>();\n        while (set[x] != x) {\n            stk.push(x);\n            x = set[x];\n        }\n        while (!stk.empty()) {\n            set[stk.pop()] = x;\n        }\n        return x;\n    }\n\n    public boolean union_set(int x, int y) {\n        int x_root, y_root;\n        x_root = find_set(x);\n        y_root = find_set(y);\n        if (x_root == y_root) {\n            return false;\n        }\n        if (rank[x_root] < rank[y_root]) {\n            set[x_root] = y_root;\n            cb(y_root, x_root, y_root);\n        } else if (rank[x_root] > rank[y_root]) {\n            set[y_root] = x_root;\n            cb(x_root, x_root, y_root);\n        } else {\n            set[y_root] = x_root;\n            rank[x_root] += 1;\n            cb(x_root, x_root, y_root);\n        }\n        return true;\n    }\n}\n\npublic int[][] matrixRankTransform(int[][] matrix) {\n        Map<Integer, List<Integer[]>> lookup = new HashMap<Integer, List<Integer[]>>();\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if (!lookup.containsKey(matrix[i][j])) {\n                    lookup.put(matrix[i][j], new ArrayList<Integer[]>());\n                }\n                lookup.get(matrix[i][j]).add(new Integer[]{i, j});\n            }\n        }\n        int[] rank = new int[matrix.length + matrix[0].length];\n        for (int x : sorted(lookup.keySet())) {\n            int[] new_rank = rank.clone();\n            UnionFind union_find = new UnionFind(matrix.length + matrix[0].length, new cb());\n            for (Integer[] it : lookup.get(x)) {\n                union_find.union_set(it[0], it[1] + matrix.length);\n            }\n            for (Integer[] it : lookup.get(x)) {\n                matrix[it[0]][it[1]] = rank[it[0]] = rank[it[1] + matrix.length] = new_rank[union_find.find_set(it[0])] + 1;\n            }\n        }\n        return matrix;\n    }", "52": "int minDiffInBST(TreeNode* root) {\n        int prev = -1, result = INT_MAX;\n        dfs(root);\n        return result;\n    }", "53": "public static int thirdMax(int[] nums) {\n        int count = 0;\n        int[] top = new int[3];\n        Arrays.fill(top, Integer.MIN_VALUE);\n        for (int num : nums) {\n                if (num > top[0]) {\n                        top[0] = num;\n                        count += 1;\n                } else if (num != top[0] && num > top[1]) {\n                        top[1] = num;\n                        count += 1;\n                } else if (num != top[0] && num != top[1] && num >= top[2]) {\n                        top[2] = num;\n                        count += 1;\n                }\n        }\n        if (count < 3) {\n                return top[0];\n        }\n        return top[2];\n}", "54": "public class Solution {\n    public int subarraySum(int[] nums, int k) {\n        int result = 0;\n        int accumulated_sum = 0;\n        Map<Integer, Integer> lookup = new HashMap<Integer, Integer>();\n        lookup.put(0, 1);\n        for (int num : nums) {\n            accumulated_sum += num;\n            if (lookup.containsKey(accumulated_sum - k)) {\n                result += lookup.get(accumulated_sum - k);\n            }\n            lookup.put(accumulated_sum, lookup.getOrDefault(accumulated_sum, 0) + 1);\n        }\n        return result;\n    }\n}", "55": "public class BinaryTree {\n    public int val;\n    public BinaryTree left;\n    public BinaryTree right;\n    public BinaryTree(int x) {\n        this.val = x;\n        this.left = null;\n        this.right = null;\n    }\n}\n\npublic class TreeIterator {\n    private Stack<BinaryTree> stack;\n    public TreeIterator(BinaryTree root) {\n        this.stack = new Stack<>();\n        this.traversalLeft(root);\n    }\n    public boolean hasNext() {\n        return !stack.isEmpty();\n    }\n    public int next() {\n        BinaryTree node = stack.pop();\n        this.traversalLeft(node.right);\n        return node.val;\n    }\n    private void traversalLeft(BinaryTree node) {\n        while (node != null) {\n            stack.push(node);\n            node = node.left;\n        }\n    }\n}", "56": "public int[] prevPermOpt1(int[] A) {\n        for (int left = A.length - 2; left >= 0; left--) {\n                if (A[left] > A[left+1]) {\n                        break;\n                }\n        }\n        if (left == -1) {\n                return A;\n        }\n        int right = A.length - 1;\n        while (A[left] <= A[right]) {\n                right--;\n        }\n        while (A[right-1] == A[right]) {\n                right--;\n        }\n        int tmp = A[left];\n        A[left] = A[right];\n        A[right] = tmp;\n        return A;\n}", "57": "public class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        int[] counter = new int[26];\n        int max = 0;\n        int maxCount = 0;\n        for(char task : tasks) {\n            counter[task - 'A']++;\n            if(max == counter[task - 'A']) {\n                maxCount++;\n            }\n            else if(max < counter[task - 'A']) {\n                max = counter[task - 'A'];\n                maxCount = 1;\n            }\n        }\n        int partCount = max - 1;\n        int partLength = n - (maxCount - 1);\n        int emptySlots = partCount * partLength;\n        int availableTasks = tasks.length - max * maxCount;\n        int idles = Math.max(0, emptySlots - availableTasks);\n\n        return tasks.length + idles;\n    }\n}", "58": "public static int getMoneyAmount(int n) {\n        int pay[][] = new int[n][n+1];\n        for(int i=n-1; i>=0; i--) {\n                for(int j=i+1; j<n; j++) {\n                        pay[i][j] = Integer.MAX_VALUE;\n                        for(int k=i; k<=j; k++) {\n                                pay[i][j] = Math.min(pay[i][j], k+1+Math.max(pay[i][k-1], pay[k+1][j]));\n                        }\n                }\n        }\n        return pay[0][n-1];\n}", "59": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nListNode swapNodes(ListNode head, int k) {\n                ListNode left, right, curr = null, null, head\n                while curr:\n                        k -= 1\n                        if right:\n                                right = right.next\n                        if k == 0:\n                                left = curr\n                                right = head\n                        curr = curr.next\n                left.val, right.val = right.val, left.val\n                return head\n}", "60": "public static int numDecodings(String s) {\n        if (s.length() == 0 || s[0] == '0') {\n                return 0;\n        }\n        int prev = 1;\n        int prevPrev = 0;\n        for (int i = 0; i < s.length(); i++) {\n                int cur = 0;\n                if (s[i] != '0') {\n                        cur = prev;\n                }\n                if (i > 0 && (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6'))) {\n                        cur += prevPrev;\n                }\n                prevPrev = prev;\n                prev = cur;\n        }\n        return prev;\n}", "61": "public boolean backspaceCompare(String S, String T) {\n        return all(x == y for x, y in\n                                itertools.izip_longest(findNextChar(S), findNextChar(T)))\n}", "62": "public class ListNode {\n        int val;\n        ListNode next;\n        public ListNode(int x) {\n                val = x;\n                next = null;\n        }\n}\n\npublic class Solution {\n        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n                dummy = new ListNode(0);\n                current = dummy;\n                carry = 0;\n                while (l1 != null || l2 != null) {\n                        int val = carry;\n                        if (l1 != null) {\n                                val += l1.val;\n                                l1 = l1.next;\n                        }\n                        if (l2 != null) {\n                                val += l2.val;\n                                l2 = l2.next;\n                        }\n                        carry = val / 10;\n                        val = val % 10;\n                        current.next = new ListNode(val);\n                        current = current.next;\n                }\n                if (carry == 1) {\n                        current.next = new ListNode(1);\n                }\n                return dummy.next;\n        }\n}", "63": "public boolean isSubPath(ListNode head, TreeNode root) {\n        if(head == null) return true;\n        if(root == null) return false;\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\n}", "64": "public int rob(TreeNode root) {\n       int[] res = robHelper(root);\n       return Math.max(res[0], res[1]);\n}\n\npublic int[] robHelper(TreeNode root) {\n       if (root == null) return new int[2];\n       int[] left = robHelper(root.left);\n       int[] right = robHelper(root.right);\n       int[] res = new int[2];\n\n       res[0] = root.val + left[1] + right[1];\n       res[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n\n       return res;\n}", "65": "public static int minOperations(int[] nums) {\n        int result = prev = 0;\n        for (int curr : nums) {\n                if (prev < curr) {\n                        prev = curr;\n                        continue;\n                }\n                prev += 1;\n                result += prev-curr;\n        }\n        return result;\n}", "66": "public static int minimumJumps(int[] forbidden, int a, int b, int x) {\n                int max_f = Arrays.stream(forbidden).max().getAsInt();\n                int max_val = x+b > a ? x+b : max(x, max_f)+a+(b+a);\n                Set<Pair> lookup = new HashSet<>();\n                for (int pos : forbidden) {\n                        lookup.add(new Pair(pos, true));\n                        lookup.add(new Pair(pos, false));\n                }\n                int result = 0;\n                Queue<Pair> q = new LinkedList<>();\n                q.add(new Pair(0, true));\n                lookup.add(new Pair(0, true));\n                while (!q.isEmpty()) {\n                        Queue<Pair> new_q = new LinkedList<>();\n                        for (Pair p : q) {\n                                int pos = p.x;\n                                boolean can_back = p.y;\n                                if (pos == x) {\n                                        return result;\n                                }\n                                if (pos+a <= max_val && !lookup.contains(new Pair(pos+a, true))) {\n                                        lookup.add(new Pair(pos+a, true));\n                                        new_q.add(new Pair(pos+a, true));\n                                }\n                                if (!can_back) {\n                                        continue;\n                                }\n                                if (pos-b >= 0 && !lookup.contains(new Pair(pos-b, false))) {\n                                        lookup.add(new Pair(pos-b, false));\n                                        new_q.add(new Pair(pos-b, false));\n                                }\n                        }\n                        q = new_q;\n                        result += 1;\n                }\n                return -1;\n        }\n\n        private static class Pair {\n                int x;\n                boolean y;\n                Pair(int x, boolean y) {\n                        this.x = x;\n                        this.y = y;\n                }\n                public boolean equals(Object o) {\n                        if (o == null || !(o instanceof Pair)) {\n                                return false;\n                        }\n                        Pair p = (Pair)o;\n                        return p.x == x && p.y == y;\n                }\n                public int hashCode() {\n                        return Objects.hash(x, y);\n                }\n        }", "67": "public static int countPrimeSetBits(int L, int R) {\n        int count = 0;\n        for (int i = L; i <= R; i++)\n            if (isSmallPrime(Integer.bitCount(i)))\n                count++;\n        return count;\n    }\n\n    private static boolean isSmallPrime(int x) {\n        return (x == 2 || x == 3 || x == 5 || x == 7 ||\n                x == 11 || x == 13 || x == 17 || x == 19);\n    }", "68": "public boolean checkIfPangram(String sentence) {\n                return sentence.length() == 26;\n}", "69": "public static int countGoodSubstrings(String s) {\n                int K = 3;\n                int result = 0;\n                HashMap count = new HashMap();\n                for (int i = 0; i < s.length(); i++) {\n                        if (i >= K) {\n                                count[s[i-K]] -= 1;\n                                if (!count[s[i-K]]:\n                                        del count[s[i-K]];\n                        }\n                        count[s[i]] += 1;\n                        if (count.size() == K) {\n                                result += 1;\n                        }\n                }\n                return result;\n        }", "70": "public int firstUniqChar(String s) {\n        Map<Character, Integer> lookup = new HashMap<>();\n        Set<Integer> candidates = new HashSet<>();\n        for (int i = 0; i < s.length(); i++) {\n                if (lookup.containsKey(s.charAt(i))) {\n                        candidates.remove(lookup.get(s.charAt(i)));\n                } else {\n                        lookup.put(s.charAt(i), i + 1);\n                        candidates.add(i + 1);\n                }\n        }\n        return candidates.isEmpty() ? -1 : Collections.min(candidates) - 1;\n}", "71": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\npublic int sumNumbers(TreeNode root) {\n        return sumNumbersRecu(root, 0);\n}\npublic int sumNumbersRecu(TreeNode root, int num) {\n        if (root == null) {\n                return 0;\n        }\n        if (root.left == null && root.right == null) {\n                return num * 10 + root.val;\n        }\n        return sumNumbersRecu(root.left, num * 10 + root.val) + sumNumbersRecu(root.right, num * 10 + root.val);\n}", "72": "public class Solution {\n    public int minimumSwap(String s1, String s2) {\n        int x1 = 0, y1 = 0;\n        for (int i=0; i<s1.length(); i++) {\n            if (s1.charAt(i) == s2.charAt(i)) {\n                continue;\n            }\n            if (s1.charAt(i) == 'x') {\n                x1++;\n            }\n            else {\n                y1++;\n            }\n        }\n        if (x1%2 != y1%2) {\n            return -1;\n        }\n        return (x1/2 + y1/2) + (x1%2 + y1%2);\n    }\n}", "73": "public static int secondHighest(String s) {\n        int first = -1;\n        int second = -1;\n        for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                if (!Character.isDigit(c)) {\n                        continue;\n                }\n                int d = Character.getNumericValue(c);\n                if (d > first) {\n                        first = d;\n                        second = first;\n                }\n                else if (first > d && d > second) {\n                        second = d;\n                }\n        }\n        return second;\n}", "74": "public boolean isTransformable(String s, String t) {\n                List<Integer>[] idxs = new ArrayList[10];\n                for (int i = 0; i < 10; i++) {\n                        idxs[i] = new ArrayList<>();\n                }\n                for (int i = s.length() - 1; i >= 0; i--) {\n                        idxs[s.charAt(i) - '0'].add(i);\n                }\n                for (char c : t.toCharArray()) {\n                        int d = c - '0';\n                        if (idxs[d].isEmpty()) {\n                                return false;\n                        }\n                        for (int k = 0; k < d; k++) {\n                                if (!idxs[k].isEmpty() && idxs[k].get(idxs[k].size() - 1) < idxs[d].get(idxs[d].size() - 1)) {\n                                        return false;\n                                }\n                        }\n                        idxs[d].remove(idxs[d].size() - 1);\n                }\n                return true;\n        }", "75": "public class Main {\n\n    public static void main(String[] args) {\n\n        System.out.println(toGoatLatin(\"I speak Goat Latin\"));\n\n    }\n\n    public static String toGoatLatin(String S) {\n        StringBuilder res = new StringBuilder();\n        String[] words = S.split(\" \");\n        for (int i = 0; i < words.length; i++) {\n            StringBuilder cur = new StringBuilder();\n            cur.append(words[i]);\n            char firstChar = cur.charAt(0);\n            if (firstChar == 'a' || firstChar == 'e' || firstChar == 'i' || firstChar == 'o' || firstChar == 'u'\n                    || firstChar == 'A' || firstChar == 'E' || firstChar == 'I' || firstChar == 'O' || firstChar == 'U') {\n                cur.append(\"ma\");\n            } else {\n                cur.append(cur.charAt(0)).append(\"ma\").deleteCharAt(0);\n            }\n            for (int j = 0; j <= i; j++) {\n                cur.append(\"a\");\n            }\n            res.append(cur.toString()).append(\" \");\n        }\n        return res.toString().trim();\n    }\n}", "76": "public double myPow(double x, int n) {\n        if (n < 0 && n != -n) {\n                return 1.0 / myPow(x, -n);\n        }\n        if (n == 0) {\n                return 1;\n        }\n        double v = myPow(x, n / 2);\n        if (n % 2 == 0) {\n                return v * v;\n        } else {\n                return v * v * x;\n        }\n}", "77": "public class Solution {\n    public int numEnclaves(int[][] A) {\n        int[][] directions = new int[][]{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n        for (int i = 0; i < A.length; i++) {\n            dfs(A, i, 0);\n            dfs(A, i, A[0].length - 1);\n        }\n        for (int j = 1; j < A[0].length - 1; j++) {\n            dfs(A, 0, j);\n            dfs(A, A.length - 1, j);\n        }\n        int ans = 0;\n        for (int i = 0; i < A.length; ++i) {\n            for (int j = 0; j < A[0].length; ++j) {\n                if (A[i][j] == 1) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}", "78": "public static int numberOfRounds(String startTime, String finishTime) {\n                String[] h1 = startTime.split(\":\");\n                String[] h2 = finishTime.split(\":\");\n                int m1 = Integer.parseInt(h1[1]);\n                int m2 = Integer.parseInt(h2[1]);\n                if (m1 > m2) {\n                        int h2i = Integer.parseInt(h2[0]);\n                        h2i -= 1;\n                        h2[0] = Integer.toString(h2i);\n                        m2 += 60;\n                }\n                int h1i = Integer.parseInt(h1[0]);\n                int h2i = Integer.parseInt(h2[0]);\n                return Math.max(((h2i-h1i)%24)*4 + m2/15 - (m1+15-1)/15, 0);\n}", "79": "public static int[] getOrder(int[][] tasks) {\n                int[] idx = new int[tasks.length];\n                for (int i = 0; i < idx.length; i++) {\n                        idx[i] = i;\n                }\n                Arrays.sort(idx, new Comparator<Integer>() {\n                        @Override\n                        public int compare(Integer o1, Integer o2) {\n                                return tasks[o1][0] - tasks[o2][0];\n                        }\n                });\n                List<Integer> result = new ArrayList<>();\n                PriorityQueue<int[]> min_heap = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\n                int i = 0, time = tasks[idx[0]][0];\n                while (i < idx.length || !min_heap.isEmpty()) {\n                        while (i < idx.length && tasks[idx[i]][0] <= time) {\n                                min_heap.add(new int[] {tasks[idx[i]][1], idx[i]});\n                                i++;\n                        }\n                        if (min_heap.isEmpty()) {\n                                time = tasks[idx[i]][0];\n                                continue;\n                        }\n                        int[] t = min_heap.poll();\n                        time += t[0];\n                        result.add(t[1]);\n                }\n                return result.stream().mapToInt(k->k).toArray();\n        }", "80": "public int maximumUniqueSubarray(int[] nums) {\n        Map<Integer, Integer> lookup = new HashMap<>();\n        int[] prefix = new int[nums.length + 1];\n        int result = 0, left = 0;\n        for (int right = 0; right < nums.length; right++) {\n                prefix[right + 1] = prefix[right] + nums[right];\n                if (lookup.containsKey(nums[right])) {\n                        left = Math.max(left, lookup.get(nums[right]) + 1);\n                }\n                lookup.put(nums[right], right);\n                result = Math.max(result, prefix[right + 1] - prefix[left]);\n        }\n        return result;\n}", "81": "public int deleteAndEarn(int[] nums) {\n        int[] vals = new int[10001];\n        for (int num : nums) {\n                vals[num] += num;\n        }\n        int val_i = vals[0], val_i_1 = 0;\n        for (int i = 1; i < vals.length; i++) {\n                int val_i_2 = val_i_1;\n                val_i_1 = val_i;\n                val_i = Math.max(vals[i] + val_i_2, val_i_1);\n        }\n        return val_i;\n}", "82": "public class btreeGameWinningMove {\n  public static boolean btreeGameWinningMove(TreeNode root, int n, int x) {\n    int[] left_right = new int[2];\n    count(root, x, left_right);\n    int blue = Math.max(Math.max(left_right[0], left_right[1]), n-(left_right[0]+left_right[1]+1));\n    return blue > n-blue;\n  }\n  public static int count(TreeNode node, int x, int[] left_right) {\n    if (node == null) {\n      return 0;\n    }\n    int left = count(node.left, x, left_right);\n    int right = count(node.right, x, left_right);\n    if (node.val == x) {\n      left_right[0] = left;\n      left_right[1] = right;\n    }\n    return left + right + 1;\n  }\n}", "83": "public int maxProductDifference(int[] nums) {\n                int[] largest = new int[2];\n                int[] smallest = new int[2];\n                Arrays.fill(smallest, Integer.MAX_VALUE);\n                for (int x : nums) {\n                        if (x >= largest[0]) {\n                                largest[1] = largest[0];\n                                largest[0] = x;\n                        } else if (x > largest[1]) {\n                                largest[1] = x;\n                        }\n                        if (x <= smallest[0]) {\n                                smallest[1] = smallest[0];\n                                smallest[0] = x;\n                        } else if (x < smallest[1]) {\n                                smallest[1] = x;\n                        }\n                }\n                return largest[0]*largest[1] - smallest[0]*smallest[1];\n}", "84": "public int repeatedNTimes(int[] A) {\n        for (int i = 2; i < A.length; i++) {\n                if (A[i-1] == A[i] || A[i-2] == A[i]) {\n                        return A[i];\n                }\n        }\n        return A[0];\n}", "85": "public static int kthSmallest(TreeNode root, int k) {\n        Stack<TreeNode> s = new Stack<>();\n        TreeNode cur = root;\n        int rank = 0;\n        while (s.size() != 0 || cur != null) {\n                if (cur != null) {\n                        s.add(cur);\n                        cur = cur.left;\n                } else {\n                        cur = s.pop();\n                        rank += 1;\n                        if (rank == k) {\n                                return cur.val;\n                        }\n                        cur = cur.right;\n                }\n        }\n        return Integer.MIN_VALUE;\n}", "86": "public class Solution {\n    public int maxLevelSum(TreeNode root) {\n        int result = 0, level = 1;\n        double maxTotal = Double.NEGATIVE_INFINITY;\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            int total = 0;\n            for (int i = 0; i < q.size(); i++) {\n                TreeNode node = q.poll();\n                total += node.val;\n                if (node.left != null) {\n                    q.add(node.left);\n                }\n                if (node.right != null) {\n                    q.add(node.right);\n                }\n            }\n            if (total > maxTotal) {\n                result = level;\n                maxTotal = total;\n            }\n            level++;\n        }\n        return result;\n    }\n}", "87": "def divisorGame(self, N):\n                def memoization(N, dp):\n                        if N == 1:\n                                return False\n                        if N not in dp:\n                                result = False\n                                for i in xrange(1, N+1):\n                                        if i*i > N:\n                                                break\n                                        if N % i == 0:\n                                                if not memoization(N-i, dp):\n                                                        result = True\n                                                        break\n                                dp[N] = result\n                        return dp[N]\n                return memoization(N, {})", "88": "def countSubIslands(grid1, grid2):\n                directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n                def dfs(grid1, grid2, i, j):\n                        if not (0 <= i < len(grid2) and\n                                        0 <= j < len(grid2[0]) and grid2[i][j] == 1):\n                                return 1\n                        grid2[i][j] = 0\n                        result = grid1[i][j]\n                        for di, dj in directions:\n                                result &= dfs(grid1, grid2, i+di, j+dj)\n                        return result\n                return sum(dfs(grid1, grid2, i, j) for i in xrange(len(grid2)) for j in xrange(len(grid2[0])) if grid2[i][j])", "89": "public int balancedString(String s) {\n        int count = 0;\n        int result = s.length();\n        int left = 0;\n        for (int right = 0; right < s.length(); right++) {\n                count = count - (int) s.charAt(right);\n                while (left < s.length() &&\n                        all(v <= s.length()//4 for v in count.itervalues())) {\n                        result = min(result, right-left+1);\n                        count = count + (int) s.charAt(left);\n                        left = left + 1;\n                }\n        }\n        return result;\n}", "90": "public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(nums);\n        boolean[] used = new boolean[nums.length];\n        dfs(result, new ArrayList<>(), nums, used);\n        return result;\n}\n\npublic void dfs(List<List<Integer>> result, List<Integer> curList, int[] nums, boolean[] used) {\n        if (curList.size() == nums.length) {\n                result.add(new ArrayList<>(curList));\n                return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n                if (used[i] || (i > 0 && nums[i - 1] == nums[i] && !used[i - 1])) {\n                        continue;\n                }\n                used[i] = true;\n                curList.add(nums[i]);\n                dfs(result, curList, nums, used);\n                curList.remove(curList.size() - 1);\n                used[i] = false;\n        }\n}", "91": "public int maxDepth(String s) {\n        int result = 0;\n        int curr = 0;\n        for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n                        curr++;\n                        result = Math.max(result, curr);\n                }\n                else if (s.charAt(i) == ')') {\n                        curr--;\n                }\n        }\n        return result;\n}", "92": "class Node {\n        Node left;\n        Node right;\n        int val;\n        Node(int x) {\n                this.val = x;\n                this.left = null;\n                this.right = null;\n}\nNode increasingBST(Node root) {\n                return increasingBSTHelper(root, null);\n}\nNode increasingBSTHelper(Node root, Node tail) {\n                        if (root == null) {\n                                return tail;\n                        }\n                        Node result = increasingBSTHelper(root.left, root);\n                        root.left = null;\n                        root.right = increasingBSTHelper(root.right, tail);\n                        return result;\n                }", "93": "public class Solution {\n    public int maxDotProduct(int[] nums1, int[] nums2) {\n                if (nums1.length < nums2.length) {\n                        return maxDotProduct(nums2, nums1);\n                }\n                int[][] dp = new int[2][nums2.length];\n                for (int i = 0; i < nums1.length; i++) {\n                        for (int j = 0; j < nums2.length; j++) {\n                                dp[i%2][j] = nums1[i]*nums2[j];\n                                if (i > 0 && j > 0) {\n                                        dp[i%2][j] += Math.max(dp[(i-1)%2][j-1], 0);\n                                }\n                                if (i > 0) {\n                                        dp[i%2][j] = Math.max(dp[i%2][j], dp[(i-1)%2][j]);\n                                }\n                                if (j > 0) {\n                                        dp[i%2][j] = Math.max(dp[i%2][j], dp[i%2][j-1]);\n                                }\n                        }\n                }\n                return dp[(nums1.length-1)%2][nums2.length-1];\n    }\n}", "94": "public class Main {\n    public static void main(String[] args) {\n        char[] ring = {'g', 'd', 'q', 'c', 'i', 'n', 't', 'y', 'e', 'w', 'k'};\n        char[] key = {'n', 'y', 't', 'g', 'i'};\n        System.out.println(findRotateSteps(ring, key));\n    }\n    \n    public static int findRotateSteps(char[] ring, char[] key) {\n                Map<Character, List<Integer>> lookup = new HashMap<>();\n                for (int i = 0; i < ring.length; i++) {\n                        if (!lookup.containsKey(ring[i])) {\n                                lookup.put(ring[i], new ArrayList<>());\n                        }\n                        lookup.get(ring[i]).add(i);\n                }\n                int[][] dp = new int[2][ring.length];\n                int[] prev = {0};\n                for (int i = 1; i <= key.length; i++) {\n                        int curr = i % 2;\n                        int last = (i - 1) % 2;\n                        Arrays.fill(dp[curr], Integer.MAX_VALUE);\n                        for (int j : lookup.get(key[i - 1])) {\n                                for (int k : prev) {\n                                        dp[curr][j] = Math.min(dp[curr][j], Math.min((k + ring.length - j) % ring.length,\n                                                        (j + ring.length - k) % ring.length) + dp[last][k]);\n                                }\n                        }\n                        prev = lookup.get(key[i - 1]);\n                }\n                return Integer.min(dp[key.length % 2]) + key.length;\n    }\n}", "95": "public boolean checkPalindromeFormation(String a, String b) {\n                boolean is_palindrome(String s, int i, int j) {\n                        while (i < j) {\n                                if (s.charAt(i) != s.charAt(j)) {\n                                        return false;\n                                }\n                                i += 1;\n                                j -= 1;\n                        }\n                        return true;\n                }\n                boolean check(String a, String b) {\n                        int i = 0, j = b.length() - 1;\n                        while (i < j) {\n                                if (a.charAt(i) != b.charAt(j)) {\n                                        return is_palindrome(a, i, j) || is_palindrome(b, i, j);\n                                }\n                                i += 1;\n                                j -= 1;\n                        }\n                        return true;\n                }\n                return check(a, b) || check(b, a);\n        }", "96": NaN, "97": NaN, "98": "public int getMaximumGenerated(int n) {\n        if (n == 0) {\n                return 0;\n        }\n        int[] nums = new int[n + 1];\n        nums[1] = 1;\n        int result = 1;\n        for (int i = 2; i <= n; i++) {\n                if (i%2 == 0) {\n                        nums[i] = nums[i/2];\n                } else {\n                        nums[i] = nums[i/2] + nums[i/2+1];\n                }\n                result = Math.max(result, nums[i]);\n        }\n        return result;\n}", "99": "public static int subsetXORSum(int[] nums) {\n        int result = 0;\n        for (int x : nums) {\n                result |= x;\n        }\n        return result * (1 << (nums.length - 1));\n}", "100": "public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        for (int i = 0; i < len; i++) {\n                if (flowerbed[i] == 0 && (i == 0 || flowerbed[i-1] == 0) && (i == len-1 || flowerbed[i+1] == 0)) {\n                        flowerbed[i] = 1;\n                        n--;\n                }\n                if (n <= 0) {\n                        return true;\n                }\n        }\n        return false;\n}", "101": "public class Main { \n   \n    public static int maxPower(String s) \n    { \n        int result = 1, count = 1; \n        for (int i = 1; i < s.length(); i++) { \n            if (s.charAt(i) == s.charAt(i - 1)) \n                count++; \n            else\n                count = 1; \n            result = Math.max(result, count); \n        } \n        return result; \n    } \n   \n    public static void main(String[] args) \n    { \n        String s = \"leetcode\"; \n        System.out.println(maxPower(s)); \n    } \n}", "102": "public List<Integer> findBall(int[][] grid) {\n        List<Integer> result = new ArrayList<>();\n        for(int c = 0; c < grid[0].length; c++) {\n                for(int r = 0; r < grid.length; r++) {\n                        int nc = c + grid[r][c];\n                        if(!(0 <= nc < grid[0].length && grid[r][nc] == grid[r][c])) {\n                                c = -1;\n                                break;\n                        }\n                        c = nc;\n                }\n                result.add(c);\n        }\n        return result;\n}", "103": "public class DiagonalSort {\n    public static void main(String[] args) {\n        int[][] mat = {{3,3,1,1}, \n        {2,2,1,2}, \n        {1,1,1,2}};\n        int rows = mat.length;\n        int cols = mat[0].length;\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n        for(int i=0; i<rows; i++){\n            for(int j=0; j<cols; j++){\n                if(!map.containsKey(i-j)){\n                    map.put(i-j, new ArrayList<>());\n                }\n                map.get(i-j).add(mat[i][j]);\n            }\n        }\n        for(int i=rows-1; i>=0; i--){\n            for(int j=cols-1; j>=0; j--){\n                List<Integer> temp = map.get(i-j);\n                Collections.sort(temp);\n                mat[i][j] = temp.remove(temp.size()-1);\n            }\n        }\n        for(int i=0; i<rows; i++){\n            for(int j=0; j<cols; j++){\n                System.out.print(mat[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}", "104": "public static int maximumScore(int a, int b, int c) {\n        return Math.min((a+b+c)/2, a+b+c - Math.max(a, b, c));\n}", "105": "public class Solution {\n    public List<Integer> diffWaysToCompute(String input) {\n                String[] tokens = re.split('(\\D)', input);\n                int[] nums = map(int, tokens[::2]);\n                char[] ops = map({'+': operator.add, '-': operator.sub, '*': operator.mul}.get, tokens[1::2]);\n                int[][] lookup = [[None for _ in xrange(len(nums))] for _ in xrange(len(nums))];\n                public List<Integer> diffWaysToComputeRecu(int left, int right) {\n                        if (left == right) {\n                                return [nums[left]];\n                        }\n                        if (lookup[left][right]) {\n                                return lookup[left][right];\n                        }\n                        for (int i = left; i < right; i++) {\n                                lookup[left][right] = [ops[i](x, y) for x in diffWaysToComputeRecu(left, i) for y in diffWaysToComputeRecu(i + 1, right)];\n                        }\n                        return lookup[left][right];\n                }\n                return diffWaysToComputeRecu(0, len(nums) - 1);\n    }\n}", "106": "public boolean canPartition(int[] nums) {\n        int sum = 0;\n        for (int num : nums) {\n                sum += num;\n        }\n        if (sum % 2 != 0) {\n                return false;\n        }\n        int W = sum / 2;\n        boolean[] dp = new boolean[W + 1];\n        dp[0] = true;\n        for (int num : nums) {\n                for (int i = W; i >= 0; i--) {\n                        if (num <= i) {\n                                dp[i] = dp[i] || dp[i - num];\n                        }\n                }\n        }\n        return dp[W];\n}", "107": "public int movesToMakeZigzag(int[] nums) {\n        int[] result = {0, 0};\n        for (int i=0; i<nums.length; i++) {\n                int left = i-1>=0 ? nums[i-1] : Integer.MAX_VALUE;\n                int right = i+1<nums.length ? nums[i+1] : Integer.MAX_VALUE;\n                result[i%2] += Math.max(nums[i]-Math.min(left, right)+1, 0);\n        }\n        return Math.min(result[0], result[1]);\n}", "108": "public static String largestMerge(String word1, String word2) {\n        Queue<Character> q1 = new LinkedList<Character>();\n        Queue<Character> q2 = new LinkedList<Character>();\n        List<Character> result = new ArrayList<Character>();\n        for (char c : word1.toCharArray()) {\n                q1.add(c);\n        }\n        for (char c : word2.toCharArray()) {\n                q2.add(c);\n        }\n        while (!q1.isEmpty() || !q2.isEmpty()) {\n                if (q1.peek() > q2.peek()) {\n                        result.add(q1.poll());\n                }\n                else {\n                        result.add(q2.poll());\n                }\n        }\n        StringBuilder sb = new StringBuilder();\n        for (char c : result) {\n                sb.append(c);\n        }\n        return sb.toString();\n}", "109": "public static int countOrders(int n) {\n        MOD = 10^9+7;\n        result = 1;\n        for (int i = reversed(2, 2*n+1, 2)) {\n                result = result * i*(i-1)/2 % MOD;\n        return result;\n        }\n}", "110": "public int numRookCaptures(char[][] board) {\n        int directions[][] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        int r = 0, c = 0;\n        for (int i = 0; i < 8; i++) {\n                if (r != 0) {\n                        break;\n                }\n                for (int j = 0; j < 8; j++) {\n                        if (board[i][j] == 'R') {\n                                r = i;\n                                c = j;\n                                break;\n                        }\n                }\n        }\n        int result = 0;\n        for (int d[] : directions) {\n                int nr = r + d[0];\n                int nc = c + d[1];\n                while (0 <= nr && nr < 8 && 0 <= nc && nc < 8) {\n                        if (board[nr][nc] == 'p') {\n                                result += 1;\n                        }\n                        if (board[nr][nc] != '.') {\n                                break;\n                        }\n                        nr = nr + d[0];\n                        nc = nc + d[1];\n                }\n        }\n        return result;\n}", "111": "class modifyString {\n    public static String modifyString(String s) {\n                char[] s = s.toCharArray();\n                for (int i = 0; i < s.length; i++) {\n                        if (s[i] != '?') {\n                                continue;\n                                }\n                        for (char c : ('a', 'b', 'c')) {\n                                if (i == 0 || s[i-1] != c) && (i == s.length-1 || c != s[i+1]) {\n                                        break;\n                                        }\n                        s[i] = c;\n                }\n                return new String(s);\n    }\n}", "112": "public int findJudge(int N, int[][] trust) {\n        int[] degrees = new int[N];\n        for (int i, j : trust) {\n                degrees[i-1] -= 1;\n                degrees[j-1] += 1;\n        }\n        for (int i = 0; i < degrees.length; i++) {\n                if (degrees[i] == N-1) {\n                        return i+1;\n                }\n        }\n        return -1;\n}", "113": "public class mostVisited {\n    public static void main(String[] args) {\n        int n = 5;\n        int[] rounds = {2, 1, 2, 1, 2, 1, 2, 1, 2};\n        if (rounds[0] <= rounds[rounds.length - 1]) {\n            for (int i = rounds[0]; i <= rounds[rounds.length - 1]; i++) {\n                System.out.print(i + \" \");\n            }\n        } else {\n            for (int i = 1; i <= rounds[rounds.length - 1]; i++) {\n                System.out.print(i + \" \");\n            }\n            for (int i = rounds[0]; i <= n; i++) {\n                System.out.print(i + \" \");\n            }\n        }\n    }\n}", "114": "public class Solution {\n    public int minSubarray(int[] nums, int p) {\n                int residue = sum(nums) % p;\n                if (!residue)\n                        return 0;\n                int result = len(nums);\n                int curr = 0;\n                HashMap<int, int> lookup = {0: -1};\n                for (int i=0, num : nums) {\n                        curr = (curr+num) % p;\n                        lookup.put(curr, i);\n                        if ((curr-residue) % p in lookup) {\n                                result = min(result, i-lookup.get((curr-residue)%p));\n                        }\n                }\n                return result if result < len(nums) else -1;\n    }\n}", "115": "public class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (isBadVersion(mid)) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}", "116": "public static void transpose(int[][] A)\n{\n        for(int i=0;i<A[0].length;i++)\n        {\n                for(int j=0;j<i;j++)\n                {\n                        int temp=A[i][j];\n                        A[i][j]=A[j][i];\n                        A[j][i]=temp;\n                }\n        }\n}", "117": "class Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int result = Integer.MAX_VALUE, total = 0, curr = 0, left = 0;\n        for (int right = 0; right < cardPoints.length; right++) {\n            total += cardPoints[right];\n            curr += cardPoints[right];\n            if (right - left + 1 > cardPoints.length - k) {\n                curr -= cardPoints[left];\n                left += 1;\n            }\n            if (right - left + 1 == cardPoints.length - k) {\n                result = Math.min(result, curr);\n            }\n        }\n        return total - result;\n    }\n}", "118": "public String shortestCompletingWord(String licensePlate, String[] words) {\n        \n        def contains(counter1, w2):\n                c2 = collections.Counter(w2.lower())\n                c2.subtract(counter1)\n                return all(map(lambda x: x >= 0, c2.values()))\n        result = None\n        counter = collections.Counter(c.lower() for c in licensePlate if c.isalpha())\n        for word in words:\n                if (result is None or (len(word) < len(result))) and \\\n                contains(counter, word):\n                        result = word\n        return result", "119": "public boolean isAnagram(String s, String t) {\n        return Arrays.equals(s.toCharArray(), t.toCharArray());\n}", "120": "public int maximalNetworkRank(int n, int[][] roads) {\n        int[] degree = new int[n];\n        Map<Integer, Set<Integer>> adj = new HashMap();\n        for (int[] road: roads) {\n                degree[road[0]]++;\n                degree[road[1]]++;\n                if (!adj.containsKey(road[0]))\n                        adj.put(road[0], new HashSet());\n                if (!adj.containsKey(road[1]))\n                        adj.put(road[1], new HashSet());\n                adj.get(road[0]).add(road[1]);\n                adj.get(road[1]).add(road[0]);\n        }\n\n        int result = 0;\n        for (int i = 0; i < n-1; i++) {\n                for (int j = i+1; j < n; j++)\n                        result = Math.max(result, degree[i] + degree[j] - (adj.containsKey(i) && adj.get(i).contains(j) ? 1 : 0));\n        }\n\n        return result;\n}", "121": "public class gameOfLife{\n  public void gameOfLife(int[][] board){\n    int m = len(board);\n    int n = len(board[0]) if m else 0;\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        int count = 0;\n        for(int I = 0; I < max(i-1, 0), min(i+2, m); I++){\n          for(int J = 0; J < max(j-1, 0), min(j+2, n); J++){\n            count += board[I][J] & 1;\n          }\n        }\n        if((count == 4 && board[i][j]) || count == 3){\n          board[i][j] |= 2;\n        }\n      }\n    }\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        board[i][j] >>= 1;\n      }\n    }\n  }\n}", "122": "public int findSecondMinimumValue(TreeNode root) {\n        int[] max_heap = new int[3];\n        Set<Integer> lookup = new HashSet<>();\n        findSecondMinimumValueHelper(root, max_heap, lookup);\n        if (max_heap.length < 2) {\n                return -1;\n        }\n        return max_heap[0];\n}\npublic void findSecondMinimumValueHelper(TreeNode root, int[] max_heap, Set<Integer> lookup) {\n        if (root == null) {\n                return;\n        }\n        if (!lookup.contains(root.val)) {\n                heapq.heappush(max_heap, -root.val);\n                lookup.add(root.val);\n                if (max_heap.length > 2) {\n                        lookup.remove(-heapq.heappop(max_heap));\n                }\n        }\n        findSecondMinimumValueHelper(root.left, max_heap, lookup);\n        findSecondMinimumValueHelper(root.right, max_heap, lookup);\n}", "123": "public class Solution {\n    public int findLHS(int[] nums) {\n        Map<Integer, Integer> lookup = new HashMap<>();\n        int result = 0;\n        for (int num : nums) {\n            lookup.put(num, lookup.getOrDefault(num, 0) + 1);\n            for (int diff : new int[] {-1, 1}) {\n                if (lookup.containsKey(num + diff)) {\n                    result = Math.max(result, lookup.get(num) + lookup.get(num + diff));\n                }\n            }\n        }\n        return result;\n    }\n}", "124": "public boolean containsPattern(int[] arr, int m, int k) {\n        int cnt = 0;\n        for (int i = 0; i < arr.length - m; i++) {\n                if (arr[i] != arr[i+m]) {\n                        cnt = 0;\n                        continue;\n                }\n                cnt += 1;\n                if (cnt == (k-1)*m) {\n                        return true;\n                }\n        }\n        return false;\n}", "125": "public int minCostClimbingStairs(int[] cost) {\n        int[] dp = new int[3];\n        for (int i = cost.length - 1; i >= 0; i--) {\n                dp[i % 3] = cost[i] + Math.min(dp[(i + 1) % 3], dp[(i + 2) % 3]);\n        }\n        return Math.min(dp[0], dp[1]);\n}", "126": "public int primePalindrome(int N){\n    def is_prime(n):\n                        if n < 2 or n % 2 == 0:\n                                return n == 2\n                        return all(n % d for d in xrange(3, int(n**.5) + 1, 2))\n    if 8 <= N <= 11:\n                        return 11\n    for i in xrange(10**(len(str(N))//2), 10**5):\n                        j = int(str(i) + str(i)[-2::-1])\n                        if j >= N and is_prime(j):\n                                return j\n}", "127": "public class TrieNode {\n    private int TOP_COUNT = 3;\n    Map<Character, TrieNode> leaves = new HashMap<>();\n    List<Integer> infos = new ArrayList<>();\n    \n    public void insert(String[] words, int i) {\n        TrieNode curr = this;\n        for (char c : words[i].toCharArray()) {\n            if (!curr.leaves.containsKey(c)) {\n                curr.leaves.put(c, new TrieNode());\n            }\n            curr = curr.leaves.get(c);\n            curr.addInfo(words, i);\n        }\n    }\n    \n    public void addInfo(String[] words, int i) {\n        infos.add(i);\n        Collections.sort(infos, (a, b) -> words[a].compareTo(words[b]));\n        if (infos.size() > TOP_COUNT) {\n            infos.remove(infos.size() - 1);\n        }\n    }\n    \n    public List<List<String>> suggestedProducts(String[] products, String searchWord) {\n        List<List<String>> result = new ArrayList<>();\n        TrieNode curr = this;\n        String prefix = \"\";\n        for (int i = 0; i < searchWord.length(); i++) {\n            char c = searchWord.charAt(i);\n            prefix += c;\n            if (!curr.leaves.containsKey(c)) {\n                for (int j = 0; j < 3; j++) {\n                    result.add(new ArrayList<>());\n                }\n                return result;\n            }\n            curr = curr.leaves.get(c);\n            List<String> productsList = getProducts(products, curr.infos);\n            result.add(productsList);\n        }\n        return result;\n    }\n    \n    public List<String> getProducts(String[] products, List<Integer> infos) {\n        List<String> res = new ArrayList<>();\n        for (int info : infos) {\n            res.add(products[info]);\n        }\n        return res;\n    }\n}", "128": "def countPalindromicSubsequences(S):\n          prv = [None] * len(S)\n                nxt = [None] * len(S)\n                last = [None] * 4\n                for i in xrange(len(S)):\n                        last[ord(S[i])-ord('a')] = i\n                        prv[i] = tuple(last)\n                last = [None] * 4\n                for i in reversed(xrange(len(S))):\n                        last[ord(S[i])-ord('a')] = i\n                        nxt[i] = tuple(last)\n                P = 10**9 + 7\n                lookup = [[None] * len(S) for _ in xrange(len(S))]\n                return dp(0, len(S)-1, prv, nxt, lookup) - 1", "129": "public int maxValueAfterReverse(int[] nums) {\n        int result = 0, add = 0, maxPair = Integer.MIN_VALUE, minPair = Integer.MAX_VALUE;\n        for (int i = 1; i < nums.length; i++) {\n                result += Math.abs(nums[i-1]-nums[i]);\n                add = Math.max(add, Math.abs(nums[0]-nums[i]) - Math.abs(nums[i-1]-nums[i]));\n                add = Math.max(add, Math.abs(nums[nums.length-1]-nums[i-1]) - Math.abs(nums[i-1]-nums[i]));\n                minPair = Math.min(minPair, Math.max(nums[i-1], nums[i]));\n                maxPair = Math.max(maxPair, Math.min(nums[i-1], nums[i]));\n        }\n        return result + Math.max(add, (maxPair-minPair)*2);\n}", "130": "public class Solution {\n    public boolean isMatch(String s, String p) {\n                int count = 0;\n                int p_ptr = 0, s_ptr = 0, last_s_ptr = -1, last_p_ptr = -1;\n                while (s_ptr < s.length()) {\n                        if (p_ptr < p.length() && (s.charAt(s_ptr) == p.charAt(p_ptr) || p.charAt(p_ptr) == '?')) {\n                                s_ptr += 1;\n                                p_ptr += 1;\n                        } else if (p_ptr < p.length() && p.charAt(p_ptr) == '*') {\n                                p_ptr += 1;\n                                last_s_ptr = s_ptr;\n                                last_p_ptr = p_ptr;\n                        } else if (last_p_ptr != -1) {\n                                last_s_ptr += 1;\n                                s_ptr = last_s_ptr;\n                                p_ptr = last_p_ptr;\n                        } else {\n                                return false;\n                        }\n                        count += 1;\n                }\n                while (p_ptr < p.length() && p.charAt(p_ptr) == '*') {\n                        p_ptr += 1;\n                        count += 1;\n                }\n                return p_ptr == p.length();\n    }\n}", "131": "public boolean isBipartite(int[][] graph) {\n        int n = graph.length;\n        int[] color = new int[n];\n        Arrays.fill(color, -1);\n\n        for (int start = 0; start < n; ++start) {\n                if (color[start] == -1) {\n                        Stack<Integer> stack = new Stack();\n                        stack.push(start);\n                        color[start] = 0;\n\n                        while (!stack.empty()) {\n                                Integer node = stack.pop();\n                                for (int nei: graph[node]) {\n                                        if (color[nei] == -1) {\n                                                stack.push(nei);\n                                                color[nei] = color[node] ^ 1;\n                                        } else if (color[nei] == color[node]) {\n                                                return false;\n                                        }\n                                }\n                        }\n                }\n        }\n\n        return true;\n}", "132": "public class Solution {\n    public int maxProduct(String[] words) {\n        if (words == null || words.length <= 1) {\n            return 0;\n        }\n        Arrays.sort(words, new Comparator<String>() {\n            public int compare(String s1, String s2) {\n                return s2.length() - s1.length();\n            }\n        });\n        int len = words.length;\n        int[] bits = new int[len];\n        for (int i = 0; i < len; i++) {\n            for (char c : words[i].toCharArray()) {\n                bits[i] |= (1 << (c - 'a'));\n            }\n        }\n        int max = 0;\n        for (int i = 0; i < len - 1; i++) {\n            if (words[i].length() * words[i].length() <= max) {\n                break;\n            }\n            for (int j = i + 1; j < len; j++) {\n                if (words[i].length() * words[j].length() <= max) {\n                    break;\n                }\n                if ((bits[i] & bits[j]) == 0) {\n                    max = Math.max(max, words[i].length() * words[j].length());\n                }\n            }\n        }\n        return max;\n    }\n}", "133": "public class UnionFind {\n    private int[] set;\n    \n    public UnionFind() {\n        set = new int[];\n    }\n    \n    public get_id() {\n        set.append(set.length);\n        return set.length - 1;\n    }\n    \n    public find_set(int x) {\n        if (set[x] != x) {\n            set[x] = find_set(set[x]);\n        }\n        return set[x];\n    }\n    \n    public union_set(int x, int y) {\n        int x_root, y_root = map(find_set, (x, y));\n        if (x_root != y_root) {\n            set[min(x_root, y_root)] = max(x_root, y_root);\n        }\n    }\n}\n\npublic List<List<String>> accountsMerge(List<List<String>> accounts) {\n        UnionFind union_find = new UnionFind();\n        Map<String, String> email_to_name = new HashMap<String, String>();\n        Map<String, Integer> email_to_id = new HashMap<String, Integer>();\n        for (List<String> account : accounts) {\n            String name = account.get(0);\n            for (int i = 1; i < account.size(); i++) {\n                if (!email_to_id.containsKey(account.get(i))) {\n                    email_to_name.put(account.get(i), name);\n                    email_to_id.put(account.get(i), union_find.get_id());\n                }\n                union_find.union_set(email_to_id.get(account.get(1)), email_to_id.get(account.get(i)));\n            }\n        }\n        Map<Integer, List<String>> result = new HashMap<Integer, List<String>>();\n        for (String email : email_to_name.keySet()) {\n            int index = union_find.find_set(email_to_id.get(email));\n            if (!result.containsKey(index)) {\n                result.put(index, new ArrayList<String>());\n            }\n            result.get(index).add(email);\n        }\n        for (List<String> emails : result.values()) {\n            emails.sort();\n        }\n        return new ArrayList<List<String>>(result.values());\n    }", "134": "def minTime(n, edges, hasApple):\n                graph = collections.defaultdict(list)\n                for u, v in edges:\n                        graph[u].append(v)\n                        graph[v].append(u)\n                return 2*max(dfs(graph, -1, 0, hasApple)-1, 0)", "135": NaN, "136": "public boolean containsNearbyDuplicate(int[] nums, int k) {\n        HashMap<Integer, Integer> lookup = new HashMap<Integer, Integer>();\n        for(int i = 0; i < nums.length; i++) {\n                if(lookup.containsKey(nums[i])) {\n                        if(i - lookup.get(nums[i]) <= k) {\n                                return true;\n                        }\n                }\n                lookup.put(nums[i], i);\n        }\n        return false;\n}", "137": "public int findUnsortedSubarray(int[] nums) {\n        int[] a = sorted(nums);\n        int left, right = 0, len(nums) -1;\n        while (nums[left] == a[left] or nums[right] == a[right]) {\n                if right - left <= 1 {\n                        return 0;\n                }\n                if nums[left] == a[left] {\n                        left += 1;\n                }\n                if nums[right] == a[right] {\n                        right -= 1;\n                }\n        }\n        return right - left + 1;\n}", "138": "public int longestStrChain(String[] words) {\n        Arrays.sort(words, new Comparator<String>(){\n                public int compare(String a, String b){\n                        return a.length() - b.length();\n                }\n        });\n        int max = 0;\n        HashMap<String, Integer> dp = new HashMap<>();\n        for(String word : words){\n                for(int i=0; i<word.length(); i++){\n                        String prev = word.substring(0,i) + word.substring(i+1);\n                        dp.put(word, Math.max(dp.getOrDefault(word,0), dp.getOrDefault(prev,0)+1));\n                        max = Math.max(max, dp.get(word));\n                }\n        }\n        return max;\n}", "139": "public void merge(int A[], int m, int B[], int n){\n        int last = m + n - 1;\n        int i = m - 1;\n        int j = n - 1;\n \n        while(i >= 0 && j>= 0){\n            if(A[i] > B[j]){\n                A[last] = A[i];\n                last--;\n                i--;\n            }\n            else{\n                A[last] = B[j];\n                last--;\n                j--;\n            }\n        }\n \n        while(j >= 0){\n            A[last] = B[j];\n            last--;\n            j--;\n        }\n    }", "140": "public int maxSumRangeQuery(int[] nums, int[][] requests) {\n                int[] count = new int[nums.length];\n                for (int[] request : requests) {\n                        int start = request[0];\n                        int end = request[1];\n                        count[start] += 1;\n                        if (end + 1 < count.length) {\n                                count[end + 1] -= 1;\n                        }\n                }\n                for (int i = 1; i < count.length; i++) {\n                        count[i] += count[i - 1];\n                }\n                Arrays.sort(nums);\n                Arrays.sort(count);\n                int result = 0;\n                for (int i = 0; i < nums.length; i++) {\n                        result += nums[i] * count[i];\n                        result %= MOD;\n                }\n                return result;\n        }", "141": "public boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n}", "142": "public int minimumOneBitOperations(int n) {\n        int result = 0;\n        while (n != 0) {\n                result = -result - (n ^ (n - 1));\n                n &= (n - 1);\n        }\n        return Math.abs(result);\n}", "143": "public class UnionFind {\n    private int[] set;\n    \n    public UnionFind(int n) {\n        set = new int[n];\n        for (int i = 0; i < n; i++) {\n            set[i] = i;\n        }\n    }\n    \n    public int find_set(int x) {\n        if (set[x] != x) {\n            set[x] = find_set(set[x]); \n        }\n        return set[x];\n    }\n    \n    public void union_set(int x, int y) {\n        x_root, y_root = map(find_set, new int[]{x, y});\n        if (x_root == y_root) {\n            return;\n        }\n        set[min(x_root, y_root)] = max(x_root, y_root);\n    }\n}\n\npublic int minMalwareSpread(int[][] graph, int[] initial) {\n        Set<Integer> initial_set = new HashSet<>();\n        for (int i : initial) {\n            initial_set.add(i);\n        }\n        List<Integer> clean = new ArrayList<>();\n        for (int i = 0; i < graph.length; i++) {\n            if (!initial_set.contains(i)) {\n                clean.add(i);\n            }\n        }\n        UnionFind union_find = new UnionFind(graph.length);\n        for (int i = 0; i < clean.size(); i++) {\n            for (int j = i + 1; j < clean.size(); j++) {\n                if (graph[clean.get(i)][clean.get(j)] == 1) {\n                    union_find.union_set(clean.get(i), clean.get(j));\n                }\n            }\n        }\n        Map<Integer, Integer> union_size = new HashMap<>();\n        for (int i = 0; i < graph.length; i++) {\n            int root = union_find.find_set(i);\n            if (!union_size.containsKey(root)) {\n                union_size.put(root, 1);\n            } else {\n                union_size.put(root, union_size.get(root) + 1);\n            }\n        }\n        Map<Integer, Set<Integer>> shared_union = new HashMap<>();\n        for (int i : initial) {\n            for (int j : clean) {                                \n                if (graph[i][j] == 1) {\n                    int x = union_find.find_set(j);\n                    if (!shared_union.containsKey(x)) {\n                        shared_union.put(x, new HashSet<>());\n                    }\n                    shared_union.get(x).add(i);\n                }\n            }\n        }\n        int result = Integer.MAX_VALUE, total = Integer.MIN_VALUE;\n        for (int i : initial) {\n            Set<Integer> lookup = new HashSet<>();\n            int curr = 0;\n            for (int j : clean) {                                \n                if (graph[i][j] == 1) {\n                    int x = union_find.find_set(j);\n                    if (shared_union.get(x).size() == 1 && \n                         x not in lookup) {\n                        curr += union_size.get(x);\n                        lookup.add(x);\n                    }\n                }\n            }\n            if (curr > total || \n                (curr == total && i < result)) {\n                total = curr;\n                result = i;\n            }\n        }\n        return result;\n    }", "144": "public static int smallestRangeII(int[] A, int K) {\n        Arrays.sort(A);\n        int result = A[A.length - 1] - A[0];\n        for (int i = 0; i < A.length - 1; i++) {\n                result = Math.min(result,\n                                        Math.max(A[A.length - 1] - K, A[i] + K) -\n                                        Math.min(A[0] + K, A[i + 1] - K));\n        }\n        return result;\n}", "145": "public ArrayList<String> removeComments(String source) {\n        boolean inBlock = false;\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<String> newline = new ArrayList<String>();\n        for (String line : source) {\n                int i = 0;\n                while (i < line.length()) {\n                        if (!inBlock && i+1 < line.length() && line.substring(i,i+2).equals(\"/*\")) {\n                                inBlock = true;\n                                i += 1;\n                        } else if (inBlock && i+1 < line.length() && line.substring(i,i+2).equals(\"*/\")) {\n                                inBlock = false;\n                                i += 1;\n                        } else if (!inBlock && i+1 < line.length() && line.substring(i,i+2).equals(\"//\")) {\n                                break;\n                        } else if (!inBlock) {\n                                newline.add(line.substring(i,i+1));\n                        }\n                        i += 1;\n                }\n                if (newline.size() > 0 && !inBlock) {\n                        result.add(\"\".join(newline));\n                        newline = new ArrayList<String>();\n                }\n        }\n        return result;\n}", "146": "public class Test {\n    public static void main(String[] args) {\n        boolean result = canEat(5, [[0, 2, 5], [1, 2, 3], [2, 2, 2], [3, 2, 4], [4, 2, 1]]);\n        System.out.println(result);\n    }\n\n    public static boolean canEat(int candiesCount, int[][] queries) {\n\n        int[] prefix = new int[candiesCount + 1];\n        for (int i = 0; i < candiesCount; i++) {\n            prefix[i + 1] = prefix[i] + candiesCount[i];\n        }\n\n        for (int[] query : queries) {\n            int t = query[0];\n            int d = query[1];\n            int c = query[2];\n            if (prefix[t] / c < d + 1 && d + 1 <= prefix[t + 1] / c) {\n                return true;\n            }\n        }\n        return false;\n    }\n}", "147": "public int minTimeToVisitAllPoints(int[][] points) {\n        int sum=0;\n        for(int i=0;i<points.length-1;i++)\n        {\n        sum+=Math.max(Math.abs(points[i+1][0]-points[i][0]),Math.abs(points[i+1][1]-points[i][1]));\n        }\n        return sum;\n        }", "148": "public class PrisonAfterNDays{\n        public static void main(String[] args){\n                int[] cells = {0,1,0,1,1,0,0,1};\n                int N = 7;\n                cells = tuple(cells);\n                lookup = {}\n                while N:\n                        lookup[cells] = N\n                        N -= 1\n                        cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in xrange(1, 7)] + [0])\n                        if cells in lookup:\n                                assert(lookup[cells] - N in (1, 7, 14))\n                                N %= lookup[cells] - N\n                                break\n                while N:\n                        N -= 1\n                        cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in xrange(1, 7)] + [0])\n                return list(cells)\n        }\n}", "149": "def kthLargestValue(self, matrix, k):\n                def nth_element(nums, n, compare=lambda a, b: a < b):\n                        def tri_partition(nums, left, right, target, compare):\n                                mid = left\n                                while mid <= right:\n                                        if nums[mid] == target:\n                                                mid += 1\n                                        elif compare(nums[mid], target):\n                                                nums[left], nums[mid] = nums[mid], nums[left]\n                                                left += 1\n                                                mid += 1\n                                        else:\n                                                nums[mid], nums[right] = nums[right], nums[mid]\n                                                right -= 1\n                                return left, right\n                        left, right = 0, len(nums)-1\n                        while left <= right:\n                                pivot_idx = random.randint(left, right)\n                                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                                if pivot_left <= n <= pivot_right:\n                                        return\n                                elif pivot_left > n:\n                                        right = pivot_left-1\n                                else: \n                                        left = pivot_right+1\n                vals = []\n                for r in xrange(len(matrix)):\n                        curr = 0\n                        for c in xrange(len(matrix[0])):\n                                curr = curr^matrix[r][c]\n                                if r == 0:\n                                        matrix[r][c] = curr\n                                else:\n                                        matrix[r][c] = curr^matrix[r-1][c]\n                                vals.append(matrix[r][c])\n                nth_element(vals, k-1, compare=lambda a, b: a > b)\n                return vals[k-1]", "150": "def countSubstrings(s):\n                def manacher(s):\n                        s = '^' + '#'.join(s) + '$'\n                        P = [0] * len(s)\n                        C, R = 0, 0\n                        for i in xrange(1, len(s) - 1):\n                                i_mirror = 2*C-i\n                                if R > i:\n                                        P[i] = min(R-i, P[i_mirror])\n                                while s[i+1+P[i]] == s[i-1-P[i]]:\n                                        P[i] += 1\n                                if i+P[i] > R:\n                                        C, R = i, i+P[i]\n                        return P\n                return sum((max_len+1)//2 for max_len in manacher(s))\n\n\ndef countSubstrings(self, s):\n        def manacher(s):\n            s = '^' + '#'.join(s) + '$'\n            P = [0] * len(s)\n            C, R = 0, 0\n            for i in xrange(1, len(s) - 1):\n                i_mirror = 2*C-i\n                if R > i:\n                    P[i] = min(R-i, P[i_mirror])\n                while s[i+1+P[i]] == s[i-1-P[i]]:\n                    P[i] += 1\n                if i+P[i] > R:\n                    C, R = i, i+P[i]\n            return P\n        return sum((max_len+1)//2 for max_len in manacher(s))", "151": "public class Solution {\n    public int minSwapsCouples(int[] row) {\n                N = len(row)//2\n                couples = [[] for _ in xrange(N)]\n                for seat, num in enumerate(row):\n                        couples[num//2].append(seat//2)\n                adj = [[] for _ in xrange(N)]\n                for couch1, couch2 in couples:\n                        adj[couch1].append(couch2)\n                        adj[couch2].append(couch1)\n                result = 0\n                for couch in xrange(N):\n                        if not adj[couch]: continue\n                        couch1, couch2 = couch, adj[couch].pop()\n                        while couch2 != couch:\n                                result += 1\n                                adj[couch2].remove(couch1)\n                                couch1, couch2 = couch2, adj[couch2].pop()\n                return result\n    }\n}", "152": "public List<Integer> createTargetArray(int[] nums, int[] index) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n                result.add(index[i], nums[i]);\n        }\n        return result;\n}", "153": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic boolean flipEquiv(TreeNode root1, TreeNode root2) {\n                if (!root1 && !root2) {\n                        return true;\n                }\n                if (!root1 || !root2 || root1.val != root2.val) {\n                        return false;\n                }\n                return (flipEquiv(root1.left, root2.left) &&\n                                flipEquiv(root1.right, root2.right) ||\n                                flipEquiv(root1.left, root2.right) &&\n                                flipEquiv(root1.right, root2.left));\n}", "154": "public class BusSeatAllocator {\n    private Map<Integer, int[]> seats;\n    private PriorityQueue<int[]> maxHeap;\n    private int num;\n\n    public BusSeatAllocator(int N) {\n        seats = new HashMap<>();\n        maxHeap = new PriorityQueue<>(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return o2[0] - o1[0];\n            }\n        });\n        num = N;\n    }\n\n    private void allocateSeat(int p) {\n        int[] leftRight = seats.get(p);\n        seats.remove(p);\n        seats.get(leftRight[0])[1] = leftRight[1];\n        seats.get(leftRight[1])[0] = leftRight[0];\n        maxHeap.offer(new int[] {-distance(leftRight), leftRight[0], leftRight[1]});\n    }\n\n    private int distance(int[] segment) {\n        if (segment[0] == -1 || segment[1] == num) {\n            return segment[1] - segment[0] - 1;\n        }\n        return (segment[1] - segment[0]) / 2;\n    }\n}", "155": "public class SegmentTree {\n        int N;\n        int H;\n        int query_fn;\n        int update_fn;\n        int default_val;\n        int tree;\n        int lazy;\n        public SegmentTree(int N,\n                                build_fn=lambda x, y: [y]*(2*x),\n                                query_fn=lambda x, y: y if x is None else max(x, y), update_fn=lambda x, y: y, default_val=0){\n                this.N = N;\n                this.H = (N-1).bit_length();\n                this.query_fn = query_fn;\n                this.update_fn = update_fn;\n                this.default_val = default_val;\n                this.tree = build_fn(N, default_val);\n                this.lazy = [None]*N;\n        public void __apply(int x, int val){\n                this.tree[x] = this.update_fn(this.tree[x], val);\n                if x < this.N:\n                        this.lazy[x] = this.update_fn(this.lazy[x], val);\n        public void update(int L, int R, int h){ \n                def pull(x):\n                        while x > 1:\n                                x //= 2\n                                this.tree[x] = this.query_fn(this.tree[x*2], this.tree[x*2+1]);\n                                if this.lazy[x] is not None:\n                                        this.tree[x] = this.update_fn(this.tree[x], this.lazy[x]);\n                L += this.N;\n                R += this.N;\n                L0, R0 = L, R;\n                while L <= R:\n                        if L & 1: \n                                this.__apply(L, h); \n                                L += 1;\n                        if R & 1 == 0: \n                                this.__apply(R, h);\n                                R -= 1;\n                        L //= 2;\n                        R //= 2;\n                pull(L0);\n                pull(R0);\n        public int query(int L, int R){ \n                def push(x):\n                        n = 2**this.H;\n                        while n != 1:\n                                y = x // n;\n                                if this.lazy[y] is not None:\n                                        this.__apply(y*2, this.lazy[y]);\n                                        this.__apply(y*2 + 1, this.lazy[y]);\n                                        this.lazy[y] = None;\n                                n //= 2;\n                result = None;\n                if L > R:\n                        return result;\n                L += this.N;\n                R += this.N;\n                push(L);\n                push(R);\n                while L <= R:\n                        if L & 1: \n                                result = this.query_fn(result, this.tree[L]);\n                                L += 1;\n                        if R & 1 == 0: \n                                result = this.query_fn(result, this.tree[R]);\n                                R -= 1;\n                        L //= 2;\n                        R //= 2;\n                return result;\n        public String __str__(){\n                showList = [];\n                for i in xrange(this.N):\n                        showList.append(this.query(i, i));\n                return \",\".join(map(str, showList));\n        public int bestTeamScore(int[] scores, int[] ages){\n                players = sorted(zip(ages, scores));\n                dp = [0]*len(players);\n                result = 0;\n                for i in xrange(len(players)):\n                        dp[i] = players[i][1];\n                        for j in xrange(i):\n                                if players[j][1] <= players[i][1]:\n                                        dp[i] = max(dp[i], dp[j] + players[i][1]);\n                        result = max(result, dp[i]);\n                return result;\n        public void pull(int x){\n                        while x > 1:\n                                x //= 2;\n                                this.tree[x] = this.query_fn(this.tree[x*2], this.tree[x*2+1]);\n                                if this.lazy[x] is not None:\n                                        this.tree[x] = this.update_fn(this.tree[x], this.lazy[x]);\n        public void push(int x){\n                        n = 2**this.H;\n                        while n != 1:\n                                y = x // n;\n                                if this.lazy[y] is not None:\n                                        this.__apply(y*2, this.lazy[y]);\n                                        this.__apply(y*2 + 1, this.lazy[y]);\n                                        this.lazy[y] = None;\n                                n //= 2;", "156": "public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        List<Integer> path = new ArrayList<>();\n        binaryTreePathsRecu(root, path, result);\n        return result;\n}\n\npublic void binaryTreePathsRecu(TreeNode node, List<Integer> path, List<String> result) {\n        if (node == null) {\n                return;\n        }\n        if (node.left == null && node.right == null) {\n                StringBuilder sb = new StringBuilder();\n                for (int i : path) {\n                        sb.append(i + \"->\");\n                }\n                sb.append(node.val);\n                result.add(sb.toString());\n        }\n        if (node.left != null) {\n                path.add(node.left.val);\n                binaryTreePathsRecu(node.left, path, result);\n                path.remove(path.size() - 1);\n        }\n        if (node.right != null) {\n                path.add(node.right.val);\n                binaryTreePathsRecu(node.right, path, result);\n                path.remove(path.size() - 1);\n        }\n}", "157": "public static char slowestKey(int[] releaseTimes, String keysPressed) {\n        char result = 'a';\n        int[] lookup = new int[26];\n        for (int i = 0; i < keysPressed.length(); i++) {\n                lookup[keysPressed.charAt(i) - 'a'] = Math.max(lookup[keysPressed.charAt(i) - 'a'], releaseTimes[i] - (i > 0 ? releaseTimes[i-1] : 0));\n                if (lookup[keysPressed.charAt(i) - 'a'] > lookup[result - 'a'] || lookup[keysPressed.charAt(i) - 'a'] == lookup[result - 'a'] && keysPressed.charAt(i) > result) {\n                        result = keysPressed.charAt(i);\n                }\n        }\n        return result;\n}", "158": "def minIncompatibility(int[] nums, int k) {\n                return min(greedy(nums, k, false), greedy(nums, k, true));\n        }\n\ndef greedy(int[] nums, int k, boolean is_reversed) {\n                Map<Integer, Integer> count = new HashMap<>();\n                for (int x : nums)\n                        count.put(x, count.getOrDefault(x, 0)+1);\n                if (Collections.max(count.values()) > k)\n                        return -1;\n                List<Integer> sorted_keys = new ArrayList<>(count.keySet());\n                Collections.sort(sorted_keys, new Comparator<Integer>() {\n                        public int compare(Integer a, Integer b) {\n                                return (is_reversed ? -1 : 1) * a.compareTo(b);\n                        }\n                });\n                int[][] stks = new int[k][];\n                int curr = 0, remain = nums.length;\n                while (remain > 0) {\n                        for (int x : sorted_keys) {\n                                if (count.get(x) != k-curr)\n                                        continue;\n                                for (int i = curr; i < k; ++i)\n                                        stks[i] = new int[] {x};\n                                remain -= count.get(x);\n                                count.put(x, 0);\n                        }\n                        for (int x : sorted_keys) {\n                                if (count.get(x) == 0)\n                                        continue;\n                                stks[curr] = new int[] {x};\n                                remain--;\n                                count.put(x, count.get(x)-1);\n                                if (stks[curr].length == nums.length/k)\n                                        curr++;\n                                break;\n                        }\n                }\n                int ret = 0;\n                for (int[] stk : stks)\n                        ret += stk[stk.length-1]-stk[0];\n                return ret;\n        }", "159": "public int peakIndexInMountainArray(int[] arr) {\n        int left = 0;\n        int right = arr.length-1;\n        while (left <= right) {\n                int mid = left + (right-left)/2;\n                if (arr[mid] > arr[mid+1]) {\n                        right = mid-1;\n                }\n                else {\n                        left = mid+1;\n                }\n        }\n        return left;\n}", "160": "public int removeCoveredIntervals(int[][] intervals) {\n    Arrays.sort(intervals, new Comparator<int[]>() {\n        @Override\n        public int compare(int[] a, int[] b) {\n            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\n        }\n    });\n\n    int res = 0, right = 0;\n    for (int[] interval : intervals) {\n        if (interval[1] > right) {\n            right = interval[1];\n            res++;\n        }\n    }\n    return res;\n}", "161": "public int climbStairs(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        int first = 1;\n        int second = 2;\n        for (int i = 3; i <= n; i++) {\n            int third = first + second;\n            first = second;\n            second = third;\n        }\n        return second;\n }", "162": "def countCharacters(words, chars):\n                count = collections.Counter(chars)\n                return sum(len(word) for word in words if check(word, chars, count))", "163": "public int maxTurbulenceSize(int[] A) {\n        int N = A.length;\n        int ans = 1;\n        int anchor = 0;\n\n        for (int i = 1; i < N; ++i) {\n                int c = cmp(A[i-1], A[i]);\n                if (c == 0) {\n                        anchor = i;\n                } else if (i == N-1 || c * cmp(A[i], A[i+1]) != -1) {\n                        ans = Math.max(ans, i - anchor + 1);\n                        anchor = i;\n                }\n        }\n\n        return ans;\n}\n\nprivate int cmp(int x, int y) {\n        return (x > y) ? 1 : (x == y ? 0 : -1);\n}", "164": "public static int titleToNumber(String s) {\n        int result = 0;\n        for (int i = 0; i < s.length(); i++) {\n                result *= 26;\n                result += s.charAt(i) - 'A' + 1;\n        }\n        return result;\n}", "165": "public class rearrangeSticks{\n\n    public static int MOD = 10**9+7;\n\n    public static void main(String[] args){\n\n        int n = 5;\n        int k = 2;\n\n        int[][] dp = new int[2][k+1];\n        dp[1][1] = 1;\n\n        for(int i = 2; i <= n+1; i++){\n            for(int j = 1; j <= Math.min(i, k)+1; j++){\n                dp[i%2][j] = (dp[(i-1)%2][j-1]+(i-1)*dp[(i-1)%2][j]) % MOD;\n            }\n        }\n        System.out.println(dp[n%2][k]);\n    }\n}", "166": "public int maxLength(String[] arr) {\n                bitsets = [bitset(x) for x in arr];\n                result = 0;\n                for (int i = power[arr.length]; i >= 0; i--) {\n                        curr_bitset = 0;\n                        curr_len = 0;\n                        while (i > 0) {\n                                j = i & -i;\n                                i ^= j;\n                                j = log2[j];\n                                if (!bitsets[j] || (curr_bitset & bitsets[j])) {\n                                        break;\n                                }\n                                curr_bitset |= bitsets[j];\n                                curr_len += len(arr[j]);\n                        }\n                        else {\n                                result = max(result, curr_len);\n                        }\n                }\n                return result;\n        }", "167": "public static String dayOfTheWeek(int day, int month, int year) {\n                String[] DAYS = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \\ \"Thursday\", \"Friday\", \"Saturday\"};\n                if (month < 3) {\n                        month += 12;\n                        year -= 1;\n                }\n                int c, y;\n                y = year % 100;\n                c = year / 100;\n                int w = (c/4 - 2*c + y + y/4 + 13*(month+1)/5 + day - 1) % 7;\n                return DAYS[w];\n}", "168": "public class Solution {\n    public int totalHammingDistance(int[] nums) {\n        int sum = 0;\n        for (int i = 0; i < 32; i++) {\n            int count0 = 0;\n            int count1 = 0;\n            for (int j = 0; j < nums.length; j++) {\n                if ((nums[j] >>> i & 1) == 0) {\n                    count0++;\n                } else {\n                    count1++;\n                }\n            }\n            sum += count0 * count1;\n        }\n        return sum;\n    }\n}", "169": "public static int minTaps(int n, int[] ranges) {\n        int[] max_range = new int[n+1];\n        for (int i = 0; i < ranges.length; i++) {\n                int left = Math.max(i - ranges[i], 0);\n                int right = Math.min(i + ranges[i], n);\n                max_range[left] = Math.max(max_range[left], right - left);\n        }\n        return jump_game(max_range);\n}\n\npublic static int jump_game(int[] A) {\n        int jump_count = 0;\n        int reachable = 0;\n        int curr_reachable = 0;\n        for (int i = 0; i < A.length; i++) {\n                if (i > reachable) {\n                        return -1;\n                }\n                if (i > curr_reachable) {\n                        curr_reachable = reachable;\n                        jump_count++;\n                }\n                reachable = Math.max(reachable, i + A[i]);\n        }\n        return jump_count;\n}", "170": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        Set<String> lookup = new HashSet<>(Arrays.asList(words));\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n                boolean[] dp = new boolean[word.length() + 1];\n                dp[0] = true;\n                for (int i = 0; i < word.length(); i++) {\n                        if (!dp[i]) {\n                                continue;\n                        }\n                        for (int j = i+1; j <= word.length(); j++) {\n                                if (j - i < word.length() && lookup.contains(word.substring(i, j))) {\n                                        dp[j] = true;\n                                }\n                        }\n                        if (dp[word.length()]) {\n                                result.add(word);\n                                break;\n                        }\n                }\n        }\n        return result;\n}", "171": "public int findPeakElement(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (nums[mid] > nums[mid + 1])\n                        right = mid;\n                else\n                        left = mid + 1;\n        }\n        return left;\n}", "172": "public class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n                dictionary = new HashSet(wordList);\n                result, cur, visited, found, trace = new ArrayList(), new ArrayList(), new HashSet(), false, new DefaultDict(new ArrayList());\n                while (!cur.isEmpty() && !found) {\n                        for (String word : cur) {\n                                visited.add(word);\n                        }\n                        next = new ArrayList();\n                        for (String word : cur) {\n                                for (int i = 0; i < word.length(); i++) {\n                                        for (char c : ascii_lowercase) {\n                                                candidate = word.substring(0, i) + c + word.substring(i + 1, word.length());\n                                                if (!visited.contains(candidate) && dictionary.contains(candidate)) {\n                                                        if (candidate.equals(endWord)) {\n                                                                found = true;\n                                                        }\n                                                        next.add(candidate);\n                                                        trace[candidate].append(word);\n                                                }\n                                        }\n                                }\n                        }\n                        cur = next;\n                }\n                if (found) {\n                        backtrack(result, trace, new ArrayList(), endWord);\n                }\n                return result;\n    }\n    \n    public void backtrack(List<List<String>> result, DefaultDict<List<String>> trace, List<String> path, String word) {\n                if (trace[word].isEmpty()) {\n                        path.add(word);\n                        result.add(path.reverse());\n                        path.pop();\n                } else {\n                        for (String prev : trace[word]) {\n                                path.add(word);\n                                backtrack(result, trace, path, prev);\n                                path.pop();\n                        }\n                }\n    }\n}", "173": "def lengthLongestPath( input):\n                def split_iter(s, tok):\n                        start = 0\n                        for i in xrange(len(s)):\n                                if s[i] == tok:\n                                        yield s[start:i]\n                                        start = i + 1\n                        yield s[start:]\n                max_len = 0\n                path_len = {0: 0}\n                for line in split_iter(input, '\\n'):\n                        name = line.lstrip('\\t')\n                        depth = len(line) - len(name)\n                        if '.' in name:\n                                max_len = max(max_len, path_len[depth] + len(name))\n                        else:\n                                path_len[depth + 1] = path_len[depth] + len(name) + 1\n                return max_len\ndef split_iter(s, tok):\n                        start = 0\n                        for i in xrange(len(s)):\n                                if s[i] == tok:\n                                        yield s[start:i]\n                                        start = i + 1\n                        yield s[start:]\n\n\npublic int lengthLongestPath(String input) {\n                public void split_iter(String s, String tok) {\n                        int start = 0;\n                        for (int i = 0; i < s.length(); i++) {\n                                if (s[i] == tok) {\n                                        yield s[start:i];\n                                        start = i + 1;\n                                }\n                        }\n                        yield s[start:];\n                }\n                int max_len = 0;\n                Map<Integer, Integer> path_len = {0: 0};\n                for (String line : split_iter(input, \"\\n\")) {\n                        String name = line.lstrip(\"\\t\");\n                        int depth = len(line) - len(name);\n                        if (\".\" in name) {\n                                max_len = max(max_len, path_len[depth] + len(name));\n                        }\n                        else {\n                                path_len[depth + 1] = path_len[depth] + len(name) + 1;\n                        }\n                }\n                return max_len;\n        }", "174": "public class Main {\n    public static void largestOverlap(int[] A, int[] B) {\n        int count = 0;\n        for (int i = 0; i < A.length; i++) {\n            for (int j = 0; j < A[0].length; j++) {\n                if (A[i][j] == 0)\n                    continue;\n                for (int i2 = 0; i2 < B.length; i2++) {\n                    for (int j2 = 0; j2 < B[0].length; j2++) {\n                        if (B[i2][j2] == 0)\n                            continue;\n                        count[(A.length - 1 + i - i2) * (2 * A.length - 1) + A.length - 1 + j - j2] += 1;\n                    }\n                }\n            }\n        }\n        return Math.max(count);\n    }\n}", "175": "public int characterReplacement(String s, int k) {\n        int result = 0, max_count = 0;\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n                count[s.charAt(i) - 'A']++;\n                max_count = Math.max(max_count, count[s.charAt(i) - 'A']);\n                if (result - max_count >= k) {\n                        count[s.charAt(i-result) - 'A']--;\n                } else {\n                        result++;\n                }\n        }\n        return result;\n}", "176": "public int[] replaceElements(int[] arr) {\n        int curr_max = -1;\n        for (int i = arr.length - 1; i >= 0; i--) {\n            arr[i] = curr_max;\n            curr_max = Math.max(curr_max, arr[i]);\n        }\n        return arr;\n}", "177": "class Node {\n                private Set<Node> nodes;\n                private Map<Node, Set<Node>> in_degree;\n                private Map<Node, Set<Node>> out_degree;\n        public Node() {\n                this.nodes = new HashSet<>();\n                this.in_degree = new HashMap<>();\n                this.out_degree = new HashMap<>();\n        }\n        public void addNode(Node node) {\n                this.nodes.add(node);\n        }\n        public void addEdge(Node src, Node dst) {\n                this.addNode(src);\n                this.addNode(dst);\n                this.in_degree.get(dst).add(src);\n                this.out_degree.get(src).add(dst);\n        }\n        public List<Node> sort() {\n                Queue<Node> q = new LinkedList<>();\n                List<Node> result = new ArrayList<>();\n                for (Node node : this.nodes) {\n                        if (!this.in_degree.containsKey(node)) {\n                                q.add(node);\n                        }\n                }\n                while (!q.isEmpty()) {\n                        Node node = q.poll();\n                        result.add(node);\n                        for (Node nei : this.out_degree.get(node)) {\n                                this.in_degree.get(nei).remove(node);\n                                if (this.in_degree.get(nei).isEmpty()) {\n                                        this.in_degree.remove(nei);\n                                        q.add(nei);\n                                }\n                        }\n                }\n                if (result.size() < this.nodes.size()) {\n                        return null;\n                }\n                return result;\n        }\n}\npublic List<Integer> sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n                for (int i = 0; i < n; i++) {\n                        if (group[i] == -1) {\n                                group[i] = m;\n                                m += 1;\n                        }\n                }\n                Node global_group = new Node();\n                for (int i = 0; i < m; i++) {\n                        global_group.addNode(i);\n                }\n                Map<Integer, Node> local_groups = new HashMap<>();\n                for (int i = 0; i < n; i++) {\n                        local_groups.putIfAbsent(group[i], new Node());\n                        local_groups.get(group[i]).addNode(i);\n                }\n                for (int i = 0; i < n; i++) {\n                        for (int j : beforeItems.get(i)) {\n                                if (group[i] == group[j]) {\n                                        local_groups.get(group[i]).addEdge(j, i);\n                                } else {\n                                        global_group.addEdge(group[j], group[i]);\n                                }\n                        }\n                }\n                List<Integer> order = global_group.sort();\n                if (order == null) {\n                        return new ArrayList<>();\n                }\n                List<Integer> result = new ArrayList<>();\n                for (int x : order) {\n                        result.addAll(local_groups.get(x).sort());\n                }\n                return result;\n}", "178": "public double mincostToHireWorkers(int[] quality, int[] wage, int K) {\n        double result = Double.MAX_VALUE, qsum = 0;\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>();\n        for (int i = 0; i < quality.length; i++) {\n                double r = (double)wage[i] / quality[i];\n                qsum += quality[i];\n                maxHeap.offer(-quality[i]);\n                if (maxHeap.size() > K) {\n                        qsum += maxHeap.poll();\n                }\n                if (maxHeap.size() == K) {\n                        result = Math.min(result, qsum * r);\n                }\n        }\n        return result;\n}", "179": "int xorOperation(int n, int start) {\n            return Arrays.stream(new int[2 * n]).reduce(0, (a, b) -> a ^ (start + 2 * b));\n        }", "180": "public static int minOperations(int n)\n{\n        return (n//2)*((n+1)//2);\n}", "181": "public boolean uniqueOccurences(int[] arr) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int i : arr) {\n                count.put(i, count.getOrDefault(i, 0) + 1);\n        }\n        return count.size() == new HashSet<>(count.values()).size();\n}", "182": "public static int numPoints(int[][] points, int r) {\n                for (int i = 0; i < points.length; i++) {\n                        count_points = count_points(points, r, i);\n                }\n                return max(count_points);\n        }", "183": "public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\n                int result = 0;\n                Deque<Integer> q = new ArrayDeque<>(initialBoxes);\n                while (!q.isEmpty()) {\n                        boolean changed = false;\n                        for (int _ = 0; _ < q.size(); _++) {\n                                int box = q.removeFirst();\n                                if (status[box] == 0) {\n                                        q.add(box);\n                                        continue;\n                                }\n                                changed = true;\n                                result += candies[box];\n                                for (int contained_key : keys[box]) {\n                                        status[contained_key] = 1;\n                                }\n                                for (int contained_box : containedBoxes[box]) {\n                                        q.add(contained_box);\n                                }\n                        }\n                        if (!changed) {\n                                break;\n                        }\n                }\n                return result;\n        }", "184": "public class Solution {\n    public List<List<String>> solveNQueens(int n) {\n                List<List<String>> ress = new ArrayList<List<String>>();\n                dfs(new ArrayList<Integer>(), new ArrayList<Integer>(), new ArrayList<Integer>());\n                return [['.'*i + 'Q' + '.'*(n-i-1) for i in res] for res in ress];\n}", "185": "public static int countBalls(int lowLimit, int highLimit) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int i = lowLimit; i <= highLimit; i++) {\n                int sum = 0;\n                for (char c : Integer.toString(i).toCharArray()) {\n                        sum += c - '0';\n                }\n                count.put(sum, count.getOrDefault(sum, 0) + 1);\n        }\n        return Collections.max(count.values());\n}", "186": "public static List<String> maxNumOfSubstrings(String s) {\n            Map<Character, Integer> first = new HashMap<>();\n            Map<Character, Integer> last = new HashMap<>();\n            for (int i = 0; i < s.length(); ++i) {\n                char c = s.charAt(i);\n                if (!first.containsKey(c)) {\n                    first.put(c, i);\n                    last.put(c,i);\n                } else {\n                    last.put(c,i);\n                }\n            }\n            List<int[]> intervals = new ArrayList<>();\n            for (char c: first.keySet()) {\n                int left = first.get(c);\n                int right = find_right_from_left(s, first, last, left);\n                if (right != -1) {\n                    intervals.add(new int[]{right, left});\n                }\n            }\n            Collections.sort(intervals, (a, b) -> a[0] - b[0]);\n            List<String> result = new", "187": "public class Main {\n    public static int[] maxSlidingWindow(int[] nums, int k) {\n                int[] result = new int[nums.length - k + 1];\n                Deque<Integer> deque = new ArrayDeque<>();\n                for (int i = 0; i < nums.length; i++) {\n                        if (!deque.isEmpty() && i - deque.getFirst() == k) {\n                                deque.removeFirst();\n                        }\n                        while (!deque.isEmpty() && nums[deque.getLast()] <= nums[i]) {\n                                deque.removeLast();\n                        }\n                        deque.add(i);\n                        if (i >= k - 1) {\n                                result[i - k + 1] = nums[deque.getFirst()];\n                        }\n                }\n                return result;\n        }\n}", "188": "public class Solution {\n    public int numDistinct(String S, String T) {\n        int[] ways = new int[T.length() + 1];\n        ways[0] = 1;\n        for (char S_char : S.toCharArray()) {\n            for (int j = T.length() - 1; j >= 0; j--) {\n                if (S_char == T.charAt(j)) {\n                    ways[j + 1] += ways[j];\n                }\n            }\n        }\n        return ways[T.length()];\n    }\n}", "189": "public class BestCoordinate {\n    public int[] bestCoordinate(int[][] towers, int radius) {\n        int min_x = min(towers, key=lambda x:x[0])[0];\n        int max_x = max(towers, key=lambda x:x[0])[0];\n        int min_y = min(towers, key=lambda x:x[1])[1];\n        int max_y = max(towers, key=lambda x:x[1])[1];\n        int max_quality = 0;\n        for (int x = min_x; x <= max_x; x++) {\n            for (int y = min_y; y <= max_y; y++) {\n                int q = 0;\n                for (int[] tower : towers) {\n                    int d = (int) Math.sqrt((tower[0]-x)*(tower[0]-x) + (tower[1]-y)*(tower[1]-y));\n                    if (d <= radius) {\n                        q += tower[2]/(1+d);\n                    }\n                }\n                if (q > max_quality) {\n                    max_quality = q;\n                    int[] result = new int[] {x, y};\n                }\n            }\n        }\n        return result;\n    }\n}", "190": "public class canWinNim {\n                public static boolean canWinNim(int n) {\n                                return n % 4 != 0;\n                }\n}", "191": "public List<Character> commonChars(String[] A) {\n        List<Character> result = new ArrayList<Character>(A[0].length());\n        int[] minfreq = new int[26];\n        for (int i = 0; i < A[0].length(); i++) {\n                minfreq[A[0].charAt(i) - 'a']++;\n        }\n        for (int i = 1; i < A.length; i++) {\n                int[] freq = new int[26];\n                for (int j = 0; j < A[i].length(); j++) {\n                        char c = A[i].charAt(j);\n                        if (minfreq[c - 'a'] > 0) {\n                                freq[c - 'a']++;\n                                if (freq[c - 'a'] == minfreq[c - 'a']) {\n                                        for (int k = 0; k < minfreq[c - 'a']; k++) {\n                                                result.add(c);\n                                        }\n                                        minfreq[c - 'a'] = 0;\n                                }\n                        }\n                }\n        }\n        return result;\n}", "192": "public static int maxUniqueSplit(String s) {\n                int result = 1;\n                int total = 2^(s.length()-1);\n                int mask = 0;\n                while(mask < total) {\n                        if(popcount(mask) < result) {\n                                mask++;\n                                continue;\n                        }\n                        Set<String> lookup = new HashSet;\n                        List<String> curr = new ArrayList;\n                        int base = total/2;\n                        for(int i = 0; i < s.length(); i++) {\n                                curr.add(s.charAt(i));\n                                if((mask&base) || base == 0) {\n                                        if(lookup.contains(\"\".join(curr))) {\n                                                mask = (mask | (base-1)) + 1;\n                                                break;\n                                        }\n                                        lookup.add(\"\".join(curr));\n                                        curr = new ArrayList;\n                                }\n                                base >>= 1;\n                        }\n                        else {\n                                result = Math.max(result, lookup.size());\n                                mask++;\n                        }\n                }\n                return result;\n}", "193": "class Solution {\n    public int numTrees(int n) {\n        if (n == 0) {\n            return 1;\n        }\n        int combination(int n, int k) {\n            int count = 1;\n            for (int i = 1; i < k + 1; i++) {\n                count = count * (n - i + 1) / i;\n            }\n            return count;\n        }\n        return combination(2 * n, n) - combination(2 * n, n - 1);\n    }\n}", "194": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic boolean isValidBST(TreeNode root) {\n        prev, cur = None, root\n        while cur:\n                if cur.left is None:\n                        if prev and prev.val >= cur.val:\n                                return False\n                        prev = cur\n                        cur = cur.right\n                else:\n                        node = cur.left\n                        while node.right and node.right != cur:\n                                node = node.right\n                        if node.right is None:\n                                node.right = cur\n                                cur = cur.left\n                        else:\n                                if prev and prev.val >= cur.val:\n                                        return False\n                                node.right = None\n                                prev = cur\n                                cur = cur.right\n        return True\n}", "195": "public class Lookup {\n    private List<Person> persons;\n    private List<Time> times;\n    \n    public Lookup(List<Person> persons, List<Time> times) {\n        this.persons = persons;\n        this.times = times;\n    }\n    \n    public Person getPerson(Time time) {\n        int index = Collections.binarySearch(this.times, time);\n        return this.persons.get(index);\n    }\n}", "196": "public class shortestPathLength {\n    public static int shortestPathLength(int[][] graph) {\n                int[][] dp = new int[1 << len(graph)][len(graph)];\n                for (int i = 0; i < len(graph); i++) {\n                        dp[1 << i][i] = 0;\n                        q.append((1 << i, i))\n                }\n                while (!q.isEmpty()) {\n                        state, node = q.poll();\n                        steps = dp[state][node];\n                        for (int nei : graph[node]) {\n                                new_state = state | (1 << nei);\n                                if (dp[new_state][nei] == float(\"inf\")) {\n                                        dp[new_state][nei] = steps+1;\n                                        q.add((new_state, nei))\n                                }\n                        }\n                }\n                return min(dp[-1]);\n    }\n}", "197": "public boolean validUtf8(int[] data) {\n        int count = 0;\n        for(int c : data) {\n                if(count == 0) {\n                        if((c >> 5) == 0b110) {\n                                count = 1;\n                        } else if((c >> 4) == 0b1110) {\n                                count = 2;\n                        } else if((c >> 3) == 0b11110) {\n                                count = 3;\n                        } else if((c >> 7)) {\n                                return false;\n                        }\n                } else {\n                        if((c >> 6) != 0b10) {\n                                return false;\n                        }\n                        count--;\n                }\n        }\n        return count == 0;\n}", "198": "class Solution {\n    public int bitwiseComplement(int N) {\n        int mask = 1;\n        while (N > mask) {\n            mask = mask*2+1;\n        }\n        return mask-N;\n    }\n}", "199": "public class Solution {\n    public boolean isSelfCrossing(int[] x) {\n                if (x.length >= 5 && x[3] == x[1] && x[4] + x[0] >= x[2])\n                        return true;\n                for (int i = 3; i < x.length; i++) {\n                        if (x[i] >= x[i - 2] && x[i - 3] >= x[i - 1])\n                                return true;\n                        elif (i >= 5 && x[i - 4] <= x[i - 2] && x[i] + x[i - 4] >= x[i - 2] && \\\n                                                        x[i - 1] <= x[i - 3] && x[i - 5] + x[i - 1] >= x[i - 3])\n                                return true;\n                }\n                return false;\n    }\n}"}}, "C++ - Python": {"ID": {"0": 1217, "1": 1457, "2": 1769, "3": 479, "4": 1758, "5": 1904, "6": 910, "7": 212, "8": 491, "9": 1665, "10": 691, "11": 1590, "12": 1103, "13": 904, "14": 923, "15": 191, "16": 554, "17": 1254, "18": 456, "19": 661, "20": 474, "21": 911, "22": 104, "23": 424, "24": 495, "25": 4, "26": 592, "27": 1260, "28": 869, "29": 1400, "30": 1861, "31": 126, "32": 1830, "33": 521, "34": 71, "35": 670, "36": 882, "37": 1647, "38": 896, "39": 274, "40": 390, "41": 1654, "42": 1496, "43": 1909, "44": 1900, "45": 771, "46": 1051, "47": 1727, "48": 1886, "49": 2, "50": 473, "51": 889, "52": 899, "53": 1672, "54": 242, "55": 564, "56": 1315, "57": 430, "58": 1386, "59": 88, "60": 1578, "61": 1482, "62": 1203, "63": 107, "64": 516, "65": 1685, "66": 572, "67": 1143, "68": 609, "69": 1584, "70": 967, "71": 1340, "72": 1318, "73": 268, "74": 1471, "75": 765, "76": 878, "77": 1184, "78": 653, "79": 798, "80": 970, "81": 1822, "82": 1477, "83": 934, "84": 130, "85": 372, "86": 638, "87": 1169, "88": 1092, "89": 1639, "90": 80, "91": 453, "92": 717, "93": 1202, "94": 405, "95": 623, "96": 257, "97": 1443, "98": 1307, "99": 699}, "C++": {"0": "int minCostToMoveChips(vector<int>& chips) {\n                vector<int> count(2);\n                for (const auto& p : chips) {\n                        ++count[p % 2];\n                }\n                return min(count[0], count[1]);\n        }", "1": "int pseudoPalindromicPaths (TreeNode* root) {\n                int result = 0;\n                vector<pair<TreeNode *, int>> stk = {{root, 0}};\n                while (!stk.empty()) {\n                        auto [node, count] = stk.back(); stk.pop_back();\n                        if (!node) {\n                                continue;\n                        }\n                        count ^= 1 << node->val;\n                        result += int(!node->left && !node->right && (count & (count - 1)) == 0);\n                        stk.emplace_back(node->right, count);\n                        stk.emplace_back(node->left, count);\n                }\n                return result;\n        }", "2": "vector<int> minOperations(string boxes) {\n                vector<int> result(size(boxes)); \n                for (int i = 0, accu = 0, cnt = 0; i < size(boxes); ++i) {\n                result[i] += accu;\n                cnt += (boxes[i] == '1') ? 1 : 0;\n                accu += cnt;\n                }\n                for (int i = size(boxes) - 1, accu = 0, cnt = 0; i >= 0; --i) {\n                        result[i] += accu;\n                        cnt += (boxes[i] == '1') ? 1 : 0;\n                        accu += cnt;\n                }\n                return result;\n        }", "3": "int largestPalindrome(int n) {\n                if (n == 1) {\n                        return 9;\n                }\n                const int upper = pow(10, n) - 1;\n                for (int k = 2; k <= upper; ++k) {\n                        const int left = pow(10, n) - k;\n                        auto s = to_string(left);\n                        reverse(begin(s), end(s));\n                        const int right = stoi(s);\n                        const int d = k * k - right * 4;\n                        if (d < 0) {\n                                continue;\n                        }\n                        if (sqrt(d) == int(sqrt(d)) && k % 2 == int(sqrt(d)) % 2) {\n                                return (static_cast<uint64_t>(left * pow(10, n)) + right) % 1337;\n                        }\n                }\n                return -1;\n        }\nlong long buildPalindrome(int n) {\n                string s = to_string(n);\n                reverse(s.begin(), s.end());\n                return stoll(to_string(n) + s);\n        }", "4": "int minOperations(string s) {\n                int cnt = 0;\n                for (int i = 0; i < size(s); ++i) {\n                        if (s[i] - '0' == i % 2) {\n                                ++cnt;\n                        }\n                }\n                return min(cnt, int(size(s)) - cnt);\n        }", "5": "int numberOfRounds(string startTime, string finishTime) {\n                int start = stoi(startTime.substr(0, 2)) * 60 + stoi(startTime.substr(3));\n                int finish = stoi(finishTime.substr(0, 2)) * 60 + stoi(finishTime.substr(3));\n                if (start > finish) {\n                        finish += 1440;\n                }\n                return max(finish / 15 - (start + 15 - 1) / 15, 0);\n        }", "6": "int smallestRangeII(vector<int>& A, int K) {\n                sort(A.begin(), A.end());\n                int result = A.back() - A.front();\n                for (int i = 0; i < A.size() - 1; ++i) {\n                        result = min(result,\n                                                max(A.back() - K, A[i] + K) - \n                                                min(A.front() + K, A[i + 1] - K));\n                }\n                return result;\n        }", "7": "vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n                unordered_set<string> ret;\n                vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));\n                string cur;\n                TrieNode trie;\n                for (const auto& word : words) {\n                        trie.Insert(word);\n                }\n                for (int i = 0; i < board.size(); ++i) {\n                        for (int j = 0; j < board[0].size(); ++j) {\n                                findWordsDFS(board, visited, &trie, i, j, cur, ret);\n                        }\n                }\n                return vector<string>(ret.begin(), ret.end());\n        }\nvoid findWordsDFS(vector<vector<char>> &grid, vector<vector<bool>> &visited, TrieNode *trie, int i, int j, string cur, unordered_set<string> &ret) {\n                if (!trie || i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size()) {\n                        return;\n                }\n                if (!trie->leaves[grid[i][j] ] visited[i][j]) {\n                        return;\n                }\n                TrieNode *nextNode = trie->leaves[grid[i][j]];\n                cur.push_back(grid[i][j]);\n                if (nextNode->isString) {\n                        ret.insert(cur);\n                }\n                visited[i][j] = true;\n                const vector<pair<int, int>> directions{{0, -1}, {0, 1},\n                                                                                                {-1, 0}, {1, 0}};\n                for (const auto& d : directions) {\n                        findWordsDFS(grid, visited, nextNode, i + d.first, j + d.second, cur, ret); } visited[i][j] = false; }\nbool Insert(const string& s) {\n                        auto* p = this;\n                        for (const auto& c : s) {\n                                if (p->leaves.find(c) == p->leaves.cend()) {\n                                        p->leaves[c] = new TrieNode;\n                                }\n                                p = p->leaves[c];\n                        }\n                        if (p->isString) {\n                                return false;\n                        } else {\n                                p->isString = true;\n                                return true;\n                        }\n                }\n~TrieNode() {\n                        for (auto& kv : leaves) {\n                                if (kv.second) {\n                                        delete kv.second;\n                                }\n                        }\n                }", "8": "vector<vector<int>> findSubsequences(vector<int>& nums) {\n                vector<vector<int>> result;\n                vector<int> seq;\n                findSubsequencesHelper(nums, 0, &seq, &result);\n                return result;\n        }\nvoid findSubsequencesHelper(const vector<int>& nums, int i, vector<int> *seq, vector<vector<int>> *result) {\n                if (seq->size() >= 2) {\n                        result->emplace_back(*seq);\n                }\n                unordered_set<int> lookup;\n                for (; i < nums.size(); ++i) {\n                        if ((seq->empty() || nums[i] >= seq->back()) &&\n                                lookup.find(nums[i]) == lookup.end()) {\n                                lookup.emplace(nums[i]);\n                                seq->emplace_back(nums[i]);\n                                findSubsequencesHelper(nums, i + 1, seq, result);\n                                seq->pop_back();\n                        }\n                }\n        }", "9": "int minimumEffort(vector<vector<int>>& tasks) {\n                sort(begin(tasks), end(tasks),\n                        [](const auto& a, const auto& b) { return a[1] - a[0] < b[1] - b[0]; });\n                int result = 0;\n                for (const auto& task : tasks) { \n                        result = max(result + task[0], task[1]);\n                }\n                return result;\n        }", "10": "int minStickers(vector<string>& stickers, string target) {\n                vector<vector<int>> sticker_counts(stickers.size(), vector<int>(26));\n                unordered_map<string, int> dp;\n                for (int i = 0; i < stickers.size(); ++i) {\n                        for (const auto& c : stickers[i]) {\n                                ++sticker_counts[i][c - 'a'];\n                        }\n                }\n                dp[\"\"] = 0;\n                return minStickersHelper(sticker_counts, target, &dp);\n        }\nint minStickersHelper(const vector<vector<int>>& sticker_counts, const string& target, unordered_map<string, int> *dp) {\n                if (dp->count(target)) {\n                        return (*dp)[target];\n                }\n                int result = numeric_limits<int>::max();\n                vector<int> target_count(26);\n                for (const auto& c : target) {\n                        ++target_count[c - 'a'];\n                }\n                for (const auto& sticker_count : sticker_counts) {\n                        if (sticker_count[target[0] - 'a'] == 0) {\n                                continue; \n                        }\n                        string new_target;\n                        for (int i = 0; i < target_count.size(); ++i) {\n                                if (target_count[i] - sticker_count[i] > 0) {\n                                        new_target += string(target_count[i] - sticker_count[i], 'a' + i);\n                                }\n                        }\n                        if (new_target.length() != target.length()) {\n                                int num = minStickersHelper(sticker_counts, new_target, dp);\n                                if (num != -1) {\n                                        result = min(result, 1 + num);\n                                }\n                        }\n                }\n                (*dp)[target] = (result == numeric_limits<int>::max()) ? -1 : result;\n                return (*dp)[target];\n        }", "11": "int minSubarray(vector<int>& nums, int p) {\n                int residue = 0;\n                for (const auto& num : nums) {\n                        residue = (residue + num) % p;\n                }\n                if (!residue) {\n                        return 0;\n                }\n                int result = size(nums);\n                unordered_map<int, int> lookup = {{0, -1}};\n                for (int i = 0, curr = 0; i < size(nums); ++i) {\n                        curr = (curr + nums[i]) % p;\n                        lookup[curr] = i;\n                        if (lookup.count((curr - residue + p) % p)) {\n                                result = min(result, i - lookup[(curr - residue + p) % p]);\n                        }\n                }\n                return result < size(nums) ? result : -1;\n        }", "12": "vector<int> distributeCandies(int candies, int num_people) {\n                int p = int(sqrt(2 * candies + 0.25) - 0.5);\n                int remaining = candies - (p + 1) * p / 2;\n                int rows = p / num_people, cols = p % num_people;\n                vector<int> result(num_people);\n                for (int i = 0; i < num_people; ++i) {\n                        result[i] = (i < cols) ? (i + 1) * (rows + 1) + (rows * (rows + 1) / 2) * num_people\n                                                                : (i + 1) * rows + ((rows - 1) * rows / 2) * num_people;\n                }\n                result[cols] += remaining;\n                return result;\n        }", "13": "int totalFruit(vector<int>& tree) {\n                unordered_map<int, int> count;\n                int result = 0;\n                for (int i = 0, j = 0; j < tree.size(); ++j) {\n                        ++count[tree[j]];\n                        while (count.size() > 2) {\n                                --count[tree[i]];\n                                if (count[tree[i]] == 0) {\n                                        count.erase(tree[i]);\n                                }\n                                ++i;\n                        }\n                        result = max(result, j - i + 1);\n                }\n                return result;\n        }", "14": "int threeSumMulti(vector<int>& A, int target) {\n                unordered_map<int, uint64_t> count;\n                for (const auto& a : A) {\n                        ++count[a];\n                }\n                uint64_t result = 0;\n                for (const auto& kvp1 : count) {\n                        for (const auto& kvp2 : count) {\n                                int i = kvp1.first, j = kvp2.first, k = target - i - j;\n                                if (!count.count(k)) {\n                                        continue;\n                                }\n                                if (i == j && j == k) {\n                                        result += count[i] * (count[i] - 1) * (count[i] - 2) / 6;\n                                } else if (i == j && j != k) {\n                                        result += count[i] * (count[i] - 1) / 2 * count[k];\n                                } else if (i < j && j < k) {\n                                        result += count[i] * count[j] * count[k];\n                                }\n                        }\n                }\n                return result % static_cast<int>(1e9 + 7);\n        }", "15": "int hammingWeight(uint32_t n) {\n                n = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n                n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n                n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F);\n                n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF);\n                n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF);\n                return n;\n        }", "16": "int leastBricks(vector<vector<int>>& wall) {\n\t\tunordered_map<int, int> widths;\n\t\tauto result = wall.size();\n\t\tfor (const auto& row : wall) {\n\t\t\tfor (auto i = 0, width = 0; i < row.size() - 1; ++i) {\n\t\t\t\tresult = min(result, wall.size() - (++widths[width += row[i]]));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "17": "int closedIsland(vector<vector<int>>& grid) {\n                for (int j = 0; j < grid[0].size(); ++j) {\n                        fill(&grid, 0, j);\n                        fill(&grid, grid.size() - 1, j);\n                }\n                for (int i = 1; i + 1 < grid.size(); ++i) {\n                        fill(&grid, i, 0);\n                        fill(&grid, i, grid[0].size() - 1);\n                }\n                int result = 0;\n                for (int i = 1; i + 1 < grid.size(); ++i) {\n                        for (int j = 1; j + 1 < grid[0].size(); ++j) {\n                                if (fill(&grid, i, j)) {\n                                        ++result;\n                                }\n                        }\n                }\n                return result;\n        }\nbool fill(vector<vector<int>> *grid, int i, int j) {\n                static vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n                if (i < 0 || j < 0 ||\n                        i >= grid->size() || j >= (*grid)[i].size() ||\n                        (*grid)[i][j]) {\n                        return false;\n                }\n                (*grid)[i][j] = 1;\n                for (const auto& [dx, dy] : directions) {\n                        fill(grid, i + dx, j + dy);\n                }\n                return true;\n        }", "18": "bool find132pattern(vector<int>& nums) {\n                int ak = numeric_limits<int>::min();\n                stack<int> st;\n                for (int i = nums.size() - 1; i >= 0; --i) {\n                        if (nums[i] < ak) {\n                                return true;\n                        } else {\n                                while (!st.empty() && nums[i] > st.top()) {\n                                        ak = st.top(), st.pop(); \n                                }\n                        }\n                        st.emplace(nums[i]);\n                }\n                return false;\n        }", "19": "vector<vector<int>> imageSmoother(vector<vector<int>>& M) {\n                const auto& m = M.size(), &n = M[0].size();\n                vector<vector<int>> result(M);\n                for (int i = 0; i < m; ++i) {\n                        for (int j = 0; j < n; ++j) {\n                                result[i][j] = getGray(M, i, j);\n                        }\n                }\n                return result;\n        }\nint getGray(const vector<vector<int>>& M, int i, int j) {\n                const auto& m = M.size(), &n = M[0].size();\n                double total = 0.0;\n                int count = 0;\n                for (int r = -1; r < 2; ++r) {\n                        for (int c = -1; c < 2; ++c) {\n                                const auto& ii = i + r;\n                                const auto& jj = j + c;\n                                if (0 <= ii && ii < m && 0 <= jj && jj < n) {\n                                        total += M[ii][jj];\n                                        ++count;\n                                }\n                        }\n                }\n                return static_cast<int>(total / count);\n        }", "20": "int findMaxForm(vector<string>& strs, int m, int n) {\n                vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n                for (const auto &str : strs) {\n                        int zero_count = 0, one_count = 0;\n                        for (const auto& c : str) {\n                                if (c == '0') {\n                                        ++zero_count;\n                                } else if (c == '1') {\n                                        ++one_count;\n                                }\n                        }\n                        for (int i = m; i - zero_count >= 0; --i) {\n                                for (int j = n; j - one_count >= 0; --j) {\n                                        dp[i][j] = max(dp[i][j], dp[i - zero_count][j - one_count] + 1);\n                                }\n                        }\n                }\n                return dp[m][n];\n        }", "21": "TopVotedCandidate(vector<int> persons, vector<int> times) {\n                int lead = -1;\n                unordered_map<int, int> count;\n                for (int i = 0; i < persons.size(); ++i) {\n                        if (++count[persons[i]] >= count[lead]) {\n                                lead = persons[i];\n                                lookup_.emplace_back(times[i], persons[i]);\n                        }\n                }\n        }\nint q(int t) {\n                return prev(upper_bound(lookup_.cbegin(), lookup_.cend(),\n                                                                make_pair(t, numeric_limits<int>::max())))->second;\n        }", "22": "int maxDepth(TreeNode* root) {\n                if (!root) {\n                        return 0;\n                }\n                return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n        }", "23": "int characterReplacement(string s, int k) {\n                int result = 0, max_count = 0;\n                unordered_map<char, int> count;\n                for (int i = 0; i < s.length(); ++i) {\n                        ++count[s[i]];\n                        max_count = max(max_count, count[s[i]]);\n                        if (result - max_count >= k) {\n                                --count[s[i-result]];\n                        } else {\n                                ++result;\n                        }\n                }\n                return result;\n        }", "24": "int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n                int result = duration * timeSeries.size();\n                for (int i = 1; i < timeSeries.size(); ++i){\n                        result -= max(0, duration - (timeSeries[i] - timeSeries[i - 1]));\n                }\n                return result;\n        }", "25": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n                if ((nums1.size() + nums2.size()) % 2 == 1) {\n                        return findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2 + 1);\n                } else {\n                        return (findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2) +\n                                        findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2 + 1)) / 2.0;\n                }\n        }\nint findKthInTwoSortedArrays(const vector<int>& A, const vector<int>& B, int k) {\n                const int m = A.size();\n                const int n = B.size();\n                if (m > n) {\n                        return findKthInTwoSortedArrays(B, A, k);\n                }\n                int left = 0;\n                int right = m - 1;\n                while (left <= right) {\n                        int mid = left + (right - left) / 2;\n                        if (0 <= k - 1 - mid && k - 1 - mid < n && A[mid] >= B[k - 1 - mid]) {\n                                right = mid - 1;\n                        } else {\n                                left = mid + 1;\n                        }\n                }\n                int Ai_minus_1 = left - 1 >= 0 ? A[left - 1] : numeric_limits<int>::min();\n                int Bj = k - 1 - left >= 0 ? B[k - 1 - left] : numeric_limits<int>::min();\n                return max(Ai_minus_1, Bj);\n        }", "26": "string fractionAddition(string expression) {\n                istringstream iss(expression);\n                int A = 0, B = 1, a, b;\n                char _;\n                while (iss >> a >> _ >> b) {\n                        A = A * b + a * B;\n                        B *= b;\n                        auto g = abs(__gcd(A, B));\n                        A /= g;\n                        B /= g;\n                }\n                return to_string(A) + '/' + to_string(B);\n        }", "27": "vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\n                rotate(&grid, k);\n                return grid;\n        }\nvoid rotate(vector<vector<int>> *grid, int k) {\n                k %= grid->size() * (*grid)[0].size();\n                reverse(grid, 0, grid->size() * (*grid)[0].size());\n                reverse(grid, 0, k);\n                reverse(grid, k, grid->size() * (*grid)[0].size());\n        }\nvoid reverse(vector<vector<int>> *grid, int start, int end) {\n                for (; start < end; ++start, --end) {\n                        int start_r = start / (*grid)[0].size();\n                        int start_c = start % (*grid)[0].size();\n                        int end_r = (end - 1) / (*grid)[0].size();\n                        int end_c = (end - 1) % (*grid)[0].size();\n                        swap((*grid)[start_r][start_c], (*grid)[end_r][end_c]);\n                }\n        }", "28": "bool reorderedPowerOf2(int N) {\n                vector<int> count = counter(N);\n                for (int i = 0; i < 31; ++i) {\n                        if (count == counter(1 << i)) {\n                                return true;\n                        }\n                }\n                return false;\n        }\nvector<int> counter(int N) {\n                vector<int> result(10, 0);\n                for (; N; N /= 10) {\n                        ++result[N % 10];\n                }\n                return result;\n        }", "29": "bool canConstruct(string s, int k) {\n                bitset<26> odd;\n                for (const auto& c : s) {\n                        odd.flip(c - 'a');\n                }\n                return odd.count() <= k && k <= s.length();\n        }", "30": "vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {\n                vector<vector<char>> result(size(box[0]), vector<char>(size(box), '.'));\n                for (int i = 0; i < size(box); ++i) {\n                        for (int j = size(box[0]) - 1, k = size(box[0]) - 1; j >= 0; --j) {\n                                if (box[i][j] == '.') {\n                                        continue;\n                                }\n                                if (box[i][j] == '*') {\n                                        k = j;\n                                }\n                                result[k--][size(box) -1 - i] = box[i][j];\n                        }\n                }\n                return result;\n        }", "31": "vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n                unordered_set<string> words(cbegin(wordList), cend(wordList));\n                if (!words.count(endWord)) {\n                        return {};\n                }\n                unordered_map<string, unordered_set<string>> tree;\n                unordered_set<string> left = {beginWord}, right = {endWord};\n                bool is_found = false, is_reversed = false;\n                while (!empty(left)) {\n                        for (const auto& word : left) {\n                                words.erase(word);\n                        }\n                        unordered_set<string> new_left;\n                        for (const auto& word : left) {\n                                auto new_word = word;\n                                for (int i = 0; i < size(new_word); ++i) {\n                                        char prev = new_word[i];\n                                        for (int j = 0; j < 26; ++j) {\n                                                new_word[i] = 'a' + j;\n                                                if (!words.count(new_word)) {\n                                                        continue;\n                                                }\n                                                if (right.count(new_word)) {\n                                                        is_found = true;\n                                                } else {\n                                                        new_left.emplace(new_word);\n                                                }\n                                                if (!is_reversed) {\n                                                        tree[new_word].emplace(word);\n                                                } else {\n                                                        tree[word].emplace(new_word);\n                                                }\n                                        }\n                                        new_word[i] = prev;\n                                }\n                        }\n                        if (is_found) {\n                                break;\n                        }\n                        left = move(new_left);\n                        if (size(left) > size(right)) {\n                                swap(left, right);\n                                is_reversed = !is_reversed;\n                        }\n                }\n                return backtracking(tree, beginWord, endWord);\n        }\nvector<vector<string>> backtracking( const unordered_map<string, unordered_set<string>>& tree, const string& beginWord, const string& word) {\n                vector<vector<string>> result;\n                if (word == beginWord) {\n                        result.emplace_back(vector<string>({beginWord}));\n                } else {\n                        if (tree.count(word)) {\n                                for (const auto& new_word : tree.at(word)) {\n                                        if (word == new_word) {\n                                                continue;\n                                        }\n                                        auto paths = backtracking(tree, beginWord, new_word);\n                                        for (auto& path : paths) {\n                                                path.emplace_back(word);\n                                                result.emplace_back(move(path));\n                                        }\n                                }\n                        }\n                }\n                return result;\n        }", "32": "int makeStringSorted(string s) { \n                static const int MOD = 1e9 + 7;\n                array<int, 26> count = {0};\n                int result = 0, comb_total = 1;\n                for (int i = size(s) - 1; i >= 0; --i) {\n                        int num = s[i] - 'a';\n                        comb_total = ((comb_total * int64_t(size(s) - i) % MOD) * inverse(++count[num], MOD)) % MOD;\n                        result = (result + ((comb_total * accumulate(cbegin(count), cbegin(count) + num, 0LL) % MOD) * inverse(size(s) - i, MOD) % MOD)) % MOD;\n                }\n                return result;\n        }\nint inverse(int n, int m) {\n                static vector<int> inv = {0, 1};\n                for (int i = size(inv); i <= n; ++i) { \n                        inv.emplace_back(inv[m % i] * int64_t(m - m / i) % m); \n                }\n                return inv[n];\n        }", "33": "int findLUSlength(string a, string b) {\n                if (a == b) {\n                        return -1;\n                }\n                return max(a.length(), b.length());\n        }", "34": "string simplifyPath(string path) {\n                vector<string> names;\n                vector<string> tokens(move(split(path, '/')));\n                for (const auto& token : tokens) {\n                        if (token == \"..\" && !names.empty()) {\n                                names.pop_back();\n                        } else if (token != \"..\" && token != \".\" && !token.empty()) {\n                                names.emplace_back(token);\n                        }\n                }\n                return string(\"/\").append(join(names, '/'));\n        }\nvector<string> split(const string& s, const char delim) {\n                vector<string> tokens;\n                stringstream ss(s);\n                string token;\n                while (getline(ss, token, delim)) {\n                        tokens.emplace_back(token);\n                }\n                return tokens;\n        }\nstring join(const vector<string>& names, const char delim) {\n                ostringstream ss;\n                if (!names.empty()) {\n                        const string delim_str(1, delim);\n                        copy(names.cbegin(), prev(names.cend()),\n                                ostream_iterator<string>(ss, delim_str.c_str()));\n                        ss << names.back();\n                }\n                return ss.str();\n        }", "35": "int maximumSwap(int num) {\n                string digits = to_string(num);\n                int left = 0, right = 0;\n                int max_idx = digits.length() - 1;\n                for (int i = digits.length() - 1; i >= 0; --i) {\n                        if (digits[i] > digits[max_idx]) {\n                                max_idx = i;\n                        } else if (digits[max_idx] > digits[i]) {\n                                left = i;\n                                right = max_idx;\n                        }\n                }\n                swap(digits[left], digits[right]);\n                return stoi(digits);\n        }", "36": "int reachableNodes(vector<vector<int>>& edges, int M, int N) {\n                using P = pair<int, int>;\n                vector<vector<P>> adj(N);\n                for (const auto& edge: edges) {\n                        int u = edge[0], v = edge[1], w = edge[2];\n                        adj[u].emplace_back(v, w);\n                        adj[v].emplace_back(u, w);\n                }\n                unordered_map<int, int> best;\n                best[0] = 0;\n                unordered_map<int, unordered_map<int, int>> count;\n                int result = 0;\n                priority_queue<P, vector<P>, greater<P>> min_heap;\n                min_heap.emplace(0, 0);\n                while (!min_heap.empty()) {\n                        int curr_total, u;\n                        tie(curr_total, u) = min_heap.top(); min_heap.pop();\n                        if (best.count(u) && best[u] < curr_total) {\n                                continue;\n                        }\n                        ++result;\n                        for (const auto& kvp: adj[u]) {\n                                int v, w;\n                                tie(v, w) = kvp;\n                                count[u][v] = min(w, M - curr_total);\n                                int next_total = curr_total + w + 1;\n                                if (next_total <= M && \n                                        (!best.count(v) next_total < best[v])) {\n                                        best[v] = next_total;\n                                        min_heap.emplace(next_total, v);\n                                }\n                        }\n                }\n                for (const auto& edge: edges) {\n                        int u = edge[0], v = edge[1], w = edge[2];\n                        result += min(w, count[u][v] + count[v][u]);\n                }\n                return result;\n        }", "37": "int minDeletions(string s) {\n                vector<int> count(26);\n                for (const auto& c : s) {\n                        ++count[c - 'a'];\n                }\n                int result = 0;\n                unordered_set<int> lookup;\n                for (int i = 0; i < 26; ++i) {\n                        for (int c = count[i]; c > 0; --c, ++result) {\n                                if (!lookup.count(c)) {\n                                        lookup.emplace(c);\n                                        break;\n                                }\n                        }\n                }\n                return result;\n        }", "38": "bool isMonotonic(vector<int>& A) {\n                bool inc = false, dec = false;\n                for (int i = 0; i + 1 < A.size(); ++i) {\n                        if (A[i] < A[i + 1]) {\n                                inc = true;\n                        } else if (A[i] > A[i + 1]) {\n                                dec = true;\n                        }\n                }\n                return !inc || !dec;\n        }", "39": "int hIndex(vector<int>& citations) {\n                const auto n = citations.size();\n                vector<int> count(n + 1, 0);\n                for (const auto& x : citations) {\n                        if (x >= n) {\n                                ++count[n];\n                        } else {\n                                ++count[x];\n                        }\n                }\n                int h = 0;\n                for (int i = n; i >= 0; --i) {\n                        h += count[i];\n                        if (h >= i) {\n                                return i;\n                        }\n                }\n                return h;\n        }", "40": "int lastRemaining(int n) {\n                int start = 1;\n                for (int step = 2, direction = 1; n > 1; n /= 2, step *= 2, direction *= -1) {\n                        start += direction * (step * (n / 2) - step / 2);\n                }\n                return start;\n        }\n", "41": "int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\n                int max_f = *max_element(cbegin(forbidden), cend(forbidden));\n                int max_val = (a >= b) ? x + b : max(x, max_f) + a + b; \n                vector<unordered_set<int>> lookup(2); \n                for (const auto& pos : forbidden) {\n                        lookup[0].emplace(pos);\n                        lookup[1].emplace(pos);\n                }\n                int result = 0;\n                vector<pair<int, int>> q = {{0, true}};\n                lookup[0].emplace(0);\n                while (!empty(q)) {\n                        vector<pair<int, int>> new_q;\n                        for (const auto& [pos, can_back] : q) {\n                                if (pos == x) {\n                                        return result;\n                                }\n                                if (pos + a <= max_val && !lookup[0].count(pos + a)) {\n                                        lookup[0].emplace(pos + a);\n                                        new_q.emplace_back(pos + a, true);\n                                }\n                                if (!can_back) {\n                                        continue;\n                                }\n                                if (pos - b >= 0 && !lookup[1].count(pos - b)) {\n                                        lookup[1].emplace(pos - b);\n                                        new_q.emplace_back(pos - b, false);\n                                }\n                        }\n                        q = move(new_q);\n                        ++result;\n                }\n                return -1;\n        }", "42": "bool isPathCrossing(string path) {\n                unordered_set<pair<int, int>, PairHash<int>> lookup = {{0, 0}};\n                int x = 0, y = 0;\n                for (const auto& c : path) {\n                        switch(c) {\n                                case 'E':\n                                        ++x;\n                                        break;\n                                case 'W':\n                                        --x;\n                                        break;\n                                case 'N':\n                                        ++y;\n                                        break;\n                                case 'S':\n                                        --y;\n                                        break;\n                        }\n                        if (!lookup.emplace(x, y).second) {\n                                return true;\n                        }\n                }\n                return false;\n        }\nsize_t operator()(const pair<T, T>& p) const {\n                        size_t seed = 0;\n                        seed ^= std::hash<T>{}(p.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        seed ^= std::hash<T>{}(p.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        return seed;\n                }", "43": "bool canBeIncreasing(vector<int>& nums) {\n                bool deleted = false;\n                for (int i = 1; i < size(nums); ++i) {        \n                        if (nums[i] > nums[i - 1]) {\n                                continue;\n                        }\n                        if (deleted) {\n                                return false;\n                        }\n                        deleted = true;\n                        if (i >= 2 && nums[i - 2] > nums[i]) { \n                                nums[i] = nums[i - 1];\n                        }\n                }\n                return true;\n        }", "44": "vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n                Lookup lookup;\n                return memoization(n, firstPlayer - 1, n - secondPlayer, &lookup);\n        }\nvector<int> memoization(int t, int l, int r, Lookup *lookup) {\n                if (!lookup->count(tuple(t, l, r))) {\n                        if (l == r) {\n                                return {1, 1};\n                        }\n                        if (l > r) { \n                                swap(l, r);\n                        }\n                        vector<int> result = {numeric_limits<int>::max(), 0};\n                        for (int i = 0; i <= l; ++i) {\n                                const auto nt = (t + 1) / 2;\n                                const auto pair_cnt = t / 2;\n                                const auto l_lose_cnt = l - i;\n                                const auto l_win_cnt = i + 1;\n                                int min_j = max(l_lose_cnt, r - (pair_cnt - l_lose_cnt)); \n                                int max_j = min(r - l_win_cnt, (nt - l_win_cnt) - 1); \n                                for (int j = min_j; j <= max_j; ++j) {\n                                        const auto& tmp = memoization(nt, i, j, lookup);\n                                        result = {min(result[0], tmp[0] + 1), max(result[1], tmp[1] + 1)};\n                                }\n                        }\n                        (*lookup)[tuple(t, l, r)] = move(result);\n                }\n                return (*lookup)[tuple(t, l, r)];\n        }\nsize_t operator()(const tuple<A, B, C>& p) const {\n                        size_t seed = 0;\n                        A a; B b; C c;\n                        tie(a, b, c) = p;\n                        seed ^= std::hash<A>{}(a) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        seed ^= std::hash<B>{}(b) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        seed ^= std::hash<C>{}(c) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        return seed;\n                }", "45": "int numJewelsInStones(string J, string S) {\n                unordered_set<char> lookup;\n                for (const auto& j : J) {\n                        lookup.emplace(j);\n                }\n                int result = 0;\n                for (const auto& s : S) {\n                        result += lookup.count(s);\n                }\n                return result;\n        }", "46": "int heightChecker(vector<int>& heights) {\n                vector<int> sorted_heights{heights};\n                sort(sorted_heights.begin(), sorted_heights.end());\n                int result = 0;\n                for (int i = 0; i < heights.size(); ++i) {\n                        result += static_cast<int>(heights[i] != sorted_heights[i]);\n                }\n                return result;\n        }", "47": "int largestSubmatrix(vector<vector<int>>& matrix) {\n                int resuilt = 0;\n                for (int c = 0; c < size(matrix[0]); ++c) {\n                        int h = 0;\n                        for (int r = 0; r < size(matrix); ++r) {\n                                h = (matrix[r][c] == 1) ? h + 1 : 0;\n                                matrix[r][c] = h;\n                        }\n                }\n                int result = 0;\n                for (auto& row : matrix) {\n                        sort(begin(row), end(row));\n                        for (int c = 0; c < size(row); ++c) {\n                                result = max(result, int(size(row) - c) * row[c]);\n                        }\n                }\n                return result;\n        }", "48": "bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {\n                vector<function<bool (int, int)>> checks = {\n                        [&mat, &target](int i, int j) { return mat[i][j] == target[i][j]; },\n                        [&mat, &target](int i, int j) { return mat[i][j] == target[j][size(mat) - 1 - i]; },\n                        [&mat, &target](int i, int j) { return mat[i][j] == target[size(mat) - 1 - i][size(mat[0]) - 1 - j]; },\n                        [&mat, &target](int i, int j) { return mat[i][j] == target[size(mat[0]) - 1 - j][i]; },\n                };\n                const auto& traverse = [&mat, &target](const auto& check) {\n                        for (int i = 0; i < size(mat); ++i) {\n                                for (int j = 0; j < size(mat[0]); ++j) {\n                                        if (!check(i, j)) {\n                                                return false;\n                                        }\n                                }\n                        }\n                        return true;\n                };\n                for (const auto& check : checks) {\n                        if (traverse(check)) {\n                                return true;\n                        }\n                }\n                return false;\n        }", "49": "ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n                ListNode dummy{0};\n                auto curr = &dummy;\n                auto carry = 0;\n                while (l1 l2 carry) {\n                        auto a = l1? l1->val : 0, b = l2? l2->val : 0;\n                        auto val = carry + a + b;\n                        curr->next = new ListNode(val % 10);\n                        carry = val / 10;\n                        l1 = l1 ? l1->next : nullptr;\n                        l2 = l2 ? l2->next : nullptr;\n                        curr = curr->next;\n                }\n                return dummy.next;\n        }", "50": "bool makesquare(vector<int>& nums) {\n                int sum = accumulate(nums.begin(), nums.end(), 0);\n                if (sum % 4) {\n                        return false;\n                }\n                const auto side_len = sum / 4;\n                const auto all = (1 << nums.size()) - 1;\n                vector<int> used_subsets;\n                vector<bool> valid_half_subsets(1 << nums.size());\n                for (int subset = 0; subset <= all; ++subset) {\n                        int subset_sum = 0;\n                        for (int i = 0; i < nums.size(); ++i) {\n                                if (subset & (1 << i)) {\n                                        subset_sum += nums[i];\n                                }\n                        }\n                        if (subset_sum == side_len) {\n                                for (const auto& used_subset : used_subsets) {\n                                        if ((used_subset & subset) == 0) {\n                                                int valid_half_subset = used_subset | subset;\n                                                valid_half_subsets[valid_half_subset] = true;\n                                                if (valid_half_subsets[all ^ valid_half_subset]) {\n                                                        return true;\n                                                }\n                                        }\n                                }\n                                used_subsets.emplace_back(subset);\n                        }\n                }\n                return false;\n        }", "51": "TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\n                vector<TreeNode*> s;\n                s.emplace_back(new TreeNode(pre[0]));\n                for (int i = 1, j = 0; i < pre.size(); ++i) {\n                        auto node = new TreeNode(pre[i]);\n                        while (s.back()->val == post[j]) {\n                                s.pop_back(), ++j;\n                        }\n                        if (s.back()->left == nullptr) {\n                                s.back()->left = node;\n                        } else {\n                                s.back()->right = node;\n                        }\n                        s.emplace_back(node);\n                }\n                return s[0];\n        }", "52": "string orderlyQueue(string S, int K) {\n                if (K == 1) {\n                        auto result{S};\n                        for (int i = 1; i < S.length(); ++i) {\n                                result = min(result, S.substr(i) + S.substr(0, i));\n                        }\n                        return result;\n                }\n                sort(S.begin(), S.end());\n                return S;\n        }", "53": "int maximumWealth(vector<vector<int>>& accounts) {\n                int result = 0;\n                for (const auto& account : accounts) {\n                        int total = accumulate(cbegin(account), cend(account), 0);\n                        result = max(result, total);\n                }\n                return result;\n        }", "54": "bool isAnagram(string s, string t) {\n                if (size(s) != size(t)) {\n                        return false;\n                }\n                unordered_map<char, int> count;\n                for (const auto& c: s) {\n                        ++count[c];\n                }\n                for (const auto& c: t) {\n                        --count[c];\n                        if (count[c] < 0) {\n                                return false;\n                        }\n                }\n                return true;\n        }", "55": "string nearestPalindromic(string n) {\n                const auto l = n.size();\n                unordered_set<long long> candidates;\n                candidates.emplace(static_cast<long long>(pow(10, l)) + 1);\n                candidates.emplace(static_cast<long long>(pow(10, l - 1)) - 1);\n                auto prefix = stol(n.substr(0, (l + 1) / 2));\n                for (long long i = -1; i <= 1; ++i) {\n                        auto p = to_string(prefix + i);\n                        auto pp = p + string(p.rbegin() + (l % 2), p.rend());\n                        candidates.emplace(stol(pp));\n                }\n                long long num = stol(n), closest_val = numeric_limits<long long>::max();\n                candidates.erase(num);\n                for (const auto& val : candidates) {\n                        if (abs(val - num) < abs(closest_val - num)) {\n                                closest_val = val;\n                        } else if (abs(val - num) == abs(closest_val - num)) {\n                                closest_val = min(closest_val, val);\n                        }\n                }\n                return to_string(closest_val);\n        }", "56": "int sumEvenGrandparent(TreeNode* root) {\n                return sumEvenGrandparentHelper(root, 1, 1);\n        }\nint sumEvenGrandparentHelper(TreeNode *root, int p, int gp) {\n                return root\n                        ? sumEvenGrandparentHelper(root->left, root->val, p) +\n                                sumEvenGrandparentHelper(root->right, root->val, p) +\n                                (gp % 2 == 0 ? root->val : 0)\n                        : 0;\n        }", "57": "Node* flatten(Node* head) {\n                for (auto curr = head; curr; curr = curr->next) {\n                        if (!curr->child) {\n                                continue;\n                        }\n                        auto curr_next = curr->next;\n                        curr->child->prev = curr;\n                        curr->next = curr->child;\n                        auto last_child = curr;\n                        while (last_child->next) {\n                                last_child = last_child->next;\n                        }\n                        if (curr_next) {\n                                last_child->next = curr_next;\n                                curr_next->prev = last_child;\n                        }\n                        curr->child = nullptr;\n                }\n                return head;\n        }", "58": "int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats) {\n                unordered_map<int, unordered_map<int, bool>> lookup;\n                for (const auto& seat : reservedSeats) {\n                        if (2 <= seat[1] && seat[1] <= 5) {\n                                lookup[seat[0]][0] = true;\n                        }\n                        if (4 <= seat[1] && seat[1] <= 7) {\n                                lookup[seat[0]][1] = true;\n                        }\n                        if (6 <= seat[1] && seat[1] <= 9) {\n                                lookup[seat[0]][2] = true;\n                        }\n                }\n                int result = 2 * n;\n                for (auto& [_, reserved] : lookup) {\n                        if (!reserved[0] && !reserved[2]) {\n                                continue;\n                        }\n                        if (!reserved[0] !reserved[1] !reserved[2]) {\n                                --result;\n                                continue;\n                        }\n                        result -= 2;\n                }\n                return result;\n        }", "59": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n                int i = m + n;\n                while (m > 0 && n > 0) {\n                        if (nums1[m - 1] > nums2[n - 1]) {\n                                nums1[i - 1] = nums1[m - 1];\n                                --m;\n                        } else {\n                                nums1[i - 1] = nums2[n - 1];\n                                --n;\n                        }\n                        --i;\n                }\n                while (n > 0) {\n                        nums1[i - 1] = nums2[n - 1];\n                        --n;\n                        --i;\n                }\n        }", "60": "int minCost(string s, vector<int>& cost) {\n                int result = 0, accu = 0, max_cost = 0;\n                for (int i = 0; i < s.length(); ++i) {\n                        if (i && s[i] != s[i - 1]) {\n                                result += accu - max_cost;\n                                accu = max_cost = 0;\n                        }\n                        accu += cost[i];\n                        max_cost = max(max_cost, cost[i]);\n                }\n                result += accu - max_cost;\n                return result;\n        }", "61": "int minDays(vector<int>& bloomDay, int m, int k) {\n                if (m * k > bloomDay.size()) {\n                        return -1;\n                }\n                int left = 1, right = *max_element(cbegin(bloomDay), cend(bloomDay));\n                while (left <= right) {\n                        const auto& mid = left + (right - left) / 2;\n                        if (check(bloomDay, m, k, mid)) {\n                                right = mid - 1;\n                        } else {\n                                left = mid + 1;\n                        }\n                }\n                return left;\n        }\nbool check(const vector<int>& bloomDay, int m, int k, int x) {\n                int result = 0, count = 0;\n                for (const auto& d : bloomDay) {\n                        count = (d <= x) ? count + 1 : 0;\n                        if (count == k) {\n                                count = 0;\n                                if (++result == m) {\n                                        break;\n                                }\n                        }\n                }\n                return result >= m;\n        }", "62": "vector<int> sortItems(int n, int m, vector<int>& group_id, vector<vector<int>>& beforeItems) {\n                for (int i = 0; i < n; ++i) {\n                        if (group_id[i] == -1) {\n                                group_id[i] = m++;\n                        }\n                }\n                Topo global_group;\n                for (int i = 0; i < m; ++i) {\n                        global_group.addNode(i);\n                }\n                unordered_map<int, Topo> local_groups;\n                for (int i = 0; i < n; ++i) {\n                        local_groups[group_id[i]].addNode(i);\n                }\n                for (int i = 0; i < n; ++i) {\n                        for (const auto& j : beforeItems[i]) {\n                                if (group_id[i] == group_id[j]) {\n                                        local_groups[group_id[i]].addEdge(j, i);\n                                } else {\n                                        global_group.addEdge(group_id[j], group_id[i]);\n                                }\n                        }\n                }\n                vector<int> result;\n                const auto& global_order = global_group.sort();\n                if (!global_order) {\n                        return {};\n                }                \n                for (const auto& i : *global_order) {\n                        const auto& local_order = local_groups[i].sort();\n                        if (!local_order) {\n                                return {};\n                        }\n                        for (const auto& x : *local_order) {\n                                result.emplace_back(x);\n                        }\n                }\n                return result;\n        }\nvoid addNode(int node) {\n                        nodes_.emplace(node);\n                }\nvoid addEdge(int from, int to) {\n                        addNode(from), addNode(to);\n                        in_degree_[to].emplace(from);\n                        out_degree_[from].emplace(to);\n                }\nunique_ptr<vector<int>> sort() {\n                        queue<int> q;\n                        auto result = make_unique<vector<int>>();\n                        for (const auto& node : nodes_) {\n                                if (!in_degree_.count(node)) {\n                                        q.emplace(node);\n                                }\n                        }\n                        while (!q.empty()) {\n                                auto node = q.front(); q.pop();\n                                result->emplace_back(node);\n                                for (const auto& nei : out_degree_[node]) {\n                                        in_degree_[nei].erase(node);\n                                        if (in_degree_[nei].empty()) {\n                                                in_degree_.erase(nei);\n                                                q.emplace(nei);\n                                        }\n                                }\n                        }                        \n                        if (result->size() < nodes_.size()) {\n                                return nullptr;\n                        }\n                        return result;\n                }", "63": "vector<vector<int>> levelOrderBottom(TreeNode* root) {\n                vector<vector<int>> result;\n                queue<TreeNode *> que;\n                if (root != nullptr) {\n                        que.emplace(root);\n                }\n                while (!que.empty()) {\n                        vector<int> level;\n                        int size = que.size();\n                        for (int i = 0; i < size; i++) {\n                                auto *front = que.front();\n                                que.pop();\n                                level.emplace_back(front->val);\n                                if (front->left != nullptr) {\n                                        que.emplace(front->left);\n                                }\n                                if (front->right != nullptr) {\n                                        que.emplace(front->right);\n                                }\n                        }\n                        result.emplace_back(move(level));\n                }\n                reverse(result.begin(), result.end());\n                return result;\n        }", "64": "int longestPalindromeSubseq(string s) {\n                if (s == string(s.rbegin(), s.rend())) { \n                        return s.length();\n                }\n                vector<vector<int>> dp(2, vector<int>(s.size(), 1));\n                for (int i = s.length() - 2; i >= 0; --i) {\n                        for (int j = i + 1; j < s.length(); ++j) {\n                                if (s[i] == s[j]) {\n                                        dp[i % 2][j] = (i + 1 <= j - 1) ? 2 + dp[(i + 1) % 2][j - 1] : 2;\n                                } else {\n                                        dp[i % 2][j] = max(dp[(i + 1) % 2][j], dp[i % 2][j - 1]);\n                                }\n                        }\n                }\n                return dp[0][s.length() - 1];\n        }", "65": "vector<int> getSumAbsoluteDifferences(vector<int>& nums) {\n                int prefix = 0, suffix = accumulate(cbegin(nums), cend(nums), 0);\n                vector<int> result;\n                for (int i = 0; i < size(nums); ++i) {\n                        suffix -= nums[i];\n                        result.emplace_back((i * nums[i] - prefix) + (suffix - ((size(nums) - 1) - i) * nums[i]));\n                        prefix += nums[i];\n                }\n                return result;\n        }", "66": "bool isSubtree(TreeNode* s, TreeNode* t) {\n                return preOrderTraverse(s, t);\n        }\nbool preOrderTraverse(TreeNode *s, TreeNode *t) {\n                return s && (isSame(s, t) ||\n                                        preOrderTraverse(s->left, t) ||\n                                        preOrderTraverse(s->right, t));\n        }\nbool isSame(TreeNode *x,TreeNode *y) {\n                if (!x && !y) {\n                        return true;\n                }\n                if (!x !y) {\n                        return false;\n                }\n                return x->val == y->val &&\n                        isSame(x->left, y->left) &&\n                        isSame(x->right, y->right);\n        }", "67": "int longestCommonSubsequence(string text1, string text2) {\n                                if (text1.length() < text2.length()) {\n                        return longestCommonSubsequence(text2, text1);\n                }\n                vector<vector<int>> dp(2, vector<int>(text2.length() + 1));\n                for (int i = 1; i <= text1.length(); ++i) {\n                        for (int j = 1; j <= text2.length(); ++j) {\n                                dp[i % 2][j] = (text1[i - 1] == text2[j - 1])\n                                                        ? dp[(i - 1) % 2][j - 1] + 1\n                                                        : max(dp[(i - 1) % 2][j], dp[i % 2][j - 1]);\n                        }\n                }\n                return dp[text1.length() % 2][text2.length()]; }", "68": "vector<vector<string>> findDuplicate(vector<string>& paths) {\n                unordered_map<string, vector<string>> files;\n                for (const auto& path : paths) {\n                        stringstream ss(path);\n                        string root;\n                        string s;\n                        getline(ss, root, ' ');\n                        while (getline(ss, s, ' ')) {\n                                auto fileName = root + '/' + s.substr(0, s.find('('));\n                                auto fileContent = s.substr(s.find('(') + 1, s.find(')') - s.find('(') - 1);\n                                files[fileContent].emplace_back(fileName);\n                        }\n                }\n                vector<vector<string>> result;\n                for (const auto& file : files) {\n                        if (file.second.size() > 1) {\n                                result.emplace_back(file.second);\n                        }\n                }\n                return result;\n        }", "69": "int minCostConnectPoints(vector<vector<int>>& points) {\n                int result = 0, u = 0; \n                vector<int> dist(size(points), numeric_limits<int>::max());\n                unordered_set<int> lookup;\n                for (int i = 0; i < size(points) - 1; ++i) {\n                        int x0 = points[u][0], y0 = points[u][1];\n                        lookup.emplace(u);\n                        for (int v = 0; v < size(points); ++v) {\n                                if (lookup.count(v)) {\n                                        continue;\n                                }\n                                dist[v] = min(dist[v], abs(points[v][0] - x0) + abs(points[v][1] - y0));\n                        }\n                        int val = numeric_limits<int>::max();\n                        for (int v = 0; v < size(dist); ++v) {\n                                if (dist[v] < val) {\n                                        val = dist[v];\n                                        u = v;\n                                }\n                        }\n                        dist[u] = numeric_limits<int>::max(); \n                        result += val;\n                }\n                return result;\n        }", "70": "vector<int> numsSameConsecDiff(int N, int K) {\n                vector<int> curr(10);\n                iota(curr.begin(), curr.end(), 0);\n                for (int i = 0; i < N - 1; ++i) {\n                        vector<int> next;\n                        for (const auto& x : curr) {\n                                int y = x % 10;\n                                if (x > 0 && y + K < 10) {\n                                        next.emplace_back(x * 10 + y + K);\n                                }\n                                if (x > 0 && K > 0 && y - K >= 0) {\n                                        next.emplace_back(x * 10 + y - K);\n                                }\n                        }\n                        curr = move(next);\n                }\n                return curr;\n        }", "71": "int maxJumps(vector<int>& arr, int d) {\n                vector<vector<int>> left(arr.size());\n                deque<int> decreasing_dq;\n                for (int i = 0; i < arr.size(); ++i) {\n                        if (!decreasing_dq.empty() && i - decreasing_dq.front() == d + 1) {\n                                decreasing_dq.pop_front();\n                        }\n                        while (!decreasing_dq.empty() && arr[decreasing_dq.back()] < arr[i]) {\n                                if (!left[i].empty() && arr[left[i].back()] != arr[decreasing_dq.back()]) {\n                                        left[i].clear();\n                                }\n                                left[i].emplace_back(decreasing_dq.back());\n                                decreasing_dq.pop_back();\n                        }\n                        decreasing_dq.emplace_back(i);\n                }\n                vector<vector<int>> right(arr.size());\n                decreasing_dq.clear();\n                for (int i = arr.size() - 1; i >= 0; --i) {\n                        if (!decreasing_dq.empty() && decreasing_dq.front() - i == d + 1) {\n                                decreasing_dq.pop_front();\n                        }\n                        while (!decreasing_dq.empty() && arr[decreasing_dq.back()] < arr[i]) {\n                                if (!right[i].empty() && arr[right[i].back()] != arr[decreasing_dq.back()]) {\n                                        right[i].clear();\n                                }\n                                right[i].emplace_back(decreasing_dq.back());\n                                decreasing_dq.pop_back();\n                        }\n                        decreasing_dq.emplace_back(i);\n                }\n                int result = 0;\n                vector<int> lookup(arr.size());\n                for (int i = 0; i < arr.size(); ++i) {\n                        result = max(result, dp(arr, d, i, left, right, &lookup));\n                }\n                return result;\n        }\nint dp(const vector<int>& arr, int d, int i, const vector<vector<int>>& left, const vector<vector<int>>& right, vector<int> *lookup) {\n                if ((*lookup)[i]) {\n                        return (*lookup)[i];\n                }\n                (*lookup)[i] = 1;\n                for (const auto& j : left[i]) {\n                        (*lookup)[i] = max((*lookup)[i], dp(arr, d, j, left, right, lookup) + 1);\n                }\n                for (const auto& j : right[i]) {\n                        (*lookup)[i] = max((*lookup)[i], dp(arr, d, j, left, right, lookup) + 1);\n                }\n                return (*lookup)[i];\n        }", "72": "int minFlips(int a, int b, int c) {\n                return number_of_1_bits((a b) ^ c) + number_of_1_bits(a & b & ~c);\n        }\nint number_of_1_bits(int n) {\n                n = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n                n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n                n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F);\n                n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF);\n                n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF);\n                return n;\n        }", "73": "int missingNumber(vector<int>& nums) {\n        int num = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n        num ^= nums[i] ^ (i + 1);\n        }\n        return num;\n }", "74": "vector<int> getStrongest(vector<int>& arr, int k) {\n                nth_element(begin(arr), begin(arr) + (arr.size() - 1) / 2, end(arr));\n                const auto m = arr[(arr.size() -1) / 2];\n                nth_element(begin(arr), begin(arr) + k, end(arr), [&](int a, int b) { \n                        return abs(a - m) != abs(b - m) ? abs(a - m) > abs(b - m) : a > b; });\n                arr.resize(k);\n                return arr;\n        }", "75": "int minSwapsCouples(vector<int>& row) {\n                int N = row.size() / 2;\n                vector<vector<int>> couples(N);\n                for (int seat = 0; seat < row.size(); ++seat) {\n                        couples[row[seat] / 2].emplace_back(seat / 2);\n                }\n                vector<vector<int>> adj(N);\n                for (const auto& couple : couples) {\n                        adj[couple[0]].emplace_back(couple[1]);\n                        adj[couple[1]].emplace_back(couple[0]);\n                }\n                int result = 0;\n                for (int couch = 0; couch < N; ++couch) {\n                        if (adj[couch].empty()) {\n                                continue;\n                        }\n                        int couch1 = couch;\n                        int couch2 = adj[couch1].back(); adj[couch1].pop_back();\n                        while (couch2 != couch) {\n                                ++result;\n                                adj[couch2].erase(find(adj[couch2].begin(), adj[couch2].end(), couch1));\n                                couch1 = couch2;\n                                couch2 = adj[couch1].back(); adj[couch1].pop_back();\n                        }\n                }\n                return result; \n        }", "76": "int nthMagicalNumber(int N, int A, int B) {\n                static const int M = 1000000007;\n                const uint64_t a = A, b = B;\n                const auto lcm = a * b / gcd(a, b);\n                auto left = min(a, b), right = max(a, b) * N;\n                while (left <= right) {\n                        const auto mid = left + (right - left) / 2;\n                        if (check(A, B, N, lcm, mid)) {\n                                right = mid - 1;\n                        } else {\n                                left = mid + 1;\n                        }\n                }\n                return left % M;\n        }\nbool check(uint64_t a, uint64_t b, uint64_t N, uint64_t lcm, uint64_t target) {\n                return target / a + target / b - target / lcm >= N;\n        }\nuint64_t gcd(uint64_t a, uint64_t b) {\n                while (b != 0) {\n                        int tmp = b;\n                        b = a % b;\n                        a = tmp;\n                }\n                return a;\n        }", "77": "int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n                if (start > destination) {\n                        swap(start, destination);\n                }\n                const auto& s_to_d = accumulate(distance.cbegin() + start,\n                                                                                distance.cbegin() + destination, 0);\n                const auto& d_to_s = accumulate(distance.cbegin(),\n                                                                                distance.cbegin() + start, 0) +\n                                                        accumulate(distance.cbegin() + destination,\n                                                                                distance.cend(), 0);\n                return min(s_to_d, d_to_s);\n        }", "78": "bool findTarget(TreeNode* root, int k) {\n                if (!root) {\n                        return false;\n                }\n                BSTIterator left(root, true), right(root, false);\n                while (*left < *right) {\n                        if (*left + *right == k) {\n                                return true;\n                        } else if (*left + *right < k) {\n                                ++left;\n                        } else {\n                                ++right;\n                        }\n                }\n                return false;\n        }\nBSTIterator(TreeNode *root, bool forward) :\n                        node_(root),\n                        forward_(forward) {\n                        ++(*this);\n                }\nint operator*() {\n                        return cur_; \n                }\nvoid operator++() {\n                        while (node_ || !s_.empty()) {\n                                if (node_) {\n                                        s_.emplace(node_);\n                                        node_ = forward_ ? node_->left : node_->right;\n                                } else {\n                                        node_ = s_.top();\n                                        s_.pop();\n                                        cur_ = node_->val;\n                                        node_ = forward_ ? node_->right : node_->left;\n                                        break;\n                                }\n                        }\n                }", "79": "int bestRotation(vector<int>& A) {\n                const int N = A.size();\n                vector<int> change(N);\n                for (int i = 0; i < N; ++i) {\n                        --change[(i - A[i] + 1 + N) % N];\n                }\n                for (int i = 1; i < N; ++i) {\n                        change[i] += change[i - 1] + 1;\n                }\n                return distance(change.begin(), max_element(change.begin(), change.begin() + N));\n        }", "80": "vector<int> powerfulIntegers(int x, int y, int bound) {\n                unordered_set<int> result;\n                int log_x = (x != 1) ? int(floor(log(bound) / log(x))) + 1 : 1;\n                int log_y = (y != 1) ? int(floor(log(bound) / log(y))) + 1 : 1;\n                for (int i = 0, pow_x = 1; i < log_x; ++i, pow_x *= x) {\n                        for (int j = 0, pow_y = 1; j < log_y; ++j, pow_y *= y) {\n                                auto val = pow_x + pow_y;\n                                if (val <= bound) {\n                                        result.emplace(val);\n                                }\n                        }\n                }\n                return vector<int>(result.cbegin(), result.cend());\n        }", "81": "int arraySign(vector<int>& nums) {\n                uint8_t flag = 0;\n                for (const auto& x : nums) {\n                        if (x == 0) {\n                                return 0;\n                        }\n                        if (x < 0) {\n                                flag ^= 1;\n                        }\n                }\n                return flag % 2 ? -1 : 1;\n        }", "82": "int minSumOfLengths(vector<int>& arr, int target) {\n                unordered_map<int, int> prefix = {{0, -1}};\n                vector<int> dp(arr.size());\n                int result = numeric_limits<int>::max(), min_len = numeric_limits<int>::max();\n                int accu = 0;\n                for (int right = 0; right < arr.size(); ++right) {\n                        accu += arr[right];\n                        prefix[accu] = right;\n                        if (prefix.count(accu - target)) {\n                                auto left = prefix[accu - target];\n                                min_len = min(min_len, right - left);\n                                if (left != -1 && dp[left] != numeric_limits<int>::max()) {\n                                        result = min(result, dp[left] + (right - left));\n                                }\n                        }\n                        dp[right] = min_len;\n                }\n                return result != numeric_limits<int>::max() ? result : -1;\n        }", "83": "int shortestBridge(vector<vector<int>>& A) {\n                static const vector<pair<int, int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n                unordered_set<pair<int, int>, PairHash<int>> lookup;\n                unordered_set<pair<int, int>, PairHash<int>> target;\n                auto islands = get_islands(A);\n                lookup = move(islands[0]);\n                target = move(islands[1]);\n                queue<pair<pair<int, int>, int>> q;\n                for (const auto& node : lookup) {\n                        q.emplace(node, 0);\n                }\n                while (!q.empty()) {\n                        pair<int, int> node;\n                        int dis;\n                        tie(node, dis) = q.front(); q.pop();\n                        if (target.count(node)) {\n                                return dis - 1;\n                        }\n                        for (const auto& d : directions) {\n                                pair<int, int> nei = make_pair(node.first + d.first, node.second + d.second);\n                                if (0 > nei.first || nei.first >= A.size() ||\n                                        0 > nei.second || nei.second >= A[0].size() ||\n                                        lookup.count(nei)) {\n                                        continue;\n                                }\n                                q.emplace(nei, dis + 1);\n                                lookup.emplace(nei);\n                        }\n                }\n        }\nvector<unordered_set<pair<int, int>, PairHash<int>>> get_islands(const vector<vector<int>>& A) {\n                static const vector<pair<int, int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n                vector<unordered_set<pair<int, int>, PairHash<int>>> islands;\n                unordered_set<pair<int, int>, PairHash<int>> done;\n                for (int r = 0; r < A.size(); ++r) {\n                        for (int c = 0; c < A[0].size(); ++c) {\n                                if (A[r][c] == 0 || done.count(make_pair(r, c))) {\n                                        continue;\n                                }\n                                vector<pair<int, int>> s{{r, c}};\n                                unordered_set<pair<int, int>, PairHash<int>> lookup(s.cbegin(), s.cend());\n                                while (!s.empty()) {\n                                        auto node = s.back(); s.pop_back();\n                                        for (const auto& d : directions) {\n                                                pair<int, int> nei = make_pair(node.first + d.first, node.second + d.second);\n                                                if (0 > nei.first || nei.first >= A.size() ||\n                                                        0 > nei.second || nei.second >= A[0].size() ||\n                                                        lookup.count(nei) A[nei.first][nei.second] == 0) {\n                                                        continue;\n                                                }\n                                                s.emplace_back(nei);\n                                                lookup.emplace(nei);\n                                        }\n                                }\n                                for (const auto& node : lookup) {\n                                        done.emplace(node);\n                                }\n                                islands.emplace_back(move(lookup));\n                                if (islands.size() == 2) {\n                                        break;\n                                }\n                        }\n                }\n                return islands;\n        }\nsize_t operator()(const pair<T, T>& p) const {\n                        size_t seed = 0;\n                        seed ^= std::hash<T>{}(p.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        seed ^= std::hash<T>{}(p.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        return seed;\n                }", "84": "void solve(vector<vector<char>>& board) {\n                if (board.empty()) {\n                        return;\n                }\n                queue<pair<int, int>> q;\n                for (int i = 0; i < board.size(); ++i) {\n                        if (board[i][0] == 'O') {\n                                board[i][0] = 'V';\n                                q.emplace(i, 0);\n                        }\n                        if (board[i][board[0].size() - 1] == 'O') {\n                                board[i][board[0].size() - 1] = 'V';\n                                q.emplace(i, board[0].size() - 1);\n                        }\n                }\n                for (int j = 1; j < board[0].size() - 1; ++j) {\n                        if (board[0][j] == 'O') {\n                                board[0][j] = 'V';\n                                q.emplace(0, j);\n                        }\n                        if (board[board.size() - 1][j] == 'O') {\n                                board[board.size() - 1][j] = 'V';\n                                q.emplace(board.size() - 1, j);\n                        }\n                }\n                while (!q.empty()) {\n                        int i, j;\n                        tie(i, j) = q.front();\n                        q.pop();\n                        static const vector<pair<int, int>> directions{{0, -1}, {0, 1},\n                                                                                                                {-1, 0}, {1, 0}};\n                        for (const auto& d : directions) {\n                                const int x = i + d.first, y = j + d.second;\n                                if (0 <= x && x < board.size() &&\n                                        0 <= y && y < board[0].size() && board[x][y] == 'O') {\n                                        board[x][y] = 'V';\n                                        q.emplace(x, y);\n                                }\n                        }\n                }\n                for (int i = 0; i < board.size(); ++i) {\n                        for (int j = 0; j < board[0].size(); ++j) {\n                                if (board[i][j] != 'V') {\n                                        board[i][j] = 'X';\n                                } else {\n                                        board[i][j] = 'O';\n                                }\n                        }\n                }\n        }", "85": "int superPow(int a, vector<int>& b) {\n                int result = 1;\n                for (const auto& digit : b) {\n                        result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337;\n                }\n                return result;\n        }\nint myPow(int a, int n, int b) {\n                int result = 1;\n                int x = a % b;\n                while (n) {\n                        if (n & 1) {\n                                result = result * x % b;\n                        }\n                        n >>= 1;\n                        x = x * x % b;\n                }\n                return result % b;\n        }", "86": "int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\n                return shoppingOffersHelper(price, special, needs, 0);\n        }\nint shoppingOffersHelper(const vector<int>& price, const vector<vector<int>>& special, vector<int>& needs, int i) {\n                if (i == special.size()) {\n                        return inner_product(price.begin(), price.end(), needs.begin(), 0);\n                }\n                int result = shoppingOffersHelper(price, special, needs, i + 1);\n                for (int j = 0; j < needs.size(); ++j) {\n                        needs[j] -= special[i][j];\n                }\n                if (all_of(needs.begin(), needs.end(), [](int i) { return i >= 0; })) {\n                        result = min(result, special[i].back() + shoppingOffersHelper(price, special, needs, i));\n                }\n                for (int j = 0; j < needs.size(); ++j) {\n                        needs[j] += special[i][j];\n                }\n                return result;\n        }", "87": "vector<string> invalidTransactions(vector<string>& transactions) {\n                static const int AMOUNT = 1000;\n                static const int MINUTES = 60;\n                vector<tuple<string, int, int, string>> trans;\n                for (const auto& transaction : transactions) {\n                        const auto& t = split(transaction, ',');\n                        trans.emplace_back(t[0], stoi(t[1]), stoi(t[2]), t[3]);\n                }\n                sort(trans.begin(), trans.end(),\n                        [](const auto& a, const auto& b) {\n                                return get<1>(a) < get<1>(b); });\n                unordered_map<string, vector<int>> trans_indexes;\n                for (int i = 0; i < trans.size(); ++i) {\n                        trans_indexes[get<0>(trans[i])].emplace_back(i);\n                }\n                vector<string> result;\n                for (const auto& [name, indexes] : trans_indexes) {\n                        int left = 0, right = 0;\n                        for (int i = 0; i < indexes.size(); ++i) {\n                                const auto& t = trans[indexes[i]];\n                                if (get<2>(t) > AMOUNT) {\n                                        result.emplace_back(to_str(t));\n                                        continue;\n                                }\n                                while (left + 1 < indexes.size() &&\n                                        get<1>(trans[indexes[left]]) < get<1>(t) - MINUTES) {\n                                        ++left;\n                                }\n                                while (right + 1 < indexes.size() &&\n                                        get<1>(trans[indexes[right + 1]]) <= get<1>(t) + MINUTES) {\n                                        ++right;\n                                }\n                                for (int i = left; i <= right; ++i) {\n                                        if (get<3>(trans[indexes[i]]) != get<3>(t)) {\n                                                result.emplace_back(to_str(t));\n                                                break;\n                                        }\n                                }\n                        }\n                }\n                return result;\n        }\nvector<string> split(const string& s, const char delim) {\n                vector<string> result;\n                auto end = string::npos;\n                do {\n                        const auto& start = end + 1;\n                        end = s.find(delim, start);\n                        result.emplace_back(s.substr(start, end - start));\n                } while (end != string::npos); \n                return result;\n        }\nstring to_str(const T& t) {\n                stringstream ss;\n                ss << get<0>(t) << \",\" << get<1>(t) << \",\"\n                << get<2>(t) << \",\" << get<3>(t);\n                return ss.str();\n        }", "88": "string shortestCommonSupersequence(string str1, string str2) {\n                vector<vector<int>> dp(2, vector<int>(str2.size() + 1));\n                vector<vector<tuple<int, int, char>>> bt(str1.size() + 1,\n                                                                                                vector<tuple<int, int, char>>(str2.size() + 1));\n                for (int i = 0; i < str1.length(); ++i) {\n                        bt[i + 1][0] = {i, 0, str1[i]};\n                }\n                for (int j = 0; j < str2.length(); ++j) {\n                        bt[0][j + 1] = {0, j, str2[j]};\n                }\n                for (int i = 0; i < str1.length(); ++i) {\n                        for (int j = 0; j < str2.length(); ++j) {\n                                if (dp[i % 2][j + 1] > dp[(i + 1) % 2][j]) {\n                                        dp[(i + 1) % 2][j + 1] = dp[i % 2][j + 1];\n                                        bt[i + 1][j + 1] = {i, j + 1, str1[i]};\n                                } else {\n                                        dp[(i + 1) % 2][j + 1] = dp[(i + 1) % 2][j];\n                                        bt[i + 1][j + 1] = {i + 1, j, str2[j]};\n                                }\n                                if (str1[i] != str2[j]) {\n                                        continue;\n                                }\n                                if (dp[i % 2][j] + 1 > dp[(i + 1) % 2][j + 1]) {\n                                        dp[(i + 1) % 2][j + 1] = dp[i % 2][j] + 1;\n                                        bt[i + 1][j + 1] = {i, j, str1[i]};\n                                }\n                        }\n                }\n                int i = str1.length(), j = str2.length();\n                char c = 0;\n                string result;\n                while (i != 0 j != 0) {\n                        tie(i, j, c) = bt[i][j];\n                        result.push_back(c);\n                }\n                reverse(result.begin(), result.end());\n                return result;\n        }", "89": "int numWays(vector<string>& words, string target) {\n                static const int MOD = 1e9 + 7;\n                vector<uint64_t> dp(size(target) + 1); \n                dp[0] = 1;\n                for (int i = 0; i < size(words[0]); ++i) {\n                        vector<int> count(26);\n                        for (const auto& w : words) {\n                                ++count[w[i] - 'a'];\n                        }\n                        for (int j = size(target) - 1; j >= 0; --j) {\n                                dp[j + 1] += dp[j] * count[target[j] - 'a'] % MOD;\n                        }\n                }\n                return dp.back() % MOD;\n        }", "90": "int removeDuplicates(vector<int>& nums) {\n                if (nums.empty()) {\n                        return 0;\n                }\n                const int k = 2; \n                int left = 0;\n                int right = 1;\n                while (right < nums.size()) {\n                        if (nums[left] != nums[right] ||\n                                (left - k + 1 < 0 nums[left] != nums[left - k + 1])) {\n                                ++left;\n                                nums[left] = nums[right];\n                        }\n                        ++right;\n                }\n                return left + 1; \n        }", "91": "int minMoves(vector<int>& nums) {\n                return accumulate(nums.cbegin(), nums.cend(), 0) -\n                        nums.size() * *min_element(nums.cbegin(), nums.cend());\n        }", "92": "bool isOneBitCharacter(vector<int>& bits) {\n                auto parity = 0;\n                for (int i = static_cast<int>(bits.size()) - 2; i >= 0 && bits[i]; --i) {\n                        parity ^= bits[i];\n                }\n                return parity == 0;\n        }", "93": "string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) { \n                UnionFind union_find(s.length());\n                for (const auto& pair : pairs) {\n                        union_find.union_set(pair[0], pair[1]);\n                }\n                unordered_map<int, vector<char>> components;\n                for (int i = 0; i < s.length(); ++i) {\n                        components[union_find.find_set(i)].emplace_back(s[i]);\n                }\n                for (auto& [i, list] : components) {\n                        sort(list.begin(), list.end(), greater<char>());\n                }\n                for (int i = 0; i < s.length(); ++i) {\n                        const auto& j = union_find.find_set(i);\n                        s[i] = components[j].back();\n                        components[j].pop_back();\n                }\n                return s;\n        }", "94": "string toHex(int num) {\n                if (!num) {\n                        return \"0\";\n                }\n                string result;\n                while (num && result.length() != sizeof(int) * 2) {\n                        int hex = num & 15;\n                        if (hex < 10) {\n                                result.push_back('0' + hex);\n                        } else {\n                                result.push_back('a' + hex - 10);\n                        }\n                        num >>= 4;\n                }\n                reverse(result.begin(), result.end());\n                return result;\n        }", "95": "TreeNode* addOneRow(TreeNode* root, int v, int d) {\n                if (d == 0 d == 1) {\n                        auto node = new TreeNode(v);\n                        (d == 1 ? node->left : node->right) = root;\n                        return node;\n                }\n                if (root && d >= 2) {\n                        root->left = addOneRow(root->left, v, d > 2 ? d - 1 : 1);\n                        root->right = addOneRow(root->right, v, d > 2 ? d - 1 : 0);\n                }\n                return root;\n        }", "96": "vector<string> binaryTreePaths(TreeNode* root) {\n                vector<string> result;\n                vector<TreeNode *> path;\n                binaryTreePathsRecu(root, &path, &result);\n                return result;\n        }\nvoid binaryTreePathsRecu(TreeNode *node, vector<TreeNode *> *path, vector<string> *result) {\n                if (!node) {\n                        return;\n                }\n                if (!node->left && !node->right) {\n                        string ans = \"\";\n                        for (const auto& n : *path) {\n                                ans.append(to_string(n->val).append(\"->\"));\n                        }\n                        result->emplace_back(move(ans.append(to_string(node->val))));\n                }\n                if (node->left) {\n                        path->emplace_back(node);\n                        binaryTreePathsRecu(node->left, path, result);\n                        path->pop_back();\n                }\n                if (node->right) {\n                        path->emplace_back(node);\n                        binaryTreePathsRecu(node->right, path, result);\n                        path->pop_back();\n                }\n        }", "97": "int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n                unordered_map<int, vector<int>> graph;\n                for (const auto& edge : edges) {\n                        graph[edge[0]].emplace_back(edge[1]);\n                        graph[edge[1]].emplace_back(edge[0]);\n                }\n                using RET = pair<int, int>;\n                RET result{};\n                vector<tuple<int, int, int, shared_ptr<RET>, RET *>> stk = {{1, -1, 0, nullptr, &result}};\n                while (!stk.empty()) {\n                        const auto [step, par, node, new_ret, ret] = stk.back(); stk.pop_back();\n                        if (step == 1) {\n                                ret->second = int(hasApple[node]);\n                                for (const auto& nei : graph[node]) {\n                                        if (nei == par) {\n                                                continue;\n                                        }\n                                        const auto& new_ret = make_shared<RET>();\n                                        stk.emplace_back(2, -1, -1, new_ret, ret);\n                                        stk.emplace_back(1, node, nei, nullptr, new_ret.get());\n                                }\n                        } else {\n                                ret->first += new_ret->first + new_ret->second;\n                                ret->second |= bool(new_ret->first + new_ret->second);\n                        }\n                }\n                return 2 * result.first;\n        }", "98": "bool isSolvable(vector<string>& words, string result) {\n                for (auto& w : words) {\n                        reverse(w.begin(), w.end());\n                }\n                reverse(result.begin(), result.end());\n                unordered_map<char, int> lookup;\n                unordered_set<int> used;\n                return backtracking(words, result, 0, 0, 0, &lookup, &used);\n        }\nbool backtracking(const vector<string>& words, const string& result, int i, int j, int carry, unordered_map<char, int> *lookup, unordered_set<int> *used) {\n                if (j == result.length()) {\n                        return carry == 0;\n                }\n                if (i != words.size()) {\n                        if (j >= words[i].length() || lookup->count(words[i][j])) {\n                                return backtracking(words, result, i + 1, j, carry, lookup, used);\n                        }\n                        for (int val = 0; val < 10; ++val) {\n                                if (used->count(val) || (val == 0 && j == words[i].length() - 1)) {\n                                        continue;\n                                }\n                                (*lookup)[words[i][j]] = val;\n                                used->emplace(val);\n                                if (backtracking(words, result, i + 1, j, carry, lookup, used)) {\n                                        return true;\n                                }\n                                used->erase(val);\n                                lookup->erase(words[i][j]);\n                        }\n                        return false;\n                }\n                const auto& total = accumulate(words.cbegin(), words.cend(), carry,\n                                                                        [&j, &lookup](const auto& x, const auto& y) {\n                                                                                return (j < y.length()) ? x + (*lookup)[y[j]] : x; });\n                carry = total / 10;\n                int val = total % 10;\n                if (lookup->count(result[j])) {\n                        return val == (*lookup)[result[j]] &&\n                                backtracking(words, result, 0, j + 1, carry, lookup, used);\n                }\n                if (used->count(val) || (val == 0 && j == result.length() - 1)) {\n                        return false;\n                }\n                (*lookup)[result[j]] = val;\n                used->emplace(val);\n                if (backtracking(words, result, 0, j + 1, carry, lookup, used)) {\n                        return true;\n                }\n                used->erase(val);\n                lookup->erase(result[j]);\n                return false;\n        }", "99": "vector<int> fallingSquares(vector<vector<int>>& positions) {\n                vector<int> result;\n                map<int, int> heights;\n                int maxH = heights[-1] = 0;\n                for (const auto& p : positions) {\n                        auto it0 = heights.upper_bound(p[0]);\n                        auto it1 = heights.lower_bound(p[0] + p[1]);\n                        int h0 = prev(it0)->second;\n                        int h1 = prev(it1)->second;\n                        for (auto it = it0; it != it1; ++it) {\n                                h0 = max(h0, it->second);\n                        }\n                        heights.erase(it0, it1);\n                        heights[p[0]] = h0 + p[1];\n                        heights[p[0] + p[1]] = h1;\n                        maxH = max(maxH, h0 + p[1]);\n                        result.emplace_back(maxH);\n                }\n                return result;\n        }\n"}, "Python": {"0": "def minCostToMoveChips(chips: List[int]) -> int:\n        even, odd = 0, 0\n        for i in chips:\n                if i % 2 == 0:\n                        even += 1\n                else:\n                        odd += 1\n        return min(even, odd)", "1": "def pseudoPalindromicPaths (root):\n        result = 0\n        stk = [[root, 0]]\n        while (len(stk) != 0):\n                node, count = stk.pop()\n                if (not node):\n                        continue\n                count = count ^ (1 << node.val)\n                result += int(not node.left and not node.right and (count & (count - 1)) == 0)\n                stk.append([node.right, count])\n                stk.append([node.left, count])\n        return result", "2": "def minOperations(boxes):\n        result = [0] * len(boxes)\n        for i in range(0, len(boxes)):\n                result[i] += accu\n                cnt += (boxes[i] == 1) ? 1 : 0\n                accu += cnt\n        for i in range(len(boxes) - 1, 0, -1):\n                result[i] += accu\n                cnt += (boxes[i] == 1) ? 1 : 0\n                accu += cnt\n        return result", "3": "def largestPalindrome(n):\n        if (n == 1):\n                return 9\n        upper = pow(10, n) - 1\n        for k in range(2, upper+1):\n                left = pow(10, n) - k\n                s = str(left)\n                s = s[::-1]\n                right = int(s)\n                d = k * k - right * 4\n                if (d < 0):\n                        continue\n                if (sqrt(d) == int(sqrt(d)) and k % 2 == int(sqrt(d)) % 2):\n                        return (int(left * pow(10, n)) + right) % 1337\n        return -1\n\ndef buildPalindrome(n):\n        s = str(n)\n        s = s[::-1]\n        return int(str(n) + s)", "4": "def minOperations(s):\n        cnt = 0\n        for i in range(len(s)):\n                if s[i] - '0' == i % 2:\n                        cnt += 1\n        return min(cnt, len(s) - cnt)", "5": "def number_of_rounds(start_time, finish_time):\n        start = int(start_time[0:2]) * 60 + int(start_time[3:])\n        finish = int(finish_time[0:2]) * 60 + int(finish_time[3:])\n        if start > finish:\n                finish += 1440\n        return max(finish / 15 - (start + 15 - 1) / 15, 0)", "6": "def smallestRangeII(self, A: List[int], K: int) -> int:\n        A.sort()\n        ans = A[-1] - A[0]\n\n        for i in range(len(A) - 1):\n            a, b = A[i], A[i+1]\n            ans = min(ans, max(A[-1] - K, a + K) - min(b - K, A[0] + K))\n\n        return ans", "7": "class TrieNode:\n    def __init__(self):\n        self.leaves={}\n        self.isString=False\n    def Insert(self, s):\n        p=self\n        for c in s:\n            if c not in p.leaves:\n                p.leaves[c]=TrieNode()\n            p=p.leaves[c]\n        if p.isString:\n            return False\n        else:\n            p.isString=True\n            return True\n    def __del__(self):\n        for kv in self.leaves:\n            if kv[1]:\n                del kv[1]\ndef findWords(board, words):\n    ret=set()\n    visited=[[False]*len(board[0]) for _ in range(len(board))]\n    cur=''\n    trie=TrieNode()\n    for word in words:\n        trie.Insert(word)\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            findWordsDFS(board, visited, trie, i, j, cur, ret)\n    return list(ret)\ndef findWordsDFS(grid, visited, trie, i, j, cur, ret):\n    if not trie or i<0 or i>=len(grid) or j<0 or j>=len(grid[0]) or not visited[i][j]:\n        return\n    if grid[i][j] not in trie.leaves:\n        return\n    nextNode=trie.leaves[grid[i][j]]\n    cur+=grid[i][j]\n    if nextNode.isString:\n        ret.add(cur)\n    visited[i][j]=True\n    findWordsDFS(grid, visited, nextNode, i-1, j, cur, ret)\n    findWordsDFS(grid, visited, nextNode, i+1, j, cur, ret)\n    findWordsDFS(grid, visited, nextNode, i, j-1, cur, ret)\n    findWordsDFS(grid, visited, nextNode, i, j+1, cur, ret)\n    visited[i][j]=False", "8": "def findSubsequences(nums):\n                result = []\n                seq = []\n                findSubsequencesHelper(nums, 0, seq, result)\n                return result\ndef findSubsequencesHelper(nums, i, seq, result):\n                if seq.size() >= 2:\n                        result.emplace_back(seq)\n                lookup = set()\n                for i in range(i, len(nums)):\n                        if (not seq or nums[i] >= seq[-1]) and nums[i] not in lookup:\n                                lookup.add(nums[i])\n                                seq.append(nums[i])\n                                findSubsequencesHelper(nums, i + 1, seq, result)\n                                seq.pop()", "9": "def minimumEffort(tasks):\n        tasks.sort(key=lambda x: x[1] - x[0])\n        result = 0\n        for task in tasks:\n                result = max(result + task[0], task[1])\n        return result", "10": "def minStickers(stickers, target):\n    sticker_counts = []\n    dp = {}\n    for i in range(len(stickers)):\n        sticker_counts.append([0]*26)\n        for c in stickers[i]:\n            sticker_counts[i][ord(c)-ord('a')] += 1\n    dp[\"\"] = 0\n    return minStickersHelper(sticker_counts, target, dp)\n\ndef minStickersHelper(sticker_counts, target, dp):\n    if target in dp:\n        return dp[target]\n    result = float('inf')\n    target_count = [0]*26\n    for c in target:\n        target_count[ord(c)-ord('a')] += 1\n    for sticker_count in sticker_counts:\n        if sticker_count[ord(target[0])-ord('a')] == 0:\n            continue\n        new_target = \"\"\n        for i in range(26):\n            if target_count[i] - sticker_count[i] > 0:\n                new_target += chr(i+ord('a'))*(target_count[i] - sticker_count[i])\n        if len(new_target) != len(target):\n            num = minStickersHelper(sticker_counts, new_target, dp)\n            if num != -1:\n                result = min(result, 1+num)\n    dp[target] = -1 if result==float('inf') else result\n    return dp[target]", "11": "def minSubarray(nums, p):\n                residue = 0\n                for num in nums:\n                        residue = (residue + num) % p\n                if not residue:\n                        return 0\n                result = len(nums)\n                lookup = {0: -1}\n                for i in range(0, len(nums)), curr = 0:\n                        curr = (curr + nums[i]) % p\n                        lookup[curr] = i\n                        if (lookup.count((curr - residue + p) % p))\n                                result = min(result, i - lookup[(curr - residue + p) % p])\n                return result < len(nums) ? result : -1", "12": "def distributeCandies(candies, num_people):\n  p = int(sqrt(2 * candies + 0.25) - 0.5)\n  remaining = candies - (p + 1) * p / 2\n  rows = p / num_people\n  cols = p % num_people\n  result = [0] * num_people\n  for i in range(num_people):\n    if (i < cols):\n      result[i] = (i + 1) * (rows + 1) + (rows * (rows + 1) / 2) * num_people\n    else:\n      result[i] = (i + 1) * rows + ((rows - 1) * rows / 2) * num_people\n  result[cols] += remaining\n  return result", "13": "def totalFruit(tree):\n        count = {}\n        result = 0\n        for i in range(0, len(tree)):\n                count[tree[i]] = count.get(tree[i], 0) + 1\n                while len(count) > 2:\n                        count[tree[i]] = count[tree[i]] - 1\n                        if count[tree[i]] == 0:\n                                del count[tree[i]]\n                        i = i + 1\n                result = max(result, j - i + 1)\n        return result", "14": "def threeSumMulti(A, target):\n        count = {}\n        for a in A:\n                if a in count:\n                        count[a] += 1\n                else:\n                        count[a] = 1\n\n        result = 0\n\n        for i in count:\n                for j in count:\n                        k = target - i - j\n                        if k in count:\n                                if i == j == k:\n                                        result += count[i] * (count[i] - 1) * (count[i] - 2) / 6\n                                elif i == j != k:\n                                        result += count[i] * (count[i] - 1) / 2 * count[k]\n                                elif i < j < k:\n                                        result += count[i] * count[j] * count[k]\n\n    return result % (10**9 + 7)", "15": "def hammingWeight(n):\n        n = (n & 0x55555555) + ((n >> 1) & 0x55555555)\n        n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n        n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)\n        n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)\n        n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)\n        return n", "16": "def hammingWeight(n):\n        n = (n & 0x55555555) + ((n >> 1) & 0x55555555)\n        n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n        n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)\n        n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)\n        n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)\n        return n", "17": "def closedIsland(grid):\n        for j in range(grid[0].size):\n                fill(grid, 0, j)\n                fill(grid, grid.size - 1, j)\n        for i in range(1, grid.size - 1):\n                fill(grid, i, 0)\n                fill(grid, i, grid[0].size - 1)\n        result = 0\n        for i in range(1, grid.size - 1):\n                for j in range(1, grid[0].size - 1):\n                        if fill(grid, i, j):\n                                result+=1\n        return result\ndef fill(grid, i, j):\n        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n        if i < 0 or j < 0 or i >= grid.size or j >= grid[i].size or grid[i][j]:\n                return false\n        grid[i][j] = 1\n        for dx, dy in directions:\n                fill(grid, i + dx, j + dy)\n        return true", "18": "def find132pattern(nums):\n                ak = -sys.maxsize\n                st = []\n                for i in range(len(nums)-1, -1, -1):\n                        if nums[i] < ak:\n                                return True\n                        else:\n                                while len(st) != 0 and nums[i] > st[-1]:\n                                        ak = st[-1]\n                                        st.pop()\n                        st.append(nums[i])\n                return False", "19": "def imageSmoother(M):\n        m = len(M)\n        n = len(M[0])\n        result = [[0 for x in range(n)] for y in range(m)] \n        for i in range(m):\n                for j in range(n):\n                        result[i][j] = getGray(M, i, j)\n        return result\ndef getGray(M, i, j):\n                m = len(M)\n                n = len(M[0])\n                total = 0.0\n                count = 0\n                for r in range(-1, 2):\n                        for c in range(-1, 2):\n                                ii = i + r\n                                jj = j + c\n                                if 0 <= ii and ii < m and 0 <= jj and jj < n:\n                                        total += M[ii][jj]\n                                        count += 1\n                return int(total / count)", "20": "def findMaxForm(strs, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for s in strs:\n        zero_count = s.count('0')\n        one_count = s.count('1')\n        for i in range(m, -1, -1):\n            for j in range(n, -1, -1):\n                if i - zero_count >= 0 and j - one_count >= 0:\n                    dp[i][j] = max(dp[i][j], dp[i - zero_count][j - one_count] + 1)\n    return dp[m][n]", "21": "def TopVotedCandidate(persons, times):\n                lead = -1\n                count = {}\n                for i in range(0, len(persons)):\n                        if (++count[persons[i]] >= count[lead]):\n                                lead = persons[i]\n                                lookup_.append(times[i], persons[i])\n        return q(t)\n\ndef q(t):\n                return prev(upper_bound(lookup_.cbegin(), lookup_.cend(),\n                                                                make_pair(t, numeric_limits<int>::max())))->second", "22": "def maxDepth(root):\n        if not root:\n                return 0\n        return max(maxDepth(root.left), maxDepth(root.right)) + 1", "23": "def characterReplacement(s, k):\n        result = 0\n        max_count = 0\n        count = {}\n\n        for i in range(len(s)):\n                count[s[i]] += 1\n                max_count = max(max_count, count[s[i]])\n\n                if result - max_count >= k:\n                        count[s[i-result]] -= 1\n                else:\n                        result += 1\n        return result", "24": "def findPoisonedDuration(self, timeSeries, duration):\n        result = duration * len(timeSeries)\n        for i in range(1, len(timeSeries)):\n                result -= max(0, duration - (timeSeries[i] - timeSeries[i - 1]))\n        return result", "25": "def findMedianSortedArrays(nums1, nums2):\n        if ((nums1.size() + nums2.size()) % 2 == 1):\n                return findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2 + 1)\n        else:\n                return (findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2) +\n                                findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2 + 1)) / 2.0\n\ndef findKthInTwoSortedArrays(A, B, k):\n                m = A.size()\n                n = B.size()\n                if (m > n):\n                        return findKthInTwoSortedArrays(B, A, k)\n                left = 0\n                right = m - 1\n                while (left <= right):\n                        mid = left + (right - left) / 2\n                        if (0 <= k - 1 - mid && k - 1 - mid < n && A[mid] >= B[k - 1 - mid]):\n                                right = mid - 1\n                        else:\n                                left = mid + 1\n                Ai_minus_1 = left - 1 >= 0 ? A[left - 1] : numeric_limits<int>::min()\n                Bj = k - 1 - left >= 0 ? B[k - 1 - left] : numeric_limits<int>::min()\n                return max(Ai_minus_1, Bj)", "26": "def fractionAddition(expression):\n                istringstream iss(expression);\n                int A = 0, B = 1, a, b;\n                char _;\n                while (iss >> a >> _ >> b):\n                        A = A * b + a * B;\n                        B *= b;\n                        auto g = abs(__gcd(A, B));\n                        A /= g;\n                        B /= g;\n                return to_string(A) + '/' + to_string(B);", "27": "def shiftGrid(grid, k):\n        rotate(&grid, k)\n        return grid\ndef rotate(grid, k):\n        k %= grid.size() * grid[0].size()\n        reverse(grid, 0, grid.size() * grid[0].size())\n        reverse(grid, 0, k)\n        reverse(grid, k, grid.size() * grid[0].size())\ndef reverse(grid, start, end):\n        for (; start < end; ++start, --end) {\n                int start_r = start / grid[0].size()\n                int start_c = start % grid[0].size()\n                int end_r = (end - 1) / grid[0].size()\n                int end_c = (end - 1) % grid[0].size()\n                swap(grid[start_r][start_c], grid[end_r][end_c])", "28": "def reorderedPowerOf2(N):\n        count = counter(N)\n        for i in range(31):\n                if count == counter(1 << i):\n                        return true\n        return false\ndef counter(N):\n        result = [0,0,0,0,0,0,0,0,0,0]\n        for i in range (10):\n                result[i] = str(N).count(str(i))\n        return result", "29": "def canConstruct(s, k):\n    odd = [0] * 26\n    for c in s:\n        odd[ord(c) - ord('a')] += 1\n    return sum(i % 2 for i in odd) <= k and k <= len(s)", "30": "def rotateTheBox(box):\n    result = [['.' for j in range(len(box[0]))] for i in range(len(box))]\n    for i in range(len(box)):\n        for j in range(len(box[0]) - 1, -1, -1):\n            if box[i][j] == '.':\n                continue\n            if box[i][j] == '*':\n                k = j\n            result[k][len(box) - 1 - i] = box[i][j]\n            k -= 1\n    return result", "31": "def findLadders(beginWord, endWord, wordList):\n        words = set(wordList)\n        if endWord not in words:\n                return []\n        tree = {}\n        left = {beginWord}\n        right = {endWord}\n        is_found = False\n        is_reversed = False\n        while left:\n                for word in left:\n                        words.remove(word)\n                new_left = set()\n                for word in left:\n                        for i in range(len(word)):\n                                prev = word[i]\n                                for j in range(26):\n                                        word[i] = 'a' + j\n                                        if word not in words:\n                                                continue\n                                        if word in right:\n                                                is_found = True\n                                        else:\n                                                new_left.add(word)\n                                        if not is_reversed:\n                                                if word not in tree:\n                                                        tree[word] = set()\n                                                tree[word].add(prev)\n                                        else:\n                                                if prev not in tree:\n                                                        tree[prev] = set()\n                                                tree[prev].add(word)\n                                        word[i] = prev\n                if is_found:\n                        break\n                left = new_left\n                if len(left) > len(right):\n                        left, right = right, left\n                        is_reversed = not is_reversed\n        return backtracking(tree, beginWord, endWord, [], [])\ndef backtracking(tree, beginWord, word, path, result):\n        if word == beginWord:\n                result.append([beginWord] + path)\n        else:\n                if word in tree:\n                        for new_word in tree[word]:\n                                if new_word == word:\n                                        continue\n                                backtracking(tree, beginWord, new_word, [word] + path, result)\n        return result", "32": "def makeStringSorted(s):\n                MOD = 1e9 + 7\n                count = [0] * 26\n                result = 0\n                comb_total = 1\n                for i in range(len(s) - 1, -1, -1):\n                        num = s[i] - 'a'\n                        comb_total = (comb_total * (len(s) - i) % MOD) * inverse(count[num] + 1, MOD)) % MOD\n                        result = (result + (comb_total * (sum(count[0:num]) % MOD)) * inverse(len(s) - i, MOD) % MOD) % MOD\n                return result\n        \ndef inverse(n, m):\n                inv = [0, 1]\n                for i in range(2, n + 1): \n                        inv.append(inv[m % i] * (m - m // i) % m) \n                return inv[n]", "33": "def findLUSlength(a, b):\n                if (a == b):\n                        return -1;\n                return max(len(a), len(b));", "34": "def simplifyPath(path):\n                names = []\n                tokens = path.split('/')\n                for token in tokens:\n                        if token == \"..\" and not names.empty():\n                                names.pop()\n                        elif token != \"..\" and token != \".\" and not token.empty():\n                                names.append(token)\n                return \"/\".join(names)", "35": "def maximumSwap(num):\n                digits = to_string(num)\n                left = 0\n                right = 0\n                max_idx = digits.length() - 1\n                for i in range(digits.length() - 1, 0, -1):\n                        if (digits[i] > digits[max_idx]):\n                                max_idx = i\n                        elif (digits[max_idx] > digits[i]):\n                                left = i\n                                right = max_idx\n                swap(digits[left], digits[right])\n                return int(digits)", "36": "def reachableNodes(edges, M, N):\n                using P = pair<int, int>;\n                vector<vector<P>> adj(N);\n                for (const auto& edge: edges) {\n                        int u = edge[0], v = edge[1], w = edge[2];\n                        adj[u].emplace_back(v, w);\n                        adj[v].emplace_back(u, w);\n                }\n                unordered_map<int, int> best;\n                best[0] = 0;\n                unordered_map<int, unordered_map<int, int>> count;\n                int result = 0;\n                priority_queue<P, vector<P>, greater<P>> min_heap;\n                min_heap.emplace(0, 0);\n                while (!min_heap.empty()) {\n                        int curr_total, u;\n                        tie(curr_total, u) = min_heap.top(); min_heap.pop();\n                        if (best.count(u) && best[u] < curr_total) {\n                                continue;\n                        }\n                        ++result;\n                        for (const auto& kvp: adj[u]) {\n                                int v, w;\n                                tie(v, w) = kvp;\n                                count[u][v] = min(w, M - curr_total);\n                                int next_total = curr_total + w + 1;\n                                if (next_total <= M && \n                                        (!best.count(v) next_total < best[v])) {\n                                        best[v] = next_total;\n                                        min_heap.emplace(next_total, v);\n                                }\n                        }\n                }\n                for (const auto& edge: edges) {\n                        int u = edge[0], v = edge[1], w = edge[2];\n                        result += min(w, count[u][v] + count[v][u]);\n                }\n                return result;", "37": "def minDeletions(s):\n        count = [0] * 26\n        for c in s:\n                count[c - 'a'] += 1\n        result = 0\n        lookup = set()\n        for i in range(26):\n                for c in count[i]:\n                        if c not in lookup:\n                                lookup.add(c)\n                                break\n                        result += 1\n        return result", "38": "def isMonotonic(A):\n                inc = false\n                dec = false\n                for i in range(0, len(A) - 1): \n                        if (A[i] < A[i + 1]): \n                                inc = true\n                        elif (A[i] > A[i + 1]): \n                                dec = true\n\n                return not inc or not dec", "39": "def hIndex(citations):\n    n = len(citations)\n    count = [0] * (n + 1)\n    for x in citations:\n        if x >= n:\n            count[n] += 1\n        else:\n            count[x] += 1\n    h = 0\n    for i in range(n, -1, -1):\n        h += count[i]\n        if h >= i:\n            return i\n    return h", "40": "def lastRemaining(n):\n        start = 1\n        for step in 2, direction in 1, n > 1, n /= 2, step *= 2, direction *= -1:\n                start += direction * (step * (n / 2) - step / 2)\n        return start", "41": "def minimumJumps(forbidden, a, b, x):\n                max_f = max(forbidden)\n                max_val = (a >= b) * x + b or max(x, max_f) + a + b\n                lookup = [set(), set()]\n                for pos in forbidden:\n                        lookup[0].add(pos)\n                        lookup[1].add(pos)\n                result = 0\n                q = [[0, true]]\n                lookup[0].add(0)\n                while q:\n                        new_q = []\n                        for pos, can_back in q:\n                                if pos == x:\n                                        return result\n                                if pos + a <= max_val and (pos + a) not in lookup[0]:\n                                        lookup[0].add(pos + a)\n                                        new_q.append([pos + a, true])\n                                if not can_back:\n                                        continue\n                                if pos - b >= 0 and (pos - b) not in lookup[1]:\n                                        lookup[1].add(pos - b)\n                                        new_q.append([pos - b, false])\n                        q = new_q\n                        ++result\n                return -1", "42": "def isPathCrossing(path):\n                lookup = set({(0, 0)})\n                x = 0\n                y = 0\n                for c in path:\n                        if c == 'E':\n                                x += 1\n                        if c == 'W':\n                                x -= 1\n                        if c == 'N':\n                                y += 1\n                        if c == 'S':\n                                y -= 1\n                        if (x, y) in lookup:\n                                return True\n                        lookup.add((x, y))\n                return False", "43": "def canBeIncreasing(nums):\n                deleted = False\n                for i in range(1, len(nums)):\n                        if nums[i] > nums[i - 1]:\n                                continue\n                        if deleted:\n                                return False\n                        deleted = True\n                        if i >= 2 and nums[i - 2] > nums[i]: \n                                nums[i] = nums[i - 1]\n                return True", "44": "def earliestAndLatest(n, firstPlayer, secondPlayer):\n                lookup = dict()\n                return memoization(n, firstPlayer - 1, n - secondPlayer, lookup)\n\ndef memoization(t, l, r, lookup):\n                if (tuple(t, l, r) not in lookup.keys()):\n                        if (l == r):\n                                return [1, 1]\n                        if (l > r): \n                                l, r = r, l\n                        result = [float('inf'), 0]\n                        for i in range(l + 1):\n                                nt = (t + 1) // 2\n                                pair_cnt = t // 2\n                                l_lose_cnt = l - i\n                                l_win_cnt = i + 1\n                                min_j = max(l_lose_cnt, r - (pair_cnt - l_lose_cnt)) \n                                max_j = min(r - l_win_cnt, (nt - l_win_cnt) - 1) \n                                for j in range(min_j, max_j + 1):\n                                        tmp = memoization(nt, i, j, lookup)\n                                        result = [min(result[0], tmp[0] + 1), max(result[1], tmp[1] + 1)]\n                        lookup[tuple(t, l, r)] = result\n                return lookup[tuple(t, l, r)]", "45": "def numJewelsInStones(J,S):\n        lookup = set(J)\n        result = 0\n        for s in S:\n                if s in lookup:\n                        result += 1\n        return result", "46": "def heightChecker(heights):\n        sorted_heights = heights.copy()\n        sorted_heights.sort()\n        result = 0\n        for i in range(len(heights)):\n                result += int(heights[i] != sorted_heights[i])\n        return result", "47": "def largestSubmatrix(matrix):\n        result = 0\n        for c in range(len(matrix[0])):\n                h = 0\n                for r in range(len(matrix)):\n                        h = (matrix[r][c] == 1) ? h + 1 : 0\n                        matrix[r][c] = h\n        for row in matrix:\n                row.sort()\n                for c in range(len(row)):\n                        result = max(result, (len(row) - c) * row[c])\n        return result", "48": "def findRotation(mat, target):\n                checks = [\n                        lambda i, j: mat[i][j] == target[i][j],\n                        lambda i, j: mat[i][j] == target[j][len(mat) - 1 - i],\n                        lambda i, j: mat[i][j] == target[len(mat) - 1 - i][len(mat[0]) - 1 - j],\n                        lambda i, j: mat[i][j] == target[len(mat[0]) - 1 - j][i],\n                ]\n                def traverse(check):\n                        for i in range(len(mat)):\n                                for j in range(len(mat[0])):\n                                        if not check(i, j):\n                                                return False\n                        return True\n                for check in checks:\n                        if traverse(check):\n                                return True\n                return False", "49": "def addTwoNumbers(l1, l2):\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        while l1 or l2 or carry:\n                a = l1.val if l1 else 0\n                b = l2.val if l2 else 0\n                val = carry + a + b\n                curr.next = ListNode(val % 10)\n                carry = val // 10\n                if l1:\n                        l1 = l1.next\n                if l2:\n                        l2 = l2.next\n                curr = curr.next\n        return dummy.next", "50": "def makesquare(nums):\n        sum = 0\n        for num in nums:\n                sum += num\n        if sum % 4:\n                return false\n        side_len = sum / 4\n        all = (1 << len(nums)) - 1\n        used_subsets = []\n        valid_half_subsets = [false] * (1 << len(nums))\n        for subset in range(0, all + 1):\n                subset_sum = 0\n                for i in range(0, len(nums)):\n                        if subset & (1 << i):\n                                subset_sum += nums[i]\n                if subset_sum == side_len:\n                        for used_subset in used_subsets:\n                                if (used_subset & subset) == 0:\n                                        valid_half_subset = used_subset | subset\n                                        valid_half_subsets[valid_half_subset] = true\n                                        if valid_half_subsets[all ^ valid_half_subset]:\n                                                return true\n                        used_subsets.append(subset)\n        return false", "51": "class Solution:\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\n        stack = []\n        stack.append(TreeNode(pre[0]))\n        for i in range(1, len(pre)):\n            node = TreeNode(pre[i])\n            while stack[-1].val == post[i - 1]:\n                stack.pop()\n                i += 1\n            if stack[-1].left is None:\n                stack[-1].left = node\n            else:\n                stack[-1].right = node\n            stack.append(node)\n        return stack[0]", "52": "def orderlyQueue(S, K):\n                if (K == 1):\n                        result = S;\n                        for i in range(1, len(S)):\n                                result = min(result, S[i:] + S[0:i]);\n                        return result;\n                S = sorted(S);\n                return S;", "53": "def maximumWealth(accounts):\n        result = 0\n        for account in accounts:\n                total = sum(account)\n                result = max(result, total)\n        return result", "54": "def is_anagram(s, t):\n    if len(s) != len(t):\n        return false\n    count = {}\n    for c in s:\n        if c not in count:\n            count[c] = 1\n        else:\n            count[c] += 1\n    for c in t:\n        if c not in count:\n            return false\n        count[c] -= 1\n        if count[c] < 0:\n            return false\n    return true", "55": "def nearestPalindromic(n):\n                l = len(n)\n                candidates = []\n                candidates.append(pow(10, l) + 1)\n                candidates.append(pow(10, l - 1) - 1)\n                prefix = int(n[0:((l + 1) / 2)])\n                for i in range(-1, 1):\n                        p = str(prefix + i)\n                        pp = p + string(p.reverse() + (l % 2), p.reverse())\n                        candidates.append(int(pp))\n                num = int(n)\n                closest_val = numeric_limits<int>::max()\n                candidates.remove(num)\n                for val in candidates:\n                        if abs(val - num) < abs(closest_val - num):\n                                closest_val = val\n                        elif abs(val - num) == abs(closest_val - num):\n                                closest_val = min(closest_val, val)\n                return str(closest_val)", "56": "def sumEvenGrandparent(root):\n        return sumEvenGrandparentHelper(root, 1, 1)\ndef sumEvenGrandparentHelper(root, p, gp):\n        return root if root else 0 + sumEvenGrandparentHelper(root.left, root.val, p) + sumEvenGrandparentHelper(root.right, root.val, p) + (gp % 2 == 0 ? root.val : 0)", "57": "def flatten(head):\n        for curr in head:\n                if (!curr.child):\n                        continue\n                curr_next = curr.next\n                curr.child.prev = curr\n                curr.next = curr.child\n                last_child = curr\n                while (last_child.next):\n                        last_child = last_child.next\n                if (curr_next):\n                        last_child.next = curr_next\n                        curr_next.prev = last_child\n                curr.child = nullptr\n        return head", "58": "def maxNumberOfFamilies(n, reservedSeats):\n        lookup = {}\n        for seat in reservedSeats:\n                if 2 <= seat[1] <= 5:\n                        lookup[seat[0]][0] = True\n                if 4 <= seat[1] <= 7:\n                        lookup[seat[0]][1] = True\n                if 6 <= seat[1] <= 9:\n                        lookup[seat[0]][2] = True\n        result = 2 * n\n        for _, reserved in lookup.items():\n                if not reserved[0] and not reserved[2]:\n                        continue\n                if not reserved[0] !reserved[1] !reserved[2]:\n                        result -= 1\n                        continue\n                result -= 2\n        return result", "59": "def merge(nums1, m, nums2, n):\n    i = m + n\n    while m > 0 and n > 0:\n        if nums1[m - 1] > nums2[n - 1]:\n            nums1[i - 1] = nums1[m - 1]\n            m -= 1\n        else:\n            nums1[i - 1] = nums2[n - 1]\n            n -= 1\n        i -= 1\n    while n > 0:\n        nums1[i - 1] = nums2[n - 1]\n        n -= 1\n        i -= 1", "60": "def minCost(s, cost):\n        result = 0\n        accu = 0\n        max_cost = 0\n        for i in range(len(s)):\n                if i != 0 and s[i] != s[i - 1]:\n                        result += accu - max_cost\n                        accu = max_cost = 0\n                accu += cost[i]\n                max_cost = max(max_cost, cost[i])\n        result += accu - max_cost\n        return result", "61": "def minDays(bloomDay, m, k):\n        if m * k > len(bloomDay):\n                return -1\n        left = 1\n        right = max(bloomDay)\n        while left <= right:\n                mid = left + (right - left) // 2\n                if check(bloomDay, m, k, mid):\n                        right = mid - 1\n                else:\n                        left = mid + 1\n        return left\ndef check(bloomDay, m, k, x):\n        result = 0\n        count = 0\n        for d in bloomDay:\n                count = count + 1 if d <= x else 0\n                if count == k:\n                        count = 0\n                        if result + 1 == m:\n                                break\n                        result += 1\n        return result >= m", "62": "def sortItems(n, m, group_id, beforeItems):\n                for i in range(n):\n                        if group_id[i] == -1:\n                                group_id[i] = m\n                                m += 1\n                global_group = Topo()\n                for i in range(m):\n                        global_group.addNode(i)\n                local_groups = {}\n                for i in range(n):\n                        if group_id[i] not in local_groups:\n                                local_groups[group_id[i]] = Topo()\n                        local_groups[group_id[i]].addNode(i)\n                for i in range(n):\n                        for j in beforeItems[i]:\n                                if group_id[i] == group_id[j]:\n                                        local_groups[group_id[i]].addEdge(j, i)\n                                else:\n                                        global_group.addEdge(group_id[j], group_id[i])\n                result = []\n                global_order = global_group.sort()\n                if not global_order:\n                        return []\n                for i in global_order:\n                        local_order = local_groups[i].sort()\n                        if not local_order:\n                                return []\n                        for x in local_order:\n                                result.append(x)\n                return result\n\n\ndef addNode(node):\n                        nodes_.append(node)\n                def addEdge(from, to):\n                        addNode(from)\n                        addNode(to)\n                        if to not in in_degree_:\n                                in_degree_[to] = set()\n                        if from not in out_degree_:\n                                out_degree_[from] = set()\n                        in_degree_[to].add(from)\n                        out_degree_[from].add(to)\n                def sort():\n                        q = []\n                        result = []\n                        for node in nodes_:\n                                if node not in in_degree_:\n                                        q.append(node)\n                        while len(q) > 0:\n                                node = q.pop(0)\n                                result.append(node)\n                                for nei in out_degree_[node]:\n                                        in_degree_[nei].remove(node)\n                                        if len(in_degree_[nei]) == 0:\n                                                in_degree_.pop(nei)\n                                                q.append(nei)\n                        if len(result) < len(nodes_):\n                                return None\n                        return result", "63": "def levelOrderBottom(root):\n        result = []\n        que = []\n        if root != None:\n                que.append(root)\n        while que != []:\n                level = []\n                size = len(que)\n                for i in range(0, size):\n                        front = que[0]\n                        que.pop(0)\n                        level.append(front.val)\n                        if front.left != None:\n                                que.append(front.left)\n                        if front.right != None:\n                                que.append(front.right)\n                result.append(level)\n        result.reverse()\n        return result", "64": "def longestPalindromeSubseq(s):\n        if s == string(s.rbegin(), s.rend()):\n                return s.length()\n        vector<vector<int>> dp(2, vector<int>(s.size(), 1))\n        for i in s.length() - 2:\n                for j in i + 1:\n                        if s[i] == s[j]:\n                                dp[i % 2][j] = (i + 1 <= j - 1) ? 2 + dp[(i + 1) % 2][j - 1] : 2\n                        else:\n                                dp[i % 2][j] = max(dp[(i + 1) % 2][j], dp[i % 2][j - 1])\n        return dp[0][s.length() - 1]", "65": "def getSumAbsoluteDifferences(nums):\n        prefix = 0\n        suffix = sum(nums)\n        result = []\n        for i in range(len(nums)):\n                suffix -= nums[i]\n                result.append((i * nums[i] - prefix) + (suffix - ((len(nums) - 1) - i) * nums[i]))\n                prefix += nums[i]\n        return result", "66": "def isSubtree(s, t):\n        return preOrderTraverse(s, t)\ndef preOrderTraverse(s, t):\n        return s and (isSame(s, t) or\n                                preOrderTraverse(s.left, t) or\n                                preOrderTraverse(s.right, t))\ndef isSame(x,y):\n        if not x and not y:\n                return true\n        if not x !y:\n                return false\n        return x.val == y.val and\n                isSame(x.left, y.left) and\n                isSame(x.right, y.right)", "67": "def longestCommonSubsequence(text1, text2):\n        if len(text1) < len(text2):\n                return longestCommonSubsequence(text2, text1)\n        dp = [None]*(len(text2)+1)\n        for i in range(1, len(text1)+1):\n                for j in range(1, len(text2)+1):\n                        dp[j] = (text1[i-1] == text2[j-1])\n                                ? dp[j-1] + 1\n                                : max(dp[j-1], dp[j])\n        return dp[len(text2)]", "68": "def findDuplicate(paths):\n\n        files = {}\n\n        for path in paths:\n\n                ss = path.split()\n\n                root = ss[0]\n\n                for s in ss[1:]:\n\n                        fileName = root + '/' + s[:s.find('(')]\n\n                        fileContent = s[s.find('(')+1:s.find(')')]\n\n                        files[fileContent] = files.get(fileContent, []) + [fileName]\n\n        result = []\n\n        for file in files:\n\n                if len(files[file]) > 1:\n\n                        result.append(files[file])\n\n        return result", "69": "def minCostConnectPoints(points):\n        result = 0\n        u = 0\n        dist = [math.inf] * len(points)\n        lookup = set()\n        for i in range(len(points) - 1):\n                x0 = points[u][0]\n                y0 = points[u][1]\n                lookup.add(u)\n                for v in range(len(points)):\n                        if v in lookup:\n                                continue\n                        dist[v] = min(dist[v], abs(points[v][0] - x0) + abs(points[v][1] - y0))\n                val = math.inf\n                for v in range(len(dist)):\n                        if dist[v] < val:\n                                val = dist[v]\n                                u = v\n                dist[u] = math.inf\n                result += val\n        return result", "70": "def numsSameConsecDiff(N, K):\n        curr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        for i in range(0, N-1):\n                next = []\n                for x in curr:\n                        y = x % 10\n                        if x > 0 and y + K < 10:\n                                next.append(x * 10 + y + K)\n                        if x > 0 and K > 0 and y - K >= 0:\n                                next.append(x * 10 + y - K)\n                curr = next\n        return curr", "71": "def maxJumps(arr, d):\n    left = [0] * len(arr)\n    decreasing_dq = []\n    for i in range(0, len(arr)):\n        if decreasing_dq and i - decreasing_dq[0] == d + 1:\n            decreasing_dq.popleft()\n        while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:\n            if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]:\n                left[i].clear()\n            left[i].append(decreasing_dq[-1])\n            decreasing_dq.pop()\n        decreasing_dq.append(i)\n\n    right = [0] * len(arr)\n    decreasing_dq = []\n    for i in range(len(arr) - 1, -1, -1):\n        if decreasing_dq and decreasing_dq[0] - i == d + 1:\n            decreasing_dq.popleft()\n        while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:\n            if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]:\n                right[i].clear()\n            right[i].append(decreasing_dq[-1])\n            decreasing_dq.pop()\n        decreasing_dq.append(i)\n\n    result = 0\n    lookup = [0] * len(arr)\n    for i in range(0, len(arr)):\n        result = max(result, dp(arr, d, i, left, right, lookup))\n    return result\n\n\ndef dp(arr, d, i, left, right, lookup):\n    if lookup[i]:\n        return lookup[i]\n    lookup[i] = 1\n    for j in left[i]:\n        lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup) + 1)\n    for j in right[i]:\n        lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup) + 1)\n    return lookup[i]", "72": "def minFlips(a, b, c):\n                return number_of_1_bits((a b) ^ c) + number_of_1_bits(a & b & ~c);\ndef number_of_1_bits(n):\n                n = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n                n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n                n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F);\n                n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF);\n                n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF);\n                return n;", "73": "def missingNumber(nums):\n        num = 0\n        for i in range (0, len(nums)):\n        num ^= nums[i] ^ (i + 1)\n        return num", "74": "def getStrongest(arr, k):\n                arr.sort()\n                m = arr[(arr.size() -1) / 2]\n                arr = arr[k:]\n                return arr", "75": "def minSwapsCouples(row):\n                N = len(row) / 2\n                couples = [[] for i in range(N)]\n                for seat in range(len(row)):\n                        couples[row[seat] / 2].append(seat / 2)\n                adj = [[] for i in range(N)]\n                for couple in couples:\n                        adj[couple[0]].append(couple[1])\n                        adj[couple[1]].append(couple[0])\n                result = 0\n                for couch in range(N):\n                        if not adj[couch]:\n                                continue\n                        couch1 = couch\n                        couch2 = adj[couch1].pop()\n                        while couch2 != couch:\n                                result += 1\n                                adj[couch2].remove(couch1)\n                                couch1 = couch2\n                                couch2 = adj[couch1].pop()\n                return result", "76": "def nthMagicalNumber(N, A, B):\n\n        M = 1000000007\n\n        a = A\n        b = B\n\n        lcm = a * b / gcd(a, b)\n\n        left = min(a, b)\n        right = max(a, b) * N\n\n        while (left <= right):\n\n                mid = left + (right - left) / 2\n\n                if (check(A, B, N, lcm, mid)):\n                        right = mid - 1\n\n                else:\n                        left = mid + 1\n\n        return left % M\n\n\ndef check(a, b, N, lcm, target):\n\n        return target / a + target / b - target / lcm >= N\n\n\n\ndef gcd(a, b):\n\n        while (b != 0):\n                tmp = b\n                b = a % b\n                a = tmp\n\n        return a", "77": "def distanceBetweenBusStops(distance, start, destination):\n                if (start > destination):\n                        swap(start, destination)\n                s_to_d = accumulate(distance[start:destination], 0)\n                d_to_s = accumulate(distance[:start], 0) + accumulate(distance[destination:], 0)\n                return min(s_to_d, d_to_s)", "78": "def findTarget(root, k):\n        if (not root):\n                return False\n        left = BSTIterator(root, True)\n        right = BSTIterator(root, False)\n        while (*left < *right):\n                if (*left + *right == k):\n                        return True\n                elif (*left + *right < k):\n                        ++left\n                else:\n                        ++right\n        return False", "79": "def bestRotation(A):\n    N = len(A)\n    change = [0]*N\n    \n    for i in range(0, N):\n        change[(i - A[i] + 1 + N)%N] -= 1\n        \n    for i in range(1, N):\n        change[i] += change[i-1] + 1\n        \n    return change.index(max(change))", "80": "def powerfulIntegers(x, y, bound):\n        log_x = 1 if x == 1 else int(floor(log(bound) / log(x))) + 1\n        log_y = 1 if y == 1 else int(floor(log(bound) / log(y))) + 1\n        result = unordered_set()\n        pow_x = 1\n        for i in range(log_x):\n                pow_y = 1\n                for j in range(log_y):\n                        val = pow_x + pow_y\n                        if val <= bound:\n                                result.add(val)\n                        pow_y *= y\n                pow_x *= x\n        return list(result)", "81": "def arraySign(nums):\n                flag = 0;\n                for x in nums:\n                        if x == 0:\n                                return 0;\n                        if x < 0:\n                                flag ^= 1;\n                return flag % 2 ? -1 : 1;", "82": "def minSumOfLengths(arr, target):\n        prefix = {0: -1}\n        dp = [0]*len(arr)\n        result = float('inf')\n        min_len = float('inf')\n        accu = 0\n        for right in range(len(arr)):\n                accu += arr[right]\n                prefix[accu] = right\n                if accu - target in prefix:\n                        left = prefix[accu - target]\n                        min_len = min(min_len, right - left)\n                        if left != -1 and dp[left] != float('inf'):\n                                result = min(result, dp[left] + (right - left))\n                dp[right] = min_len\n        return result if result != float('inf') else -1", "83": "def shortestBridge(A):\n                directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n                lookup = {}\n                target = {}\n                islands = get_islands(A)\n                lookup = move(islands[0])\n                target = move(islands[1])\n                q = []\n                for node in lookup:\n                        q.append([node, 0])\n                while q:\n                        node = q.pop(0)\n                        if target.count(node):\n                                return node - 1\n                        for d in directions:\n                                nei = make_pair(node[0] + d[0], node[1] + d[1])\n                                if 0 > nei[0] or nei[0] >= A.size() or 0 > nei[1] or nei[1] >= A[0].size() or lookup.count(nei):\n                                        continue\n                                q.append([nei, node + 1])\n                                lookup.add(nei)\n\ndef get_islands(A):\n                directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n                islands = []\n                done = {}\n                for r in range(A.size()):\n                        for c in range(A[0].size()):\n                                if A[r][c] == 0 or done.count([r, c]):\n                                        continue\n                                s = [[r, c]]\n                                lookup = set(s)\n                                while s:\n                                        node = s.pop()\n                                        for d in directions:\n                                                nei = [node[0] + d[0], node[1] + d[1]]\n                                                if 0 > nei[0] or nei[0] >= A.size() or 0 > nei[1] or nei[1] >= A[0].size() or lookup.count(nei) or A[nei[0]][nei[1]] == 0:\n                                                        continue\n                                                s.append(nei)\n                                                lookup.add(nei)\n                                for node in lookup:\n                                        done.add(node)\n                                islands.append(lookup)\n                                if len(islands) == 2:\n                                        break\n                return islands", "84": "def solve(board):\n    if board.empty():\n        return\n    q = []\n    for i in range(0, len(board)):\n        if board[i][0] == 'O':\n            board[i][0] = 'V'\n            q.append((i, 0))\n        if board[i][len(board[0]) - 1] == 'O':\n            board[i][len(board[0]) - 1] = 'V'\n            q.append((i, len(board[0]) - 1))\n    for j in range(1, len(board[0]) - 1):\n        if board[0][j] == 'O':\n            board[0][j] = 'V'\n            q.append((0, j))\n        if board[len(board) - 1][j] == 'O':\n            board[len(board) - 1][j] = 'V'\n            q.append((len(board) - 1, j))\n    directions = [[0, -1], [0, 1], [-1, 0], [1, 0]]\n    while len(q) > 0:\n        i, j = q.pop()\n        for d in directions:\n            x = i + d[0]\n            y = j + d[1]\n            if 0 <= x and x < len(board) and 0 <= y and y < len(board[0]) and board[x][y] == 'O':\n                board[x][y] = 'V'\n                q.append((x, y))\n    for i in range(0, len(board)):\n        for j in range(0, len(board[0])):\n            if board[i][j] != 'V':\n                board[i][j] = 'X'\n            else:\n                board[i][j] = 'O'", "85": "def superPow(a, b):\n        result = 1\n        for digit in b:\n                result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337\n        return result\n        \ndef myPow(a, n, b):\n        result = 1\n        x = a % b\n        while n:\n                if n & 1:\n                        result = result * x % b\n                n >>= 1\n                x = x * x % b\n        return result % b", "86": "def shoppingOffers(price, special, needs):\n        return shoppingOffersHelper(price, special, needs, 0)\ndef shoppingOffersHelper(price, special, needs, i):\n        if i == len(special):\n                return sum([a*b for a,b in zip(price,needs)])\n        result = shoppingOffersHelper(price, special, needs, i + 1)\n        for j in range(len(needs)):\n                needs[j] -= special[i][j]\n        if all(i>=0 for i in needs):\n                result = min(result, special[i][-1] + shoppingOffersHelper(price, special, needs, i))\n        for j in range(len(needs)):\n                needs[j] += special[i][j]\n        return result", "87": "vector<string> invalidTransactions(vector<string>& transactions) {\n        static const int AMOUNT = 1000;\n        static const int MINUTES = 60;\n        vector<tuple<string, int, int, string>> trans;\n        for (const auto& transaction : transactions) {\n                const auto& t = split(transaction, ',');\n                trans.emplace_back(t[0], stoi(t[1]), stoi(t[2]), t[3]);\n        }\n        sort(trans.begin(), trans.end(),\n                [](const auto& a, const auto& b) {\n                        return get<1>(a) < get<1>(b); });\n        unordered_map<string, vector<int>> trans_indexes;\n        for (int i = 0; i < trans.size(); ++i) {\n                trans_indexes[get<0>(trans[i])].emplace_back(i);\n        }\n        vector<string> result;\n        for (const auto& [name, indexes] : trans_indexes) {\n                int left = 0, right = 0;\n                for (int i = 0; i < indexes.size(); ++i) {\n                        const auto& t = trans[indexes[i]];\n                        if (get<2>(t) > AMOUNT) {\n                                result.emplace_back(to_str(t));\n                                continue;\n                        }\n                        while (left + 1 < indexes.size() &&\n                                get<1>(trans[indexes[left]]) < get<1>(t) - MINUTES) {\n                                ++left;\n                        }\n                        while (right + 1 < indexes.size() &&\n                                get<1>(trans[indexes[right + 1]]) <= get<1>(t) + MINUTES) {\n                                ++right;\n                        }\n                        for (int i = left; i <= right; ++i) {\n                                if (get<3>(trans[indexes[i]]) != get<3>(t)) {\n                                        result.emplace_back(to_str(t));\n                                        break;\n                                }\n                        }\n                }\n        }\n        return result;\n}\nvector<string> split(const string& s, const char delim) {\n        vector<string> result;\n        auto end = string::npos;\n        do {\n                const auto& start = end + 1;\n                end = s.find(delim, start);\n                result.emplace_back(s.substr(start, end - start));\n        } while (end != string::npos); \n        return result;\n}\nstring to_str(const T& t) {\n        stringstream ss;\n        ss << get<0>(t) << \",\" << get<1>(t) << \",\"\n        << get<2>(t) << \",\" << get<3>(t);\n        return ss.str();\n}", "88": "def shortestCommonSupersequence(str1, str2):\n        dp = [[0 for i in range(len(str2)+1)] for j in range(2)]\n        bt = [[(0,0,'0') for i in range(len(str2)+1)] for j in range(len(str1)+1)]\n        for i in range(len(str1)):\n                bt[i+1][0] = (i,0,str1[i])\n        for j in range(len(str2)):\n                bt[0][j+1] = (0,j,str2[j])\n        for i in range(len(str1)):\n                for j in range(len(str2)):\n                        if (dp[i%2][j+1] > dp[(i+1)%2][j]):\n                                dp[(i+1)%2][j+1] = dp[i%2][j+1]\n                                bt[i+1][j+1] = (i,j+1,str1[i])\n                        else:\n                                dp[(i+1)%2][j+1] = dp[(i+1)%2][j]\n                                bt[i+1][j+1] = (i+1,j,str2[j])\n                        if (str1[i] != str2[j]):\n                                continue\n                        if (dp[i%2][j] + 1 > dp[(i+1)%2][j+1]):\n                                dp[(i+1)%2][j+1] = dp[i%2][j]+1\n                                bt[i+1][j+1] = (i,j,str1[i])\n        i = len(str1)\n        j = len(str2)\n        c = '0'\n        result = ''\n        while (i != 0) and (j != 0):\n                i,j,c = bt[i][j]\n                result = c + result\n        return result", "89": "def numWays(words, target):\n        MOD = 1e9 + 7\n        dp = [0] * (len(target) + 1)\n        dp[0] = 1\n        for i in range(len(words[0])):\n                count = [0] * 26\n                for w in words:\n                        count[ord(w[i]) - ord('a')] += 1\n                for j in range(len(target) - 1, -1, -1):\n                        dp[j + 1] += dp[j] * count[ord(target[j]) - ord('a')] % MOD\n        return dp[-1] % MOD", "90": "def removeDuplicates(nums):\n        if not nums:\n                return 0\n        k = 2\n        left, right = 0, 1\n        while right < len(nums):\n                if nums[left] != nums[right] or (left - k + 1 < 0 and nums[left] != nums[left - k + 1]):\n                        left += 1\n                        nums[left] = nums[right]\n                right += 1\n        return left + 1", "91": "def minMoves(nums):\n        return sum(nums) - len(nums) * min(nums)", "92": "def isOneBitCharacter(bits):\n        parity = 0\n        for i in range(len(bits)-2, -1, -1):\n                if bits[i]:\n                        parity ^= bits[i]\n        return parity == 0", "93": "class UnionFind:\n    def __init__(self, n):\n        self.parents_rank = [i for i in range(n)]\n        self.parents = [i for i in range(n)]\n\n    def find_set(self, x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find_set(self.parents[x])\n        return self.parents[x]\n    \n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return \n        \n        if self.parents_rank[x_root] < self.parents_rank[y_root]:\n            self.parents[x_root] = y_root\n        elif self.parents_rank[x_root] > self.parents_rank[y_root]:\n            self.parents[y_root] = x_root\n        else:\n            self.parents[y_root] = x_root\n            self.parents_rank[x_root] += 1", "94": "def toHex(num):\n        if not num:\n                return \"0\"\n        result = \"\"\n        while num and len(result) != 8:\n                hex = num & 15\n                if hex < 10:\n                        result.push_back('0' + hex)\n                else: \n                        result.push_back('a' + hex - 10)\n                num >>= 4\n        reverse(result)\n        return result", "95": "def addOneRow(self, root, v, d):\n        if d == 1 or d == 0:\n                node = TreeNode(v)\n                if d == 1:\n                        node.left = root\n                else:\n                        node.right = root\n                return node\n        if root and d >= 2:\n                root.left = self.addOneRow(root.left, v, d-1 if d > 2 else 1)\n                root.right = self.addOneRow(root.right, v, d-1 if d > 2 else 0)\n        return root", "96": "def binaryTreePaths(root):\n        result = []\n        path = []\n        binaryTreePathsRecu(root, path, result)\n        return result\ndef binaryTreePathsRecu(node, path, result):\n        if not node:\n                return\n        if not node.left and not node.right:\n                ans = \"\"\n                for n in path:\n                        ans.append(to_string(n.val).append(\"->\"))\n                result.emplace_back(move(ans.append(to_string(node.val))))\n        if node.left:\n                path.emplace_back(node)\n                binaryTreePathsRecu(node.left, path, result)\n                path.pop_back()\n        if node.right:\n                path.emplace_back(node)\n                binaryTreePathsRecu(node.right, path, result)\n                path.pop_back()", "97": "def minTime(n, edges, hasApple):\n                graph = {}\n                for edge in edges:\n                        graph[edge[0]].append(edge[1])\n                        graph[edge[1]].append(edge[0])\n                using RET = pair<int, int>\n                result = RET()\n                stk = [[1, -1, 0, None, &result]]\n                while not stk.empty():\n                        step, par, node, new_ret, ret = stk.pop()\n                        if step == 1:\n                                ret.second = int(hasApple[node])\n                                for nei in graph[node]:\n                                        if nei == par:\n                                                continue\n                                        const new_ret = make_shared<RET>()\n                                        stk.append([2, -1, -1, new_ret, ret])\n                                        stk.append([1, node, nei, None, new_ret.get()])\n                        else:\n                                ret.first += new_ret->first + new_ret->second\n                                ret.second |= bool(new_ret->first + new_ret->second)\n                return 2 * result.first", "98": "def isSolvable(words, result):\n    for w in words:\n        w = w[::-1]\n    result = result[::-1]\n    lookup = {}\n    used = set()\n    return backtracking(words, result, 0, 0, 0, lookup, used)\n\ndef backtracking(words, result, i, j, carry, lookup, used):\n    if j == len(result):\n        return carry == 0\n    if i != len(words):\n        if j >= len(words[i]) or words[i][j] in lookup:\n            return backtracking(words, result, i + 1, j, carry, lookup, used)\n        for val in range(10):\n            if val in used or (val == 0 and j == len(words[i]) - 1):\n                continue\n            lookup[words[i][j]] = val\n            used.add(val)\n            if backtracking(words, result, i + 1, j, carry, lookup, used):\n                return True\n            used.remove(val)\n            del lookup[words[i][j]]\n        return False\n    total = carry\n    for w in words:\n        if j < len(w):\n            total += lookup[w[j]]\n    carry = total // 10\n    val = total % 10\n    if result[j] in lookup:\n        return val == lookup[result[j]] and backtracking(words, result, 0, j + 1, carry, lookup, used)\n    if val in used or (val == 0 and j == len(result) - 1):\n        return False\n    lookup[result[j]] = val\n    used.add(val)\n    if backtracking(words, result, 0, j + 1, carry, lookup, used):\n        return True\n    used.remove(val)\n    del lookup[result[j]]\n    return False", "99": "def fallingSquares(positions):\n                result = []\n                heights = {}\n                maxH = heights[-1] = 0\n                for p in positions:\n                        it0 = heights.upper_bound(p[0])\n                        it1 = heights.lower_bound(p[0] + p[1])\n                        h0 = prev(it0).second\n                        h1 = prev(it1).second\n                        for it in it0:\n                                h0 = max(h0, it.second)\n                        heights.erase(it0, it1)\n                        heights[p[0]] = h0 + p[1]\n                        heights[p[0] + p[1]] = h1\n                        maxH = max(maxH, h0 + p[1])\n                        result.emplace_back(maxH)\n                return result"}}, "Python - C++": {"ID": {"0": 1000, "1": 1566, "2": 599, "3": 1856, "4": 1434, "5": 930, "6": 228, "7": 1691, "8": 977, "9": 236, "10": 833, "11": 227, "12": 404, "13": 1686, "14": 955, "15": 1563, "16": 1128, "17": 1780, "18": 796, "19": 567, "20": 909, "21": 153, "22": 1854, "23": 784, "24": 1018, "25": 1482, "26": 1117, "27": 1829, "28": 1524, "29": 840, "30": 1471, "31": 199, "32": 28, "33": 1642, "34": 1910, "35": 1888, "36": 406, "37": 859, "38": 1723, "39": 1391, "40": 815, "41": 766, "42": 787, "43": 1787, "44": 1737, "45": 917, "46": 233, "47": 111, "48": 658, "49": 1201, "50": 135, "51": 1632, "52": 783, "53": 414, "54": 560, "55": 173, "56": 1053, "57": 621, "58": 375, "59": 1721, "60": 91, "61": 844, "62": 2, "63": 1367, "64": 337, "65": 1827, "66": 1654, "67": 762, "68": 1832, "69": 1876, "70": 387, "71": 129, "72": 1247, "73": 1796, "74": 1585, "75": 824, "76": 50, "77": 1020, "78": 1904, "79": 1834, "80": 1695, "81": 740, "82": 1145, "83": 1913, "84": 961, "85": 230, "86": 1161, "87": 1025, "88": 1905, "89": 1234, "90": 47, "91": 1614, "92": 897, "93": 1458, "94": 514, "95": 1616, "96": 1021, "97": 690, "98": 1646, "99": 1863}, "Python": {"0": "def mergeStones(self, stones, K):\n                if (len(stones)-1) % (K-1):\n                        return -1\n                prefix = [0]\n                for x in stones:\n                        prefix.append(prefix[-1]+x)\n                dp = [[0]*len(stones) for _ in xrange(len(stones))]\n                for l in xrange(K-1, len(stones)):\n                        for i in xrange(len(stones)-l):\n                                dp[i][i+l] = min(dp[i][j]+dp[j+1][i+l] for j in xrange(i, i+l, K-1))\n                                if l % (K-1) == 0:\n                                        dp[i][i+l] += prefix[i+l+1] - prefix[i]\n                return dp[0][len(stones)-1]", "1": "def containsPattern(self, arr, m, k):\n                cnt = 0\n                for i in xrange(len(arr)-m):\n                        if arr[i] != arr[i+m]:\n                                cnt = 0\n                                continue\n                        cnt += 1\n                        if cnt == (k-1)*m:\n                                return True\n                return False", "2": "def findRestaurant(self, list1, list2):\n                lookup = {}\n                for i, s in enumerate(list1):\n                        lookup[s] = i\n                result = []\n                min_sum = float(\"inf\")\n                for j, s in enumerate(list2):\n                        if j > min_sum:\n                                break\n                        if s in lookup:\n                                if j + lookup[s] < min_sum:\n                                        result = [s]\n                                        min_sum = j + lookup[s]\n                                elif j + lookup[s] == min_sum:\n                                        result.append(s)\n                return result", "3": "def maxSumMinProduct(self, nums):\n                MOD = 10**9+7\n                prefix = [0]*(len(nums)+1)\n                for i in xrange(len(nums)):\n                        prefix[i+1] = prefix[i]+nums[i]\n                stk, result = [-1], 0\n                for i in xrange(len(nums)+1):\n                        while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):\n                                result = max(result, nums[stk.pop()]*(prefix[(i-1)+1]-prefix[stk[-1]+1]))\n                        stk.append(i) \n                return result%MOD", "4": "def numberWays(self, hats):\n                MOD = 10**9 + 7\n                HAT_SIZE = 40\n                hat_to_people = [[] for _ in xrange(HAT_SIZE)]\n                for i in xrange(len(hats)):\n                        for h in hats[i]:\n                                hat_to_people[h-1].append(i)\n                dp = [0]*(1<<len(hats))\n                dp[0] = 1\n                for people in hat_to_people:\n                        for mask in reversed(xrange(len(dp))):\n                                for p in people:\n                                        if mask & (1<<p):\n                                                continue\n                                        dp[mask (1<<p)] += dp[mask]\n                                        dp[mask (1<<p)] %= MOD\n                return dp[-1]", "5": "def numSubarraysWithSum(self, A, S):\n                result = 0\n                left, right, sum_left, sum_right = 0, 0, 0, 0\n                for i, a in enumerate(A):\n                        sum_left += a\n                        while left < i and sum_left > S:\n                                sum_left -= A[left]\n                                left += 1\n                        sum_right += a\n                        while right < i and \\\n                                (sum_right > S or (sum_right == S and not A[right])):\n                                sum_right -= A[right]\n                                right += 1\n                        if sum_left == S:\n                                result += right-left+1\n                return result", "6": "def summaryRanges(self, nums):\n                ranges = []\n                if not nums:\n                        return ranges\n                start, end = nums[0], nums[0]\n                for i in xrange(1, len(nums) + 1):\n                        if i < len(nums) and nums[i] == end + 1:\n                                end = nums[i]\n                        else:\n                                interval = str(start)\n                                if start != end:\n                                        interval += \"->\" + str(end)\n                                ranges.append(interval)\n                                if i < len(nums):\n                                        start = end = nums[i]\n                return ranges", "7": "def maxHeight(self, cuboids):\n                for cuboid in cuboids:\n                        cuboid.sort()\n                cuboids.append([0, 0, 0])\n                cuboids.sort()\n                dp = [0]*len(cuboids)\n                for i in xrange(1, len(cuboids)):\n                        for j in xrange(i):\n                                if all(cuboids[j][k] <= cuboids[i][k] for k in xrange(3)):\n                                        dp[i] = max(dp[i], dp[j]+cuboids[i][2])\n                return max(dp)", "8": "def sortedSquares(self, A):\n                right = bisect.bisect_left(A, 0)\n                left = right-1\n                result = []\n                while 0 <= left or right < len(A):\n                        if right == len(A) or \\\n                        (0 <= left and A[left]**2 < A[right]**2):\n                                result.append(A[left]**2)\n                                left -= 1\n                        else:\n                                result.append(A[right]**2)\n                                right += 1\n                return result", "9": "def lowestCommonAncestor(self, root, p, q):\n                if root in (None, p, q):\n                        return root\n                left, right = [self.lowestCommonAncestor(child, p, q) \\ for child in (root.left, root.right)]\n                return root if left and right else left or right", "10": "def findReplaceString(self, S, indexes, sources, targets):\n                for i, s, t in sorted(zip(indexes, sources, targets), reverse=True):\n                        if S[i:i+len(s)] == s:\n                                S = S[:i] + t + S[i+len(s):]\n                return S", "11": "def calculate(self, s):\n                def compute(operands, operators):\n                        right, left = operands.pop(), operands.pop()\n                        operands.append(ops[operators.pop()](left, right))\n                ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n                precedence = {'+':0, '-':0, '*':1, '/':1}\n                operands, operators, operand = [], [], 0\n                for i in xrange(len(s)):\n                        if s[i].isdigit():\n                                operand = operand*10 + int(s[i])\n                                if i == len(s)-1 or not s[i+1].isdigit():\n                                        operands.append(operand)\n                                        operand = 0\n                        elif s[i] == '(':\n                                operators.append(s[i]) elif s[i] == ')':\n                                while operators[-1] != '(':\n                                        compute(operands, operators)\n                                operators.pop()\n                        elif s[i] in precedence:\n                                while operators and operators[-1] in precedence and \\\n                                        precedence[operators[-1]] >= precedence[s[i]]:\n                                        compute(operands, operators)\n                                operators.append(s[i])\n                while operators:\n                        compute(operands, operators)\n                return operands[-1]", "12": "def sumOfLeftLeaves(self, root):\n                def sumOfLeftLeavesHelper(root, is_left):\n                        if not root:\n                                return 0\n                        if not root.left and not root.right:\n                                return root.val if is_left else 0\n                        return sumOfLeftLeavesHelper(root.left, True) + \\\n                                sumOfLeftLeavesHelper(root.right, False)\n                return sumOfLeftLeavesHelper(root, False)\ndef sumOfLeftLeavesHelper(root, is_left):\n                        if not root:\n                                return 0\n                        if not root.left and not root.right:\n                                return root.val if is_left else 0\n                        return sumOfLeftLeavesHelper(root.left, True) + \\\n                                sumOfLeftLeavesHelper(root.right, False)", "13": "def stoneGameVI(self, aliceValues, bobValues):\n                sorted_vals = sorted(((a, b) for a, b in zip(aliceValues, bobValues)), key=sum, reverse=True)\n                return cmp(sum(a for a, _ in sorted_vals[::2]), sum(b for _, b in sorted_vals[1::2]))", "14": "def minDeletionSize(self, A):\n                result = 0\n                is_sorted = [False]*(len(A)-1)\n                for j in xrange(len(A[0])):\n                        tmp = is_sorted[:]\n                        for i in xrange(len(A)-1):\n                                if A[i][j] > A[i+1][j] and tmp[i] == False:\n                                        result += 1\n                                        break\n                                if A[i][j] < A[i+1][j]:\n                                        tmp[i] = True\n                        else:\n                                is_sorted = tmp\n                return result", "15": "def stoneGameV(self, stoneValue):\n                n = len(stoneValue)\n                prefix = [0]\n                for v in stoneValue:\n                        prefix.append(prefix[-1] + v)\n                mid = [[0]*n for _ in xrange(n)]\n                for l in xrange(1, n+1):\n                        for i in xrange(n-l+1):\n                                j = i+l-1\n                                p = i if l == 1 else mid[i][j-1]\n                                while prefix[p]-prefix[i] < prefix[j+1]-prefix[p]:\n                                        p += 1 \n                                mid[i][j] = p\n                rmq = [[0]*n for _ in xrange(n)]\n                for i in xrange(n):\n                        rmq[i][i] = stoneValue[i]\n                dp = [[0]*n for _ in xrange(n)]\n                for l in xrange(2, n+1):\n                        for i in xrange(n-l+1):\n                                j = i+l-1\n                                p = mid[i][j]\n                                max_score = 0\n                                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:\n                                        max_score = max(rmq[i][p-1], rmq[j][p])\n                                else:\n                                        if i <= p-2:\n                                                max_score = max(max_score, rmq[i][p-2])\n                                        if p <= j:\n                                                max_score = max(max_score, rmq[j][p])\n                                dp[i][j] = max_score\n                                rmq[i][j] = max(rmq[i][j-1], (prefix[j+1]-prefix[i]) + max_score)\n                                rmq[j][i] = max(rmq[j][i+1], (prefix[j+1]-prefix[i]) + max_score)\n                return dp[0][n-1]", "16": "def numEquivDominoPairs(self, dominoes):\n                counter = collections.Counter((min(x), max(x)) for x in dominoes)\n                return sum(v*(v-1)//2 for v in counter.itervalues())", "17": "def checkPowersOfThree(self, n):\n                while n > 0:\n                        if n%3 == 2:\n                                return False\n                        n //= 3\n                return True", "18": "def rotateString(self, A, B):\n                return len(A) == len(B) and B in A*2", "19": "def checkInclusion(self, s1, s2):\n                counts = collections.Counter(s1)\n                l = len(s1)\n                for i in xrange(len(s2)):\n                        if counts[s2[i]] > 0:\n                                l -= 1\n                        counts[s2[i]] -= 1\n                        if l == 0:\n                                return True\n                        start = i + 1 - len(s1)\n                        if start >= 0:\n                                counts[s2[start]] += 1\n                                if counts[s2[start]] > 0:\n                                        l += 1\n                return False", "20": "def snakesAndLadders(self, board):\n                def coordinate(n, s):\n                        a, b = divmod(s-1, n)\n                        r = n-1-a\n                        c = b if r%2 != n%2 else n-1-b\n                        return r, c\n                n = len(board)\n                lookup = {1: 0}\n                q = collections.deque([1])\n                while q:\n                        s = q.popleft()\n                        if s == n*n:\n                                return lookup[s]\n                        for s2 in xrange(s+1, min(s+6, n*n)+1):\n                                r, c = coordinate(n, s2)\n                                if board[r][c] != -1:\n                                        s2 = board[r][c]\n                                if s2 not in lookup:\n                                        lookup[s2] = lookup[s]+1\n                                        q.append(s2)\n                return -1\ndef coordinate(n, s):\n                        a, b = divmod(s-1, n)\n                        r = n-1-a\n                        c = b if r%2 != n%2 else n-1-b\n                        return r, c", "21": "def findMin(self, nums):\n                left, right = 0, len(nums) - 1\n                while left < right and nums[left] >= nums[right]:\n                        mid = left + (right - left) / 2\n                        if nums[mid] < nums[left]:\n                                right = mid\n                        else:\n                                left = mid + 1\n                return nums[left]", "22": "def maximumPopulation(self, logs):\n                MIN_YEAR, MAX_YEAR = 1950, 2050\n                years = [0]*(MAX_YEAR-MIN_YEAR+1)\n                for s, e in logs:\n                        years[s-MIN_YEAR] += 1\n                        years[e-MIN_YEAR] -= 1\n                result = 0\n                for i in xrange(len(years)):\n                        if i:\n                                years[i] += years[i-1]\n                        if years[i] > years[result]:\n                                result = i\n                return result+MIN_YEAR", "23": "def letterCasePermutation(self, S):\n                result = [[]]\n                for c in S:\n                        if c.isalpha():\n                                for i in xrange(len(result)):\n                                        result.append(result[i][:])\n                                        result[i].append(c.lower())\n                                        result[-1].append(c.upper())\n                        else:\n                                for s in result:\n                                        s.append(c)\n                return map(\"\".join, result)", "24": "def prefixesDivBy5(self, A):\n                for i in xrange(1, len(A)):\n                        A[i] += A[i-1] * 2 % 5\n                return [x % 5 == 0 for x in A]", "25": "def minDays(self, bloomDay, m, k):\n                def check(bloomDay, m, k, x):\n                        result = count = 0\n                        for d in bloomDay:\n                                count = count+1 if d <= x else 0\n                                if count == k:\n                                        count = 0\n                                        result += 1\n                                        if result == m:\n                                                break\n                        return result >= m\n                if m*k > len(bloomDay):\n                        return -1\n                left, right = 1, max(bloomDay)\n                while left <= right:\n                        mid = left + (right-left)//2\n                        if check(bloomDay, m, k, mid):\n                                right = mid-1\n                        else:\n                                left = mid+1\n                return left\ndef check(bloomDay, m, k, x):\n                        result = count = 0\n                        for d in bloomDay:\n                                count = count+1 if d <= x else 0\n                                if count == k:\n                                        count = 0\n                                        result += 1\n                                        if result == m:\n                                                break\n                        return result >= m", "26": "def __init__(self):\n                self.__l = threading.Lock()\n                self.__nH = 0\n                self.__nO = 0\n                self.__releaseHydrogen = None\n                self.__releaseOxygen = None\ndef hydrogen(self, releaseHydrogen):\n                with self.__l:\n                        self.__releaseHydrogen = releaseHydrogen\n                        self.__nH += 1\n                        self.__output()\ndef oxygen(self, releaseOxygen):\n                with self.__l:\n                        self.__releaseOxygen = releaseOxygen\n                        self.__nO += 1\n                        self.__output()\ndef __output(self):\n                while self.__nH >= 2 and \\\n                        self.__nO >= 1:\n                        self.__nH -= 2\n                        self.__nO -= 1\n                        self.__releaseHydrogen()\n                        self.__releaseHydrogen()\n                        self.__releaseOxygen()\ndef __init__(self):\n                self.__nH = 0\n                self.__nO = 0\n                self.__cv = threading.Condition()\ndef hydrogen(self, releaseHydrogen):\n                with self.__cv:\n                        while 2*(self.__nO+1) - self.__nH > 2:\n                                self.__cv.wait()\n                        self.__nO += 1\n                        releaseOxygen()\n                        self.__cv.notifyAll()", "27": "def getMaximumXor(self, nums, maximumBit):\n                result = [0]*len(nums)\n                mask = 2**maximumBit-1\n                for i in xrange(len(nums)):\n                        mask ^= nums[i]\n                        result[-1-i] = mask\n                return result", "28": "def numOfSubarrays(self, arr):\n                MOD = 10**9+7\n                result, accu = 0, 0\n                dp = [1, 0]\n                for x in arr:\n                        accu ^= x&1\n                        dp[accu] += 1\n                        result = (result + dp[accu^1]) % MOD\n                return result", "29": "def numMagicSquaresInside(self, grid):\n                def magic(grid, r, c):\n                        expect = k * (k**2+1) // 2\n                        nums = set()\n                        min_num = float(\"inf\")\n                        sum_diag, sum_anti = 0, 0\n                        for i in xrange(k):\n                                sum_diag += grid[r+i][c+i]\n                                sum_anti += grid[r+i][c+k-1-i]\n                                sum_r, sum_c = 0, 0\n                                for j in xrange(k):\n                                        min_num = min(min_num, grid[r+i][c+j])\n                                        nums.add(grid[r+i][c+j])\n                                        sum_r += grid[r+i][c+j]\n                                        sum_c += grid[r+j][c+i]\n                                if not (sum_r == sum_c == expect):\n                                        return False\n                        return sum_diag == sum_anti == expect and \\\n                                len(nums) == k**2 and \\\n                                min_num == 1\n                k = 3\n                result = 0\n                for r in xrange(len(grid)-k+1):\n                        for c in xrange(len(grid[r])-k+1):\n                                if magic(grid, r, c):\n                                        result += 1\n                return result\ndef magic(grid, r, c):\n                        expect = k * (k**2+1) // 2\n                        nums = set()\n                        min_num = float(\"inf\")\n                        sum_diag, sum_anti = 0, 0\n                        for i in xrange(k):\n                                sum_diag += grid[r+i][c+i]\n                                sum_anti += grid[r+i][c+k-1-i]\n                                sum_r, sum_c = 0, 0\n                                for j in xrange(k):\n                                        min_num = min(min_num, grid[r+i][c+j])\n                                        nums.add(grid[r+i][c+j])\n                                        sum_r += grid[r+i][c+j]\n                                        sum_c += grid[r+j][c+i]\n                                if not (sum_r == sum_c == expect):\n                                        return False\n                        return sum_diag == sum_anti == expect and \\\n                                len(nums) == k**2 and \\\n                                min_num == 1", "30": "def getStrongest(self, arr, k):\n                def nth_element(nums, n, compare=lambda a, b: a < b):\n                        def partition_around_pivot(left, right, pivot_idx, nums, compare):\n                                new_pivot_idx = left\n                                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                                for i in xrange(left, right):\n                                        if compare(nums[i], nums[right]):\n                                                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                                                new_pivot_idx += 1\n                                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                                return new_pivot_idx\n                        left, right = 0, len(nums) - 1\n                        while left <= right:\n                                pivot_idx = random.randint(left, right)\n                                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)\n                                if new_pivot_idx == n:\n                                        return\n                                elif new_pivot_idx > n:\n                                        right = new_pivot_idx - 1\n                                else: \n                                        left = new_pivot_idx + 1\n                nth_element(arr, (len(arr)-1)//2)\n                m = arr[(len(arr)-1)//2]\n                nth_element(arr, k, lambda a, b: abs(a-m) > abs(b-m) if abs(a-m) != abs(b-m) else a > b)\n                return arr[:k]\ndef nth_element(nums, n, compare=lambda a, b: a < b):\n                        def partition_around_pivot(left, right, pivot_idx, nums, compare):\n                                new_pivot_idx = left\n                                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                                for i in xrange(left, right):\n                                        if compare(nums[i], nums[right]):\n                                                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                                                new_pivot_idx += 1\n                                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                                return new_pivot_idx\n                        left, right = 0, len(nums) - 1\n                        while left <= right:\n                                pivot_idx = random.randint(left, right)\n                                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)\n                                if new_pivot_idx == n:\n                                        return\n                                elif new_pivot_idx > n:\n                                        right = new_pivot_idx - 1\n                                else: \n                                        left = new_pivot_idx + 1\ndef partition_around_pivot(left, right, pivot_idx, nums, compare):\n                                new_pivot_idx = left\n                                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                                for i in xrange(left, right):\n                                        if compare(nums[i], nums[right]):\n                                                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                                                new_pivot_idx += 1\n                                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                                return new_pivot_idx", "31": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef rightSideView(self, root):\n                result = []\n                self.rightSideViewDFS(root, 1, result)\n                return result\ndef rightSideViewDFS(self, node, depth, result):\n                if not node:\n                        return\n                if depth > len(result):\n                        result.append(node.val)\n                self.rightSideViewDFS(node.right, depth+1, result)\n                self.rightSideViewDFS(node.left, depth+1, result)", "32": "def strStr(self, haystack, needle):\n                for i in xrange(len(haystack) - len(needle) + 1):\n                        if haystack[i : i + len(needle)] == needle:\n                                return i\n                return -1", "33": "def furthestBuilding(self, heights, bricks, ladders):\n                min_heap = []\n                for i in xrange(len(heights)-1):\n                        diff = heights[i+1]-heights[i]\n                        if diff > 0:\n                                heapq.heappush(min_heap, diff)\n                        if len(min_heap) <= ladders: \n                                continue\n                        bricks -= heapq.heappop(min_heap) \n                        if bricks < 0: \n                                return i\n                return len(heights)-1", "34": "def removeOccurrences(self, s, part):\n                def getPrefix(pattern):\n                        prefix = [-1]*len(pattern)\n                        j = -1\n                        for i in xrange(1, len(pattern)):\n                                while j != -1 and pattern[j+1] != pattern[i]:\n                                        j = prefix[j]\n                                if pattern[j+1] == pattern[i]:\n                                        j += 1\n                                prefix[i] = j\n                        return prefix\n                prefix = getPrefix(part)\n                result, lookup = [], []\n                i = -1\n                for c in s:\n                        while i != -1 and part[i+1] != c:\n                                i = prefix[i]\n                        if part[i+1] == c:\n                                i += 1\n                        result.append(c)\n                        lookup.append(i)\n                        if i == len(part)-1:\n                                result[len(result)-len(part):] = []\n                                lookup[len(lookup)-len(part):] = []\n                                i = lookup[-1] if lookup else -1\n                return \"\".join(result)\ndef getPrefix(pattern):\n                        prefix = [-1]*len(pattern)\n                        j = -1\n                        for i in xrange(1, len(pattern)):\n                                while j != -1 and pattern[j+1] != pattern[i]:\n                                        j = prefix[j]\n                                if pattern[j+1] == pattern[i]:\n                                        j += 1\n                                prefix[i] = j\n                        return prefix", "35": "def minFlips(self, s):\n                result = float(\"inf\")\n                cnt1 = cnt2 = 0\n                for i in xrange(2*len(s)-1 if len(s)%2 else len(s)):\n                        if i >= len(s):\n                                cnt1 -= int(s[i%len(s)])^((i-len(s))%2)^0\n                                cnt2 -= int(s[i%len(s)])^((i-len(s))%2)^1\n                        cnt1 += int(s[i%len(s)])^(i%2)^0\n                        cnt2 += int(s[i%len(s)])^(i%2)^1\n                        if i >= len(s)-1:\n                                result = min(result, cnt1, cnt2)\n                return result", "36": "def reconstructQueue(self, people):\n                people.sort(key=lambda h_k1: (-h_k1[0], h_k1[1]))\n                result = []\n                for p in people:\n                        result.insert(p[1], p)\n                return result", "37": "def buddyStrings(self, A, B):\n                if len(A) != len(B):\n                        return False\n                diff = []\n                for a, b in itertools.izip(A, B):\n                        if a != b:\n                                diff.append((a, b))\n                                if len(diff) > 2:\n                                        return False\n                return (not diff and len(set(A)) < len(A)) or \\\n                        (len(diff) == 2 and diff[0] == diff[1][::-1])", "38": "def minimumTimeRequired(self, jobs, k):\n                def backtracking(jobs, i, counts, result):\n                        if i == len(jobs):\n                                result[0] = min(result[0], max(counts))\n                                return\n                        for j in xrange(len(counts)):\n                                if counts[j]+jobs[i] <= result[0]:\n                                        counts[j] += jobs[i]\n                                        backtracking(jobs, i+1, counts, result)\n                                        counts[j] -= jobs[i]\n                                if counts[j] == 0:\n                                        break\n                jobs.sort(reverse=False)\n                result = [sum(jobs)]\n                backtracking(jobs, 0, [0]*k, result)\n                return result[0]\ndef backtracking(jobs, i, counts, result):\n                        if i == len(jobs):\n                                result[0] = min(result[0], max(counts))\n                                return\n                        for j in xrange(len(counts)):\n                                if counts[j]+jobs[i] <= result[0]:\n                                        counts[j] += jobs[i]\n                                        backtracking(jobs, i+1, counts, result)\n                                        counts[j] -= jobs[i]\n                                if counts[j] == 0:\n                                        break", "39": "def hasValidPath(self, grid):\n                E, S, W, N = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n                directions = [\n                        [W, E], [N, S],\n                        [W, S], [S, E],\n                        [W, N], [N, E] ]\n                for r, c in directions[grid[0][0]-1]:\n                        if not (0 <= r < len(grid) and 0 <= c < len(grid[0])):\n                                continue\n                        pr, pc = 0, 0\n                        while r != len(grid)-1 or c != len(grid[0])-1:\n                                for dx, dy in directions[grid[r][c]-1]:\n                                        nr, nc = r+dx, c+dy\n                                        if (nr == pr and nc == pc) or \\\n                                        not(0 <= nr < len(grid) and 0 <= nc < len(grid[0])) or \\\n                                        (-dx, -dy) not in directions[grid[nr][nc]-1]:\n                                                continue\n                                        pr, pc, r, c = r, c, nr, nc\n                                        break\n                                else:\n                                        return False\n                        return True\n                return len(grid) == len(grid[0]) == 1", "40": "def numBusesToDestination(self, routes, S, T):\n                if S == T:\n                        return 0\n                to_route = collections.defaultdict(set)\n                for i, route in enumerate(routes):\n                        for stop in route:\n                                to_route[stop].add(i)\n                result = 1\n                q = [S]\n                lookup = set([S])\n                while q:\n                        next_q = []\n                        for stop in q:\n                                for i in to_route[stop]:\n                                        for next_stop in routes[i]:\n                                                if next_stop in lookup:\n                                                        continue\n                                                if next_stop == T:\n                                                        return result\n                                                next_q.append(next_stop)\n                                                to_route[next_stop].remove(i)\n                                                lookup.add(next_stop)\n                        q = next_q\n                        result += 1\n                return -1", "41": "def isToeplitzMatrix(self, matrix):\n                for row_index, row in enumerate(matrix):\n                        for digit_index, digit in enumerate(row):\n                                if not row_index or not digit_index:\n                                        continue\n                                if matrix[row_index - 1][digit_index - 1] != digit:\n                                        return False\n                return True", "42": "def findCheapestPrice(self, n, flights, src, dst, K):\n                adj = collections.defaultdict(list)\n                for u, v, w in flights:\n                        adj[u].append((v, w))\n                best = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\"inf\")))\n                best[src][K+1] = 0\n                min_heap = [(0, src, K+1)]\n                while min_heap:\n                        result, u, k = heapq.heappop(min_heap)\n                        if k < 0 or best[u][k] < result:\n                                continue\n                        if u == dst:\n                                return result\n                        for v, w in adj[u]:\n                                if result+w < best[v][k-1]:\n                                        best[v][k-1] = result+w                                        \n                                        heapq.heappush(min_heap, (result+w, v, k-1))\n                return -1", "43": "def minChanges(self, nums, k):\n                def one_are_not_from_nums(nums, cnts):\n                        mxs = [cnts[i].most_common(1)[0][1] for i in xrange(k)]\n                        return len(nums) - (sum(mxs)-min(mxs))\n                def all_are_from_nums(nums, cnts):\n                        dp = {0:0}\n                        for cnt in cnts:\n                                new_dp = collections.defaultdict(int)\n                                for x in dp.iterkeys():\n                                        for y in cnt.iterkeys():\n                                                new_dp[x^y] = max(new_dp[x^y], dp[x]+cnt[y])\n                                dp = new_dp\n                        return len(nums)-dp[0]\n                cnts = [collections.Counter(nums[j] for j in xrange(i, len(nums), k)) for i in xrange(k)]\n                return min(one_are_not_from_nums(nums, cnts), all_are_from_nums(nums, cnts))\ndef one_are_not_from_nums(nums, cnts):\n                        mxs = [cnts[i].most_common(1)[0][1] for i in xrange(k)]\n                        return len(nums) - (sum(mxs)-min(mxs))\ndef all_are_from_nums(nums, cnts):\n                        dp = {0:0}\n                        for cnt in cnts:\n                                new_dp = collections.defaultdict(int)\n                                for x in dp.iterkeys():\n                                        for y in cnt.iterkeys():\n                                                new_dp[x^y] = max(new_dp[x^y], dp[x]+cnt[y])\n                                dp = new_dp\n                        return len(nums)-dp[0]", "44": "def minCharacters(self, a, b):\n                count1 = collections.Counter(ord(c)-ord('a') for c in a)\n                count2 = collections.Counter(ord(c)-ord('a') for c in b)\n                result = len(a) + len(b) - max((count1+count2).itervalues()) \n                for i in xrange(26-1):\n                        if i > 0:\n                                count1[i] += count1[i-1]\n                                count2[i] += count2[i-1]\n                        result = min(result, len(a) - count1[i] + count2[i]) \n                        result = min(result, len(b) - count2[i] + count1[i]) \n                return result", "45": "def reverseOnlyLetters(self, S):\n                def getNext(S):\n                        for i in reversed(xrange(len(S))):\n                                if S[i].isalpha():\n                                        yield S[i]\n                result = []\n                letter = getNext(S)\n                for i in xrange(len(S)):\n                        if S[i].isalpha():\n                                result.append(letter.next())\n                        else:\n                                result.append(S[i])\n                return \"\".join(result)\ndef getNext(S):\n                        for i in reversed(xrange(len(S))):\n                                if S[i].isalpha():\n                                        yield S[i]", "46": "def countDigitOne(self, n):\n                DIGIT = 1\n                is_zero = int(DIGIT == 0)\n                result = is_zero\n                base = 1\n                while n >= base:\n                        result += (n//(10*base)-is_zero)*base + \\\n                                        min(base, max(n%(10*base) - DIGIT*base + 1, 0))\n                        base *= 10\n                return result", "47": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef minDepth(self, root):\n                if root is None:\n                        return 0\n                if root.left and root.right:\n                        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n                else:\n                        return max(self.minDepth(root.left), self.minDepth(root.right)) + 1", "48": "def findClosestElements(self, arr, k, x):\n                i = bisect.bisect_left(arr, x)\n                left, right = i-1, i\n                while k:\n                        if right >= len(arr) or \\\n                        (left >= 0 and abs(arr[left]-x) <= abs(arr[right]-x)):\n                                left -= 1\n                        else:\n                                right += 1\n                        k -= 1\n                return arr[left+1:right]", "49": "def nthUglyNumber(self, n, a, b, c):\n                def gcd(a, b):\n                        while b:\n                                a, b = b, a % b\n                        return a\n                def lcm(x, y):\n                        return x//gcd(x, y)*y\n                def count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):\n                        return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c\n                lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a)\n                lcm_a_b_c = lcm(lcm_a_b, lcm_b_c)\n                left, right = 1, 2*10**9\n                while left <= right:\n                        mid = left + (right-left)//2\n                        if count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n:\n                                right = mid-1\n                        else:\n                                left = mid+1\n                return left\ndef gcd(a, b):\n                        while b:\n                                a, b = b, a % b\n                        return a\ndef lcm(x, y):\n                        return x//gcd(x, y)*y\ndef count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):\n                        return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c", "50": "def candy(self, ratings):\n                candies = [1 for _ in xrange(len(ratings))]\n                for i in xrange(1, len(ratings)):\n                        if ratings[i] > ratings[i - 1]:\n                                candies[i] = candies[i - 1] + 1\n                for i in reversed(xrange(1, len(ratings))):\n                        if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]:\n                                candies[i - 1] = candies[i] + 1\n                return sum(candies)", "51": "def __init__(self, n, cb):\n                self.set = range(n)\n                self.rank = [0]*n\n                self.cb = cb\ndef find_set(self, x):\n                stk = []\n                while self.set[x] != x: \n                        stk.append(x)\n                        x = self.set[x]\n                while stk:\n                        self.set[stk.pop()] = x\n                return x\ndef union_set(self, x, y):\n                x_root, y_root = map(self.find_set, (x, y))\n                if x_root == y_root:\n                        return False\n                if self.rank[x_root] < self.rank[y_root]: \n                        self.set[x_root] = y_root\n                        self.cb(y_root, x_root, y_root)\n                elif self.rank[x_root] > self.rank[y_root]:\n                        self.set[y_root] = x_root\n                        self.cb(x_root, x_root, y_root)\n                else:\n                        self.set[y_root] = x_root\n                        self.rank[x_root] += 1\n                        self.cb(x_root, x_root, y_root)\n                return True\ndef matrixRankTransform(self, matrix):\n                def cb(x, y, z):\n                        new_rank[x] = max(new_rank[y], new_rank[z])\n                lookup = collections.defaultdict(list)\n                for i in xrange(len(matrix)):\n                        for j in xrange(len(matrix[0])):\n                                lookup[matrix[i][j]].append([i, j])\n                rank = [0]*(len(matrix)+len(matrix[0]))\n                for x in sorted(lookup):\n                        new_rank = rank[:]\n                        union_find = UnionFind(len(matrix)+len(matrix[0]), cb)\n                        for i, j in lookup[x]:\n                                union_find.union_set(i, j+len(matrix))\n                        for i, j in lookup[x]:\n                                matrix[i][j] = rank[i] = rank[j+len(matrix)] = new_rank[union_find.find_set(i)]+1\n                return matrix\ndef cb(x, y, z):\n                        new_rank[x] = max(new_rank[y], new_rank[z])", "52": "def minDiffInBST(self, root):\n                def dfs(node):\n                        if not node:\n                                return\n                        dfs(node.left)\n                        self.result = min(self.result, node.val-self.prev)\n                        self.prev = node.val\n                        dfs(node.right)\n                self.prev = float('-inf')\n                self.result = float('inf')\n                dfs(root)\n                return self.result\ndef dfs(node):\n                        if not node:\n                                return\n                        dfs(node.left)\n                        self.result = min(self.result, node.val-self.prev)\n                        self.prev = node.val\n                        dfs(node.right)", "53": "def thirdMax(self, nums):\n                count = 0\n                top = [float(\"-inf\")] * 3\n                for num in nums:\n                        if num > top[0]:\n                                top[0], top[1], top[2] = num, top[0], top[1]\n                                count += 1\n                        elif num != top[0] and num > top[1]:\n                                top[1], top[2] = num, top[1]\n                                count += 1\n                        elif num != top[0] and num != top[1] and num >= top[2]:\n                                top[2] = num\n                                count += 1\n                if count < 3:\n                        return top[0]\n                return top[2]", "54": "def subarraySum(self, nums, k):\n                result = 0\n                accumulated_sum = 0\n                lookup = collections.defaultdict(int)\n                lookup[0] += 1\n                for num in nums:\n                        accumulated_sum += num\n                        result += lookup[accumulated_sum - k]\n                        lookup[accumulated_sum] += 1\n                return result", "55": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef __init__(self, root):\n                self.__stk = []\n                self.__traversalLeft(root)\ndef hasNext(self):\n                return self.__stk\ndef next(self):\n                node = self.__stk.pop()\n                self.__traversalLeft(node.right)\n                return node.val\ndef __traversalLeft(self, node):\n                while node is not None:\n                        self.__stk.append(node)\n                        node = node.left", "56": "def prevPermOpt1(self, A):\n                for left in reversed(xrange(len(A)-1)):\n                        if A[left] > A[left+1]:\n                                break\n                else:\n                        return A\n                right = len(A)-1\n                while A[left] <= A[right]:\n                        right -= 1\n                while A[right-1] == A[right]:\n                        right -= 1\n                A[left], A[right] = A[right], A[left]\n                return A", "57": "def leastInterval(self, tasks, n):\n                counter = Counter(tasks)\n                _, max_count = counter.most_common(1)[0]\n                result = (max_count-1) * (n+1)\n                for count in counter.values():\n                        if count == max_count:\n                                result += 1\n                return max(result, len(tasks))", "58": "def getMoneyAmount(self, n):\n                pay = [[0] * n for _ in xrange(n+1)]\n                for i in reversed(xrange(n)):\n                        for j in xrange(i+1, n):\n                                pay[i][j] = min(k+1 + max(pay[i][k-1], pay[k+1][j]) \\\n                                                                for k in xrange(i, j+1))\n                return pay[0][n-1]", "59": "def __init__(self, val=0, next=None):\n                pass\ndef swapNodes(self, head, k):\n                left, right, curr = None, None, head\n                while curr:\n                        k -= 1\n                        if right:\n                                right = right.next\n                        if k == 0:\n                                left = curr\n                                right = head\n                        curr = curr.next\n                left.val, right.val = right.val, left.val\n                return head", "60": "def numDecodings(self, s):\n                if len(s) == 0 or s[0] == '0':\n                        return 0\n                prev, prev_prev = 1, 0\n                for i in xrange(len(s)):\n                        cur = 0\n                        if s[i] != '0':\n                                cur = prev\n                        if i > 0 and (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] <= '6')):\n                                cur += prev_prev\n                        prev, prev_prev = cur, prev\n                return prev", "61": "def backspaceCompare(self, S, T):\n                def findNextChar(S):\n                        skip = 0\n                        for i in reversed(xrange(len(S))):\n                                if S[i] == '\n                                        skip += 1\n                                elif skip:\n                                        skip -= 1\n                                else:\n                                        yield S[i]\n                return all(x == y for x, y in\n                                itertools.izip_longest(findNextChar(S), findNextChar(T)))\ndef findNextChar(S):\n                        skip = 0\n                        for i in reversed(xrange(len(S))):\n                                if S[i] == '\n                                        skip += 1\n                                elif skip:\n                                        skip -= 1\n                                else:\n                                        yield S[i]", "62": "def __init__(self, x):\n                self.val = x\n                self.next = None\ndef addTwoNumbers(self, l1, l2):\n                dummy = ListNode(0)\n                current, carry = dummy, 0\n                while l1 or l2:\n                        val = carry\n                        if l1:\n                                val += l1.val\n                                l1 = l1.next\n                        if l2:\n                                val += l2.val\n                                l2 = l2.next\n                        carry, val = divmod(val, 10)\n                        current.next = ListNode(val)\n                        current = current.next\n                if carry == 1:\n                        current.next = ListNode(1)\n                return dummy.next", "63": "def __init__(self, x):\n                self.val = x\n                self.next = None\ndef __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef isSubPath(self, head, root):\n                def dfs(head, root):\n                        if not head:\n                                return True\n                        if not root:\n                                return False\n                        return root.val == head.val and \\\n                                (dfs(head.next, root.left) or \n                                        dfs(head.next, root.right))\n                if not head:\n                        return True\n                if not root:\n                        return False\n                return dfs(head, root) or \\\n                        self.isSubPath(head, root.left) or \\\n                        self.isSubPath(head, root.right)\ndef dfs(head, root):\n                        if not head:\n                                return True\n                        if not root:\n                                return False\n                        return root.val == head.val and \\\n                                (dfs(head.next, root.left) or \n                                        dfs(head.next, root.right))", "64": "def rob(self, root):\n                def robHelper(root):\n                        if not root:\n                                return (0, 0)\n                        left, right = robHelper(root.left), robHelper(root.right)\n                        return (root.val + left[1] + right[1], max(left) + max(right))\n                return max(robHelper(root))\ndef robHelper(root):\n                        if not root:\n                                return (0, 0)\n                        left, right = robHelper(root.left), robHelper(root.right)\n                        return (root.val + left[1] + right[1], max(left) + max(right))", "65": "def minOperations(self, nums):\n                result = prev = 0\n                for curr in nums:\n                        if prev < curr:\n                                prev = curr\n                                continue\n                        prev += 1\n                        result += prev-curr                                \n                return result", "66": "def minimumJumps(self, forbidden, a, b, x):\n                max_f = max(forbidden)\n                max_val = x+b if a >= b else max(x, max_f)+a+(b+a) \n                lookup = set()        \n                for pos in forbidden:\n                        lookup.add((pos, True))\n                        lookup.add((pos, False))\n                result = 0\n                q = [(0, True)]\n                lookup.add((0, True))\n                while q:\n                        new_q = []\n                        for pos, can_back in q:\n                                if pos == x:\n                                        return result\n                                if pos+a <= max_val and (pos+a, True) not in lookup:\n                                        lookup.add((pos+a, True))\n                                        new_q.append((pos+a, True))\n                                if not can_back:\n                                        continue\n                                if pos-b >= 0 and (pos-b, False) not in lookup:\n                                        lookup.add((pos-b, False))\n                                        new_q.append((pos-b, False))\n                        q = new_q\n                        result += 1\n                return -1", "67": "def countPrimeSetBits(self, L, R):\n                def bitCount(n):\n                        result = 0\n                        while n:\n                                n &= n-1\n                                result += 1\n                        return result\n                primes = {2, 3, 5, 7, 11, 13, 17, 19}\n                return sum(bitCount(i) in primes\n                                for i in xrange(L, R+1))\ndef bitCount(n):\n                        result = 0\n                        while n:\n                                n &= n-1\n                                result += 1\n                        return result", "68": "def checkIfPangram(self, sentence):\n                return len(set(sentence)) == 26", "69": "def countGoodSubstrings(self, s):\n                K = 3\n                result = 0\n                count = collections.Counter()\n                for i in xrange(len(s)):\n                        if i >= K:\n                                count[s[i-K]] -= 1\n                                if not count[s[i-K]]:\n                                        del count[s[i-K]]\n                        count[s[i]] += 1\n                        if len(count) == K:\n                                result += 1\n                return result", "70": "def firstUniqChar(self, s):\n                lookup = defaultdict(int)\n                candidtates = set()\n                for i, c in enumerate(s):\n                        if lookup[c]:\n                                candidtates.discard(lookup[c])\n                        else:\n                                lookup[c] = i+1\n                                candidtates.add(i+1)\n                return min(candidtates)-1 if candidtates else -1", "71": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef sumNumbers(self, root):\n                return self.sumNumbersRecu(root, 0)\ndef sumNumbersRecu(self, root, num):\n                if root is None:\n                        return 0\n                if root.left is None and root.right is None:\n                        return num * 10 + root.val\n                return self.sumNumbersRecu(root.left, num * 10 + root.val) + self.sumNumbersRecu(root.right, num * 10 + root.val)", "72": "def minimumSwap(self, s1, s2):\n                x1, y1 = 0, 0\n                for i in xrange(len(s1)):\n                        if s1[i] == s2[i]:\n                                continue\n                        x1 += int(s1[i] == 'x')\n                        y1 += int(s1[i] == 'y')\n                if x1%2 != y1%2: \n                        return -1\n                return (x1//2 + y1//2) + (x1%2 + y1%2)", "73": "def secondHighest(self, s):\n                first = second = -1\n                for c in s:\n                        if not c.isdigit():\n                                continue\n                        d = int(c)\n                        if d > first:\n                                first, second = d, first\n                        elif first > d > second:\n                                second = d\n                return second", "74": "def isTransformable(self, s, t):\n                idxs = [[] for _ in xrange(10)]\n                for i in reversed(xrange(len(s))):\n                        idxs[int(s[i])].append(i)\n                for c in t:\n                        d = int(c)\n                        if not idxs[d]:\n                                return False\n                        for k in xrange(d): \n                                if idxs[k] and idxs[k][-1] < idxs[d][-1]:\n                                        return False\n                        idxs[d].pop()\n                return True", "75": "def toGoatLatin(self, S):\n                def convert(S):\n                        vowel = set('aeiouAEIOU')\n                        for i, word in enumerate(S.split(), 1):\n                                if word[0] not in vowel:\n                                        word = word[1:] + word[:1]\n                                yield word + 'ma' + 'a'*i\n                return \" \".join(convert(S))\ndef convert(S):\n                        vowel = set('aeiouAEIOU')\n                        for i, word in enumerate(S.split(), 1):\n                                if word[0] not in vowel:\n                                        word = word[1:] + word[:1]\n                                yield word + 'ma' + 'a'*i", "76": "def myPow(self, x, n):\n                if n < 0 and n != -n:\n                        return 1.0 / self.myPow(x, -n)\n                if n == 0:\n                        return 1\n                v = self.myPow(x, n / 2)\n                if n % 2 == 0:\n                        return v * v\n                else:\n                        return v * v * x", "77": "def numEnclaves(self, A):\n                directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n                def dfs(A, i, j):\n                        if not (0 <= i < len(A) and 0 <= j < len(A[0]) and A[i][j]):\n                                return\n                        A[i][j] = 0\n                        for d in directions:\n                                dfs(A, i+d[0], j+d[1])\n                for i in xrange(len(A)):\n                        dfs(A, i, 0)\n                        dfs(A, i, len(A[0])-1)\n                for j in xrange(1, len(A[0])-1):\n                        dfs(A, 0, j)\n                        dfs(A, len(A)-1, j)\n                return sum(sum(row) for row in A)\ndef dfs(A, i, j):\n                        if not (0 <= i < len(A) and 0 <= j < len(A[0]) and A[i][j]):\n                                return\n                        A[i][j] = 0\n                        for d in directions:\n                                dfs(A, i+d[0], j+d[1])", "78": "def numberOfRounds(self, startTime, finishTime):\n                h1, m1 = map(int, startTime.split(\":\"))\n                h2, m2 = map(int, finishTime.split(\":\"))\n                if m1 > m2:\n                        h2 -= 1\n                        m2 += 60\n                return max((h2-h1)%24*4 + m2//15 - (m1+15-1)//15, 0)", "79": "def getOrder(self, tasks):\n                idx = range(len(tasks))\n                idx.sort(key=lambda x: tasks[x][0])\n                result, min_heap = [], []\n                i, time = 0, tasks[idx[0]][0]\n                while i < len(idx) or min_heap:\n                        while i < len(idx) and tasks[idx[i]][0] <= time:\n                                heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i]))\n                                i += 1\n                        if not min_heap:\n                                time = tasks[idx[i]][0]\n                                continue\n                        t, j = heapq.heappop(min_heap)\n                        time += t\n                        result.append(j)\n                return result", "80": "def maximumUniqueSubarray(self, nums):\n                lookup = {}\n                prefix = [0]*(len(nums)+1)\n                result, left = 0, 0\n                for right, num in enumerate(nums):\n                        prefix[right+1] = prefix[right]+num\n                        if num in lookup:\n                                left = max(left, lookup[num]+1)\n                        lookup[num] = right\n                        result = max(result, prefix[right+1]-prefix[left])\n                return result", "81": "def deleteAndEarn(self, nums):\n                vals = [0] * 10001\n                for num in nums:\n                        vals[num] += num\n                val_i, val_i_1 = vals[0], 0\n                for i in xrange(1, len(vals)):\n                        val_i_1, val_i_2 = val_i, val_i_1\n                        val_i = max(vals[i] + val_i_2, val_i_1)\n                return val_i", "82": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef btreeGameWinningMove(self, root, n, x):\n                def count(node, x, left_right):\n                        if not node:\n                                return 0\n                        left, right = count(node.left, x, left_right), count(node.right, x, left_right)\n                        if node.val == x:\n                                left_right[0], left_right[1] = left, right\n                        return left + right + 1\n                left_right = [0, 0]\n                count(root, x, left_right)\n                blue = max(max(left_right), n-(sum(left_right)+1))\n                return blue > n-blue\ndef count(node, x, left_right):\n                        if not node:\n                                return 0\n                        left, right = count(node.left, x, left_right), count(node.right, x, left_right)\n                        if node.val == x:\n                                left_right[0], left_right[1] = left, right\n                        return left + right + 1", "83": "def maxProductDifference(self, nums):\n                largest, smallest = [0]*2, [float(\"inf\")]*2\n                for x in nums:\n                        if x >= largest[0]:\n                                largest[:] = [x, largest[0]]\n                        elif x > largest[1]:\n                                largest[1] =x\n                        if x <= smallest[0]:\n                                smallest[:] = [x, smallest[0]]\n                        elif x < smallest[1]:\n                                smallest[1] = x\n                return largest[0]*largest[1] - smallest[0]*smallest[1]", "84": "def repeatedNTimes(self, A):\n                for i in xrange(2, len(A)):\n                        if A[i-1] == A[i] or A[i-2] == A[i]:\n                                return A[i]\n                return A[0]", "85": "def kthSmallest(self, root, k):\n                s, cur, rank = [], root, 0\n                while s or cur:\n                        if cur:\n                                s.append(cur)\n                                cur = cur.left\n                        else:\n                                cur = s.pop()\n                                rank += 1\n                                if rank == k:\n                                        return cur.val\n                                cur = cur.right\n                return float(\"-inf\")", "86": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef maxLevelSum(self, root):\n                result, level, max_total = 0, 1, float(\"-inf\")\n                q = collections.deque([root])\n                while q:\n                        total = 0\n                        for _ in xrange(len(q)):\n                                node = q.popleft()\n                                total += node.val\n                                if node.left:\n                                        q.append(node.left)\n                                if node.right:\n                                        q.append(node.right)\n                        if total > max_total:\n                                result, max_total = level, total\n                        level += 1\n                return result", "87": "def divisorGame(self, N):\n                def memoization(N, dp):\n                        if N == 1:\n                                return False\n                        if N not in dp:\n                                result = False\n                                for i in xrange(1, N+1):\n                                        if i*i > N:\n                                                break\n                                        if N % i == 0:\n                                                if not memoization(N-i, dp):\n                                                        result = True\n                                                        break\n                                dp[N] = result\n                        return dp[N]\n                return memoization(N, {})\ndef memoization(N, dp):\n                        if N == 1:\n                                return False\n                        if N not in dp:\n                                result = False\n                                for i in xrange(1, N+1):\n                                        if i*i > N:\n                                                break\n                                        if N % i == 0:\n                                                if not memoization(N-i, dp):\n                                                        result = True\n                                                        break\n                                dp[N] = result\n                        return dp[N]", "88": "def countSubIslands(self, grid1, grid2):\n                directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n                def dfs(grid1, grid2, i, j):\n                        if not (0 <= i < len(grid2) and\n                                        0 <= j < len(grid2[0]) and grid2[i][j] == 1):\n                                return 1\n                        grid2[i][j] = 0\n                        result = grid1[i][j]\n                        for di, dj in directions:\n                                result &= dfs(grid1, grid2, i+di, j+dj)\n                        return result\n                return sum(dfs(grid1, grid2, i, j) for i in xrange(len(grid2)) for j in xrange(len(grid2[0])) if grid2[i][j])\ndef dfs(grid1, grid2, i, j):\n                        if not (0 <= i < len(grid2) and\n                                        0 <= j < len(grid2[0]) and grid2[i][j] == 1):\n                                return 1\n                        grid2[i][j] = 0\n                        result = grid1[i][j]\n                        for di, dj in directions:\n                                result &= dfs(grid1, grid2, i+di, j+dj)\n                        return result", "89": "def balancedString(self, s):\n                count = collections.Counter(s)\n                result = len(s) \n                left = 0\n                for right in xrange(len(s)):\n                        count[s[right]] -= 1\n                        while left < len(s) and \\\n                                all(v <= len(s)//4 for v in count.itervalues()):\n                                result = min(result, right-left+1)\n                                count[s[left]] += 1\n                                left += 1\n                return result", "90": "def permuteUnique(self, nums):\n                nums.sort()\n                result = []\n                used = [False] * len(nums)\n                self.permuteUniqueRecu(result, used, [], nums)\n                return result\ndef permuteUniqueRecu(self, result, used, cur, nums):\n                if len(cur) == len(nums):\n                        result.append(cur + [])\n                        return\n                for i in xrange(len(nums)):\n                        if used[i] or (i > 0 and nums[i-1] == nums[i] and not used[i-1]):\n                                continue\n                        used[i] = True\n                        cur.append(nums[i])\n                        self.permuteUniqueRecu(result, used, cur, nums)\n                        cur.pop()\n                        used[i] = False", "91": "def maxDepth(self, s):\n                result = curr = 0\n                for c in s:\n                        if c == '(':\n                                curr += 1\n                                result = max(result, curr) elif c == ')':\n                                curr -= 1\n                return result", "92": "def __init__(self, x):\n                self.val = x\n                self.left = None\n                self.right = None\ndef increasingBST(self, root):\n                def increasingBSTHelper(root, tail):\n                        if not root:\n                                return tail\n                        result = increasingBSTHelper(root.left, root)\n                        root.left = None\n                        root.right = increasingBSTHelper(root.right, tail)\n                        return result\n                return increasingBSTHelper(root, None)\ndef increasingBSTHelper(root, tail):\n                        if not root:\n                                return tail\n                        result = increasingBSTHelper(root.left, root)\n                        root.left = None\n                        root.right = increasingBSTHelper(root.right, tail)\n                        return result", "93": "def maxDotProduct(self, nums1, nums2):\n                if len(nums1) < len(nums2):\n                        return self.maxDotProduct(nums2, nums1)\n                dp = [[0]*len(nums2) for i in xrange(2)]\n                for i in xrange(len(nums1)):\n                        for j in xrange(len(nums2)):\n                                dp[i%2][j] = nums1[i]*nums2[j]\n                                if i and j:\n                                        dp[i%2][j] += max(dp[(i-1)%2][j-1], 0)\n                                if i:\n                                        dp[i%2][j] = max(dp[i%2][j], dp[(i-1)%2][j])\n                                if j:\n                                        dp[i%2][j] = max(dp[i%2][j], dp[i%2][j-1])\n                return dp[(len(nums1)-1)%2][-1]", "94": "def findRotateSteps(self, ring, key):\n                lookup = collections.defaultdict(list)\n                for i in xrange(len(ring)):\n                        lookup[ring[i]].append(i)\n                dp = [[0] * len(ring) for _ in xrange(2)]\n                prev = [0]\n                for i in xrange(1, len(key)+1):\n                        dp[i%2] = [float(\"inf\")] * len(ring)\n                        for j in lookup[key[i-1]]:\n                                for k in prev:\n                                        dp[i%2][j] = min(dp[i%2][j],\n                                                                        min((k+len(ring)-j) % len(ring), \\\n                                                                                (j+len(ring)-k) % len(ring)) + \\\n                                                                        dp[(i-1) % 2][k])\n                        prev = lookup[key[i-1]]\n                return min(dp[len(key)%2]) + len(key)", "95": "def checkPalindromeFormation(self, a, b):\n                def is_palindrome(s, i, j):\n                        while i < j:\n                                if s[i] != s[j]:\n                                        return False\n                                i += 1\n                                j -= 1\n                        return True\n                def check(a, b):\n                        i, j = 0, len(b)-1\n                        while i < j:\n                                if a[i] != b[j]:\n                                        return is_palindrome(a, i, j) or is_palindrome(b, i, j)\n                                i += 1\n                                j -= 1\n                        return True\n                return check(a, b) or check(b, a)\ndef is_palindrome(s, i, j):\n                        while i < j:\n                                if s[i] != s[j]:\n                                        return False\n                                i += 1\n                                j -= 1\n                        return True\ndef check(a, b):\n                        i, j = 0, len(b)-1\n                        while i < j:\n                                if a[i] != b[j]:\n                                        return is_palindrome(a, i, j) or is_palindrome(b, i, j)\n                                i += 1\n                                j -= 1\n                        return True", "96": "This data point has no code", "97": "This data point has no code", "98": "def getMaximumGenerated(self, n):\n                if n == 0:\n                        return 0\n                nums = [0]*(n+1)\n                nums[1] = 1\n                result = 1\n                for i in xrange(2, n+1):\n                        if i%2 == 0:\n                                nums[i] = nums[i//2]\n                        else:\n                                nums[i] = nums[i//2] + nums[i//2+1]\n                        result = max(result, nums[i])\n                return result", "99": "def subsetXORSum(self, nums):\n                result = 0\n                for x in nums:\n                        result |= x\n                return result * 2**(len(nums)-1)"}, "C++": {"0": "int mergeStones(vector<int> stones, int K){\n                if ((stones.size()-1) % (K-1)){\n                        return -1;\n                }\n                vector<int> prefix;\n                prefix.push_back(0);\n                for (int x : stones){\n                        prefix.push_back(prefix[prefix.size()-1]+x);\n                }\n                vector<vector<int>> dp(stones.size(), vector<int>(stones.size()));\n                for (int l = K-1; l < stones.size(); l++){\n                        for (int i = 0; i < stones.size()-l; i++){\n                                dp[i][i+l] = INT_MAX;\n                                for (int j = i; j < i+l; j+=K-1){\n                                        dp[i][i+l] = min(dp[i][i+l], dp[i][j]+dp[j+1][i+l]);\n                                }\n                                if (l % (K-1) == 0){\n                                        dp[i][i+l] += prefix[i+l+1] - prefix[i];\n                                }\n                        }\n                }\n                return dp[0][stones.size()-1];\n}", "1": "bool containsPattern(vector<int>& arr, int m, int k) {\n                int cnt = 0;\n                for (int i = 0; i < arr.size() - m; i++) {\n                        if (arr[i] != arr[i + m]) {\n                                cnt = 0;\n                                continue;\n                        }\n                        cnt += 1;\n                        if (cnt == (k - 1)*m) {\n                                return true;\n                        }\n                }\n                return false;\n        }", "2": "class Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n        unordered_map<string, int> lookup;\n        for (int i = 0; i < list1.size(); i++) {\n            lookup[list1[i]] = i;\n        }\n        vector<string> result;\n        int min_sum = INT_MAX;\n        for (int j = 0; j < list2.size(); j++) {\n            if (j > min_sum) {\n                break;\n            }\n            if (lookup.count(list2[j]) > 0) {\n                if (j + lookup[list2[j]] < min_sum) {\n                    result = {list2[j]};\n                    min_sum = j + lookup[list2[j]];\n                }\n                else if (j + lookup[list2[j]] == min_sum) {\n                    result.push_back(list2[j]);\n                }\n            }\n        }\n        return result;\n    }\n};", "3": "class Solution {\npublic:\n    int maxSumMinProduct(vector<int>& nums) {\n                int MOD = 10^9+7;\n                vector<int> prefix = {0}*(nums.size()+1);\n                for (int i=0; i<nums.size(); i++) {\n                        prefix[i+1] = prefix[i]+nums[i];\n                }\n                stack<int> stk;\n                int result = 0;\n                for (int i=0; i<nums.size()+1; i++) {\n                        while (!stk.empty() && (i == nums.size() || nums[stk.top()] >= nums[i])) {\n                                result = max(result, nums[stk.pop()]*(prefix[(i-1)+1]-prefix[stk.top()+1]));\n                        }\n                        stk.push(i); \n                }\n                return result%MOD;\n    }\n};", "4": "int numberWays(int hats, vector<int>& hat_to_people, int MOD){\n        int dp[1<<hats];\n        dp[0] = 1;\n        for (int people : hat_to_people){\n                for (int mask = (1<<hats)-1; mask>=0; mask--){\n                        for (int p : people){\n                                if (mask & (1<<p)) continue;\n                                dp[mask | (1<<p)] += dp[mask];\n                                dp[mask | (1<<p)] %= MOD;\n                        }\n                }\n        }\n        return dp[(1<<hats)-1];\n}", "5": "int numSubarraysWithSum(vector<int> A, int S) {\n                int result = 0;\n                int left = 0;\n                int right = 0;\n                int sum_left = 0;\n                int sum_right = 0;\n                for (int i = 0; i < A.size(); i++) {\n                        sum_left += A[i];\n                        while (left < i && sum_left > S) {\n                                sum_left -= A[left];\n                                left += 1;\n                        }\n                        sum_right += A[i];\n                        while (right < i && (sum_right > S || (sum_right == S && !A[right]))) {\n                                sum_right -= A[right];\n                                right += 1;\n                        }\n                        if (sum_left == S) {\n                                result += right-left+1;\n                        }\n                }\n                return result;\n}", "6": "vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> ranges;\n        if (nums.size() == 0) {\n                return ranges;\n        }\n        int start = nums[0], end = nums[0];\n        for (int i = 0; i < nums.size(); ++i) {\n                if (i < nums.size() - 1 && nums[i + 1] == nums[i] + 1) {\n                        end = nums[i + 1];\n                }\n                else {\n                        string interval = to_string(start);\n                        if (start != end) {\n                                interval += \"->\" + to_string(end);\n                        }\n                        ranges.push_back(interval);\n                        if (i < nums.size() - 1) {\n                                start = end = nums[i + 1];\n                        }\n                }\n        }\n        return ranges;\n}", "7": "vector<int> maxHeight(vector<vector<int>> cuboids)\n{\n        for (int i = 0; i < cuboids.size(); i++)\n        {\n                sort(cuboids[i].begin(), cuboids[i].end());\n        }\n        cuboids.push_back(vector<int>{0, 0, 0});\n        sort(cuboids.begin(), cuboids.end());\n        vector<int> dp(cuboids.size());\n        for (int i = 1; i < cuboids.size(); i++)\n        {\n                for (int j = 0; j < i; j++)\n                {\n                        if (cuboids[j][0] <= cuboids[i][0] && cuboids[j][1] <= cuboids[i][1] && cuboids[j][2] <= cuboids[i][2])\n                        {\n                                dp[i] = max(dp[i], dp[j] + cuboids[i][2]);\n                        }\n                }\n        }\n        return dp;\n}", "8": "vector<int> sortedSquares(vector<int>& A) {\n        int right = lower_bound(A.begin(), A.end(), 0) - A.begin();\n        int left = right-1;\n        vector<int> result;\n        while (0 <= left || right < A.size()) {\n                if (right == A.size() || (0 <= left && A[left]*A[left] < A[right]*A[right])) {\n                        result.push_back(A[left]*A[left]);\n                        left -= 1;\n                }\n                else {\n                        result.push_back(A[right]*A[right]);\n                        right += 1;\n                }\n        }\n        return result;\n}", "9": "struct node * lowestCommonAncestor(struct node *root, struct node *p, struct node *q)\n{\n    if(root==NULL || root==p || root==q)\n        return root;\n    \n    struct node* left = lowestCommonAncestor(root->left, p, q);\n    struct node* right = lowestCommonAncestor(root->right, p, q);\n    \n    if(left && right)\n        return root;\n    \n    if(!left && !right)\n        return NULL;\n    \n    return (left)?left:right;\n}", "10": "void findReplaceString(string& S, vector<int>& indexes, vector<string>& sources, vector<string>& targets) {\n                for (int i = indexes.size() - 1; i >= 0; --i) {\n                        int j = indexes[i];\n                        if (S.substr(j, sources[i].length()) == sources[i]) {\n                                S.replace(j, sources[i].length(), targets[i]);\n                        }\n                }\n        }", "11": "class Solution {\npublic:\n    int calculate(string s) {\n        function<int(int, int)> compute = [&](int left, int right, char op) {\n            if (op == '+') return left + right;\n            else if (op == '-') return left - right;\n            else if (op == '*') return left * right;\n            else return left / right;\n        };\n\n        stack<int> stk;\n        char op = '+';\n        int operand = 0, n = s.size();\n        for (int i = 0; i < n; ++i) {\n            if (s[i] == ' ') continue;\n            else if (isdigit(s[i])) operand = operand * 10 + s[i] - '0';\n            else if (s[i] == '(') {\n                int j = i, cnt = 0;\n                for (; i < n; ++i) {\n                    if (s[i] == '(') ++cnt;\n                    else if (s[i] == ')') --cnt;\n                    if (cnt == 0) break;\n                }\n                operand = calculate(s.substr(j + 1, i - j - 1));\n            }\n            else {\n                int right = operand;\n                operand = 0;\n                int left = stk.top();\n                stk.pop();\n\n                int ans = compute(left, right, op);\n                stk.push(ans);\n                op = s[i];\n            }\n        }\n        return stk.top();\n    }\n};", "12": "class node{\n    public:\n    int val;\n    node* left;\n    node* right;\n    node(int data){\n        val = data;\n        left = NULL;\n        right = NULL;\n    }\n};\n\n\nint sumOfLeftLeaves(node* root){\n                int sumOfLeftLeavesHelper(node* root, bool is_left);\n                return sumOfLeftLeavesHelper(root, false);\n}\nint sumOfLeftLeavesHelper(node* root, bool is_left){\n                        if (!root){\n                                return 0;\n                        }\n                        if (!root->left && !root->right){\n                                return root->val if is_left else 0;\n                        }\n                        return sumOfLeftLeavesHelper(root->left, true) + \\\n                                sumOfLeftLeavesHelper(root->right, false);\n}", "13": "class Solution {\npublic:\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n                vector<pair<int, int>> sorted_vals;\n                for (int i = 0; i < aliceValues.size(); i++) {\n                    sorted_vals.push_back(make_pair(aliceValues[i], bobValues[i]));\n                }\n                sort(sorted_vals.begin(), sorted_vals.end(), [](pair<int, int>& lhs, pair<int, int>& rhs) {\n                    return lhs.first + lhs.second > rhs.first + rhs.second;\n                });\n                int alice_sum = 0;\n                int bob_sum = 0;\n                for (int i = 0; i < sorted_vals.size(); i++) {\n                    if (i % 2 == 0) {\n                        alice_sum += sorted_vals[i].first;\n                    } else {\n                        bob_sum += sorted_vals[i].second;\n                    }\n                }\n                if (alice_sum > bob_sum) {\n                    return 1;\n                } else if (alice_sum == bob_sum) {\n                    return 0;\n                } else {\n                    return -1;\n                }\n            }\n};", "14": "int minDeletionSize(vector<string>& A) {\n    int result = 0;\n    vector<bool> is_sorted(A.size() - 1);\n    for (int j = 0; j < A[0].size(); j++) {\n        vector<bool> tmp = is_sorted;\n        for (int i = 0; i < A.size() - 1; i++) {\n            if (A[i][j] > A[i+1][j] && tmp[i] == false) {\n                result += 1;\n                break;\n            }\n            if (A[i][j] < A[i+1][j]) {\n                tmp[i] = true;\n            }\n        }\n        else {\n            is_sorted = tmp;\n        }\n    }\n    return result;\n}", "15": "int stoneGameV(vector<int> stoneValue) {\n                int n = stoneValue.size();\n                vector<int> prefix = {0};\n                for (int v : stoneValue) {\n                        prefix.push_back(prefix.back() + v);\n                }\n                vector<vector<int>> mid(n, vector<int>(n));\n                for (int l = 1; l <= n; ++l) {\n                        for (int i = 0; i <= n - l; ++i) {\n                                int j = i + l - 1;\n                                int p = i;\n                                if (l == 1) {\n                                        p = i;\n                                } else {\n                                        p = mid[i][j - 1];\n                                }\n                                while (prefix[p] - prefix[i] < prefix[j + 1] - prefix[p]) {\n                                        ++p;\n                                }\n                                mid[i][j] = p;\n                        }\n                }\n                vector<vector<int>> rmq(n, vector<int>(n));\n                for (int i = 0; i < n; ++i) {\n                        rmq[i][i] = stoneValue[i];\n                }\n                vector<vector<int>> dp(n, vector<int>(n));\n                for (int l = 2; l <= n; ++l) {\n                        for (int i = 0; i <= n - l; ++i) {\n                                int j = i + l - 1;\n                                int p = mid[i][j];\n                                int max_score = 0;\n                                if (prefix[p] - prefix[i] == prefix[j + 1] - prefix[p]) {\n                                        max_score = max(rmq[i][p - 1], rmq[j][p]);\n                                } else {\n                                        if (i <= p - 2) {\n                                                max_score = max(max_score, rmq[i][p - 2]);\n                                        }\n                                        if (p <= j) {\n                                                max_score = max(max_score, rmq[j][p]);\n                                        }\n                                }\n                                dp[i][j] = max_score;\n                                rmq[i][j] = max(rmq[i][j - 1], (prefix[j + 1] - prefix[i]) + max_score);\n                                rmq[j][i] = max(rmq[j][i + 1], (prefix[j + 1] - prefix[i]) + max_score);\n                        }\n                }\n                return dp[0][n - 1];\n}", "16": "int numEquivDominoPairs(vector<vector<int>>& dominoes) {\n                int ans = 0;\n                unordered_map<int, int> count;\n                for (auto & d: dominoes) {\n                                int k = min(d[0], d[1]) * 10 + max(d[0], d[1]);\n                                ans += count[k]++;\n                }\n                return ans;\n}", "17": "bool checkPowersOfThree(int n)\n{\n        while (n > 0)\n        {\n                if (n%3 == 2)\n                {\n                        return false;\n                }\n                n /= 3;\n        }\n        return true;\n}", "18": "bool rotateString(string A, string B)\n{\n        return A.size() == B.size() && B in A+A;\n}", "19": "class Solution {\npublic:\n     bool checkInclusion(string s1, string s2) {\n                unordered_map<char, int> counts;\n                int l = s1.size();\n                for (int i = 0; i < s1.size(); i++) {\n                        counts[s1[i]]++;\n                }\n\n                for (int i = 0; i < s2.size(); i++) {\n                        if (counts[s2[i]] > 0) {\n                                l--;\n                        }\n                        counts[s2[i]]--;\n                        if (l == 0) {\n                                return true;\n                        }\n                        int start = i + 1 - s1.size();\n                        if (start >= 0) {\n                                counts[s2[start]]++;\n                                if (counts[s2[start]] > 0) {\n                                        l++;\n                                }\n                        }\n                }\n                return false;\n        }\n};", "20": "int snakesAndLadders(int n, vector<vector<int>> board) {\n    \n    \n\n    unordered_map<int, int> lookup;\n    queue<int> q;\n    lookup[1] = 0;\n    q.push(1);\n    \n    while(!q.empty()) {\n        int s = q.front();\n        q.pop();\n        if(s == n*n) {\n            return lookup[s];\n        }\n        \n        for(int s2 = s+1; s2 <= min(s+6, n*n); s2++) {\n            int r, c;\n            tie(r, c) = coordinate(n, s2);\n            if(board[r][c] != -1) {\n                s2 = board[r][c];\n            }\n            if(lookup.find(s2) == lookup.end()) {\n                lookup[s2] = lookup[s] + 1;\n                q.push(s2);\n            }\n        }\n    }\n    \n    return -1;\n}", "21": "int findMin(vector<int>& nums) {\n                int left = 0, right = nums.size() - 1;\n                while (left < right && nums[left] >= nums[right]) {\n                        int mid = left + (right - left) / 2;\n                        if (nums[mid] < nums[left]) {\n                                right = mid;\n                        } else {\n                                left = mid + 1;\n                        }\n                }\n                return nums[left];\n        }", "22": "int maximumPopulation(vector<pair<int, int>> logs) {\n                int MIN_YEAR = 1950, MAX_YEAR = 2050;\n                vector<int> years(MAX_YEAR-MIN_YEAR+1);\n                for (int s, e : logs) {\n                        years[s-MIN_YEAR] += 1;\n                        years[e-MIN_YEAR] -= 1;\n                }\n                int result = 0;\n                for (int i = 0; i < years.size(); i++) {\n                        if (i) {\n                                years[i] += years[i-1];\n                        }\n                        if (years[i] > years[result]) {\n                                result = i;\n                        }\n                }\n                return result+MIN_YEAR;\n}", "23": "class Solution {\npublic:\n    vector<string> letterCasePermutation(string S) {\n        vector<string> result = {\"\"};\n        for (auto &c: S) {\n            if (isalpha(c)) {\n                for (int i = 0; i < result.size(); ++i) {\n                    result.push_back(result[i]);\n                    result[i].push_back(tolower(c));\n                    result.back().push_back(toupper(c));\n                }\n            } else {\n                for (auto &s: result) {\n                    s.push_back(c);\n                }\n            }\n        }\n        return result;\n    }\n};", "24": "class Solution {\npublic:\n    vector<bool> prefixesDivBy5(vector<int>& A) {\n                for (int i = 1; i < A.size(); i++) {\n                        A[i] += A[i-1] * 2 % 5;\n                }\n                return [x % 5 == 0 for x in A];\n    }\n};", "25": NaN, "26": "int minDays(int* bloomDay, int m, int k) {\n                int result = count = 0;\n                for (int d = 0; d < len(bloomDay); d++) {\n                                count = count + 1 if (d <= x) else 0;\n                                if (count == k) {\n                                                count = 0;\n                                                result += 1;\n                                                if (result == m) {\n                                                                break;\n                                                }\n                                }\n                }\n                return result >= m;\n}", "27": "vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {\n                vector<int> result(nums.size());\n                int mask = 2**maximumBit-1;\n                for (int i = 0; i < nums.size(); i++) {\n                        mask ^= nums[i];\n                        result[nums.size()-1-i] = mask;\n                }\n                return result;\n        }", "28": "class Solution {\npublic:\n    int numOfSubarrays(vector<int>& arr) {\n                int MOD = 1e9+7;\n                int result = 0, accu = 0;\n                vector<int> dp = {1, 0}\n                for (int x : arr) {\n                        accu ^= x&1;\n                        dp[accu] += 1;\n                        result = (result + dp[accu^1]) % MOD;\n                }\n                return result;\n    }\n};", "29": "int numMagicSquaresInside(vector<vector<int>>& grid) {\n        int k = 3;\n        int result = 0;\n        for (r in xrange(len(grid)-k+1)){\n                for (c in xrange(len(grid[r])-k+1)){\n                        if (magic(grid, r, c)){\n                                result += 1;\n                        }\n                }\n        }\n        return result;\n}", "30": "int getStrongest(int arr[], int k) {\n                nth_element(arr, (len(arr)-1)//2)\n                m = arr[(len(arr)-1)//2]\n                nth_element(arr, k, lambda a, b: abs(a-m) > abs(b-m) if abs(a-m) != abs(b-m) else a > b)\n                return arr[:k]\nint nth_element(int nums[], int n, compare=lambda a, b: a < b) {\n                        int partition_around_pivot(left, right, pivot_idx, nums, compare) {\n                                new_pivot_idx = left\n                                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                                for i in xrange(left, right):\n                                        if compare(nums[i], nums[right]):\n                                                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                                                new_pivot_idx += 1\n                                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                                return new_pivot_idx\n                        left, right = 0, len(nums) - 1\n                        while left <= right:\n                                pivot_idx = random.randint(left, right)\n                                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)\n                                if new_pivot_idx == n:\n                                        return\n                                elif new_pivot_idx > n:\n                                        right = new_pivot_idx - 1\n                                else: \n                                        left = new_pivot_idx + 1\nint partition_around_pivot(left, right, pivot_idx, nums, compare) {\n                                new_pivot_idx = left\n                                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                                for i in xrange(left, right):\n                                        if compare(nums[i], nums[right]):\n                                                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                                                new_pivot_idx += 1\n                                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                                return new_pivot_idx", "31": "class Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector<int> result;\n        rightSideViewDFS(root, 1, result);\n        return result;\n    }\n    \n    void rightSideViewDFS(TreeNode* node, int depth, vector<int>& result) {\n        if (!node) return;\n        if (depth > result.size())\n            result.push_back(node->val);\n        rightSideViewDFS(node->right, depth+1, result);\n        rightSideViewDFS(node->left, depth+1, result);\n    }\n};", "32": "int strStr(string haystack, string needle) {\n        for (int i = 0; i < haystack.length() - needle.length() + 1; i++) {\n                if (haystack.substr(i, needle.length()) == needle) {\n                        return i;\n                }\n        }\n        return -1;\n}", "33": "int furthestBuilding(vector<int>& heights, int bricks, int ladders) {\n               priority_queue<int> min_heap;\n                for (int i = 0; i < heights.size()-1; i++) {\n                        int diff = heights[i+1]-heights[i];\n                        if (diff > 0) {\n                                min_heap.push(diff);\n                        }\n                        if (min_heap.size() <= ladders) {\n                                continue;\n                        }\n                        bricks -= min_heap.top();\n                        min_heap.pop();\n                        if (bricks < 0) {\n                                return i;\n                        }\n                }\n                return heights.size()-1;\n        }", "34": "removeOccurrences(self, s, part):\n                def getPrefix(pattern):\n                        prefix = [-1]*len(pattern)\n                        j = -1\n                        for i in xrange(1, len(pattern)):\n                                while j != -1 and pattern[j+1] != pattern[i]:\n                                        j = prefix[j]\n                                if pattern[j+1] == pattern[i]:\n                                        j += 1\n                                prefix[i] = j\n                        return prefix\n                prefix = getPrefix(part)\n                result, lookup = [], []\n                i = -1\n                for c in s:\n                        while i != -1 and part[i+1] != c:\n                                i = prefix[i]\n                        if part[i+1] == c:\n                                i += 1\n                        result.append(c)\n                        lookup.append(i)\n                        if i == len(part)-1:\n                                result[len(result)-len(part):] = []\n                                lookup[len(lookup)-len(part):] = []\n                                i = lookup[-1] if lookup else -1\n                return \"\".join(result)\ndef getPrefix(pattern):\n                        prefix = [-1]*len(pattern)\n                        j = -1\n                        for i in xrange(1, len(pattern)):\n                                while j != -1 and pattern[j+1] != pattern[i]:\n                                        j = prefix[j]\n                                if pattern[j+1] == pattern[i]:\n                                        j += 1\n                                prefix[i] = j\n                        return prefix", "35": "int minFlips(string s) {\n                int result = INT_MAX;\n                int cnt1 = cnt2 = 0;\n                for (int i = 0; i < 2*s.length()-1; ++i) {\n                        if (i >= s.length()) {\n                                cnt1 -= (s[i%s.length()] - '0') ^ ((i-s.length())%2) ^ 0;\n                                cnt2 -= (s[i%s.length()] - '0') ^ ((i-s.length())%2) ^ 1;\n                        }\n                        cnt1 += (s[i%s.length()] - '0') ^ (i%2) ^ 0;\n                        cnt2 += (s[i%s.length()] - '0') ^ (i%2) ^ 1;\n                        if (i >= s.length()-1) {\n                                result = min(result, cnt1, cnt2);\n                        }\n                }\n                return result;\n        }", "36": "bool cmp(pair<int, int> a, pair<int, int> b)\n{\n    return a.first > b.first || (a.first == b.first && a.second < b.second);\n}\n\nvector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) \n{\n    sort(people.begin(), people.end(), cmp);\n    vector<pair<int, int>> res;\n    for (auto& p : people) \n        res.insert(res.begin() + p.second, p);\n    return res;\n}", "37": "bool buddyStrings(string A, string B) {\n                if (A.size() != B.size())\n                        return false;\n                vector<pair<char, char>> diff;\n                for (int i = 0; i < A.size(); ++i) {\n                        if (A[i] != B[i])\n                                diff.push_back(make_pair(A[i], B[i]));\n                }\n                return (diff.empty() && set<char>(A.begin(), A.end()).size() < A.size()) || \n                        (diff.size() == 2 && diff[0] == make_pair(diff[1].second, diff[1].first));\n}", "38": "int minimumTimeRequired(vector<int>& jobs, int k){\n                sort(jobs.begin(), jobs.end(), greater<int>());\n                int result = accumulate(jobs.begin(), jobs.end(), 0);\n                vector<int> counts(k, 0);\n                backtracking(jobs, 0, counts, result);\n                return result;\n}", "39": "bool hasValidPath(vector<vector<int>>& grid){\n    int E, S, W, N = [(0, 1), (1, 0), (0, -1), (-1, 0)];\n    vector<vector<int>> directions = [\n            [W, E], [N, S],\n            [W, S], [S, E],\n            [W, N], [N, E] ];\n    for(int r, c : directions[grid[0][0]-1]){\n            if not (0 <= r < len(grid) && 0 <= c < len(grid[0])):\n                    continue\n            int pr, pc = 0, 0;\n            while(r != len(grid)-1 || c != len(grid[0])-1){\n                    for(int dx, dy : directions[grid[r][c]-1]){\n                            int nr, nc = r+dx, c+dy;\n                            if ((nr == pr && nc == pc) || \\\n                            not(0 <= nr < len(grid) && 0 <= nc < len(grid[0])) || \\\n                            (-dx, -dy) not in directions[grid[nr][nc]-1]){\n                                    continue\n                            }\n                            pr, pc, r, c = r, c, nr, nc;\n                            break;\n                    }\n                    else{\n                            return false;\n                    }\n            }\n            return true;\n    }\n    return len(grid) == len(grid[0]) == 1;\n}", "40": "int numBusesToDestination(vector<vector<int>>& routes, int S, int T) {\n                if (S == T) {\n                        return 0;\n                }\n                unordered_map<int, unordered_set<int>> to_route;\n                for (int i = 0; i < routes.size(); ++i) {\n                        for (int stop : routes[i]) {\n                                to_route[stop].insert(i);\n                        }\n                }\n                int result = 1;\n                queue<int> q;\n                unordered_set<int> lookup;\n                q.push(S);\n                lookup.insert(S);\n                while (!q.empty()) {\n                        queue<int> next_q;\n                        while (!q.empty()) {\n                                int stop = q.front();\n                                q.pop();\n                                for (int i : to_route[stop]) {\n                                        for (int next_stop : routes[i]) {\n                                                if (lookup.find(next_stop) != lookup.end()) {\n                                                        continue;\n                                                }\n                                                if (next_stop == T) {\n                                                        return result;\n                                                }\n                                                next_q.push(next_stop);\n                                                to_route[next_stop].erase(i);\n                                                lookup.insert(next_stop);\n                                        }\n                                }\n                        }\n                        swap(q, next_q);\n                        ++result;\n                }\n                return -1;\n        }", "41": "bool isToeplitzMatrix(vector<vector<int>> &matrix) {\n                for (int row_index, row : matrix) {\n                        for (int digit_index, digit : row) {\n                                if (!row_index || !digit_index) {\n                                        continue;\n                                }\n                                if (matrix[row_index - 1][digit_index - 1] != digit) {\n                                        return false;\n                                }\n                        }\n                }\n                return true;\n}", "42": "void findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\n                unordered_map<int, vector<pair<int, int>>> adj;\n                for (int u, v, w in flights) {\n                        adj[u].push_back((v, w));\n                }\n                unordered_map<int, unordered_map<int, int>> best;\n                best[src][K+1] = 0;\n                min_heap.push((0, src, K+1));\n                while (!min_heap.empty()) {\n                        int result, u, k = heapq.heappop(min_heap);\n                        if (k < 0 || best[u][k] < result) {\n                                continue;\n                        }\n                        if (u == dst) {\n                                return result;\n                        }\n                        for (int v, w in adj[u]) {\n                                if (result+w < best[v][k-1]) {\n                                        best[v][k-1] = result+w                                        \n                                        heapq.heappush(min_heap, (result+w, v, k-1))\n                                }\n                        }\n                }\n                return -1;\n}", "43": "int minChanges(vector<int> nums, int k){\n\n                int one_are_not_from_nums(vector<int> nums, map<int, int> cnts){\n                        mxs = [cnts[i].most_common(1)[0][1] for i in xrange(k)]\n                        return len(nums) - (sum(mxs)-min(mxs))\n                }\n                int all_are_from_nums(vector<int> nums, map<int, int> cnts){\n                        dp = {0:0}\n                        for cnt in cnts:\n                                new_dp = collections.defaultdict(int)\n                                for x in dp.iterkeys():\n                                        for y in cnt.iterkeys():\n                                                new_dp[x^y] = max(new_dp[x^y], dp[x]+cnt[y])\n                                dp = new_dp\n                        return len(nums)-dp[0]\n                }\n                map<int, int> cnts = [collections.Counter(nums[j] for j in xrange(i, len(nums), k)) for i in xrange(k)]\n                return min(one_are_not_from_nums(nums, cnts), all_are_from_nums(nums, cnts))\n        }", "44": "int minCharacters(string a, string b) {\n                map<char, int> count1;\n                map<char, int> count2;\n                for (int i = 0; i < a.length(); i++) {\n                        count1[a[i]-'a']++;\n                }\n                for (int i = 0; i < b.length(); i++) {\n                        count2[b[i]-'a']++;\n                }\n                int result = len(a) + len(b) - max((count1+count2).itervalues()); \n                for (int i = 0; i < 26-1; i++) {\n                        if (i > 0) {\n                                count1[i] += count1[i-1];\n                                count2[i] += count2[i-1];\n                        }\n                        result = min(result, len(a) - count1[i] + count2[i]); \n                        result = min(result, len(b) - count2[i] + count1[i]); \n                }\n                return result;\n}", "45": "def reverseOnlyLetters(S):\n               \n                result = []\n                letter = getNext(S)\n                for i in xrange(len(S)):\n                        if S[i].isalpha():\n                                result.append(letter.next())\n                        else:\n                                result.append(S[i])\n                return \"\".join(result)", "46": "int countDigitOne(int DIGIT, int n) {\n                int is_zero = int(DIGIT == 0);\n                int result = is_zero;\n                int base = 1;\n                while (n >= base) {\n                        result += (n / (10 * base) - is_zero)*base + \\\n                                        min(base, max(n%(10 * base) - DIGIT * base + 1, 0));\n                        base *= 10;\n                }\n                return result;\n}", "47": "class TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint minDepth(TreeNode* root) {\n    if (root == NULL) {\n        return 0;\n    }\n    if (root->left && root->right) {\n        return min(minDepth(root->left), minDepth(root->right)) + 1;\n    }\n    else {\n        return max(minDepth(root->left), minDepth(root->right)) + 1;\n    }\n}", "48": "int findClosestElements(vector<int>& arr, int k, int x) {\n        int i = lower_bound(arr.begin(), arr.end(), x) - arr.begin();\n        int left = i - 1, right = i;\n        while (k) {\n                if (right >= arr.size() || (left >= 0 && abs(arr[left] - x) <= abs(arr[right] - x))) {\n                        --left;\n                }\n                else {\n                        ++right;\n                }\n                --k;\n        }\n        return vector<int>(arr.begin() + left + 1, arr.begin() + right);\n}", "49": "int nthUglyNumber(int n, int a, int b, int c)\n{\n               \n                int lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a)\n                int lcm_a_b_c = lcm(lcm_a_b, lcm_b_c)\n                int left, right = 1, 2*10**9\n                while (left <= right)\n                {\n                        int mid = left + (right-left)//2\n                        if (count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n)\n                                right = mid-1;\n                        else\n                                left = mid+1;\n                }\n                return left;\n}", "50": "vector<int> candy(vector<int> &ratings) {\n                vector<int> candies;\n                for (int i = 0; i < ratings.size(); i++) {\n                        candies[i] = 1;\n                }\n                for (int i = 1; i < ratings.size(); i++) {\n                        if (ratings[i] > ratings[i - 1]) {\n                                candies[i] = candies[i - 1] + 1;\n                        }\n                }\n                for (int i = ratings.size() - 1; i > 0; i--) {\n                        if (ratings[i - 1] > ratings[i] && candies[i - 1] <= candies[i]) {\n                                candies[i - 1] = candies[i] + 1;\n                        }\n                }\n                int sum = 0;\n                for (int i = 0; i < candies.size(); i++) {\n                        sum += candies[i];\n                }\n                return sum;\n}", "51": "class UnionFind {\npublic:\n                UnionFind(int n, function<void(int, int, int)> cb): set(n), rank(n, 0), cb(cb) {}\n                void find_set(int x) {\n                        stk = [];\n                        while (set[x] != x) {\n                                stk.append(x);\n                                x = set[x];\n                        }\n                        while (!stk.empty()) {\n                                set[stk.pop()] = x;\n                        }\n                        return x;\n                }\n                bool union_set(int x, int y) {\n                        int x_root = find_set(x), y_root = find_set(y);\n                        if (x_root == y_root) {\n                                return false;\n                        }\n                        if (rank[x_root] < rank[y_root]) {\n                                set[x_root] = y_root;\n                                cb(y_root, x_root, y_root);\n                        } else if (rank[x_root] > rank[y_root]) {\n                                set[y_root] = x_root;\n                                cb(x_root, x_root, y_root);\n                        } else {\n                                set[y_root] = x_root;\n                                rank[x_root] += 1;\n                                cb(x_root, x_root, y_root);\n                        }\n                        return true;\n                }\nprivate:\n                vector<int> set;\n                vector<int> rank;\n                function<void(int, int, int)> cb;\n};\nvector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {\n                function<void(int, int, int)> cb = [&](int x, int y, int z) {\n                        new_rank[x] = max(new_rank[y], new_rank[z]);\n                };\n                unordered_map<int, vector<pair<int, int>>> lookup;\n                for (int i = 0; i < matrix.size(); ++i) {\n                        for (int j = 0; j < matrix[0].size(); ++j) {\n                                lookup[matrix[i][j]].emplace_back(i, j);\n                        }\n                }\n                vector<int> rank(matrix.size() + matrix[0].size());\n                for (const auto& it : lookup) {\n                        vector<int> new_rank(rank);\n                        UnionFind uf(matrix.size() + matrix[0].size(), cb);\n                        for (const auto& p : it.second) {\n                                uf.union_set(p.first, p.second + matrix.size());\n                        }\n                        for (const auto& p : it.second) {\n                                matrix[p.first][p.second] = rank[p.first] = rank[p.second + matrix.size()] = new_rank[uf.find_set(p.first)] + 1;\n                        }\n                }\n                return matrix;\n        }", "52": "int minDiffInBST(TreeNode *root) {\n    int prev = -INF;\n    int result = INF;\n    function<void(TreeNode*)> dfs = [&](TreeNode* node) {\n        if (!node) return;\n        dfs(node->left);\n        result = min(result, node->val - prev);\n        prev = node->val;\n        dfs(node->right);\n    };\n    dfs(root);\n    return result;\n}", "53": "int thirdMax(vector<int>& nums) {\n        int count = 0;\n        int top[3] = { INT_MIN };\n        for (int num : nums) {\n                if (num > top[0]) {\n                        top[0] = num;\n                        count++;\n                }\n                else if (num != top[0] && num > top[1]) {\n                        top[1] = num;\n                        count++;\n                }\n                else if (num != top[0] && num != top[1] && num >= top[2]) {\n                        top[2] = num;\n                        count++;\n                }\n        }\n        if (count < 3) {\n                return top[0];\n        }\n        return top[2];\n}", "54": "int subarraySum(vector<int>& nums, int k) {\n        int result = 0;\n        int accumulated_sum = 0;\n        unordered_map<int, int> lookup;\n        lookup[0] += 1;\n        for (int num : nums) {\n                accumulated_sum += num;\n                result += lookup[accumulated_sum - k];\n                lookup[accumulated_sum] += 1;\n        }\n        return result;\n}", "55": "class BSTIterator {\n    public:\n    BSTIterator(TreeNode *root) {\n        this->__stk = [];\n        this->__traversalLeft(root);\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return this->__stk;\n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        TreeNode* node = this->__stk.pop();\n        this->__traversalLeft(node->right);\n        return node->val;\n    }\n    \n    private:\n    vector<TreeNode*> __stk;\n    \n    void __traversalLeft(TreeNode* node) {\n        while (node != nullptr) {\n            this->__stk.push_back(node);\n            node = node->left;\n        }\n    }\n};", "56": "class Solution {\npublic:\n    vector<int> prevPermOpt1(vector<int>& A) {\n                for (int left = A.size() - 2; left >= 0; --left) {\n                        if (A[left] > A[left+1]) {\n                                break;\n                        }\n                }\n                if (left == -1) {\n                        return A;\n                }\n                int right = A.size() - 1;\n                while (A[left] <= A[right]) {\n                        --right;\n                }\n                while (A[right - 1] == A[right]) {\n                        --right;\n                }\n                swap(A[left], A[right]);\n                return A;\n    }\n};", "57": "class Solution {\npublic:\n    int leastInterval(vector<char>& tasks, int n) {\n        int max_count = 0;\n        unordered_map<char, int> counts;\n        for (char t : tasks) {\n            ++counts[t];\n            max_count = max(max_count, counts[t]);\n        }\n        int result = (max_count - 1) * (n + 1);\n        for (auto c : counts) {\n            if (c.second == max_count) ++result;\n        }\n        return max(result, (int)tasks.size());\n    }\n};", "58": "int getMoneyAmount(int n) {\n                int pay[n+1][n+1];\n                for (int i = n; i >= 0; i--) {\n                        for (int j = i+1; j <= n; j++) {\n                                pay[i][j] = min(k+1 + max(pay[i][k-1], pay[k+1][j]) \\\n                                                                for k in xrange(i, j+1))\n                        }\n                }\n                return pay[0][n-1];\n        }", "59": "class Node {\npublic:\n    int val;\n    Node* next;\n    Node() {}\n    Node(int _val, Node* _next = nullptr) {\n        val = _val;\n        next = _next;\n    }\n};\n\nNode* swapNodes(Node* head, int k) {\n    Node* left = nullptr;\n    Node* right = nullptr;\n    Node* curr = head;\n    while (curr) {\n        k -= 1;\n        if (right) {\n            right = right->next;\n        }\n        if (k == 0) {\n            left = curr;\n            right = head;\n        }\n        curr = curr->next;\n    }\n    left->val = right->val;\n    right->val = left->val;\n    return head;\n}", "60": "int numDecodings(string s) {\n                if (s.length() == 0 || s[0] == '0')\n                        return 0;\n                int prev = 1;\n                int prev_prev = 0;\n                for (int i = 0; i < s.length(); i++) {\n                        int cur = 0;\n                        if (s[i] != '0')\n                                cur = prev;\n                        if (i > 0 && (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6')))\n                                cur += prev_prev;\n                        prev_prev = prev;\n                        prev = cur;\n                }\n                return prev;\n}", "61": "bool backspaceCompare(string S, string T) {\n        auto findNextChar = [](string S) {\n                int skip = 0;\n                for (int i = S.size() - 1; i >= 0; i--) {\n                        if (S[i] == '#')\n                                skip++;\n                        else if (skip)\n                                skip--;\n                        else\n                                yield S[i];\n                }\n        };\n\n        return equal(findNextChar(S), findNextChar(T));\n}", "62": "class ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n                ListNode* dummy = new ListNode(0);\n                ListNode* current = dummy;\n                int carry = 0;\n                while (l1 || l2) {\n                        int val = carry;\n                        if (l1) {\n                                val += l1->val;\n                                l1 = l1->next;\n                        }\n                        if (l2) {\n                                val += l2->val;\n                                l2 = l2->next;\n                        }\n                        carry = (val) / 10;\n                        val = val % 10;\n                        current->next = new ListNode(val);\n                        current = current->next;\n                }\n                if (carry == 1) {\n                        current->next = new ListNode(1);\n                }\n                return dummy->next;\n}", "63": "class Solution {\npublic:\n    bool isSubPath(ListNode* head, TreeNode* root) {\n        if(!head) return true;\n        if(!root) return false;\n        return dfs(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\n    }\n};", "64": "int rob(root)\n{\n        int robHelper(root)\n        {\n            if (!root)\n    \t\t\treturn (0, 0)\n    \t\tleft, right = robHelper(root.left), robHelper(root.right)\n    \t\treturn (root.val + left[1] + right[1], max(left) + max(right))\n        }\n        return max(robHelper(root))\n}", "65": "int minOperations(vector<int>& nums) {\n        int result = 0;\n        int prev = 0;\n        for (int curr : nums) {\n                if (prev < curr) {\n                        prev = curr;\n                        continue;\n                }\n                prev += 1;\n                result += prev-curr\n        }\n        return result;\n}", "66": "int minimumJumps(vector<int> forbidden, int a, int b, int x) {\n                int max_f = 0;\n                for (int i = 0; i < forbidden.size(); ++i) {\n                        if (forbidden[i] > max_f) {\n                                max_f = forbidden[i];\n                        }\n                }\n                int max_val = x+b;\n                if (a >= b) {\n                        if (x > max_f) {\n                                max_val = x+a;\n                        } else {\n                                max_val = max_f+a;\n                        }\n                }\n                unordered_set<int> lookup;        \n                for (int i = 0; i < forbidden.size(); ++i) {\n                        lookup.insert(forbidden[i]*2);\n                        lookup.insert(forbidden[i]*2+1);\n                }\n                int result = 0;\n                queue<int> q;\n                q.push(0);\n                lookup.insert(0);\n                while (!q.empty()) {\n                        queue<int> new_q;\n                        while (!q.empty()) {\n                                int pos = q.front();\n                                q.pop();\n                                if (pos == x) {\n                                        return result;\n                                }\n                                if (pos+a <= max_val && lookup.find(pos+a) == lookup.end()) {\n                                        lookup.insert(pos+a);\n                                        new_q.push(pos+a);\n                                }\n                                if (pos%2 == 1) {\n                                        continue;\n                                }\n                                if (pos-b >= 0 && lookup.find(pos-b) == lookup.end()) {\n                                        lookup.insert(pos-b);\n                                        new_q.push(pos-b);\n                                }\n                        }\n                        q = new_q;\n                        result += 1;\n                }\n                return -1;\n}", "67": "int countPrimeSetBits(int L, int R)\n{\n    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19};\n    int result = 0;\n    for(int i = L; i <= R; i++)\n    {\n        if(bitCount(i) in primes)\n        {\n            result++;\n        }\n    }\n    return result;\n}", "68": "bool checkIfPangram(string sentence)\n{\n        return sentence.length() == 26;\n}", "69": "int countGoodSubstrings(string s){\n                int K = 3;\n                int result = 0;\n                map<char, int> count;\n                for (int i = 0; i < s.length(); i++){\n                        if (i >= K){\n                                count[s[i-K]] -= 1;\n                                if (!count[s[i-K]]){\n                                        del count[s[i-K]];\n                                }\n                        }\n                        count[s[i]] += 1;\n                        if (count.size() == K){\n                                result += 1;\n                        }\n                }\n                return result;\n        }", "70": "class Solution {\npublic:\n    int firstUniqChar(string s) {\n        unordered_map<char, int> lookup;\n        unordered_set<int> candidtates;\n        for (int i = 0; i < s.length(); i++) {\n            if (lookup[s[i]]) {\n                candidtates.erase(lookup[s[i]]);\n            }\n            else {\n                lookup[s[i]] = i + 1;\n                candidtates.insert(i + 1);\n            }\n        }\n        return min(candidtates) - 1;\n    }\n};", "71": "class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return sumNumbersRecu(root, 0);\n    }\n    int sumNumbersRecu(TreeNode* root, int num) {\n        if (root == nullptr) {\n            return 0;\n        }\n        if (root->left == nullptr && root->right == nullptr) {\n            return num * 10 + root->val;\n        }\n        return sumNumbersRecu(root->left, num * 10 + root->val) + sumNumbersRecu(root->right, num * 10 + root->val);\n    }\n};", "72": "int minimumSwap(string s1, string s2) {\n                int x1, y1;\n                for (int i = 0; i < s1.length(); i++) {\n                        if (s1[i] == s2[i]) {\n                                continue;\n                        }\n                        x1 += int(s1[i] == 'x');\n                        y1 += int(s1[i] == 'y');\n                }\n                if (x1%2 != y1%2) {\n                        return -1;\n                }\n                return (x1/2 + y1/2) + (x1%2 + y1%2);\n        }", "73": "int secondHighest(string s) {\n                int first = -1;\n                int second = -1;\n                for (int i = 0; i < s.length(); i++) {\n                        if (!isdigit(s[i])) {\n                                continue;\n                        }\n                        int d = stoi(s);\n                        if (d > first) {\n                                first = d;\n                                second = first;\n                        }\n                        else if (first > d > second) {\n                                second = d;\n                        }\n                }\n                return second;\n}", "74": "bool isTransformable(string s, string t) {\n                vector<vector<int>> idxs(10);\n                for (int i = s.length() - 1; i >= 0; i--) {\n                        idxs[s[i] - '0'].push_back(i);\n                }\n                for (char c : t) {\n                        int d = c - '0';\n                        if (idxs[d].empty()) {\n                                return false;\n                        }\n                        for (int k = 0; k < d; k++) {\n                                if (!idxs[k].empty() && idxs[k].back() < idxs[d].back()) {\n                                        return false;\n                                }\n                        }\n                        idxs[d].pop_back();\n                }\n                return true;\n        }", "75": "#include <iostream>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n \nstd::vector<std::string> split(const std::string& str, char delimiter)\n{\n    std::vector<std::string> tokens;\n    std::stringstream stream(str);\n    std::string token;\n    while (std::getline(stream, token, delimiter))\n    {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n \nstd::string toGoatLatin(std::string S)\n{\n    std::set<char> vowel = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    std::vector<std::string> words = split(S, ' ');\n    std::string result = \"\";\n    for (int i = 0; i < words.size(); i++)\n    {\n        std::string word = words[i];\n        if (vowel.count(word[0]) == 0)\n        {\n            word = word.substr(1) + word[0];\n        }\n        word += \"ma\";\n        for (int j = 0; j <= i; j++)\n        {\n            word += \"a\";\n        }\n        result += word;\n        if (i != words.size() - 1)\n        {\n            result += \" \";\n        }\n    }\n    return result;\n}\n \nint main()\n{\n    std::string S = \"I speak Goat Latin\";\n    std::cout << toGoatLatin(S) << std::endl;\n    return 0;\n}", "76": "class Solution {\npublic:\n    double myPow(double x, int n) {\n                if (n < 0 && n != -n) {\n                        return 1.0 / myPow(x, -n);\n                }\n                if (n == 0) {\n                        return 1;\n                }\n                double v = myPow(x, n / 2);\n                if (n % 2 == 0) {\n                        return v * v;\n                }\n                else {\n                        return v * v * x;\n                }\n    }\n};", "77": "void numEnclaves(int** A, int ASize, int* AColSize){\n        int directions[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n        \n        for(int i=0; i<ASize; i++){\n                dfs(A, i, 0);\n                dfs(A, i, *AColSize-1);\n        }\n        for(int j=1; j<*AColSize-1; j++){\n                dfs(A, 0, j);\n                dfs(A, ASize-1, j);\n        }\n        int count = 0;\n        for(int i=0; i<ASize; i++){\n                for(int j=0; j<*AColSize; j++){\n                        count += A[i][j];\n                }\n        }\n        return count;\n}", "78": "int numberOfRounds(self, startTime, finishTime){\n                int h1, m1 = map(int, startTime.split(\":\"))\n                int h2, m2 = map(int, finishTime.split(\":\"))\n                if m1 > m2:\n                        h2 -= 1\n                        m2 += 60\n                return max((h2-h1)%24*4 + m2//15 - (m1+15-1)//15, 0)\n}", "79": "vector<int> getOrder(vector<vector<int>>& tasks) {\n        int idx = range(tasks.size());\n        idx.sort(key=lambda x: tasks[x][0]);\n        result, min_heap = [], []\n        i, time = 0, tasks[idx[0]][0]\n        while (i < idx.size() || !min_heap.empty()) {\n                while (i < idx.size() && tasks[idx[i]][0] <= time) {\n                        heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i]));\n                        i++;\n                }\n                if (min_heap.empty()) {\n                        time = tasks[idx[i]][0];\n                        continue;\n                }\n                int t, j = heapq.heappop(min_heap);\n                time += t;\n                result.push_back(j);\n        }\n        return result;\n}", "80": "int maximumUniqueSubarray(int nums[], int n) \n{ \n    int lookup[n]; \n    int prefix[n+1]; \n    int result = 0, left = 0; \n    for (int right = 0; right < n; right++) \n    { \n        prefix[right+1] = prefix[right] + nums[right]; \n        if (nums[right] in lookup) \n            left = max(left, lookup[nums[right]]+1); \n        lookup[nums[right]] = right; \n        result = max(result, prefix[right+1]-prefix[left]); \n    } \n    return result; \n}", "81": "class Solution {\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        int vals[10001] = {0};\n        for (int num : nums) {\n            vals[num] += num;\n        }\n        int val_i = vals[0], val_i_1 = 0;\n        for (int i = 1; i < sizeof(vals) / sizeof(int); i++) {\n            val_i_1 = val_i;\n            val_i = max(vals[i] + val_i_1, val_i);\n        }\n        return val_i;\n    }\n};", "82": "class Node{\n    public:\n        int val;\n        Node* left;\n        Node* right;\n    Node(int x){\n        this->val = x;\n        this->left = nullptr;\n        this->right = nullptr;\n        }\n};\n\nbool btreeGameWinningMove(Node* root, int n, int x){\n        int left_right[2] = {0, 0};\n        count(root, x, left_right);\n        int blue = max(max(left_right[0], left_right[1]), n-(left_right[0]+left_right[1]+1));\n        return blue > n-blue;\n}", "83": "vector<int> maxProductDifference(vector<int> nums) {\n                vector<int> largest, smallest;\n                for (int x : nums) {\n                        if (x >= largest[0]) {\n                                largest = {x, largest[0]};\n                        } else if (x > largest[1]) {\n                                largest[1] =x;\n                        }\n                        if (x <= smallest[0]) {\n                                smallest = {x, smallest[0]};\n                        } else if (x < smallest[1]) {\n                                smallest[1] = x;\n                        }\n                }\n                return {largest[0]*largest[1] - smallest[0]*smallest[1]};\n}", "84": "int repeatedNTimes(vector<int> A)\n{\n        for (int i = 2; i < A.size(); i++)\n        {\n                if (A[i-1] == A[i] || A[i-2] == A[i])\n                {\n                        return A[i];\n                }\n        }\n        return A[0];\n}", "85": "class Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        stack<TreeNode*> s;\n        TreeNode* cur = root;\n        int rank = 0;\n        \n        while(s.size() || cur) {\n            if(cur) {\n                s.push(cur);\n                cur = cur.left;\n            }\n            else {\n                cur = s.top();\n                s.pop();\n                rank += 1;\n                if(rank == k) {\n                    return cur.val;\n                }\n                cur = cur.right;\n            }\n        }\n        return -inf;\n    }\n};", "86": "class Solution {\npublic:\n    int maxLevelSum(TreeNode* root) {\n        int result = 0, level = 1;\n        int max_total = INT_MIN;\n        queue<TreeNode*> q;\n        q.push(root);\n        while (!q.empty()) {\n            int total = 0;\n            for (int i = 0; i < q.size(); i++) {\n                TreeNode* node = q.front();\n                q.pop();\n                total += node->val;\n                if (node->left)\n                    q.push(node->left);\n                if (node->right)\n                    q.push(node->right);\n            }\n            if (total > max_total) {\n                result = level;\n                max_total = total;\n            }\n            level++;\n        }\n        return result;\n    }\n};", "87": "class Solution {\npublic:\n    bool divisorGame(int N) {\n        unordered_map<int, bool> dp;\n        return memoization(N, dp);\n    }\n    bool memoization(int N, unordered_map<int, bool> &dp) {\n        if (N == 1) return false;\n        if (dp.count(N)) return dp[N];\n        bool result = false;\n        for (int i = 1; i <= N; ++i) {\n            if (N % i == 0 && !memoization(N - i, dp)) {\n                result = true;\n                break;\n            }\n        }\n        dp[N] = result;\n        return dp[N];\n    }\n};", "88": "int countSubIslands(vector<vector<int>> grid1, vector<vector<int>> grid2){\n                directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n                int sum = 0;\n                for i in xrange(len(grid2)){\n                        for j in xrange(len(grid2[0])){\n                                if grid2[i][j] == 1:\n                                        sum += dfs(grid1, grid2, i, j);\n                        }\n                }\n                return sum;\n}", "89": "class Solution {\npublic:\n    int balancedString(string s) {\n        unordered_map<char, int> count;\n        for (char c : s)\n            count[c]++;\n        int n = s.length(), result = n, left = 0, right = 0, k = n / 4;\n        for (right = 0; right < n; right++) {\n            count[s[right]]--;\n            while (left < n && count['Q'] <= k && count['W'] <= k && count['E'] <= k && count['R'] <= k) {\n                result = min(result, right - left + 1);\n                count[s[left]]++;\n                left++;\n            }\n        }\n        return result;\n    }\n};", "90": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        nums.sort();\n        vector<vector<int>> result;\n        vector<bool> used(nums.size(), false);\n        vector<int> cur;\n        permuteUniqueRecu(result, used, cur, nums);\n        return result;\n    }\n\n    void permuteUniqueRecu(vector<vector<int>> &result, vector<bool> &used, vector<int> &cur, vector<int> &nums) {\n        if (cur.size() == nums.size()) {\n            result.push_back(cur + vector<int>());\n            return;\n        }\n        for (int i = 0; i < nums.size(); ++i) {\n            if (used[i] || (i > 0 && nums[i-1] == nums[i] && !used[i-1])) {\n                continue;\n            }\n            used[i] = true;\n            cur.push_back(nums[i]);\n            permuteUniqueRecu(result, used, cur, nums);\n            cur.pop_back();\n            used[i] = false;\n        }\n    }\n};", "91": "int maxDepth(string s)\n{\n\tint result = curr = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\tcurr += 1;\n\t\t\tresult = max(result, curr);\n\t\t}\n\t\telse if (s[i] == ')')\n\t\t{\n\t\t\tcurr -= 1;\n\t\t}\n\t}\n\treturn result;\n}", "92": "class TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* increasingBST(TreeNode* root) {\n    TreeNode* result = increasingBSTHelper(root, NULL);\n    return result;\n}\n\nTreeNode* increasingBSTHelper(TreeNode* root, TreeNode* tail) {\n    if (!root) {\n        return tail;\n    }\n    TreeNode* result = increasingBSTHelper(root->left, root);\n    root->left = NULL;\n    root->right = increasingBSTHelper(root->right, tail);\n    return result;\n}", "93": "vector<vector<int>> dp(2, vector<int>(nums2.size()));\nfor (int i = 0; i < nums1.size(); ++i) {\n        for (int j = 0; j < nums2.size(); ++j) {\n                dp[i % 2][j] = nums1[i] * nums2[j];\n                if (i && j) {\n                        dp[i % 2][j] += max(dp[(i - 1) % 2][j - 1], 0);\n                }\n                if (i) {\n                        dp[i % 2][j] = max(dp[i % 2][j], dp[(i - 1) % 2][j]);\n                }\n                if (j) {\n                        dp[i % 2][j] = max(dp[i % 2][j], dp[i % 2][j - 1]);\n                }\n        }\n}\nreturn dp[(nums1.size() - 1) % 2][nums2.size() - 1];", "94": "class Solution {\npublic:\n    int findRotateSteps(string ring, string key) {\n        unordered_map<char, vector<int>> lookup;\n        for (int i = 0; i < ring.size(); i++) {\n            lookup[ring[i]].push_back(i);\n        }\n        vector<int> dp(ring.size(), 0);\n        vector<int> prev;\n        for (int i = 0; i < key.size(); i++) {\n            vector<int> cur(ring.size(), 0);\n            for (int j : lookup[key[i]]) {\n                for (int k : prev) {\n                    cur[j] = min(cur[j], min(abs(k - j), ring.size() - abs(k - j)) + dp[k]);\n                }\n            }\n            dp = cur;\n            prev = lookup[key[i]];\n        }\n        return *min_element(dp.begin(), dp.end()) + key.size();\n    }\n};", "95": "bool is_palindrome(string s, int i, int j) {\n                        while (i < j) {\n                                if (s[i] != s[j]) {\n                                        return false;\n                                }\n                                i++;\n                                j--;\n                        }\n                        return true;\n                }\nbool check(string a, string b) {\n                        int i = 0, j = b.length() - 1;\n                        while (i < j) {\n                                if (a[i] != b[j]) {\n                                        return is_palindrome(a, i, j) || is_palindrome(b, i, j);\n                                }\n                                i++;\n                                j--;\n                        }\n                        return true;\n                }\n\nbool checkPalindromeFormation(string a, string b) {\n                return check(a, b) || check(b, a);\n        }", "96": NaN, "97": NaN, "98": "int getMaximumGenerated(int n) {\n                if (n == 0) {\n                        return 0;\n                }\n                int nums[n+1];\n                nums[1] = 1;\n                int result = 1;\n                for (int i = 2; i < n+1; i++) {\n                        if (i%2 == 0) {\n                                nums[i] = nums[i/2];\n                        } else {\n                                nums[i] = nums[i/2] + nums[i/2+1];\n                        }\n                        result = max(result, nums[i]);\n                }\n                return result;\n}", "99": "int subsetXORSum(vector<int> nums){\n        int result = 0;\n        for (auto x: nums)\n                result |= x;\n        return result * pow(2, nums.size()-1);\n}"}}, "Java -  C++": {"ID": {"0": 237, "1": 1700, "2": 1636, "3": 680, "4": 1332, "5": 104, "6": 173, "7": 466, "8": 128, "9": 1704, "10": 343, "11": 153, "12": 65, "13": 674, "14": 34, "15": 1609, "16": 278, "17": 393, "18": 1774, "19": 643, "20": 421, "21": 210, "22": 1619, "23": 832, "24": 1346, "25": 1604, "26": 1752, "27": 334, "28": 583, "29": 650, "30": 690, "31": 1672, "32": 143, "33": 931, "34": 368, "35": 1371, "36": 436, "37": 132, "38": 319, "39": 1630, "40": 1344, "41": 973, "42": 134, "43": 282, "44": 1725, "45": 179, "46": 1029, "47": 374, "48": 279, "49": 306, "50": 38, "51": 95, "52": 1576, "53": 1300, "54": 70, "55": 1717, "56": 1323, "57": 289, "58": 1860, "59": 1759, "60": 1339, "61": 1367, "62": 692, "63": 67, "64": 230, "65": 45, "66": 525, "67": 149, "68": 765, "69": 1471, "70": 523, "71": 1437, "72": 1374, "73": 94, "74": 154, "75": 639, "76": 493, "77": 633, "78": 1920, "79": 1379, "80": 1493, "81": 1400, "82": 461, "83": 524, "84": 629, "85": 42, "86": 600, "87": 532, "88": 90, "89": 457, "90": 1807, "91": 1366, "92": 1720, "93": 116, "94": 714, "95": 675, "96": 206, "97": 881, "98": 58, "99": 1078}, "Java": {"0": "public void deleteNode(ListNode node) {\n                        node.val = node.next.val;\n                        node.next = node.next.next;\n                }", "1": "public int countStudents(int[] students, int[] sandwiches) {\n                        Queue<Integer> studentsQueue = new LinkedList<>();\n                        Queue<Integer> sandwichesQueue = new LinkedList<>();\n                        for (int i = 0; i < sandwiches.length; i++) {\n                                studentsQueue.add(students[i]);\n                                sandwichesQueue.add(sandwiches[i]);\n                        }\n                        do {\n                                if (!studentsQueue.isEmpty()) {\n                                        if (studentsQueue.peek() == sandwichesQueue.peek()) {\n                                                studentsQueue.poll();\n                                                sandwichesQueue.poll();\n                                        } else {\n                                                if (!studentsQueue.contains(sandwichesQueue.peek())) {\n                                                        break;\n                                                }\n                                                studentsQueue.add(studentsQueue.poll());\n                                        }\n                                }\n                        } while (!studentsQueue.isEmpty());\n                        return studentsQueue.size();\n                }", "2": "public int[] frequencySort(int[] nums) {\n                        Map<Integer, Integer> count = new HashMap<>();\n                        for (int num : nums) {\n                                count.put(num, count.getOrDefault(num, 0) + 1);\n                        }\n                        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\n                        for (int num : count.keySet()) {\n                                int freq = count.get(num);\n                                if (!map.containsKey(freq)) {\n                                        map.put(freq, new ArrayList<>());\n                                }\n                                List<Integer> list = map.get(freq);\n                                list.add(num);\n                                map.put(freq, list);\n                        }\n                        int[] result = new int[nums.length];\n                        int i = 0;\n                        for (int num : map.keySet()) {\n                                List<Integer> list = map.get(num);\n                                Collections.sort(list, Collections.reverseOrder());\n                                int k = num;\n                                for (int j = 0; j < list.size(); j++, k = num) {\n                                        while (k-- > 0) {\n                                                result[i++] = list.get(j);\n                                        }\n                                }\n                        }\n                        return result;\n                }", "3": "public boolean validPalindrome(String s) {\n                        int left = 0;\n                        int right = s.length() - 1;\n                        int diff = 0;\n                        while (left < right) {\n                                if (s.charAt(left) != s.charAt(right)) {\n                                        left++;\n                                        diff++;\n                                        if (diff > 1) {\n                                                break;\n                                        }\n                                } else {\n                                        left++;\n                                        right--;\n                                }\n                        }\n                        if (diff < 2) {\n                                return true;\n                        }\n                        diff = 0;\n                        left = 0;\n                        right = s.length() - 1;\n                        while (left < right) {\n                                if (s.charAt(left) != s.charAt(right)) {\n                                        right--;\n                                        diff++;\n                                        if (diff > 1) {\n                                                break;\n                                        }\n                                } else {\n                                        left++;\n                                        right--;\n                                }\n                        }\n                        return diff < 2;\n                }", "4": "public int removePalindromeSub(String s) {\n                        if (s.isEmpty()) {\n                                return 0;\n                        }\n                        if (s.equals((new StringBuilder(s)).reverse().toString())) {\n                                return 1;\n                        }\n                        return 2;\n                }", "5": "public int maxDepth(TreeNode root) {\n                        if (root == null) {\n                                return 0;\n                        }\n                        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n                }", "6": "There is no code for this data point", "7": "public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n                        char[] s1chars = s1.toCharArray();\n                        char[] s2chars = s2.toCharArray();\n                        int i = 0;\n                        int j = 0;\n                        int count1 = 0;\n                        int count2 = 0;\n                        while (count1 < n1) {\n                                if (s1chars[i] == s2chars[j]) {\n                                        j++;\n                                        if (j == s2.length()) {\n                                                j = 0;\n                                                count2++;\n                                        }\n                                }\n                                i++;\n                                if (i == s1.length()) {\n                                        i = 0;\n                                        count1++;\n                                }\n                        }\n                        return count2 / n2;\n                }", "8": "public int longestConsecutive(int[] nums) {\n                        Map<Integer, Integer> map = new HashMap();\n                        UnionFind uf = new UnionFind(nums);\n                        for (int i = 0; i < nums.length; i++) {\n                                if (map.containsKey(nums[i])) {\n                                        continue;\n                                }\n                                map.put(nums[i], i);\n                                if (map.containsKey(nums[i] - 1)) {\n                                        uf.union(i, map.get(nums[i] - 1));\n                                }\n                                if (map.containsKey(nums[i] + 1)) {\n                                        uf.union(i, map.get(nums[i] + 1));\n                                }\n                        }\n                        return uf.maxUnion();\n                }", "9": "public boolean halvesAreAlike(String s) {\n                        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n                        int firstHalfVowelsCount = (int) IntStream.range(0, s.length() / 2).filter(i -> vowels.contains(s.charAt(i))).count();\n                        int secondHalfVowelsCount = (int) IntStream.range(s.length() / 2, s.length()).filter(i -> vowels.contains(s.charAt(i))).count();\n                        return firstHalfVowelsCount == secondHalfVowelsCount;\n                }", "10": "public int integerBreak(int n) {\n                        if (n == 2) {\n                                return 1;\n                        } else if (n == 3) {\n                                return 2;\n                        } else if (n % 3 == 0) {\n                                return (int) Math.pow(3, n / 3);\n                        } else if (n % 3 == 1) {\n                                return 2 * 2 * (int) Math.pow(3, (n - 4) / 3);\n                        } else {\n                                return 2 * (int) Math.pow(3, n / 3);\n                        }\n                }", "11": "public int findMin(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n        if (nums[left] < nums[right]) {\n                return nums[left];\n        }\n        int min = nums[0];\n        while (left + 1 < right) {\n                int mid = left + (right - left) / 2;\n                min = Math.min(min, nums[mid]);\n                if (nums[mid] > nums[left]) {\n                min = Math.min(nums[left], min);\n                left = mid + 1;\n                } else if (nums[mid] < nums[left]) {\n                right = mid - 1;\n                }\n        }\n        min = Math.min(min, Math.min(nums[left], nums[right]));\n        return min;\n        }", "12": "public boolean isNumber(String s) {\n                        s = s.trim();\n                        boolean pointSeen = false;\n                        boolean eSeen = false;\n                        boolean numberSeen = false;\n                        boolean numberAfterE = true;\n                        for (int i = 0; i < s.length(); i++) {\n                                if ('0' <= s.charAt(i) && s.charAt(i) <= '9') {\n                                        numberSeen = true;\n                                        numberAfterE = true;\n                                } else if (s.charAt(i) == '.') {\n                                        if (eSeen pointSeen) {\n                                                return false;\n                                        }\n                                        pointSeen = true;\n                                } else if (s.charAt(i) == 'e') {\n                                        if (eSeen !numberSeen) {\n                                                return false;\n                                        }\n                                        numberAfterE = false;\n                                        eSeen = true;\n                                } else if (s.charAt(i) == '-' || s.charAt(i) == '+') {\n                                        if (i != 0 && s.charAt(i - 1) != 'e') {\n                                                return false;\n                                        }\n                                } else {\n                                        return false;\n                                }\n                        }\n                        return numberSeen && numberAfterE;\n                }", "13": "public int findLengthOfLCIS(int[] nums) {\n                        int longest = 0;\n                        for (int i = 0; i < nums.length; i++) {\n                                int len = 1;\n                                for (int j = i + 1; j < nums.length; j++) {\n                                        if (nums[j - 1] < nums[j]) {\n                                                len++;\n                                                continue;\n                                        } else {\n                                                break;\n                                        }\n                                }\n                                longest = Math.max(longest, len);\n                        }\n                        return longest;\n                }", "14": "public int[] searchRange(int[] nums, int target) {\n                        int[] range = new int[2];\n                        range[0] = -1;\n                        range[1] = -1;\n                        if (nums == null nums.length == 0) {\n                                return range;\n                        }\n                        int start = 0;\n                        int end = nums.length - 1;\n                        while (start + 1 < end) {\n                                int mid = start + (end - start) / 2;\n                                if (nums[mid] == target) {\n                                        int left = mid;\n                                        while (left - 1 >= 0 && nums[left] == nums[left - 1]) {\n                                                left--;\n                                        }\n                                        range[0] = left;\n                                        int right = mid;\n                                        while (right + 1 < nums.length && nums[right] == nums[right + 1]) {\n                                                right++;\n                                        }\n                                        range[1] = right;\n                                        break;\n                                } else if (nums[mid] < target) {\n                                        start = mid;\n                                } else {\n                                        end = mid;\n                                }\n                        }\n                        if (nums[start] == target) {\n                                range[0] = start;\n                                while (start + 1 < nums.length && nums[start] == nums[start + 1]) {\n                                        start++;\n                                }\n                                range[1] = start;\n                        } else if (nums[end] == target) {\n                                range[1] = end;\n                                while (end - 1 >= 0 && nums[end] == nums[end - 1]) {\n                                        end--;\n                                }\n                                range[0] = end;\n                        }\n                        return range;\n                }", "15": "public boolean isEvenOddTree(TreeNode root) {\n                        Queue<TreeNode> queue = new LinkedList<>();\n                        queue.offer(root);\n                        int level = 0;\n                        while (!queue.isEmpty()) {\n                                int size = queue.size();\n                                List<Integer> list = new ArrayList<>();\n                                for (int i = 0; i < size; i++) {\n                                        TreeNode node = queue.poll();\n                                        list.add(node.val);\n                                        if (node.left != null) {\n                                                queue.add(node.left);\n                                        }\n                                        if (node.right != null) {\n                                                queue.add(node.right);\n                                        }\n                                }\n                                if (level % 2 == 0) {\n                                        for (int i = 0; i < list.size(); i++) {\n                                                if (list.get(i) % 2 == 0) {\n                                                        return false;\n                                                }\n                                                if (i < list.size() - 1 && list.get(i) >= list.get(i + 1)) {\n                                                        return false;\n                                                }\n                                        }\n                                } else {\n                                        for (int i = 0; i < list.size(); i++) {\n                                                if (list.get(i) % 2 != 0) {\n                                                        return false;\n                                                }\n                                                if (i < list.size() - 1 && list.get(i) <= list.get(i + 1)) {\n                                                        return false;\n                                                }\n                                        }\n                                }\n                                level++;\n                        }\n                        return true;\n                }", "16": "public int firstBadVersion(int n) {\n                        int left = 1;\n                        int right = n;\n                        while (left < right) {\n                                int mid = left + (right - left) / 2;\n                                if (isBadVersion(mid)) {\n                                        right = mid;\n                                } else {\n                                        left = mid + 1;\n                                }\n                        }\n                        return left;\n                }\nprivate boolean isBadVersion(int left) {\n                        return false;\n                }", "17": "public boolean validUtf8(int[] data) {\n                        int count = 0;\n                        for (int d : data) {\n                                if (count == 0) {\n                                        if ((d >> 5) == 0b110) {\n                                                count = 1;\n                                        } else if ((d >> 4) == 0b1110) {\n                                                count = 2;\n                                        } else if ((d >> 3) == 0b11110) {\n                                                count = 3;\n                                        } else if ((d >> 7) == 1) {\n                                                return false;\n                                        }\n                                } else {\n                                        if ((d >> 6) != 0b10) {\n                                                return false;\n                                        } else {\n                                                count--;\n                                        }\n                                }\n                        }\n                        return count == 0;\n                }", "18": "public int closestCost(int[] baseCosts, int[] toppingCosts, int target) {\n                        result = baseCosts[0];\n                        for (int i = 0; i < baseCosts.length; i++) {\n                                recursion(baseCosts[i], toppingCosts, 0, target);\n                        }\n                        return result;\n                }\nprivate void recursion(int currentCost, int[] toppingCosts, int index, int target) {\n                        if (Math.abs(currentCost - target) < Math.abs(result - target) || (Math.abs(currentCost - target) < Math.abs(result - target) && currentCost == result)) {\n                                result = currentCost;\n                        }\n                        if (index == toppingCosts.length currentCost == target) {\n                                return;\n                        }\n                        recursion(currentCost, toppingCosts, index + 1, target);\n                        recursion(currentCost + toppingCosts[index], toppingCosts, index + 1, target);\n                        recursion(currentCost + toppingCosts[index] * 2, toppingCosts, index + 1, target);\n                }", "19": "public double findMaxAverage(int[] nums, int k) {\n                        double sum = 0;\n                        double maxAve = Integer.MIN_VALUE;\n                        for (int i = 0; i < nums.length; i++) {\n                                if (k <= i) {\n                                        sum -= nums[i - k];\n                                }\n                                sum += nums[i];\n                                if ((i + 1) >= k) {\n                                        maxAve = Math.max(maxAve, sum / k);\n                                }\n                        }\n                        return maxAve;\n                }", "20": "public int findMaximumXOR(int[] nums) {\n                        int max = 0;\n                        int mask = 0;\n                        for (int i = 31; i >= 0; i--) {\n                                mask |= (1 << i);\n                                System.out.println(\"mask = \" + Integer.toBinaryString(mask));\n                                Set<Integer> set = new HashSet<>();\n                                for (int num : nums) {\n                                        System.out.println(\"num = \" + Integer.toBinaryString(num));\n                                        set.add(num & mask);\n                                        System.out.println(\"mask & num = \" + Integer.toBinaryString(mask & num));\n                                }\n                                int candidate = max | (1 << i);\n                                System.out.println(\"candidate = \" + Integer.toBinaryString(candidate));\n                                for (int prefix : set) {\n                                        System.out.println(\"candidate ^ prefix = \" + Integer.toBinaryString(candidate ^ prefix));\n                                        if (set.contains(candidate ^ prefix)) {\n                                                max = candidate;\n                                        }\n                                }\n                                System.out.println(\"max = \" + max);\n                                System.out.println(\"i = \" + i);\n                                System.out.println(\"===============================================\");\n                        }\n                        return max;\n                }", "21": "There is no code for this data point", "22": "public double trimMean(int[] arr) {\n                        Arrays.sort(arr);\n                        int n = arr.length;\n                        long sum = 0;\n                        for (int i = (int) Math.round(n * 0.05); i < (n - n * 0.05); i++) {\n                                sum += arr[i];\n                        }\n                        return sum / (n - n * 0.1);\n                }", "23": "public int[][] flipAndInvertImage(int[][] A) {\n                        int m = A.length;\n                        int n = A[0].length;\n                        int[][] result = new int[m][n];\n                        for (int i = 0; i < m; i++) {\n                                int[] flipped = (reverse(A[i]));\n                                result[i] = invert(flipped);\n                        }\n                        return result;\n                }\nprivate int[] invert(int[] flipped) {\n                        int[] result = new int[flipped.length];\n                        for (int i = 0; i < flipped.length; i++) {\n                                if (flipped[i] == 0) {\n                                        result[i] = 1;\n                                } else {\n                                        result[i] = 0;\n                                }\n                        }\n                        return result;\n                }\nprivate int[] reverse(int[] nums) {\n                        for (int i = 0, j = nums.length - 1; i < j; i++, j--) {\n                                int tmp = nums[i];\n                                nums[i] = nums[j];\n                                nums[j] = tmp;\n                        }\n                        return nums;\n                }", "24": "public boolean checkIfExist(int[] arr) {\n                        for (int i = 0; i < arr.length; i++) {\n                                for (int j = 0; j < arr.length; j++) {\n                                        if (i != j && (arr[i] * 2 == arr[j] arr[i] == arr[j] * 2)) {\n                                                return true;\n                                        }\n                                }\n                        }\n                        return false;\n                }", "25": "public List<String> alertNames(String[] keyName, String[] keyTime) {\n                        Map<String, List<String>> map = new HashMap<>();\n                        for (int i = 0; i < keyName.length; i++) {\n                                if (!map.containsKey(keyName[i])) {\n                                        map.put(keyName[i], new ArrayList<>());\n                                }\n                                map.get(keyName[i]).add(keyTime[i]);\n                        }\n                        List<String> people = new ArrayList<>();\n                        for (String person : map.keySet()) {\n                                List<String> times = map.get(person);\n                                List<Integer> minutes = new ArrayList<>();\n                                for (String time : times) {\n                                        String[] hourAndMin = time.split(\":\");\n                                        Integer minute = Integer.parseInt(hourAndMin[0]) * 60 + Integer.parseInt(hourAndMin[1]);\n                                        minutes.add(minute);\n                                }\n                                Collections.sort(minutes);\n                                for (int i = 0; i < minutes.size() - 2; i++) {\n                                        if (minutes.get(i + 2) - minutes.get(i) <= 60) {\n                                                people.add(person);\n                                                break;\n                                        }\n                                }\n                        }\n                        Collections.sort(people);\n                        return people;\n                }", "26": "public boolean check(int[] nums) {\n                        int[] copy = Arrays.copyOf(nums, nums.length);\n                        Arrays.sort(copy);\n                        for (int i = 1; i <= nums.length; i++) {\n                                int[] rotated = rotate(nums, i);\n                                if (Arrays.equals(rotated, copy)) {\n                                        return true;\n                                }\n                        }\n                        return false;\n                }\nprivate int[] rotate(int[] nums, int start) {\n                        int[] rotated = new int[nums.length];\n                        int j = 0;\n                        for (int i = start; i < nums.length; i++, j++) {\n                                rotated[j] = nums[i];\n                        }\n                        for (int i = 0; i < start; i++) {\n                                rotated[j++] = nums[i];\n                        }\n                        return rotated;\n                }", "27": "public boolean increasingTriplet(int[] nums) {\n                        if (nums == null nums.length == 0) {\n                                return false;\n                        }\n                        int small = nums[0];\n                        int medium = Integer.MAX_VALUE;\n                        for (int i = 1; i < nums.length; i++) {\n                                small = Math.min(small, nums[i - 1]);\n                                if (nums[i] > small) {\n                                        medium = Math.min(medium, nums[i]);\n                                        for (int j = i + 1; j < nums.length; j++) {\n                                                if (nums[j] > nums[i] nums[j] > medium) {\n                                                        return true;\n                                                }\n                                        }\n                                }\n                        }\n                        return false;\n                }", "28": "public int minDistance(String word1, String word2) {\n                        int m = word1.length();\n                        int n = word2.length();\n                        int[][] dp = new int[m + 1][n + 1];\n                        for (int i = 1; i <= m; i++) {\n                                for (int j = 1; j <= n; j++) {\n                                        dp[i][j] = word1.charAt(i - 1) == word2.charAt(j - 1) ? dp[i - 1][j - 1] + 1 : Math.max(dp[i - 1][j], dp[i][j - 1]);\n                                }\n                        }\n                        return m + n - 2 * dp[m][n];\n                }", "29": "public int minSteps(int n) {\n                        int[] dp = new int[n + 1];\n                        for (int i = 2; i <= n; i++) {\n                                dp[i] = i;\n                                for (int j = i - 1; j > 1; j--) {\n                                        if (i % j == 0) {\n                                                dp[i] = dp[j] + (i / j);\n                                                break;\n                                        }\n                                }\n                        }\n                        return dp[n];\n                }", "30": "public int getImportance(List<Employee> employees, int id) {\n                        Employee manager = employees.stream().filter(e -> e.id == id).collect(Collectors.toList()).get(0);\n                        total += manager.importance;\n                        manager.subordinates.forEach(subId -> getImportance(employees, subId));\n                        return total;\n                }", "31": "public int maximumWealth(int[][] accounts) {\n                        int m = accounts.length;\n                        int n = accounts[0].length;\n                        int max = 0;\n                        for (int i = 0; i < m; i++) {\n                                int sum = 0;\n                                for (int j = 0; j < n; j++) {\n                                        sum += accounts[i][j];\n                                }\n                                max = Math.max(max, sum);\n                        }\n                        return max;\n                }", "32": "public void reorderList(ListNode head) {\n                        if (head == null head.next == null) {\n                                return;\n                        }\n                        ListNode slowNode = head;\n                        ListNode fastNode = head;\n                        while (fastNode.next != null) {\n                                fastNode = fastNode.next;\n                                if (fastNode.next != null) {\n                                        fastNode = fastNode.next;\n                                } else {\n                                        break;\n                                }\n                                slowNode = slowNode.next;\n                        }\n                        ListNode head1 = head;\n                        ListNode head2 = slowNode.next;\n                        slowNode.next = null;\n                        ListNode cur = head2;\n                        ListNode post = cur.next;\n                        cur.next = null;\n                        while (post != null) {\n                                ListNode temp = post.next;\n                                post.next = cur;\n                                cur = post;\n                                post = temp;\n                        }\n                        head2 = cur;\n                        ListNode p = head1;\n                        ListNode q = head2;\n                        while (q != null) {\n                                ListNode temp1 = p.next;\n                                ListNode temp2 = q.next;\n                                p.next = q;\n                                q.next = temp1;\n                                p = temp1;\n                                q = temp2;\n                        }\n                }", "33": "public int minFallingPathSum(int[][] A) {\n                        int size = A.length;\n                        int[][] dp = new int[size][size];\n                        for (int i = 0; i < size; i++) {\n                                for (int j = 0; j < size; j++) {\n                                        if (i == 0) {\n                                                dp[i][j] = A[i][j];\n                                        } else {\n                                                int lastRow = dp[i - 1][j];\n                                                if (j - 1 >= 0) {\n                                                        lastRow = Math.min(dp[i - 1][j - 1], lastRow);\n                                                }\n                                                if (j + 1 < size) {\n                                                        lastRow = Math.min(dp[i - 1][j + 1], lastRow);\n                                                }\n                                                dp[i][j] = lastRow + A[i][j];\n                                        }\n                                }\n                        }\n                        int minSum = Integer.MAX_VALUE;\n                        for (int i = 0; i < size; i++) {\n                                minSum = Math.min(minSum, dp[size - 1][i]);\n                        }\n                        return minSum;\n                }", "34": "public List<Integer> largestDivisibleSubset(int[] nums) {\n                        int len = nums.length;\n                        int[] count = new int[len];\n                        int[] pre = new int[len];\n                        Arrays.sort(nums);\n                        int max = 0;\n                        int index = -1;\n                        for (int i = 0; i < len; i++) {\n                                count[i] = 1;\n                                pre[i] = -1;\n                                for (int j = i - 1; j >= 0; j--) {\n                                        if (nums[i] % nums[j] == 0) {\n                                                if (1 + count[j] > count[i]) {\n                                                        count[i] = count[j] + 1;\n                                                        pre[i] = j;\n                                                }\n                                        }\n                                }\n                                if (count[i] > max) {\n                                        max = count[i];\n                                        index = i;\n                                }\n                        }\n                        List<Integer> res = new ArrayList<>();\n                        while (index != -1) {\n                                res.add(nums[index]);\n                                index = pre[index];\n                        }\n                        return res;\n                }", "35": "public int findTheLongestSubstring(String s) {\n                        int max = 0;\n                        for (int i = 0; i < s.length(); i++) {\n                                Map<Character, Integer> map = setupMap();\n                                if (s.length() - i < max) {\n                                        return max;\n                                }\n                                for (int j = i; j < s.length(); j++) {\n                                        Character b = s.charAt(j);\n                                        if (map.containsKey(b)) {\n                                                map.put(b, map.get(b) + 1);\n                                        }\n                                        if (allEven(map)) {\n                                                max = Math.max(max, j - i + 1);\n                                        }\n                                }\n                        }\n                        return max;\n                }\nprivate Map<Character, Integer> setupMap() {\n                        Map<Character, Integer> map = new HashMap<>();\n                        map.put('a', 0);\n                        map.put('e', 0);\n                        map.put('i', 0);\n                        map.put('o', 0);\n                        map.put('u', 0);\n                        return map;\n                }\nprivate boolean allEven(Map<Character, Integer> map) {\n                        for (char c : map.keySet()) {\n                                if (map.get(c) % 2 != 0) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }", "36": "public int[] findRightInterval(int[][] intervals) {\n                        TreeMap<Integer, Integer> map = new TreeMap<>();\n                        int[] res = new int[intervals.length];\n                        for (int i = 0; i < intervals.length; i++) {\n                                map.put(intervals[i][0], i);\n                        }\n                        for (int i = 0; i < intervals.length; i++) {\n                                Integer key = map.ceilingKey(intervals[i][intervals[i].length - 1]);\n                                res[i] = key != null ? map.get(key) : -1;\n                        }\n                        return res;\n                }", "37": "public int minCut(String s) {\n                int n = s.length();\n                char[] c = s.toCharArray();\n                boolean[][] dp = new boolean[n][n];\n                int[] cut = new int[n];\n                for (int i = 0; i < n; i++) {\n                cut[i] = i;\n                for (int j = 0; j <= i; j++) {\n                        if (c[i] == c[j] && (j + 1 > i - 1 dp[j + 1][i - 1])) {\n                        dp[j][i] = true;\n                        if (j == 0) {\n                                cut[i] = 0;\n                        } else {\n                                cut[i] = (cut[i] < cut[j - 1] + 1) ? cut[i] : cut[j - 1] + 1;\n                        }\n                        }\n                }\n                }\n                return cut[n - 1];\n        }", "38": "public int bulbSwitch(int n) {\n                        if (n < 2) {\n                                return n;\n                        }\n                        return (int) Math.sqrt(n);\n                }", "39": "public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {\n                        List<Boolean> result = new ArrayList<>();\n                        for (int i = 0; i < l.length; i++) {\n                                if (isArithmetic(nums, l[i], r[i])) {\n                                        result.add(true);\n                                } else {\n                                        result.add(false);\n                                }\n                        }\n                        return result;\n                }\nprivate boolean isArithmetic(int[] nums, int start, int end) {\n                        List<Integer> list = new ArrayList<>();\n                        for (int i = start; i <= end; i++) {\n                                list.add(nums[i]);\n                        }\n                        Collections.sort(list);\n                        for (int i = 1; i < list.size(); i++) {\n                                if (list.get(i) - list.get(i - 1) != list.get(1) - list.get(0)) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }", "40": "public double angleClock(int hour, int minutes) {\n                        double minAngle = minutes * 360 / 60;\n                        double hourAnglePart1 = hour != 12 ? (hour * 360) / 12 : 0;\n                        double hourAnglePart2 = (double) (30 * minutes) / (double) 60;\n                        double hourAngle = hourAnglePart1 + hourAnglePart2;\n                        double preResult = Math.abs(minAngle - (hourAngle));\n                        return preResult > 180 ? 360 - preResult : preResult;\n                }", "41": "public int[][] kClosest(int[][] points, int K) {\n                        int[][] ans = new int[K][2];\n                        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> {\n                                double dist1 = getDistance(o1);\n                                double dist2 = getDistance(o2);\n                                if (dist1 > dist2) {\n                                        return 1;\n                                } else if (dist1 < dist2) { return -1; } else { return 0; } });\n                        for (int[] point : points) {\n                                pq.add(point);\n                        }\n                        for (int i = 0; i < K; i++) {\n                                ans[i] = pq.poll();\n                        }\n                        return ans;\n                }\nprivate double getDistance(int[] point) {\n                        return Math.sqrt(Math.pow(point[0], 2) + Math.pow(point[1], 2));\n                }", "42": "public int canCompleteCircuit(int[] gas, int[] cost) {\n        int start = gas.length - 1;\n        int end = 0;\n        int sum = gas[start] - cost[start];\n        while (start > end) {\n                if (sum >= 0) {\n                sum += gas[end] - cost[end];\n                end++;\n                } else {\n                start--;\n                sum += gas[start] - cost[start];\n                }\n        }\n        return sum >= 0 ? start : -1;\n        }", "43": "public List<String> addOperators(String num, int target) {\n                        List<String> res = new ArrayList<>();\n                        StringBuilder sb = new StringBuilder();\n                        dfs(res, sb, num, 0, target, 0, 0);\n                        return res;\n                }\nprivate void dfs(List<String> res, StringBuilder sb, String num, int pos, int target, long prev, long multi) {\n                        if (pos == num.length()) {\n                                if (target == prev) {\n                                        res.add(sb.toString());\n                                }\n                                return;\n                        }\n                        for (int i = pos; i < num.length(); i++) {\n                                if (num.charAt(pos) == '0' && i != pos) {\n                                        break;\n                                }\n                                long curr = Long.parseLong(num.substring(pos, i + 1));\n                                int len = sb.length();\n                                if (pos == 0) {\n                                        dfs(res, sb.append(curr), num, i + 1, target, curr, curr);\n                                        sb.setLength(len);\n                                } else {\n                                        dfs(res, sb.append(\"+\").append(curr), num, i + 1, target, prev + curr, curr);\n                                        sb.setLength(len);\n                                        dfs(res, sb.append(\"-\").append(curr), num, i + 1, target, prev - curr, -curr);\n                                        sb.setLength(len);\n                                        dfs(res, sb.append(\"*\").append(curr), num, i + 1, target, prev - multi + multi * curr, multi * curr);\n                                        sb.setLength(len);\n                                }\n                        }\n                }", "44": "public int countGoodRectangles(int[][] rectangles) {\n                        TreeMap<Integer, Integer> map = new TreeMap<>();\n                        for (int[] rec : rectangles) {\n                                int min = Math.min(rec[0], rec[1]);\n                                map.put(min, map.getOrDefault(min, 0) + 1);\n                        }\n                        return map.lastEntry().getValue();\n                }", "45": "public String largestNumber(int[] num) {\n        if (num.length == 0) {\n                return \"\";\n        }\n        if (num.length == 1) {\n                return Integer.toString(num[0]);\n        }\n        String[] str = new String[num.length];\n        for (int i = 0; i < num.length; i++) {\n                str[i] = Integer.toString(num[i]);\n        }\n        Arrays.sort(str, new StringComparator());\n        StringBuilder sb = new StringBuilder(\"\");\n        for (int i = num.length - 1; i >= 0; i--) {\n                sb.append(str[i]);\n        }\n        if (sb.charAt(0) == '0') {\n                return \"0\";\n        }\n        return sb.toString();\n        }\npublic int compare(String s1, String s2) {\n                if (s1.length() == 0 && s2.length() == 0) {\n                return 0;\n                }\n                if (s2.length() == 0) {\n                return 1;\n                }\n                if (s1.length() == 0) {\n                return -1;\n                }\n                for (int i = 0; i < s1.length() && i < s2.length(); i++) {\n                if (s1.charAt(i) > s2.charAt(i)) {\n                        return 1;\n                } else if (s1.charAt(i) < s2.charAt(i)) {\n                        return -1;\n                }\n                }\n                if (s1.length() == s2.length()) {\n                return 0;\n                }\n                if (s1.length() > s2.length()) {\n                if (s1.charAt(0) < s1.charAt(s2.length())) {\n                        return 1;\n                } else if (s1.charAt(0) > s1.charAt(s2.length())) {\n                        return -1;\n                } else {\n                        return compare(s1.substring(s2.length()), s2);\n                }\n                } else {\n                if (s2.charAt(0) < s2.charAt(s1.length())) {\n                        return -1;\n                } else if (s2.charAt(0) > s2.charAt(s1.length())) {\n                        return 1;\n                } else {\n                        return compare(s1, s2.substring(s1.length()));\n                }\n                }\n        }", "46": "public int twoCitySchedCost(int[][] costs) {\n                        Arrays.sort(costs, (a, b) -> (a[0] - a[1] - (b[0] - b[1])));\n                        int cost = 0;\n                        for (int i = 0; i < costs.length; i++) {\n                                if (i < costs.length / 2) {\n                                        cost += costs[i][0];\n                                } else {\n                                        cost += costs[i][1];\n                                }\n                        }\n                        return cost;\n                }", "47": "public int guessNumber(int n) {\n                        int left = 1;\n                        int right = n;\n                        while (left + 1 < right) {\n                                int mid = left + (right - left) / 2;\n                                int g = guess(mid);\n                                if (g == 0) {\n                                        return mid;\n                                } else if (g > 0) {\n                                        left = mid;\n                                } else {\n                                        right = mid;\n                                }\n                        }\n                        if (guess(left) == 0) {\n                                return left;\n                        }\n                        return right;\n                }\nprivate int guess(int num) {\n                        if (num > 6) {\n                                return -1;\n                        } else if (num < 6) {\n                                return 1;\n                        } else {\n                                return 0;\n                        }\n                }", "48": "public int numSquares(int n) {\n                        int result = n;\n                        int num = 2;\n                        while (num * num <= n) {\n                                int temp1 = n / (num * num);\n                                int temp2 = n % (num * num);\n                                result = Math.min(result, temp1 + numSquares(temp2));\n                                num++;\n                        }\n                        return result;\n                }", "49": "public boolean isAdditiveNumber(String num) {\n                        int n = num.length();\n                        for (int i = 1; i <= n / 2; ++i) {\n                                for (int j = 1; Math.max(j, i) <= n - i - j; ++j) {\n                                        if (isValid(i, j, num)) {\n                                                return true;\n                                        }\n                                }\n                        }\n                        return false;\n                }\nprivate boolean isValid(int i, int j, String num) {\n                        if (num.charAt(0) == '0' && i > 1) {\n                                return false;\n                        }\n                        if (num.charAt(i) == '0' && j > 1) {\n                                return false;\n                        }\n                        String sum;\n                        Long x1 = Long.parseLong(num.substring(0, i));\n                        Long x2 = Long.parseLong(num.substring(i, i + j));\n                        for (int start = i + j; start != num.length(); start += sum.length()) {\n                                x2 = x2 + x1;\n                                x1 = x2 - x1;\n                                sum = x2.toString();\n                                if (!num.startsWith(sum, start)) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }", "50": "public String countAndSay(int n) {\n                        StringBuilder curr = new StringBuilder(\"1\");\n                        StringBuilder prev;\n                        int count;\n                        char say;\n                        for (int i = 1; i < n; i++) {\n                                prev = curr;\n                                curr = new StringBuilder();\n                                count = 1;\n                                say = prev.charAt(0);\n                                for (int j = 1, len = prev.length(); j < len; j++) {\n                                        if (prev.charAt(j) != say) {\n                                                curr.append(count).append(say);\n                                                count = 1;\n                                                say = prev.charAt(j);\n                                        } else {\n                                                count++;\n                                        }\n                                }\n                                curr.append(count).append(say);\n                        }\n                        return curr.toString();\n                }", "51": "public List<TreeNode> generateTrees(int n) {\n                        List<TreeNode> result = new ArrayList();\n                        if (n == 0) {\n                                return result;\n                        }\n                        return generateTrees(1, n);\n                }\nprivate List<TreeNode> generateTrees(int start, int end) {\n                        List<TreeNode> result = new ArrayList();\n                        if (start > end) {\n                                result.add(null);\n                                return result;\n                        }\n                        if (start == end) {\n                                result.add(new TreeNode(start));\n                                return result;\n                        }\n                        for (int i = start; i <= end; i++) {\n                                List<TreeNode> leftList = generateTrees(start, i - 1);\n                                List<TreeNode> rightList = generateTrees(i + 1, end);\n                                for (TreeNode left : leftList) {\n                                        for (TreeNode right : rightList) {\n                                                TreeNode root = new TreeNode(i);\n                                                root.left = left;\n                                                root.right = right;\n                                                result.add(root);\n                                        }\n                                }\n                        }\n                        return result;\n                }", "52": "public String modifyString(String s) {\n                        char[] arr = s.toCharArray();\n                        for (int i = 0; i < arr.length; i++) {\n                                if (arr[i] == '?') {\n                                        for (int j = 0; j < 3; j++) {\n                                                if (i > 0 && arr[i - 1] == 'a' + j) {\n                                                        continue;\n                                                } else if (i < arr.length - 1 && arr[i + 1] == 'a' + j) {\n                                                        continue;\n                                                } else {\n                                                        arr[i] = (char) ('a' + j);\n                                                        break;\n                                                }\n                                        }\n                                }\n                        }\n                        return String.valueOf(arr);\n                }", "53": "public int findBestValue(int[] arr, int target) {\n                        int ave = target / arr.length;\n                        int min = findMin(arr);\n                        int max = findMax(arr);\n                        int closetDiff = findClosestDiffIfReplaceWithVal(arr, ave, target);\n                        int bestValue = ave;\n                        int candidateOnTheRight = ave;\n                        while (candidateOnTheRight <= max) {\n                                int thisOne = findClosestDiffIfReplaceWithVal(arr, ++candidateOnTheRight, target);\n                                if (thisOne >= closetDiff) {\n                                        break;\n                                } else {\n                                        closetDiff = thisOne;\n                                        bestValue = candidateOnTheRight;\n                                }\n                        }\n                        int candidateOnTheLeft = ave;\n                        while (candidateOnTheLeft >= min) {\n                                int thisOne = findClosestDiffIfReplaceWithVal(arr, --candidateOnTheLeft, target);\n                                if (thisOne >= closetDiff) {\n                                        break;\n                                } else {\n                                        closetDiff = thisOne;\n                                        bestValue = candidateOnTheLeft;\n                                }\n                        }\n                        return bestValue;\n                }\nprivate int findClosestDiffIfReplaceWithVal(int[] arr, int replaceValue, int target) {\n                        int sum = 0;\n                        for (int i = 0; i < arr.length; i++) {\n                                if (arr[i] > replaceValue) {\n                                        sum += replaceValue;\n                                } else {\n                                        sum += arr[i];\n                                }\n                        }\n                        return Math.abs(sum - target);\n                }\nprivate int findMax(int[] arr) {\n                        int max = arr[0];\n                        for (int i = 1; i < arr.length; i++) {\n                                max = Math.max(max, arr[i]);\n                        }\n                        return max;\n                }\nprivate int findMin(int[] arr) {\n                        int min = arr[0];\n                        for (int i = 1; i < arr.length; i++) {\n                                min = Math.min(min, arr[i]);\n                        }\n                        return min;\n                }", "54": "public int climbStairs(int n) {\n                        if (n == 1) {\n                                return n;\n                        }\n                        int[] dp = new int[n + 1];\n                        dp[1] = 1;\n                        dp[2] = 2;\n                        for (int i = 3; i <= n; i++) {\n                                dp[i] = dp[i - 1] + dp[i - 2];\n                        }\n                        return dp[n];\n                }", "55": "public int maximumGain(String s, int x, int y) {\n                        Stack<Character> stack1 = new Stack<>();\n                        int big = x > y ? x : y;\n                        int small = big == x ? y : x;\n                        char first = x == big ? 'a' : 'b';\n                        char second = first == 'a' ? 'b' : 'a';\n                        int maximumGain = 0;\n                        for (char c : s.toCharArray()) {\n                                if (c == second && !stack1.isEmpty() && stack1.peek() == first) {\n                                        stack1.pop();\n                                        maximumGain += big;\n                                } else {\n                                        stack1.push(c);\n                                }\n                        }\n                        Stack<Character> stack2 = new Stack<>();\n                        while (!stack1.isEmpty()) {\n                                char c = stack1.pop();\n                                if (c == second && !stack2.isEmpty() && stack2.peek() == first) {\n                                        stack2.pop();\n                                        maximumGain += small;\n                                } else {\n                                        stack2.push(c);\n                                }\n                        }\n                        return maximumGain;\n                }", "56": "public int maximum69Number(int num) {\n                        char[] chars = Integer.toString(num).toCharArray();\n                        IntStream.range(0, chars.length).filter(i -> chars[i] == '6').findFirst().ifPresent(i -> chars[i] = '9');\n                        return Integer.parseInt(new String(chars));\n                }", "57": "public void gameOfLife(int[][] board) {\n                        int height = board.length;\n                        int width = board[0].length;\n                        int[][] next = new int[height][width];\n                        int[][] directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};\n                        for (int i = 0; i < board.length; i++) {\n                                for (int j = 0; j < board[0].length; j++) {\n                                        int liveCellsCount = 0;\n                                        for (int[] dir : directions) {\n                                                int x = i + dir[0];\n                                                int y = j + dir[1];\n                                                if (x >= 0 && y >= 0 && x < height && y < width && board[x][y] == 1) {\n                                                        liveCellsCount++;\n                                                }\n                                        }\n                                        if (board[i][j] == 1) {\n                                                if (liveCellsCount <= 3 && liveCellsCount >= 2) {\n                                                        next[i][j] = 1;\n                                                }\n                                        } else if (board[i][j] == 0) {\n                                                if (liveCellsCount == 3) {\n                                                        next[i][j] = 1;\n                                                }\n                                        }\n                                }\n                        }\n                        for (int i = 0; i < board.length; i++) {\n                                for (int j = 0; j < board[0].length; j++) {\n                                        board[i][j] = next[i][j];\n                                }\n                        }\n                }", "58": "public int[] memLeak(int memory1, int memory2) {\n                        int time = 1;\n                        while (memory1 >= time memory2 >= time) {\n                                if (memory1 >= memory2) {\n                                        memory1 -= time;\n                                } else {\n                                        memory2 -= time;\n                                }\n                                time++;\n                        }\n                        return new int[]{time, memory1, memory2};\n                }", "59": "public int minOperations(String s) {\n                        int ops1 = 0;\n                        boolean isZero = true;\n                        for (int i = 0; i < s.length(); i++) {\n                                if (i % 2 == 0) {\n                                        if (s.charAt(i) != '0') {\n                                                ops1++;\n                                        }\n                                } else {\n                                        if (s.charAt(i) != '1') {\n                                                ops1++;\n                                        }\n                                }\n                        }\n                        int ops2 = 0;\n                        for (int i = 0; i < s.length(); i++) {\n                                if (i % 2 == 0) {\n                                        if (s.charAt(i) != '1') {\n                                                ops2++;\n                                        }\n                                } else {\n                                        if (s.charAt(i) != '0') {\n                                                ops2++;\n                                        }\n                                }\n                        }\n                        return Math.min(ops1, ops2);\n                }", "60": "public int maxProduct(TreeNode root) {\n                        Set<Long> set = new HashSet<>();\n                        int total = dfs(root, set);\n                        long result = 0L;\n                        for (long sum : set) {\n                                result = Math.max(result, sum * (total - sum));\n                        }\n                        return (int) (result % 1000000007);\n                }\nprivate int dfs(TreeNode root, Set<Long> set) {\n                        if (root == null) {\n                                return 0;\n                        }\n                        root.val += dfs(root.left, set);\n                        root.val += dfs(root.right, set);\n                        set.add((long) root.val);\n                        return root.val;\n                }", "61": "public boolean isSubPath(ListNode head, TreeNode root) {\n                        List<Integer> list = getList(head);\n                        findAllPaths(root, new ArrayList<>());\n                        for (List<Integer> path : paths) {\n                                if (path.size() >= list.size()) {\n                                        if (find(list, path)) {\n                                                return true;\n                                        }\n                                }\n                        }\n                        return false;\n                }\nprivate boolean find(List<Integer> list, List<Integer> path) {\n                        int i = 0;\n                        int j = 0;\n                        for (; i <= path.size() - list.size(); i++) {\n                                j = 0;\n                                int tmpI = i;\n                                while (j < list.size() && tmpI < path.size() && list.get(j) == path.get(tmpI)) {\n                                        tmpI++;\n                                        j++;\n                                }\n                                if (j >= list.size()) {\n                                        return true;\n                                }\n                        }\n                        return j >= list.size();\n                }\nprivate void findAllPaths(TreeNode root, List<Integer> path) {\n                        if (root == null) {\n                                return;\n                        }\n                        path.add(root.val);\n                        if (root.left == null && root.right == null) {\n                                paths.add(new ArrayList<>(path));\n                                path.remove(path.size() - 1);\n                                return;\n                        }\n                        findAllPaths(root.left, path);\n                        findAllPaths(root.right, path);\n                        path.remove(path.size() - 1);\n                }\nprivate List<Integer> getList(ListNode head) {\n                        List<Integer> list = new ArrayList<>();\n                        while (head != null) {\n                                list.add(head.val);\n                                head = head.next;\n                        }\n                        return list;\n                }", "62": "public List<String> topKFrequent(String[] words, int k) {\n                        Map<String, Integer> map = new HashMap<>();\n                        for (String word : words) {\n                                map.put(word, map.getOrDefault(word, 0) + 1);\n                        }\n                        SortedSet<Map.Entry<String, Integer>> sortedset = new TreeSet<>(\n                                        (e1, e2) -> {\n                                                if (e1.getValue() != e2.getValue()) {\n                                                        return e2.getValue() - e1.getValue();\n                                                } else {\n                                                        return e1.getKey().compareToIgnoreCase(e2.getKey()); } });\n                        sortedset.addAll(map.entrySet());\n                        List<String> result = new ArrayList<>();\n                        Iterator<Map.Entry<String, Integer>> iterator = sortedset.iterator();\n                        while (iterator.hasNext() && k-- > 0) {\n                                result.add(iterator.next().getKey());\n                        }\n                        return result;\n                }", "63": "public String addBinary(String a, String b) {\n                        int carry = 0;\n                        int i = a.length() - 1;\n                        int j = b.length() - 1;\n                        StringBuilder sb = new StringBuilder();\n                        while (i >= 0 j >= 0) {\n                                int sum = carry;\n                                if (i >= 0) {\n                                        sum += a.charAt(i--) - '0';\n                                }\n                                if (j >= 0) {\n                                        sum += b.charAt(j--) - '0';\n                                }\n                                sb.append(sum % 2);\n                                carry = sum / 2;\n                        }\n                        if (carry != 0) {\n                                sb.append(carry);\n                        }\n                        return sb.reverse().toString();\n                }", "64": "public int kthSmallest(TreeNode root, int k) {\n                        List<Integer> inorder = new ArrayList();\n                        dfs(root, inorder, k);\n                        return inorder.get(k - 1);\n                }\nprivate void dfs(TreeNode root, List<Integer> list, int k) {\n                        if (root == null) {\n                                return;\n                        }\n                        dfs(root.left, list, k);\n                        list.add(root.val);\n                        dfs(root.right, list, k);\n                        if (list.size() >= (k - 1)) {\n                                return;\n                        }\n                }", "65": "public int jump(int[] nums) {\n                        int jumps = 0;\n                        int lastJumpMax = 0;\n                        int currentJumpMax = 0;\n                        for (int i = 0; i < nums.length - 1; i++) {\n                                currentJumpMax = Math.max(currentJumpMax, i + nums[i]);\n                                if (i == lastJumpMax) {\n                                        jumps++;\n                                        lastJumpMax = currentJumpMax;\n                                }\n                                if (lastJumpMax >= nums.length) {\n                                        return jumps;\n                                }\n                        }\n                        return jumps;\n                }", "66": "public int findMaxLength(int[] nums) {\n                        if (nums == null nums.length == 0) {\n                                return 0;\n                        }\n                        int count = 0;\n                        int max = 0;\n                        Map<Integer, Integer> map = new HashMap();\n                        map.put(0, -1);\n                        for (int i = 0; i < nums.length; i++) {\n                                count += nums[i] == 1 ? 1 : -1;\n                                if (map.containsKey(count)) {\n                                        max = Math.max(i - map.get(count), max);\n                                } else {\n                                        map.put(count, i);\n                                }\n                        }\n                        return max;\n                }", "67": "public int maxPoints(int[][] points) {\n                        if (points.length < 3) {\n                                return points.length;\n                        }\n                        int max = 0;\n                        Map<Long, Integer> map = new HashMap<>();\n                        for (int i = 0; i < points.length; i++) {\n                                int dup = 1;\n                                map.clear();\n                                for (int j = i + 1; j < points.length; j++) {\n                                        int dx = points[j][0] - points[i][0];\n                                        int dy = points[j][1] - points[i][1];\n                                        if (dx == 0 && dy == 0) {\n                                                dup++;\n                                        } else {\n                                                int gcd = getGcd(dx, dy);\n                                                long slope = ((long) (dy / gcd) << 32) + (dx / gcd);\n                                                map.put(slope, map.getOrDefault(slope, 0) + 1);\n                                        }\n                                }\n                                max = Math.max(max, dup);\n                                for (Map.Entry<Long, Integer> entry : map.entrySet()) {\n                                        max = Math.max(max, entry.getValue() + dup);\n                                }\n                        }\n                        return max;\n                }\nint getGcd(int a, int b) {\n                        return b == 0 ? a : getGcd(b, a % b);\n                }", "68": "public int minSwapsCouples(int[] row) {\n                        int swaps = 0;\n                        for (int i = 0; i < row.length - 1; i += 2) {\n                                int coupleValue = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n                                if (row[i + 1] != coupleValue) {\n                                        swaps++;\n                                        int coupleIndex = findIndex(row, coupleValue);\n                                        swap(row, coupleIndex, i + 1);\n                                }\n                        }\n                        return swaps;\n                }\nprivate void swap(int[] row, int i, int j) {\n                        int tmp = row[i];\n                        row[i] = row[j];\n                        row[j] = tmp;\n                }\nprivate int findIndex(int[] row, int value) {\n                        for (int i = 0; i < row.length; i++) {\n                                if (row[i] == value) {\n                                        return i;\n                                }\n                        }\n                        return -1;\n                }", "69": "public int[] getStrongest(int[] arr, int k) {\n                        Arrays.sort(arr);\n                        int median = arr.length % 2 != 0 ? arr[arr.length / 2] : arr[arr.length / 2 - 1];\n                        TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>(Collections.reverseOrder());\n                        for (int num : arr) {\n                                int diff = Math.abs(num - median);\n                                if (!treeMap.containsKey(diff)) {\n                                        treeMap.put(diff, new ArrayList<>());\n                                }\n                                treeMap.get(diff).add(num);\n                        }\n                        List<Integer> sorted = new ArrayList<>();\n                        for (int key : treeMap.keySet()) {\n                                List<Integer> sort = treeMap.get(key);\n                                Collections.sort(sort, Collections.reverseOrder());\n                                sorted.addAll(sort);\n                        }\n                        int[] result = new int[k];\n                        for (int i = 0; i < k; i++) {\n                                result[i] = sorted.get(i);\n                        }\n                        return result;\n                }", "70": "public boolean checkSubarraySum(int[] nums, int k) {\n                        Map<Integer, Integer> map = new HashMap<>();\n                        map.put(0, -1);\n                        int sum = 0;\n                        for (int i = 0; i < nums.length; i++) {\n                                sum += nums[i];\n                                if (k != 0) {\n                                        sum %= k;\n                                }\n                                Integer prev = map.get(sum);\n                                if (prev != null) {\n                                        if (i - prev > 1) {\n                                                return true;\n                                        }\n                                } else {\n                                        map.put(sum, i);\n                                }\n                        }\n                        return false;\n                }", "71": "public boolean kLengthApart(int[] nums, int k) {\n                        int lastOneIndex = nums[0] == 1 ? 0 : -1;\n                        for (int i = 1; i < nums.length; i++) {\n                                if (nums[i] == 1) {\n                                        if (i - lastOneIndex <= k) {\n                                                return false;\n                                        } else {\n                                                lastOneIndex = i;\n                                        }\n                                }\n                        }\n                        return true;\n                }", "72": "public String generateTheString(int n) {\n                        StringBuilder sb = new StringBuilder();\n                        if (n > 1 && n % 2 == 0) {\n                                while (n-- > 1) {\n                                        sb.append(\"a\");\n                                }\n                        } else if (n > 1) {\n                                while (n-- > 2) {\n                                        sb.append(\"a\");\n                                }\n                                sb.append(\"b\");\n                        }\n                        sb.append(\"z\");\n                        return sb.toString();\n                }", "73": "public List<Integer> inorderTraversal(TreeNode root) {\n                        return inorder(root, new ArrayList());\n                }\nList<Integer> inorder(TreeNode root, List<Integer> result) {\n                        if (root == null) {\n                                return result;\n                        }\n                        inorder(root.left, result);\n                        result.add(root.val);\n                        return inorder(root.right, result);\n                }", "74": "public int findMin(int[] nums) {\n                        int left = 0;\n                        int right = nums.length - 1;\n                        if (nums[left] < nums[right]) {\n                                return nums[left];\n                        }\n                        int min = nums[0];\n                        while (left + 1 < right) {\n                                int mid = left + (right - left) / 2;\n                                min = Math.min(min, nums[mid]);\n                                if (nums[mid] > nums[left]) {\n                                        min = Math.min(nums[left], min);\n                                        left = mid + 1;\n                                } else if (nums[mid] < nums[left]) {\n                                        right = mid - 1;\n                                } else {\n                                        left++;\n                                }\n                        }\n                        min = Math.min(min, Math.min(nums[left], nums[right]));\n                        return min;\n                }", "75": "public int numDecodings(String s) {\n                        long[] dp = new long[s.length() + 1];\n                        dp[0] = 1;\n                        dp[1] = s.charAt(0) == '*' ? 9 : s.charAt(0) == '0' ? 0 : 1;\n                        for (int i = 1; i < s.length(); i++) {\n                                if (s.charAt(i) == '*') {\n                                        dp[i + 1] = 9 * dp[i];\n                                        if (s.charAt(i - 1) == '1') {\n                                                dp[i + 1] = (dp[i + 1] + 9 * dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '2') {\n                                                dp[i + 1] = (dp[i + 1] + 6 * dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '*') {\n                                                dp[i + 1] = (dp[i + 1] + 15 * dp[i - 1]) % m;\n                                        }\n                                } else {\n                                        dp[i + 1] = s.charAt(i) != '0' ? dp[i] : 0;\n                                        if (s.charAt(i - 1) == '1') {\n                                                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '2' && s.charAt(i) <= '6') {\n                                                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '*') {\n                                                dp[i + 1] = (dp[i + 1] + (s.charAt(i) <= '6' ? 2 : 1) * dp[i - 1]) % m;\n                                        }\n                                }\n                        }\n                        return (int) dp[s.length()];\n                }", "76": "public int reversePairs(int[] nums) {\n                        return mergeSort(nums, 0, nums.length - 1);\n                }\nprivate int mergeSort(int[] nums, int start, int end) {\n                        if (start >= end) {\n                                return 0;\n                        }\n                        int mid = start + (end - start) / 2;\n                        int cnt = mergeSort(nums, start, mid) + mergeSort(nums, mid + 1, end);\n                        for (int i = start, j = mid + 1; i <= mid; i++) {\n                                while (j <= end && nums[i] > nums[j] * 2.0) {\n                                        j++;\n                                }\n                                cnt += j - (mid + 1);\n                        }\n                        Arrays.sort(nums, start, end + 1);\n                        return cnt;\n                }", "77": "public boolean judgeSquareSum(int c) {\n                        if (c < 0) {\n                                return false;\n                        }\n                        int left = 0;\n                        int right = (int) (Math.sqrt(c));\n                        while (left <= right) {\n                                int curr = left * left + right * right;\n                                if (curr > c) {\n                                        right--;\n                                } else if (curr < c) {\n                                        left++;\n                                } else {\n                                        return true;\n                                }\n                        }\n                        return false;\n                }", "78": "public int[] buildArray(int[] nums) {\n                        int[] ans = new int[nums.length];\n                        for (int i = 0; i < nums.length; i++) {\n                                ans[i] = nums[nums[i]];\n                        }\n                        return ans;\n                }", "79": "public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\n                        if (original == null) {\n                                return null;\n                        }\n                        if (original.val == target.val) {\n                                return cloned;\n                        }\n                        TreeNode left = getTargetCopy(original.left, cloned.left, target);\n                        if (left != null && left.val == target.val) {\n                                return left;\n                        }\n                        return getTargetCopy(original.right, cloned.right, target);\n                }", "80": "public int longestSubarray(int[] nums) {\n                        List<int[]> brackets = new ArrayList<>();\n                        for (int i = 0; i < nums.length; i++) {\n                                if (nums[i] == 1) {\n                                        int right = i + 1;\n                                        while (right < nums.length && nums[right] == 1) {\n                                                right++;\n                                        }\n                                        if (right < nums.length && nums[right] == 1) {\n                                                brackets.add(new int[]{i, right});\n                                        } else {\n                                                brackets.add(new int[]{i, right - 1});\n                                        }\n                                        i = right;\n                                }\n                        }\n                        int longest = 0;\n                        for (int[] bracket : brackets) {\n                                if (bracket[1] == nums.length - 1 && bracket[0] == 0) {\n                                        return nums.length - 1;\n                                }\n                                longest = Math.max(bracket[1] - bracket[0] + 1, longest);\n                        }\n                        for (int i = 0; i < brackets.size() - 1; i++) {\n                                int[] first = brackets.get(i);\n                                int[] second = brackets.get(i + 1);\n                                if (first[1] + 2 == second[0]) {\n                                        int connected = (first[1] - first[0] + 1) + (second[1] - second[0] + 1);\n                                        longest = Math.max(longest, connected);\n                                }\n                        }\n                        return longest;\n                }", "81": "public boolean canConstruct(String s, int k) {\n                        if (s.length() < k) {\n                                return false;\n                        }\n                        Map<Character, Integer> map = new HashMap<>();\n                        for (char c : s.toCharArray()) {\n                                map.put(c, map.getOrDefault(c, 0) + 1);\n                        }\n                        int count = 0;\n                        for (char c : map.keySet()) {\n                                if (map.get(c) % 2 == 1) {\n                                        count++;\n                                }\n                        }\n                        return count <= k;\n                }", "82": "public int hammingDistance(int x, int y) {\n                        int n = x ^ y;\n                        int count = 0;\n                        while (n != 0) {\n                                count++;\n                                n &= (n - 1);\n                        }\n                        return count;\n                }", "83": "public String findLongestWord(String s, List<String> d) {\n                        Collections.sort(d, (a, b) -> a.length() == b.length() ? a.compareTo(b) : b.length() - a.length());\n                        for (String dictWord : d) {\n                                int i = 0;\n                                for (char c : s.toCharArray()) {\n                                        if (i < dictWord.length() && dictWord.charAt(i) == c) {\n                                                i++;\n                                        }\n                                }\n                                if (i == dictWord.length()) {\n                                        return dictWord;\n                                }\n                        }\n                        return \"\";\n                }", "84": "public int kInversePairs(int n, int k) {\n                        int mod = 1000000007;\n                        if (k > n * (n - 1) / 2 k < 0) {\n                                return 0;\n                        }\n                        if (k == 0 || k == n * (n - 1) / 2) {\n                                return 1;\n                        }\n                        long[][] dp = new long[n + 1][k + 1];\n                        dp[2][0] = 1;\n                        dp[2][1] = 1;\n                        for (int i = 3; i <= n; i++) {\n                                dp[i][0] = 1;\n                                for (int j = 1; j <= Math.min(k, i * (i - 1) / 2); j++) {\n                                        dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n                                        if (j >= i) {\n                                                dp[i][j] -= dp[i - 1][j - i];\n                                        }\n                                        dp[i][j] = (dp[i][j] + mod) % mod;\n                                }\n                        }\n                        return (int) dp[n][k];\n                }", "85": "public int trap(int[] height) {\n                        if (height == null height.length <= 2) {\n                                return 0;\n                        }\n                        int max = height[0];\n                        int maxIndex = 0;\n                        for (int i = 0; i < height.length; i++) {\n                                if (height[i] > max) {\n                                        max = height[i];\n                                        maxIndex = i;\n                                }\n                        }\n                        int water = 0;\n                        int leftMax = height[0];\n                        for (int i = 0; i < maxIndex; i++) {\n                                if (height[i] > leftMax) {\n                                        leftMax = height[i];\n                                } else {\n                                        water += leftMax - height[i];\n                                }\n                        }\n                        int rightMax = height[height.length - 1];\n                        for (int i = height.length - 1; i > maxIndex; i--) {\n                                if (height[i] > rightMax) {\n                                        rightMax = height[i];\n                                } else {\n                                        water += rightMax - height[i];\n                                }\n                        }\n                        return water;\n                }", "86": "public int findIntegers(int num) {\n                        int[] f = new int[32];\n                        f[0] = 1;\n                        f[1] = 2;\n                        for (int i = 2; i < f.length; i++) {\n                                f[i] = f[i - 1] + f[i - 2];\n                        }\n                        int i = 30;\n                        int sum = 0;\n                        int prevBit = 0;\n                        while (i >= 0) {\n                                if ((num & (1 << i)) != 0) {\n                                        sum += f[i];\n                                        if (prevBit == 1) {\n                                                sum--;\n                                                break;\n                                        }\n                                        prevBit = 1;\n                                } else {\n                                        prevBit = 0;\n                                }\n                                i--;\n                        }\n                        return sum + 1;\n                }", "87": "public int findPairs(int[] nums, int k) {\n                        if (nums == null nums.length == 0 k < 0) {\n                                return 0;\n                        }\n                        Map<Integer, Integer> map = new HashMap();\n                        for (int num : nums) {\n                                map.put(num, map.getOrDefault(num, 0) + 1);\n                        }\n                        int answer = 0;\n                        for (int key : map.keySet()) {\n                                if (k == 0) {\n                                        if (map.get(key) >= 2) {\n                                                answer++;\n                                        }\n                                } else {\n                                        if (map.containsKey(key + k)) {\n                                                answer++;\n                                        }\n                                }\n                        }\n                        return answer;\n                }", "88": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n                        List<List<Integer>> result = new ArrayList();\n                        List<Integer> empty = new ArrayList();\n                        result.add(empty);\n                        if (nums == null) {\n                                return result;\n                        }\n                        Arrays.sort(nums);\n                        for (int i = 0; i < nums.length; i++) {\n                                Set<List<Integer>> temp = new HashSet();\n                                for (List<Integer> list : result) {\n                                        List<Integer> newList = new ArrayList(list);\n                                        newList.add(nums[i]);\n                                        temp.add(newList);\n                                }\n                                result.addAll(temp);\n                        }\n                        Set<List<Integer>> resultSet = new HashSet();\n                        resultSet.addAll(result);\n                        result.clear();\n                        result.addAll(resultSet);\n                        return result;\n                }", "89": "public boolean circularArrayLoop(int[] nums) {\n                        int n = nums.length;\n                        for (int i = 0; i < n; i++) {\n                                if (nums[i] == 0) {\n                                        continue;\n                                }\n                                int j = i;\n                                int k = getIndex(i, nums);\n                                while (nums[k] * nums[i] > 0 && nums[getIndex(k, nums)] * nums[i] > 0) {\n                                        if (j == k) {\n                                                if (j == getIndex(j, nums)) {\n                                                        break;\n                                                }\n                                                return true;\n                                        }\n                                        j = getIndex(j, nums);\n                                        k = getIndex(getIndex(k, nums), nums);\n                                }\n                                j = i;\n                                int val = nums[i];\n                                while (nums[j] * val > 0) {\n                                        int next = getIndex(j, nums);\n                                        nums[j] = 0;\n                                        j = next;\n                                }\n                        }\n                        return false;\n                }\npublic int getIndex(int i, int[] nums) {\n                        int n = nums.length;\n                        return i + nums[i] >= 0 ? (i + nums[i]) % n : n + ((i + nums[i]) % n);\n                }", "90": "public String evaluate(String s, List<List<String>> knowledge) {\n                        Map<String, String> map = new HashMap<>();\n                        for (List<String> know : knowledge) {\n                                map.put(know.get(0), know.get(1));\n                        }\n                        StringBuilder sb = new StringBuilder();\n                        for (int i = 0; i < s.length(); i++) {\n                                if (s.charAt(i) == '(') {\n                                        int start = i;\n                                        while (i < s.length() && s.charAt(i) != ')') {\n                                                i++;\n                                        }\n                                        String key = s.substring(start + 1, i);\n                                        sb.append(map.getOrDefault(key, \"?\"));\n                                } else {\n                                        sb.append(s.charAt(i));\n                                }\n                        }\n                        return sb.toString();\n                }", "91": "public String rankTeams(String[] votes) {\n                        Node[] nodes = new Node[26];\n                        for (int i = 0; i < 26; i++) {\n                                nodes[i] = new Node((char) (i + 'A'));\n                        }\n                        for (String vote : votes) {\n                                for (int i = 0; i < vote.length(); i++) {\n                                        nodes[vote.charAt(i) - 'A'].count[i]++;\n                                }\n                        }\n                        Arrays.sort(nodes, new Comparator<Node>() {\n                                @Override\n                                public int compare(Node o1, Node o2) {\n                                        for (int i = 0; i < 26; i++) {\n                                                if (o1.count[i] != o2.count[i]) { return o2.count[i] - o1.count[i]; } } return o1.c - o2.c; } });\n                        StringBuilder sb = new StringBuilder();\n                        for (int i = 0; i < votes[0].length(); i++) {\n                                sb.append(nodes[i].c);\n                        }\n                        return sb.toString();\n                }\n@Override\n                                public int compare(Node o1, Node o2) {\n                                        for (int i = 0; i < 26; i++) {\n                                                if (o1.count[i] != o2.count[i]) { return o2.count[i] - o1.count[i]; } } return o1.c - o2.c; }", "92": "public int[] decode(int[] encoded, int first) {\n                        int[] arr = new int[encoded.length + 1];\n                        arr[0] = first;\n                        for (int i = 0; i < encoded.length; i++) {\n                                arr[i + 1] = encoded[i] ^ arr[i];\n                        }\n                        return arr;\n                }", "93": "public void connect(TreeLinkNode root) {\n                        TreeLinkNode head = null; \n                        TreeLinkNode prev = null; \n                        TreeLinkNode curr = root; \n                        while (curr != null) {\n                                while (curr != null) { \n                                        if (curr.left != null) {\n                                                if (prev != null) {\n                                                        prev.next = curr.left;\n                                                } else {\n                                                        head = curr.left;\n                                                }\n                                                prev = curr.left;\n                                        }\n                                        if (curr.right != null) {\n                                                if (prev != null) {\n                                                        prev.next = curr.right;\n                                                } else {\n                                                        head = curr.right;\n                                                }\n                                                prev = curr.right;\n                                        }\n                                        curr = curr.next;\n                                }\n                                curr = head;\n                                head = null;\n                                prev = null;\n                        }\n                }", "94": "public int maxProfit(int[] prices, int fee) {\n                        int n = prices.length;\n                        if (n < 2) {\n                                return 0;\n                        }\n                        int[] hold = new int[n];\n                        int[] sell = new int[n];\n                        hold[0] = -prices[0];\n                        for (int i = 1; i < prices.length; i++) {\n                                hold[i] = Math.max(hold[i - 1], sell[i - 1] - prices[i]);\n                                sell[i] = Math.max(sell[i - 1], hold[i - 1] - fee + prices[i]);\n                        }\n                        return sell[n - 1];\n                }", "95": "public int cutOffTree(List<List<Integer>> forest) {\n                        if (forest == null || forest.isEmpty() || forest.size() == 0 || forest.get(0).get(0) == 0) {\n                                return -1;\n                        }\n                        int m = forest.size();\n                        int n = forest.get(0).size();\n                        PriorityQueue<Tree> heap = new PriorityQueue<>((a, b) -> a.height - b.height);\n                        for (int i = 0; i < m; i++) {\n                                for (int j = 0; j < n; j++) {\n                                        if (forest.get(i).get(j) > 1) {\n                                                heap.offer(new Tree(i, j, forest.get(i).get(j)));\n                                        }\n                                }\n                        }\n                        int sum = 0;\n                        Tree start = new Tree();\n                        while (!heap.isEmpty()) {\n                                Tree curr = heap.poll();\n                                int step = bfs(forest, curr, start, m, n);\n                                if (step == -1) {\n                                        return -1;\n                                }\n                                sum += step;\n                                start = curr;\n                        }\n                        return sum;\n                }\nprivate int bfs(List<List<Integer>> forest, Tree target, Tree start, int m, int n) {\n                        int[] dirs = new int[]{0, 1, 0, -1, 0};\n                        boolean[][] visited = new boolean[m][n];\n                        Queue<Tree> queue = new LinkedList<>();\n                        queue.offer(start);\n                        visited[start.x][start.y] = true;\n                        int step = 0;\n                        while (!queue.isEmpty()) {\n                                int size = queue.size();\n                                for (int k = 0; k < size; k++) {\n                                        Tree tree = queue.poll();\n                                        if (tree.x == target.x && tree.y == target.y) {\n                                                return step;\n                                        }\n                                        for (int i = 0; i < 4; i++) {\n                                                int nextX = tree.x + dirs[i];\n                                                int nextY = tree.y + dirs[i + 1];\n                                                if (nextX < 0 || nextY < 0 || nextX >= m || nextY >= n || visited[nextX][nextY] || forest.get(nextX).get(nextY) == 0) {\n                                                        continue;\n                                                }\n                                                queue.offer(new Tree(nextX, nextY, forest.get(nextX).get(nextY)));\n                                                visited[nextX][nextY] = true;\n                                        }\n                                }\n                                step++;\n                        }\n                        return -1;\n                }", "96": "public ListNode reverseList(ListNode head) {\n                        ListNode newHead = null;\n                        while (head != null) {\n                                ListNode next = head.next;\n                                head.next = newHead;\n                                newHead = head;\n                                head = next;\n                        }\n                        return newHead;\n                }", "97": "public int numRescueBoats(int[] people, int limit) {\n                        TreeMap<Integer, Integer> map = new TreeMap<>();\n                        for (int w : people) {\n                                map.put(w, map.getOrDefault(w, 0) + 1);\n                        }\n                        int boats = 0;\n                        List<Integer> uniqWeights = new ArrayList(map.keySet());\n                        int left = 0;\n                        int right = uniqWeights.size() - 1;\n                        while (left < right) {\n                                int heavierWeight = uniqWeights.get(right);\n                                int lighterWeight = uniqWeights.get(left);\n                                if (heavierWeight + lighterWeight <= limit) {\n                                        int pairs = Math.min(map.get(heavierWeight), map.get(lighterWeight));\n                                        boats += pairs;\n                                        if (map.get(heavierWeight) == pairs && map.get(lighterWeight) == pairs) {\n                                                map.remove(heavierWeight);\n                                                map.remove(lighterWeight);\n                                                left++;\n                                                right--;\n                                        } else if (map.get(heavierWeight) == pairs) {\n                                                map.remove(heavierWeight);\n                                                map.put(lighterWeight, map.get(lighterWeight) - pairs);\n                                                right--;\n                                        } else {\n                                                map.remove(lighterWeight);\n                                                map.put(heavierWeight, map.get(heavierWeight) - pairs);\n                                                left++;\n                                        }\n                                } else {\n                                        boats += map.get(heavierWeight);\n                                        map.remove(heavierWeight);\n                                        right--;\n                                }\n                        }\n                        if (!map.isEmpty()) {\n                                int weight = uniqWeights.get(left);\n                                int remainingPeople = map.get(weight);\n                                if (remainingPeople == 1) {\n                                        boats++;\n                                } else {\n                                        if (weight * 2 <= limit) {\n                                                boats += (remainingPeople / 2 + ((remainingPeople % 2 == 0) ? 0 : 1));\n                                        } else {\n                                                boats += remainingPeople;\n                                        }\n                                }\n                        }\n                        return boats;\n                }", "98": "public int lengthOfLastWord(String s) {\n                        if (s == null || s.length() == 0) {\n                                return 0;\n                        }\n                        s = s.trim();\n                        int n = s.length() - 1;\n                        while (n >= 0 && s.charAt(n) != ' ') {\n                                n--;\n                        }\n                        return s.length() - n - 1;\n                }", "99": "public String[] findOcurrences(String text, String first, String second) {\n                        String[] words = text.split(\" \");\n                        return IntStream\n                                        .range(0, words.length - 2)\n                                        .filter(i -> words[i].equals(first) && words[i + 1].equals(second))\n                                        .mapToObj(i -> words[i + 2])\n                                        .collect(Collectors.toList())\n                                        .stream()\n                                        .toArray(String[]::new);\n                }"}, "C++": {"0": "void deleteNode(ListNode* node) {\n                        node->val = node->next->val;\n                        node->next = node->next->next;\n                }", "1": "int countStudents(int[] students, int[] sandwiches) {\n                        queue<int> studentsQueue;\n                        queue<int> sandwichesQueue;\n                        for (int i = 0; i < sandwiches.length; i++) {\n                                studentsQueue.push(students[i]);\n                                sandwichesQueue.push(sandwiches[i]);\n                        }\n                        do {\n                                if (!studentsQueue.empty()) {\n                                        if (studentsQueue.front() == sandwichesQueue.front()) {\n                                                studentsQueue.pop();\n                                                sandwichesQueue.pop();\n                                        } else {\n                                                if (!studentsQueue.contains(sandwichesQueue.front())) {\n                                                        break;\n                                                }\n                                                studentsQueue.push(studentsQueue.front());\n                                                studentsQueue.pop();\n                                        }\n                                }\n                        } while (!studentsQueue.empty());\n                        return studentsQueue.size();\n                }", "2": "std::vector<int> frequencySort(std::vector<int> nums) {\n                        std::map<int, int> count;\n                        for (int num : nums) {\n                                count[num] = count.getOrDefault(num, 0) + 1;\n                        }\n                        std::map<int, std::vector<int>> map;\n                        for (int num : count.keySet()) {\n                                int freq = count.get(num);\n                                if (!map.containsKey(freq)) {\n                                        map[freq] = std::vector<int>();\n                                }\n                                std::vector<int> list = map[freq];\n                                list.push_back(num);\n                                map[freq] = list;\n                        }\n                        std::vector<int> result;\n                        for (int num : map.keySet()) {\n                                std::vector<int> list = map[num];\n                                std::sort(list.rbegin(), list.rend());\n                                int k = num;\n                                for (int j = 0; j < list.size(); j++, k = num) {\n                                        while (k-- > 0) {\n                                                result.push_back(list[j]);\n                                        }\n                                }\n                        }\n                        return result;\n                }", "3": "bool validPalindrome(string s) {\n                        int left = 0;\n                        int right = s.length() - 1;\n                        int diff = 0;\n                        while (left < right) {\n                                if (s.charAt(left) != s.charAt(right)) {\n                                        left++;\n                                        diff++;\n                                        if (diff > 1) {\n                                                break;\n                                        }\n                                } else {\n                                        left++;\n                                        right--;\n                                }\n                        }\n                        if (diff < 2) {\n                                return true;\n                        }\n                        diff = 0;\n                        left = 0;\n                        right = s.length() - 1;\n                        while (left < right) {\n                                if (s.charAt(left) != s.charAt(right)) {\n                                        right--;\n                                        diff++;\n                                        if (diff > 1) {\n                                                break;\n                                        }\n                                } else {\n                                        left++;\n                                        right--;\n                                }\n                        }\n                        return diff < 2;\n                }", "4": "int removePalindromeSub(string s) \n{ \n    if (s.empty()) \n        return 0; \n  \n    if (s == string(s.rbegin(), s.rend())) \n        return 1; \n  \n    return 2; \n}", "5": "int maxDepth(TreeNode root) {\n                        if (root == null) {\n                                return 0;\n                        }\n                        return max(maxDepth(root.left), maxDepth(root.right)) + 1;\n                }", "6": NaN, "7": "int getMaxRepetitions(string s1, int n1, string s2, int n2) {\n                        char[] s1chars = s1.toCharArray();\n                        char[] s2chars = s2.toCharArray();\n                        int i = 0;\n                        int j = 0;\n                        int count1 = 0;\n                        int count2 = 0;\n                        while (count1 < n1) {\n                                if (s1chars[i] == s2chars[j]) {\n                                        j++;\n                                        if (j == s2.length()) {\n                                                j = 0;\n                                                count2++;\n                                        }\n                                }\n                                i++;\n                                if (i == s1.length()) {\n                                        i = 0;\n                                        count1++;\n                                }\n                        }\n                        return count2 / n2;\n                }", "8": "int longestConsecutive(vector<int>& nums) {\n        unordered_map<int, int> map;\n        UnionFind uf(nums);\n        for (int i = 0; i < nums.size(); i++) {\n                if (map.count(nums[i])) {\n                        continue;\n                }\n                map[nums[i]] = i;\n                if (map.count(nums[i] - 1)) {\n                        uf.union(i, map[nums[i] - 1]);\n                }\n                if (map.count(nums[i] + 1)) {\n                        uf.union(i, map[nums[i] + 1]);\n                }\n        }\n        return uf.maxUnion();\n}", "9": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <string>\n \nbool halvesAreAlike(const std::string& s)\n{\n    std::set<char> vowels {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n \n    auto firstHalfVowelsCount = std::count_if(std::begin(s), std::begin(s) + s.size()/2,\n        [&](char c){ return vowels.find(c) != std::end(vowels); });\n \n    auto secondHalfVowelsCount = std::count_if(std::begin(s) + s.size()/2, std::end(s),\n        [&](char c){ return vowels.find(c) != std::end(vowels); });\n \n    return firstHalfVowelsCount == secondHalfVowelsCount;\n}\n \nint main()\n{\n    std::cout << std::boolalpha\n              << halvesAreAlike(\"cecar\") << '\\n'\n              << halvesAreAlike(\"abcdefg\") << '\\n'\n              << halvesAreAlike(\"AeIoU\") << '\\n';\n}", "10": "int integerBreak(int n) {\n        if (n == 2) {\n                return 1;\n        } else if (n == 3) {\n                return 2;\n        } else if (n % 3 == 0) {\n                return (int) pow(3, n / 3);\n        } else if (n % 3 == 1) {\n                return 2 * 2 * (int) pow(3, (n - 4) / 3);\n        } else {\n                return 2 * (int) pow(3, n / 3);\n        }\n}", "11": "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int left = 0;\n        int right = nums.size() - 1;\n        if (nums[left] < nums[right]) {\n                return nums[left];\n        }\n        int min = nums[0];\n        while (left + 1 < right) {\n                int mid = left + (right - left) / 2;\n                min = std::min(min, nums[mid]);\n                if (nums[mid] > nums[left]) {\n                min = std::min(nums[left], min);\n                left = mid + 1;\n                } else if (nums[mid] < nums[left]) {\n                right = mid - 1;\n                }\n        }\n        min = std::min(min, std::min(nums[left], nums[right]));\n        return min;\n        }\n};", "12": "bool isNumber(string s) {\n        s = s.trim();\n        bool pointSeen = false;\n        bool eSeen = false;\n        bool numberSeen = false;\n        bool numberAfterE = true;\n        for (int i = 0; i < s.length(); i++) {\n                if ('0' <= s.charAt(i) && s.charAt(i) <= '9') {\n                        numberSeen = true;\n                        numberAfterE = true;\n                } else if (s.charAt(i) == '.') {\n                        if (eSeen pointSeen) {\n                                return false;\n                        }\n                        pointSeen = true;\n                } else if (s.charAt(i) == 'e') {\n                        if (eSeen !numberSeen) {\n                                return false;\n                        }\n                        numberAfterE = false;\n                        eSeen = true;\n                } else if (s.charAt(i) == '-' || s.charAt(i) == '+') {\n                        if (i != 0 && s.charAt(i - 1) != 'e') {\n                                return false;\n                        }\n                } else {\n                        return false;\n                }\n        }\n        return numberSeen && numberAfterE;\n}", "13": "int findLengthOfLCIS(int[] nums) {\n                        int longest = 0;\n                        for (int i = 0; i < nums.length; i++) {\n                                int len = 1;\n                                for (int j = i + 1; j < nums.length; j++) {\n                                        if (nums[j - 1] < nums[j]) {\n                                                len++;\n                                                continue;\n                                        } else {\n                                                break;\n                                        }\n                                }\n                                longest = std::max(longest, len);\n                        }\n                        return longest;\n                }", "14": "vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> range(2);\n        range[0] = -1;\n        range[1] = -1;\n        if (nums.size() == 0) {\n                return range;\n        }\n        int start = 0;\n        int end = nums.size() - 1;\n        while (start + 1 < end) {\n                int mid = start + (end - start) / 2;\n                if (nums[mid] == target) {\n                        int left = mid;\n                        while (left - 1 >= 0 && nums[left] == nums[left - 1]) {\n                                left--;\n                        }\n                        range[0] = left;\n                        int right = mid;\n                        while (right + 1 < nums.size() && nums[right] == nums[right + 1]) {\n                                right++;\n                        }\n                        range[1] = right;\n                        break;\n                } else if (nums[mid] < target) {\n                        start = mid;\n                } else {\n                        end = mid;\n                }\n        }\n        if (nums[start] == target) {\n                range[0] = start;\n                while (start + 1 < nums.size() && nums[start] == nums[start + 1]) {\n                        start++;\n                }\n                range[1] = start;\n        } else if (nums[end] == target) {\n                range[1] = end;\n                while (end - 1 >= 0 && nums[end] == nums[end - 1]) {\n                        end--;\n                }\n                range[0] = end;\n        }\n        return range;\n}", "15": "bool isEvenOddTree(TreeNode* root) {\n                        queue<TreeNode*> queue;\n                        queue.push(root);\n                        int level = 0;\n                        while (!queue.empty()) {\n                                int size = queue.size();\n                                vector<int> list;\n                                for (int i = 0; i < size; i++) {\n                                        TreeNode* node = queue.front();\n                                        queue.pop();\n                                        list.push_back(node->val);\n                                        if (node->left != NULL) {\n                                                queue.push(node->left);\n                                        }\n                                        if (node->right != NULL) {\n                                                queue.push(node->right);\n                                        }\n                                }\n                                if (level % 2 == 0) {\n                                        for (int i = 0; i < list.size(); i++) {\n                                                if (list[i] % 2 == 0) {\n                                                        return false;\n                                                }\n                                                if (i < list.size() - 1 && list[i] >= list[i + 1]) {\n                                                        return false;\n                                                }\n                                        }\n                                } else {\n                                        for (int i = 0; i < list.size(); i++) {\n                                                if (list[i] % 2 != 0) {\n                                                        return false;\n                                                }\n                                                if (i < list.size() - 1 && list[i] <= list[i + 1]) {\n                                                        return false;\n                                                }\n                                        }\n                                }\n                                level++;\n                        }\n                        return true;\n                }", "16": "int firstBadVersion(int n) {\n                        int left = 1;\n                        int right = n;\n                        while (left < right) {\n                                int mid = left + (right - left) / 2;\n                                if (isBadVersion(mid)) {\n                                        right = mid;\n                                } else {\n                                        left = mid + 1;\n                                }\n                        }\n                        return left;\n                }\nprivate bool isBadVersion(int left) {\n                        return false;\n                }", "17": "bool validUtf8(int* data, int dataSize){\n        int count = 0;\n        for (int i = 0; i < dataSize; i++) {\n                int d = data[i];\n                if (count == 0) {\n                        if ((d >> 5) == 0b110) {\n                                count = 1;\n                        } else if ((d >> 4) == 0b1110) {\n                                count = 2;\n                        } else if ((d >> 3) == 0b11110) {\n                                count = 3;\n                        } else if ((d >> 7) == 1) {\n                                return false;\n                        }\n                } else {\n                        if ((d >> 6) != 0b10) {\n                                return false;\n                        } else {\n                                count--;\n                        }\n                }\n        }\n        return count == 0;\n}", "18": "int closestCost(vector<int> baseCosts, vector<int> toppingCosts, int target) {\n                        result = baseCosts[0];\n                        for (int i = 0; i < baseCosts.size(); i++) {\n                                recursion(baseCosts[i], toppingCosts, 0, target);\n                        }\n                        return result;\n                }\nvoid recursion(int currentCost, vector<int> toppingCosts, int index, int target) {\n                        if (abs(currentCost - target) < abs(result - target) || (abs(currentCost - target) < abs(result - target) && currentCost == result)) {\n                                result = currentCost;\n                        }\n                        if (index == toppingCosts.size() || currentCost == target) {\n                                return;\n                        }\n                        recursion(currentCost, toppingCosts, index + 1, target);\n                        recursion(currentCost + toppingCosts[index], toppingCosts, index + 1, target);\n                        recursion(currentCost + toppingCosts[index] * 2, toppingCosts, index + 1, target);\n                }", "19": "double findMaxAverage(int[] nums, int k) {\n        double sum = 0;\n        double maxAve = Integer.MIN_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n                if (k <= i) {\n                        sum -= nums[i - k];\n                }\n                sum += nums[i];\n                if ((i + 1) >= k) {\n                        maxAve = Math.max(maxAve, sum / k);\n                }\n        }\n        return maxAve;\n}", "20": "int findMaximumXOR(vector<int>& nums) {\n                        int max = 0;\n                        int mask = 0;\n                        for (int i = 31; i >= 0; i--) {\n                                mask |= (1 << i);\n                                cout << \"mask = \" << bitset<32>(mask) << endl;\n                                unordered_set<int> set;\n                                for (int num : nums) {\n                                        cout << \"num = \" << bitset<32>(num) << endl;\n                                        set.insert(num & mask);\n                                        cout << \"mask & num = \" << bitset<32>(mask & num) << endl;\n                                }\n                                int candidate = max | (1 << i);\n                                cout << \"candidate = \" << bitset<32>(candidate) << endl;\n                                for (int prefix : set) {\n                                        cout << \"candidate ^ prefix = \" << bitset<32>(candidate ^ prefix) << endl;\n                                        if (set.count(candidate ^ prefix)) {\n                                                max = candidate;\n                                        }\n                                }\n                                cout << \"max = \" << max << endl;\n                                cout << \"i = \" << i << endl;\n                                cout << \"===============================================\" << endl;\n                        }\n                        return max;\n                }", "21": NaN, "22": "bool compare(int a, int b) \n{ \n    return (a < b); \n} \n  \n\nint main() \n{ \n    int arr[] = {1, 2, 3, 4, 5}; \n    int n = sizeof(arr) / sizeof(arr[0]); \n    int sum = 0; \n    sort(arr, arr + n, compare); \n  \n    for (int i = (int)round(n * 0.05); i < (n - n * 0.05); i++) \n        sum += arr[i]; \n  \n    cout << sum / (n - n * 0.1) << endl; \n  \n    return 0; \n}", "23": "vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\n    int m = A.size();\n    int n = A[0].size();\n    vector<vector<int>> result(m, vector<int>(n));\n    for (int i = 0; i < m; i++) {\n        vector<int> flipped = (reverse(A[i]));\n        result[i] = invert(flipped);\n    }\n    return result;\n}\n\nvector<int> invert(vector<int>& flipped) {\n    vector<int> result(flipped.size());\n    for (int i = 0; i < flipped.size(); i++) {\n        if (flipped[i] == 0) {\n            result[i] = 1;\n        } else {\n            result[i] = 0;\n        }\n    }\n    return result;\n}\n\nvector<int> reverse(vector<int>& nums) {\n    for (int i = 0, j = nums.size() - 1; i < j; i++, j--) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n    return nums;\n}", "24": "bool checkIfExist(vector<int> arr) {\n        for (int i = 0; i < arr.size(); i++) {\n                for (int j = 0; j < arr.size(); j++) {\n                        if (i != j && (arr[i] * 2 == arr[j] arr[i] == arr[j] * 2)) {\n                                return true;\n                        }\n                }\n        }\n        return false;\n}", "25": "std::vector<std::string> alertNames(std::vector<std::string>& keyName, std::vector<std::string>& keyTime) {\n                        std::map<std::string, std::list<std::string>> map;\n                        for (int i = 0; i < keyName.size(); i++) {\n                                if (!map.contains(keyName[i])) {\n                                        map.put(keyName[i], new std::list<std::string>());\n                                }\n                                map.get(keyName[i]).add(keyTime[i]);\n                        }\n                        std::vector<std::string> people;\n                        for (std::string person : map.keySet()) {\n                                std::list<std::string> times = map.get(person);\n                                std::list<int> minutes;\n                                for (std::string time : times) {\n                                        std::string[] hourAndMin = time.split(\":\");\n                                        int minute = Integer.parseInt(hourAndMin[0]) * 60 + Integer.parseInt(hourAndMin[1]);\n                                        minutes.add(minute);\n                                }\n                                Collections.sort(minutes);\n                                for (int i = 0; i < minutes.size() - 2; i++) {\n                                        if (minutes.get(i + 2) - minutes.get(i) <= 60) {\n                                                people.add(person);\n                                                break;\n                                        }\n                                }\n                        }\n                        Collections.sort(people);\n                        return people;\n                }", "26": "bool check(int nums[], int n) {\n\tint copy[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcopy[i] = nums[i];\n\t}\n\tsort(copy, copy + n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint rotated[n];\n\t\tint j = 0;\n\t\tfor (int k = i; k < n; k++, j++) {\n\t\t\trotated[j] = nums[k];\n\t\t}\n\t\tfor (int k = 0; k < i; k++) {\n\t\t\trotated[j++] = nums[k];\n\t\t}\n\t\tif (equal(rotated, copy, n)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "27": "bool increasingTriplet(vector<int>& nums) {\n        if (nums.size() == 0) {\n                return false;\n        }\n        int small = nums[0];\n        int medium = INT_MAX;\n        for (int i = 1; i < nums.size(); i++) {\n                small = min(small, nums[i - 1]);\n                if (nums[i] > small) {\n                        medium = min(medium, nums[i]);\n                        for (int j = i + 1; j < nums.size(); j++) {\n                                if (nums[j] > nums[i] && nums[j] > medium) {\n                                        return true;\n                                }\n                        }\n                }\n        }\n        return false;\n}", "28": "int minDistance(string word1, string word2) {\n                        int m = word1.length();\n                        int n = word2.length();\n                        int[][] dp = new int[m + 1][n + 1];\n                        for (int i = 1; i <= m; i++) {\n                                for (int j = 1; j <= n; j++) {\n                                        dp[i][j] = word1.charAt(i - 1) == word2.charAt(j - 1) ? dp[i - 1][j - 1] + 1 : Math.max(dp[i - 1][j], dp[i][j - 1]);\n                                }\n                        }\n                        return m + n - 2 * dp[m][n];\n                }", "29": "int minSteps(int n) {\n                        int *dp = new int[n + 1];\n                        for (int i = 2; i <= n; i++) {\n                                dp[i] = i;\n                                for (int j = i - 1; j > 1; j--) {\n                                        if (i % j == 0) {\n                                                dp[i] = dp[j] + (i / j);\n                                                break;\n                                        }\n                                }\n                        }\n                        return dp[n];\n                }", "30": "int getImportance(vector<Employee*> employees, int id) {\n        int total = 0;\n        Employee* manager = employees.stream().filter(e -> e.id == id).collect(Collectors.toList()).get(0);\n        total += manager->importance;\n        manager->subordinates.forEach(subId -> getImportance(employees, subId));\n        return total;\n}", "31": "#include <vector>\nusing namespace std;\n\nint maximumWealth(vector<vector<int>>& accounts) {\n                        int m = accounts.size();\n                        int n = accounts[0].size();\n                        int max = 0;\n                        for (int i = 0; i < m; i++) {\n                                int sum = 0;\n                                for (int j = 0; j < n; j++) {\n                                        sum += accounts[i][j];\n                                }\n                                max = max(max, sum);\n                        }\n                        return max;\n                }", "32": "void reorderList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n                return;\n        }\n        ListNode* slowNode = head;\n        ListNode* fastNode = head;\n        while (fastNode->next != nullptr) {\n                fastNode = fastNode->next;\n                if (fastNode->next != nullptr) {\n                        fastNode = fastNode->next;\n                } else {\n                        break;\n                }\n                slowNode = slowNode->next;\n        }\n        ListNode* head1 = head;\n        ListNode* head2 = slowNode->next;\n        slowNode->next = nullptr;\n        ListNode* cur = head2;\n        ListNode* post = cur->next;\n        cur->next = nullptr;\n        while (post != nullptr) {\n                ListNode* temp = post->next;\n                post->next = cur;\n                cur = post;\n                post = temp;\n        }\n        head2 = cur;\n        ListNode* p = head1;\n        ListNode* q = head2;\n        while (q != nullptr) {\n                ListNode* temp1 = p->next;\n                ListNode* temp2 = q->next;\n                p->next = q;\n                q->next = temp1;\n                p = temp1;\n                q = temp2;\n        }\n}", "33": "int minFallingPathSum(vector<vector<int>>& A) {\n        int size = A.size();\n        vector<vector<int>> dp(size, vector<int>(size));\n        for (int i = 0; i < size; i++) {\n                for (int j = 0; j < size; j++) {\n                        if (i == 0) {\n                                dp[i][j] = A[i][j];\n                        } else {\n                                int lastRow = dp[i - 1][j];\n                                if (j - 1 >= 0) {\n                                        lastRow = min(dp[i - 1][j - 1], lastRow);\n                                }\n                                if (j + 1 < size) {\n                                        lastRow = min(dp[i - 1][j + 1], lastRow);\n                                }\n                                dp[i][j] = lastRow + A[i][j];\n                        }\n                }\n        }\n        int minSum = INT_MAX;\n        for (int i = 0; i < size; i++) {\n                minSum = min(minSum, dp[size - 1][i]);\n        }\n        return minSum;\n}", "34": "List<int> largestDivisibleSubset(int[] nums) {\n                        int len = nums.length;\n                        int[] count = new int[len];\n                        int[] pre = new int[len];\n                        Arrays.sort(nums);\n                        int max = 0;\n                        int index = -1;\n                        for (int i = 0; i < len; i++) {\n                                count[i] = 1;\n                                pre[i] = -1;\n                                for (int j = i - 1; j >= 0; j--) {\n                                        if (nums[i] % nums[j] == 0) {\n                                                if (1 + count[j] > count[i]) {\n                                                        count[i] = count[j] + 1;\n                                                        pre[i] = j;\n                                                }\n                                        }\n                                }\n                                if (count[i] > max) {\n                                        max = count[i];\n                                        index = i;\n                                }\n                        }\n                        List<int> res = new List<>();\n                        while (index != -1) {\n                                res.add(nums[index]);\n                                index = pre[index];\n                        }\n                        return res;\n                }", "35": "int findTheLongestSubstring(string s) {\n                        int max = 0;\n                        for (int i = 0; i < s.length(); i++) {\n                                map<Character, Integer> map = setupMap();\n                                if (s.length() - i < max) {\n                                        return max;\n                                }\n                                for (int j = i; j < s.length(); j++) {\n                                        Character b = s.at(j);\n                                        if (map.count(b)) {\n                                                map.at(b) += 1;\n                                        }\n                                        if (allEven(map)) {\n                                                max = max(max, j - i + 1);\n                                        }\n                                }\n                        }\n                        return max;\n                }\nmap<Character, Integer> setupMap() {\n                        map<Character, Integer> map;\n                        map['a'] = 0;\n                        map['e'] = 0;\n                        map['i'] = 0;\n                        map['o'] = 0;\n                        map['u'] = 0;\n                        return map;\n                }\nbool allEven(map<Character, Integer> map) {\n                        for (char c : map.keys()) {\n                                if (map.at(c) % 2 != 0) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }", "36": "vector<int> findRightInterval(vector<vector<int>>& intervals) {\n\tmap<int, int> m;\n\tvector<int> res;\n\tfor (int i = 0; i < intervals.size(); ++i)\n\t\tm[intervals[i][0]] = i;\n\tfor (auto& a : intervals) {\n\t\tauto it = m.lower_bound(a.back());\n\t\tif (it == m.end()) res.push_back(-1);\n\t\telse res.push_back(it->second);\n\t}\n\treturn res;\n}", "37": "int minCut(string &s) {\n        int n = s.length();\n        char *c = new char[n];\n        bool **dp = new bool*[n];\n        int *cut = new int[n];\n        for (int i = 0; i < n; i++) {\n                c[i] = s[i];\n                dp[i] = new bool[n];\n                cut[i] = i;\n                for (int j = 0; j <= i; j++) {\n                        if (c[i] == c[j] && (j + 1 > i - 1 dp[j + 1][i - 1])) {\n                        dp[j][i] = true;\n                        if (j == 0) {\n                                cut[i] = 0;\n                        } else {\n                                cut[i] = (cut[i] < cut[j - 1] + 1) ? cut[i] : cut[j - 1] + 1;\n                        }\n                        }\n                }\n                }\n        return cut[n - 1];\n}", "38": "int bulbSwitch(int n) {\n                        if (n < 2) {\n                                return n;\n                        }\n                        return (int) sqrt(n);\n                }", "39": "vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) {\n        vector<bool> result;\n        for (int i = 0; i < l.size(); i++) {\n                if (isArithmetic(nums, l[i], r[i])) {\n                        result.push_back(true);\n                } else {\n                        result.push_back(false);\n                }\n        }\n        return result;\n}\nbool isArithmetic(vector<int>& nums, int start, int end) {\n        vector<int> list;\n        for (int i = start; i <= end; i++) {\n                list.push_back(nums[i]);\n        }\n        sort(list.begin(), list.end());\n        for (int i = 1; i < list.size(); i++) {\n                if (list.at(i) - list.at(i - 1) != list.at(1) - list.at(0)) {\n                        return false;\n                }\n        }", "40": "double angleClock(int hour, int minutes) {\n                        double minAngle = minutes * 360 / 60;\n                        double hourAnglePart1 = hour != 12 ? (hour * 360) / 12 : 0;\n                        double hourAnglePart2 = (double) (30 * minutes) / (double) 60;\n                        double hourAngle = hourAnglePart1 + hourAnglePart2;\n                        double preResult = std::abs(minAngle - (hourAngle));\n                        return preResult > 180 ? 360 - preResult : preResult;\n                }", "41": "vector<vector<int>> kClosest(vector<vector<int>> points, int K) {\n        vector<vector<int>> ans(K, vector<int>(2, 0));\n        priority_queue<vector<int>, vector<vector<int>>, Compare> pq;\n        for (vector<int> point : points) {\n                pq.push(point);\n        }\n        for (int i = 0; i < K; i++) {\n                ans[i] = pq.top();\n                pq.pop();\n        }\n        return ans;\n}\n\nclass Compare {\npublic:\n        bool operator() (vector<int>& a, vector<int>& b) {\n                return a[0]*a[0] + a[1]*a[1] > b[0]*b[0] + b[1]*b[1];\n        }\n};", "42": "int canCompleteCircuit(int[] gas, int[] cost) {\n        int start = gas.length - 1;\n        int end = 0;\n        int sum = gas[start] - cost[start];\n        while (start > end) {\n                if (sum >= 0) {\n                sum += gas[end] - cost[end];\n                end++;\n                } else {\n                start--;\n                sum += gas[start] - cost[start];\n                }\n        }\n        return sum >= 0 ? start : -1;\n        }", "43": "void addOperators(string& num, int target) {\n        list<string> res;\n        stringBuilder sb;\n        dfs(res, sb, num, 0, target, 0, 0);\n        return res;\n}\nprivate void dfs(list<string>& res, stringBuilder& sb, string& num, int pos, int target, long prev, long multi) {\n        if (pos == num.length()) {\n                if (target == prev) {\n                        res.add(sb.toString());\n                }\n                return;\n        }\n        for (int i = pos; i < num.length(); i++) {\n                if (num.charAt(pos) == '0' && i != pos) {\n                        break;\n                }\n                long curr = Long.parseLong(num.substring(pos, i + 1));\n                int len = sb.length();\n                if (pos == 0) {\n                        dfs(res, sb.append(curr), num, i + 1, target, curr, curr);\n                        sb.setLength(len);\n                } else {\n                        dfs(res, sb.append(\"+\").append(curr), num, i + 1, target, prev + curr, curr);\n                        sb.setLength(len);\n                        dfs(res, sb.append(\"-\").append(curr), num, i + 1, target, prev - curr, -curr);\n                        sb.setLength(len);\n                        dfs(res, sb.append(\"*\").append(curr), num, i + 1, target, prev - multi + multi * curr, multi * curr);\n                        sb.setLength(len);\n                }\n        }\n}", "44": "int countGoodRectangles(int rectangles[][]) \n{ \n    // Create TreeMap \n    TreeMap<Integer, Integer> map = \n                new TreeMap<Integer, Integer>(); \n      \n    for (int rec[] : rectangles) \n    { \n        int min = Math.min(rec[0], rec[1]); \n        map.put(min, map.getOrDefault(min, 0) + 1); \n    } \n  \n    return map.lastEntry().getValue(); \n}", "45": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool cmp(string &s1, string &s2) {\n        return s1 + s2 > s2 + s1;\n}\n\nclass Solution {\npublic:\n    string largestNumber(vector<int>& nums) {\n        string res;\n        vector<string> strs;\n        for (auto n: nums) strs.push_back(to_string(n));\n        sort(strs.begin(), strs.end(), cmp);\n        for (auto s: strs) res += s;\n        return res[0] == '0' ? \"0\" : res;\n    }\n};", "46": "int twoCitySchedCost(vector<vector<int>> costs) {\n                sort(costs.begin(), costs.end(), [](auto& a, auto& b) {\n                        return (a[0] - a[1]) < (b[0] - b[1]);\n                });\n                int cost = 0;\n                for (int i = 0; i < costs.size(); i++) {\n                        if (i < costs.size() / 2) {\n                                cost += costs[i][0];\n                        } else {\n                                cost += costs[i][1];\n                        }\n                }\n                return cost;\n        }", "47": "int guessNumber(int n) {\n                        int left = 1;\n                        int right = n;\n                        while (left + 1 < right) {\n                                int mid = left + (right - left) / 2;\n                                int g = guess(mid);\n                                if (g == 0) {\n                                        return mid;\n                                } else if (g > 0) {\n                                        left = mid;\n                                } else {\n                                        right = mid;\n                                }\n                        }\n                        if (guess(left) == 0) {\n                                return left;\n                        }\n                        return right;\n                }\nint guess(int num) {\n                        if (num > 6) {\n                                return -1;\n                        } else if (num < 6) {\n                                return 1;\n                        } else {\n                                return 0;\n                        }\n                }", "48": "int numSquares(int n) {\n                        int result = n;\n                        int num = 2;\n                        while (num * num <= n) {\n                                int temp1 = n / (num * num);\n                                int temp2 = n % (num * num);\n                                result = min(result, temp1 + numSquares(temp2));\n                                num++;\n                        }\n                        return result;\n                }", "49": "bool isAdditiveNumber(string num) {\n                        int n = num.size();\n                        for (int i = 1; i <= n / 2; ++i) {\n                                for (int j = 1; max(j, i) <= n - i - j; ++j) {\n                                        if (isValid(i, j, num)) {\n                                                return true;\n                                        }\n                                }\n                        }\n                        return false;\n                }\nbool isValid(int i, int j, string num) {\n                        if (num[0] == '0' && i > 1) {\n                                return false;\n                        }\n                        if (num[i] == '0' && j > 1) {\n                                return false;\n                        }\n                        string sum;\n                        long x1 = stol(num.substr(0, i));\n                        long x2 = stol(num.substr(i, j));\n                        for (int start = i + j; start != num.size(); start += sum.size()) {\n                                x2 = x2 + x1;\n                                x1 = x2 - x1;\n                                sum = to_string(x2);\n                                if (!num.starts_with(sum, start)) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }", "50": "string countAndSay(int n) {\n                        string curr = \"1\";\n                        string prev;\n                        int count;\n                        char say;\n                        for (int i = 1; i < n; i++) {\n                                prev = curr;\n                                curr = \"\";\n                                count = 1;\n                                say = prev[0];\n                                for (int j = 1, len = prev.length(); j < len; j++) {\n                                        if (prev[j] != say) {\n                                                curr.append(count).append(say);\n                                                count = 1;\n                                                say = prev[j];\n                                        } else {\n                                                count++;\n                                        }\n                                }\n                                curr.append(count).append(say);\n                        }\n                        return curr;\n                }", "51": "List<TreeNode*> generateTrees(int n) {\n                        List<TreeNode*> result = new List<TreeNode*>();\n                        if (n == 0) {\n                                return result;\n                        }\n                        return generateTrees(1, n);\n                }\nList<TreeNode*> generateTrees(int start, int end) {\n                        List<TreeNode*> result = new List<TreeNode*>();\n                        if (start > end) {\n                                result.add(null);\n                                return result;\n                        }\n                        if (start == end) {\n                                result.add(new TreeNode(start));\n                                return result;\n                        }\n                        for (int i = start; i <= end; i++) {\n                                List<TreeNode*> leftList = generateTrees(start, i - 1);\n                                List<TreeNode*> rightList = generateTrees(i + 1, end);\n                                for (TreeNode* left : leftList) {\n                                        for (TreeNode* right : rightList) {\n                                                TreeNode* root = new TreeNode(i);\n                                                root->left = left;\n                                                root->right = right;\n                                                result.add(root);\n                                        }\n                                }\n                        }\n                        return result;\n                }", "52": "string modifyString(string s) {\n                        char[] arr = s.toCharArray();\n                        for (int i = 0; i < arr.length; i++) {\n                                if (arr[i] == '?') {\n                                        for (int j = 0; j < 3; j++) {\n                                                if (i > 0 && arr[i - 1] == 'a' + j) {\n                                                        continue;\n                                                } else if (i < arr.length - 1 && arr[i + 1] == 'a' + j) {\n                                                        continue;\n                                                } else {\n                                                        arr[i] = (char) ('a' + j);\n                                                        break;\n                                                }\n                                        }\n                                }\n                        }\n                        return String.valueOf(arr);\n                }", "53": "int findBestValue(vector<int> arr, int target) {\n                        int ave = target / arr.length;\n                        int min = findMin(arr);\n                        int max = findMax(arr);\n                        int closetDiff = findClosestDiffIfReplaceWithVal(arr, ave, target);\n                        int bestValue = ave;\n                        int candidateOnTheRight = ave;\n                        while (candidateOnTheRight <= max) {\n                                int thisOne = findClosestDiffIfReplaceWithVal(arr, ++candidateOnTheRight, target);\n                                if (thisOne >= closetDiff) {\n                                        break;\n                                } else {\n                                        closetDiff = thisOne;\n                                        bestValue = candidateOnTheRight;\n                                }\n                        }\n                        int candidateOnTheLeft = ave;\n                        while (candidateOnTheLeft >= min) {\n                                int thisOne = findClosestDiffIfReplaceWithVal(arr, --candidateOnTheLeft, target);\n                                if (thisOne >= closetDiff) {\n                                        break;\n                                } else {\n                                        closetDiff = thisOne;\n                                        bestValue = candidateOnTheLeft;\n                                }\n                        }\n                        return bestValue;\n                }\nint findClosestDiffIfReplaceWithVal(vector<int> arr, int replaceValue, int target) {\n                        int sum = 0;\n                        for (int i = 0; i < arr.length; i++) {\n                                if (arr[i] > replaceValue) {\n                                        sum += replaceValue;\n                                } else {\n                                        sum += arr[i];\n                                }\n                        }\n                        return abs(sum - target);\n                }\nint findMax(vector<int> arr) {\n                        int max = arr[0];\n                        for (int i = 1; i < arr.length; i++) {\n                                max = max(max, arr[i]);\n                        }\n                        return max;\n                }\nint findMin(vector<int> arr) {\n                        int min = arr[0];\n                        for (int i = 1; i < arr.length; i++) {\n                                min = min(min, arr[i]);\n                        }\n                        return min;\n                }", "54": "int climbStairs(int n) { \n    if (n == 1) \n        return 1; \n    int dp[n+1]; \n    dp[1] = 1; \n    dp[2] = 2; \n    for (int i = 3; i<=n; i++) \n        dp[i] = dp[i-1] + dp[i-2]; \n    return dp[n]; \n}", "55": "int maximumGain(string s, int x, int y) {\n\tstack<char> stack1;\n\tint big = x > y ? x : y;\n\tint small = big == x ? y : x;\n\tchar first = x == big ? 'a' : 'b';\n\tchar second = first == 'a' ? 'b' : 'a';\n\tint maximumGain = 0;\n\tfor (char c : s) {\n\t\tif (c == second && !stack1.empty() && stack1.top() == first) {\n\t\t\tstack1.pop();\n\t\t\tmaximumGain += big;\n\t\t}\n\t\telse {\n\t\t\tstack1.push(c);\n\t\t}\n\t}\n\tstack<char> stack2;\n\twhile (!stack1.empty()) {\n\t\tchar c = stack1.top();\n\t\tstack1.pop();\n\t\tif (c == second && !stack2.empty() && stack2.top() == first) {\n\t\t\tstack2.pop();\n\t\t\tmaximumGain += small;\n\t\t}\n\t\telse {\n\t\t\tstack2.push(c);\n\t\t}\n\t}\n\treturn maximumGain;\n}", "56": "int maximum69Number(int num) {\n                        char[] chars = to_string(num).toCharArray();\n                        IntStream.range(0, chars.length).filter(i -> chars[i] == '6').findFirst().ifPresent(i -> chars[i] = '9');\n                        return stoi(new string(chars));\n                }", "57": "void gameOfLife(vector<vector<int>>& board) {\n        int height = board.size();\n        int width = board[0].size();\n        vector<vector<int>> next = new vector<vector<int>>(height, vector<int>(width));\n        vector<vector<int>> directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};\n        for (int i = 0; i < board.size(); i++) {\n                for (int j = 0; j < board[0].size(); j++) {\n                        int liveCellsCount = 0;\n                        for (vector<int> dir : directions) {\n                                int x = i + dir[0];\n                                int y = j + dir[1];\n                                if (x >= 0 && y >= 0 && x < height && y < width && board[x][y] == 1) {\n                                        liveCellsCount++;\n                                }\n                        }\n                        if (board[i][j] == 1) {\n                                if (liveCellsCount <= 3 && liveCellsCount >= 2) {\n                                        next[i][j] = 1;\n                                }\n                        } else if (board[i][j] == 0) {\n                                if (liveCellsCount == 3) {\n                                        next[i][j] = 1;\n                                }\n                        }\n                }\n        }\n        for (int i = 0; i < board.size(); i++) {\n                for (int j = 0; j < board[0].size(); j++) {\n                        board[i][j] = next[i][j];\n                }\n        }\n}", "58": "vector<int> memLeak(int memory1, int memory2) {\n        int time = 1;\n        while (memory1 >= time memory2 >= time) {\n                if (memory1 >= memory2) {\n                        memory1 -= time;\n                } else {\n                        memory2 -= time;\n                }\n                time++;\n        }\n        return {time, memory1, memory2};\n}", "59": "int minOperations(string s) {\n                        int ops1 = 0;\n                        bool isZero = true;\n                        for (int i = 0; i < s.length(); i++) {\n                                if (i % 2 == 0) {\n                                        if (s.at(i) != '0') {\n                                                ops1++;\n                                        }\n                                } else {\n                                        if (s.at(i) != '1') {\n                                                ops1++;\n                                        }\n                                }\n                        }\n                        int ops2 = 0;\n                        for (int i = 0; i < s.length(); i++) {\n                                if (i % 2 == 0) {\n                                        if (s.at(i) != '1') {\n                                                ops2++;\n                                        }\n                                } else {\n                                        if (s.at(i) != '0') {\n                                                ops2++;\n                                        }\n                                }\n                        }\n                        return min(ops1, ops2);\n                }", "60": "int maxProduct(TreeNode* root) {\n                        set<long> set;\n                        int total = dfs(root, set);\n                        long result = 0L;\n                        for (long sum : set) {\n                                result = max(result, sum * (total - sum));\n                        }\n                        return (int) (result % 1000000007);\n                }\nint dfs(TreeNode* root, set<long>& set) {\n                        if (root == null) {\n                                return 0;\n                        }\n                        root->val += dfs(root->left, set);\n                        root->val += dfs(root->right, set);\n                        set.insert((long) root->val);\n                        return root->val;\n                } ", "61": "bool isSubPath(ListNode* head, TreeNode* root) {\n                        vector<int> list = getList(head);\n                        findAllPaths(root, new vector<>());\n                        for (vector<int> path : paths) {\n                                if (path.size() >= list.size()) {\n                                        if (find(list, path)) {\n                                                return true;\n                                        }\n                                }\n                        }\n                        return false;\n                }\nbool find(vector<int> list, vector<int> path) {\n                        int i = 0;\n                        int j = 0;\n                        for (; i <= path.size() - list.size(); i++) {\n                                j = 0;\n                                int tmpI = i;\n                                while (j < list.size() && tmpI < path.size() && list.at(j) == path.at(tmpI)) {\n                                        tmpI++;\n                                        j++;\n                                }\n                                if (j >= list.size()) {\n                                        return true;\n                                }\n                        }\n                        return j >= list.size();\n                }\nvoid findAllPaths(TreeNode* root, vector<int> path) {\n                        if (root == nullptr) {\n                                return;\n                        }\n                        path.push_back(root->val);\n                        if (root->left == nullptr && root->right == nullptr) {\n                                paths.push_back(vector<int>(path));\n                                path.pop_back();\n                                return;\n                        }\n                        findAllPaths(root->left, path);\n                        findAllPaths(root->right, path);\n                        path.pop_back();\n                }\nvector<int> getList(ListNode* head) {\n                        vector<int> list;\n                        while (head != nullptr) {\n                                list.push_back(head->val);\n                                head = head->next;\n                        }\n                        return list;\n                }", "62": "vector<string> topKFrequent(vector<string>& words, int k) {\n        unordered_map<string, int> map;\n        for (string word : words) {\n                map[word]++;\n        }\n        priority_queue<pair<string, int>> pq;\n        for (auto it : map) {\n                pq.push({it.second, it.first});\n        }\n        vector<string> res;\n        while (k--) {\n                res.push_back(pq.top().second);\n                pq.pop();\n        }\n        return res;\n}", "63": "string addBinary(string a, string b) \n{ \n    int carry = 0; \n    int i = a.length() - 1;\n    int j = b.length() - 1;\n    string sb;\n    while (i >= 0 || j >= 0) \n    { \n        int sum = carry; \n        if (i >= 0) \n        { \n            sum += a.at(i--) - '0'; \n        }\n        if (j >= 0) \n        { \n            sum += b.at(j--) - '0'; \n        }\n        sb.append(sum % 2);\n        carry = sum / 2; \n    } \n    if (carry != 0) \n    { \n        sb.append(carry); \n    } \n    return sb.reverse().toString(); \n}", "64": "int kthSmallest(TreeNode root, int k) {\n                        List<Integer> inorder = new ArrayList();\n                        dfs(root, inorder, k);\n                        return inorder.get(k - 1);\n                }\nprivate void dfs(TreeNode root, List<Integer> list, int k) {\n                        if (root == null) {\n                                return;\n                        }\n                        dfs(root.left, list, k);\n                        list.push_back(root.val);\n                        dfs(root.right, list, k);\n                        if (list.size() >= (k - 1)) {\n                                return;\n                        }\n                }", "65": "int jump(vector<int>& nums) {\n        int jumps = 0;\n        int lastJumpMax = 0;\n        int currentJumpMax = 0;\n        for (int i = 0; i < nums.size() - 1; i++) {\n                currentJumpMax = max(currentJumpMax, i + nums[i]);\n                if (i == lastJumpMax) {\n                        jumps++;\n                        lastJumpMax = currentJumpMax;\n                }\n                if (lastJumpMax >= nums.size()) {\n                        return jumps;\n                }\n        }\n        return jumps;\n}", "66": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        if (nums.empty()) {\n            return 0;\n        }\n        int count = 0;\n        int max = 0;\n        unordered_map<int, int> map;\n        map[0] = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            count += nums[i] == 1 ? 1 : -1;\n            if (map.count(count)) {\n                max = std::max(i - map[count], max);\n            } else {\n                map[count] = i;\n            }\n        }\n        return max;\n    }\n};", "67": "int maxPoints(vector<vector<int>>& points) {\n                        if (points.size() < 3) {\n                                return points.size();\n                        }\n                        int max = 0;\n                        map<long, int> map;\n                        for (int i = 0; i < points.size(); i++) {\n                                int dup = 1;\n                                map.clear();\n                                for (int j = i + 1; j < points.size(); j++) {\n                                        int dx = points[j][0] - points[i][0];\n                                        int dy = points[j][1] - points[i][1];\n                                        if (dx == 0 && dy == 0) {\n                                                dup++;\n                                        } else {\n                                                int gcd = getGcd(dx, dy);\n                                                long slope = ((long) (dy / gcd) << 32) + (dx / gcd);\n                                                map[slope]++;\n                                        }\n                                }\n                                max = max(max, dup);\n                                for (pair<long, int> entry : map) {\n                                        max = max(max, entry.second + dup);\n                                }\n                        }\n                        return max;\n                }\nint getGcd(int a, int b) {\n                        return b == 0 ? a : getGcd(b, a % b);\n                }", "68": "int minSwapsCouples(int[] row) {\n                        int swaps = 0;\n                        for (int i = 0; i < row.length - 1; i += 2) {\n                                int coupleValue = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n                                if (row[i + 1] != coupleValue) {\n                                        swaps++;\n                                        int coupleIndex = findIndex(row, coupleValue);\n                                        swap(row, coupleIndex, i + 1);\n                                }\n                        }\n                        return swaps;\n                }\nvoid swap(int[] row, int i, int j) {\n                        int tmp = row[i];\n                        row[i] = row[j];\n                        row[j] = tmp;\n                }\nint findIndex(int[] row, int value) {\n                        for (int i = 0; i < row.length; i++) {\n                                if (row[i] == value) {\n                                        return i;\n                                }\n                        }\n                        return -1;\n                }", "69": "vector<int> getStrongest(vector<int> arr, int k) {\n                        sort(arr.begin(), arr.end());\n                        int median = arr.size() % 2 != 0 ? arr[arr.size() / 2] : arr[arr.size() / 2 - 1];\n                        map<int, vector<int>> treeMap;\n                        for (int num : arr) {\n                                int diff = abs(num - median);\n                                if (treeMap.find(diff) == treeMap.end()) {\n                                        treeMap[diff] = vector<int>();\n                                }\n                                treeMap[diff].push_back(num);\n                        }\n                        vector<int> sorted;\n                        for (auto key : treeMap) {\n                                vector<int> sort = key.second;\n                                sort(sort.rbegin(), sort.rend());\n                                sorted.push_back(sort);\n                        }\n                        int[] result = new int[k];\n                        for (int i = 0; i < k; i++) {\n                                result[i] = sorted[i];\n                        }\n                        return result;\n                }", "70": "bool checkSubarraySum(vector<int> nums, int k) {\n                        unordered_map<int, int> map;\n                        map[0] = -1;\n                        int sum = 0;\n                        for (int i = 0; i < nums.size(); i++) {\n                                sum += nums[i];\n                                if (k != 0) {\n                                        sum %= k;\n                                }\n                                if (map.count(sum)) {\n                                        if (i - map[sum] > 1) {\n                                                return true;\n                                        }\n                                } else {\n                                        map[sum] = i;\n                                }\n                        }\n                        return false;\n                }", "71": "bool kLengthApart(vector<int>& nums, int k) {\n        int lastOneIndex = nums[0] == 1 ? 0 : -1;\n        for (int i = 1; i < nums.size(); i++) {\n                if (nums[i] == 1) {\n                        if (i - lastOneIndex <= k) {\n                                return false;\n                        } else {\n                                lastOneIndex = i;\n                        }\n                }\n        }\n        return true;\n}", "72": "string generateTheString(int n) \n{ \n        stringBuilder sb = new stringBuilder(); \n        if (n > 1 && n % 2 == 0) \n        { \n                while (n-- > 1) \n                { \n                        sb.append(\"a\"); \n                } \n        } \n        else if (n > 1) \n        { \n                while (n-- > 2) \n                { \n                        sb.append(\"a\"); \n                } \n                sb.append(\"b\"); \n        } \n        sb.append(\"z\"); \n        return sb.toString(); \n}", "73": "template <typename T>\nstd::vector<T> inorderTraversal(TreeNode<T>* root) {\n        std::vector<T> result;\n        inorder(root, result);\n        return result;\n}\n\ntemplate <typename T>\nvoid inorder(TreeNode<T>* root, std::vector<T>& result) {\n        if (root == nullptr) {\n                return;\n        }\n        inorder(root->left, result);\n        result.push_back(root->val);\n        inorder(root->right, result);\n}", "74": "int findMin(vector<int>& nums) {\n        int left = 0;\n        int right = nums.size() - 1;\n        if (nums[left] < nums[right]) {\n                return nums[left];\n        }\n        int min = nums[0];\n        while (left + 1 < right) {\n                int mid = left + (right - left) / 2;\n                min = min(min, nums[mid]);\n                if (nums[mid] > nums[left]) {\n                        min = min(nums[left], min);\n                        left = mid + 1;\n                } else if (nums[mid] < nums[left]) {\n                        right = mid - 1;\n                } else {\n                        left++;\n                }\n        }\n        min = min(min, min(nums[left], nums[right]));\n        return min;\n}", "75": "int numDecodings(string s) {\n                        long[] dp = new long[s.length() + 1];\n                        dp[0] = 1;\n                        dp[1] = s.charAt(0) == '*' ? 9 : s.charAt(0) == '0' ? 0 : 1;\n                        for (int i = 1; i < s.length(); i++) {\n                                if (s.charAt(i) == '*') {\n                                        dp[i + 1] = 9 * dp[i];\n                                        if (s.charAt(i - 1) == '1') {\n                                                dp[i + 1] = (dp[i + 1] + 9 * dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '2') {\n                                                dp[i + 1] = (dp[i + 1] + 6 * dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '*') {\n                                                dp[i + 1] = (dp[i + 1] + 15 * dp[i - 1]) % m;\n                                        }\n                                } else {\n                                        dp[i + 1] = s.charAt(i) != '0' ? dp[i] : 0;\n                                        if (s.charAt(i - 1) == '1') {\n                                                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '2' && s.charAt(i) <= '6') {\n                                                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % m;\n                                        } else if (s.charAt(i - 1) == '*') {\n                                                dp[i + 1] = (dp[i + 1] + (s.charAt(i) <= '6' ? 2 : 1) * dp[i - 1]) % m;\n                                        }\n                                }\n                        }\n                        return (int) dp[s.length()];\n                }", "76": "int reversePairs(int[] nums) {\n                        return mergeSort(nums, 0, nums.length - 1);\n                }\nint mergeSort(int[] nums, int start, int end) {\n                        if (start >= end) {\n                                return 0;\n                        }\n                        int mid = start + (end - start) / 2;\n                        int cnt = mergeSort(nums, start, mid) + mergeSort(nums, mid + 1, end);\n                        for (int i = start, j = mid + 1; i <= mid; i++) {\n                                while (j <= end && nums[i] > nums[j] * 2.0) {\n                                        j++;\n                                }\n                                cnt += j - (mid + 1);\n                        }\n                        Arrays.sort(nums, start, end + 1);\n                        return cnt;\n                }", "77": "bool judgeSquareSum(int c) {\n                        if (c < 0) {\n                                return false;\n                        }\n                        int left = 0;\n                        int right = (int) (Math.sqrt(c));\n                        while (left <= right) {\n                                int curr = left * left + right * right;\n                                if (curr > c) {\n                                        right--;\n                                } else if (curr < c) {\n                                        left++;\n                                } else {\n                                        return true;\n                                }\n                        }\n                        return false;\n                }", "78": "vector<int> buildArray(vector<int>& nums) {\n        vector<int> ans;\n        for (int i = 0; i < nums.size(); i++) {\n                ans[i] = nums[nums[i]];\n        }\n        return ans;\n}", "79": "final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\n                        if (original == null) {\n                                return null;\n                        }\n                        if (original.val == target.val) {\n                                return cloned;\n                        }\n                        TreeNode left = getTargetCopy(original.left, cloned.left, target);\n                        if (left != null && left.val == target.val) {\n                                return left;\n                        }\n                        return getTargetCopy(original.right, cloned.right, target);\n                }", "80": "int longestSubarray(std::vector<int> nums) {\n                        std::vector<std::vector<int>> brackets;\n                        for (int i = 0; i < nums.size(); i++) {\n                                if (nums[i] == 1) {\n                                        int right = i + 1;\n                                        while (right < nums.size() && nums[right] == 1) {\n                                                right++;\n                                        }\n                                        if (right < nums.size() && nums[right] == 1) {\n                                                brackets.push_back(std::vector<int>{i, right});\n                                        } else {\n                                                brackets.push_back(std::vector<int>{i, right - 1});\n                                        }\n                                        i = right;\n                                }\n                        }\n                        int longest = 0;\n                        for (std::vector<int> bracket : brackets) {\n                                if (bracket[1] == nums.size() - 1 && bracket[0] == 0) {\n                                        return nums.size() - 1;\n                                }\n                                longest = std::max(bracket[1] - bracket[0] + 1, longest);\n                        }\n                        for (int i = 0; i < brackets.size() - 1; i++) {\n                                std::vector<int> first = brackets.at(i);\n                                std::vector<int> second = brackets.at(i + 1);\n                                if (first[1] + 2 == second[0]) {\n                                        int connected = (first[1] - first[0] + 1) + (second[1] - second[0] + 1);\n                                        longest = std::max(longest, connected);\n                                }\n                        }\n                        return longest;\n                }", "81": "bool canConstruct(string s, int k) {\n                        if (s.length() < k) {\n                                return false;\n                        }\n                        unordered_map<char, int> map;\n                        for (char c : s) {\n                                map[c] = map.getOrDefault(c, 0) + 1;\n                        }\n                        int count = 0;\n                        for (char c : map.keySet()) {\n                                if (map.get(c) % 2 == 1) {\n                                        count++;\n                                }\n                        }\n                        return count <= k;\n                }", "82": "int hammingDistance(int x, int y) {\n                        int n = x ^ y;\n                        int count = 0;\n                        while (n != 0) {\n                                count++;\n                                n &= (n - 1);\n                        }\n                        return count;\n                }", "83": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring findLongestWord(string s, vector<string> d) {\n                        sort(d.begin(), d.end(), [](a, b) { return a.length() == b.length() ? a.compareTo(b) : b.length() - a.length(); });\n                        for (string dictWord : d) {\n                                int i = 0;\n                                for (char c : s.toCharArray()) {\n                                        if (i < dictWord.length() && dictWord.charAt(i) == c) {\n                                                i++;\n                                        }\n                                }\n                                if (i == dictWord.length()) {\n                                        return dictWord;\n                                }\n                        }\n                        return \"\";\n                }", "84": "int kInversePairs(int n, int k) {\n                        int mod = 1000000007;\n                        if (k > n * (n - 1) / 2 k < 0) {\n                                return 0;\n                        }\n                        if (k == 0 || k == n * (n - 1) / 2) {\n                                return 1;\n                        }\n                        long[][] dp = new long[n + 1][k + 1];\n                        dp[2][0] = 1;\n                        dp[2][1] = 1;\n                        for (int i = 3; i <= n; i++) {\n                                dp[i][0] = 1;\n                                for (int j = 1; j <= Math.min(k, i * (i - 1) / 2); j++) {\n                                        dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n                                        if (j >= i) {\n                                                dp[i][j] -= dp[i - 1][j - i];\n                                        }\n                                        dp[i][j] = (dp[i][j] + mod) % mod;\n                                }\n                        }\n                        return (int) dp[n][k];\n                }", "85": "int trap(int[] height) \n{\n        if (height == null height.length <= 2) \n        {\n                return 0;\n        }\n        int max = height[0];\n        int maxIndex = 0;\n        for (int i = 0; i < height.length; i++) \n        {\n                if (height[i] > max) \n                {\n                        max = height[i];\n                        maxIndex = i;\n                }\n        }\n        int water = 0;\n        int leftMax = height[0];\n        for (int i = 0; i < maxIndex; i++) \n        {\n                if (height[i] > leftMax) \n                {\n                        leftMax = height[i];\n                } \n                else \n                {\n                        water += leftMax - height[i];\n                }\n        }\n        int rightMax = height[height.length - 1];\n        for (int i = height.length - 1; i > maxIndex; i--) \n        {\n                if (height[i] > rightMax) \n                {\n                        rightMax = height[i];\n                } \n                else \n                {\n                        water += rightMax - height[i];\n                }\n        }\n        return water;\n}", "86": "int findIntegers(int num) {\n\tint f[32];\n\tf[0] = 1;\n\tf[1] = 2;\n\tfor (int i = 2; i < f.length; i++) {\n\t\tf[i] = f[i - 1] + f[i - 2];\n\t}\n\tint i = 30;\n\tint sum = 0;\n\tint prevBit = 0;\n\twhile (i >= 0) {\n\t\tif ((num & (1 << i)) != 0) {\n\t\t\tsum += f[i];\n\t\t\tif (prevBit == 1) {\n\t\t\t\tsum--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevBit = 1;\n\t\t} else {\n\t\t\tprevBit = 0;\n\t\t}\n\t\ti--;\n\t}\n\treturn sum + 1;\n}", "87": "int findPairs(vector<int>& nums, int k) {\n        if (nums.empty() || nums.size() == 0 || k < 0) {\n                return 0;\n        }\n        unordered_map<int, int> map;\n        for (int num : nums) {\n                map[num] = map.find(num) == map.end() ? 0 : map[num] + 1;\n        }\n        int answer = 0;\n        for (auto key : map) {\n                if (k == 0) {\n                        if (map[key] >= 2) {\n                                answer++;\n                        }\n                } else {\n                        if (map.find(key + k) != map.end()) {\n                                answer++;\n                        }\n                }\n        }\n        return answer;\n}", "88": "vector<vector<int> > subsetsWithDup(vector<int>& nums) {\n        vector<vector<int> > result = new vector<vector<int> >();\n        vector<int> empty = new vector<int>();\n        result.push_back(empty);\n        if (nums == null) {\n                return result;\n        }\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < nums.size(); i++) {\n                set<vector<int> > temp = new set<vector<int> >();\n                for (vector<int> list : result) {\n                        vector<int> newList = new vector<int>(list);\n                        newList.push_back(nums[i]);\n                        temp.insert(newList);\n                }\n                result.insert(result.end(), temp.begin(), temp.end());\n        }\n        set<vector<int> > resultSet = new set<vector<int> >();\n        resultSet.insert(result.begin(), result.end());\n        result.clear();\n        result.insert(result.end(), resultSet.begin(), resultSet.end());\n        return result;\n}", "89": "bool circularArrayLoop(int nums[], int n) \n{ \n    for (int i = 0; i < n; i++) \n    { \n        if (nums[i] == 0) \n            continue; \n        int slow = i, fast = getIndex(i, n); \n        while (nums[fast] * nums[i] > 0 && \n               nums[getIndex(fast, n)] * nums[i] > 0) \n        { \n            if (slow == fast) \n            { \n                if (slow == getIndex(slow, n)) \n                    break; \n                return true; \n            } \n            slow = getIndex(slow, n); \n            fast = getIndex(getIndex(fast, n), n); \n        } \n        slow = i; \n        int val = nums[i]; \n        while (nums[slow] * val > 0) \n        { \n            int next = getIndex(slow, n); \n            nums[slow] = 0; \n            slow = next; \n        } \n    } \n    return false; \n} \nint getIndex(int i, int n) \n{ \n    return (i + nums[i] + n) % n; \n}", "90": "std::string evaluate(std::string s, list<list<std::string>> knowledge){\n                        map<std::string, std::string> map;\n                        for (auto know : knowledge) {\n                                map.insert(pair(know.front(), know.back()));\n                        }\n                        std::stringstream ss;\n                        for (int i = 0; i < s.length(); i++) {\n                                if (s[i] == '(') {\n                                        int start = i;\n                                        while (i < s.length() && s[i] != ')') {\n                                                i++;\n                                        }\n                                        std::string key = s.substr(start + 1, i);\n                                        ss << map.find(key)->second;\n                                } else {\n                                        ss << s[i];\n                                }\n                        }\n                        return ss.str();\n                }", "91": "class Node\n{\npublic:\n  char c;\n  int count[26];\n  Node(char ch)\n  {\n    c = ch;\n    for(int i = 0; i < 26; i++)\n    {\n      count[i] = 0;\n    }\n  }\n}\n\npublic:\n  string rankTeams(vector<string>& votes)\n  {\n    Node* nodes = new Node[26];\n    for(int i = 0; i < 26; i++)\n    {\n      nodes[i] = Node((char)(i + 'A'));\n    }\n    for(string vote : votes)\n    {\n      for(int i = 0; i < vote.length(); i++)\n      {\n        nodes[vote.charAt(i) - 'A'].count[i]++;\n      }\n    }\n    Arrays.sort(nodes, new Comparator<Node>()\n    {\n      @Override\n      public int compare(Node o1, Node o2)\n      {\n        for(int i = 0; i < 26; i++)\n        {\n          if(o1.count[i] != o2.count[i])\n          {\n            return o2.count[i] - o1.count[i];\n          }\n        }\n        return o1.c - o2.c;\n      }\n    });\n    StringBuilder sb = new StringBuilder();\n    for(int i = 0; i < votes[0].length(); i++)\n    {\n      sb.append(nodes[i].c);\n    }\n    return sb.toString();\n  }\n};", "92": "int* decode(int* encoded, int first, int len) {\n                        int* arr = new int[len + 1];\n                        arr[0] = first;\n                        for (int i = 0; i < len; i++) {\n                                arr[i + 1] = encoded[i] ^ arr[i];\n                        }\n                        return arr;\n                }", "93": "void connect(TreeLinkNode *root) {\n                        TreeLinkNode *head = NULL; \n                        TreeLinkNode *prev = NULL; \n                        TreeLinkNode *curr = root; \n                        while (curr != NULL) {\n                                while (curr != NULL) { \n                                        if (curr->left != NULL) {\n                                                if (prev != NULL) {\n                                                        prev->next = curr->left;\n                                                } else {\n                                                        head = curr->left;\n                                                }\n                                                prev = curr->left;\n                                        }\n                                        if (curr->right != NULL) {\n                                                if (prev != NULL) {\n                                                        prev->next = curr->right;\n                                                } else {\n                                                        head = curr->right;\n                                                }\n                                                prev = curr->right;\n                                        }\n                                        curr = curr->next;\n                                }\n                                curr = head;\n                                head = NULL;\n                                prev = NULL;\n                        }\n                }", "94": "int maxProfit(int prices[], int fee) {\n\tint n = prices.length;\n\tif (n < 2) {\n\t\treturn 0;\n\t}\n\tint hold[];\n\tint sell[];\n\thold[0] = -prices[0];\n\tfor (int i = 1; i < prices.length; i++) {\n\t\thold[i] = max(hold[i - 1], sell[i - 1] - prices[i]);\n\t\tsell[i] = max(sell[i - 1], hold[i - 1] - fee + prices[i]);\n\t}\n\treturn sell[n - 1];\n}", "95": "int cutOffTree(vector<vector<int>>& forest) {\n        if (forest == null || forest.empty() ||Forest.size() == 0 || Forest[0][0] == 0) {\n                return -1;\n        }\n        int m = forest.size();\n        int n = Forest[0].size();\n        priority_queue<Tree, vector<Tree>, function<bool(Tree, Tree)>> heap([](Tree a, Tree b) {return a.height - b.height; });\n        for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                        if (forest[i][j] > 1) {\n                                heap.emplace(i, j, forest[i][j]);\n                        }\n                }\n        }\n        int sum = 0;\n        Tree start = new Tree();\n        while (!heap.empty()) {\n                Tree curr = heap.top();\n                heap.pop();\n                int step = bfs(forest, curr, start, m, n);\n                if (step == -1) {\n                        return -1;\n                }\n                sum += step;\n                start = curr;\n        }\n        return sum;\n}\nint bfs(vector<vector<int>>& Forest, Tree target, Tree start, int m, int n) {\n        int[] dirs = new int[]{0, 1, 0, -1, 0};\n        vector<vector<bool>> visited(m, vector<bool> (n, false));\n        queue<Tree> queue;\n        queue.emplace(start);\n        visited[start.x][start.y] = true;\n        int step = 0;\n        while (!queue.empty()) {\n                int size = queue.size();\n                for (int k = 0; k < size; k++) {\n                        Tree tree = queue.front();\n                        queue.pop();\n                        if (tree.x == target.x && tree.y == target.y) {\n                                return step;\n                        }\n                        for (int i = 0; i < 4; i++) {\n                                int nextX = tree.x + dirs[i];\n                                int nextY = tree.y + dirs[i + 1];\n                                if (nextX < 0 || nextY < 0 || nextX >= m || nextY >= n || visited[nextX][nextY] || forest[nextX][nextY] == 0) {\n                                        continue;\n                                }\n                                queue.emplace(nextX, nextY, forest[nextX][nextY]);\n                                visited[nextX][nextY] = true;\n                        }\n                }\n                step++;\n        }\n        return -1;\n}", "96": "ListNode* reverseList(ListNode* head) {\n                        ListNode* newHead = nullptr;\n                        while (head != nullptr) {\n                                ListNode* next = head->next;\n                                head->next = newHead;\n                                newHead = head;\n                                head = next;\n                        }\n                        return newHead;\n                }", "97": "int numRescueBoats(vector<int> people, int limit) {\n                        TreeMap<int, int> map;\n                        for (int w : people) {\n                                map.put(w, map.getOrDefault(w, 0) + 1);\n                        }\n                        int boats = 0;\n                        List<int> uniqWeights = new ArrayList(map.keySet());\n                        int left = 0;\n                        int right = uniqWeights.size() - 1;\n                        while (left < right) {\n                                int heavierWeight = uniqWeights.get(right);\n                                int lighterWeight = uniqWeights.get(left);\n                                if (heavierWeight + lighterWeight <= limit) {\n                                        int pairs = Math.min(map.get(heavierWeight), map.get(lighterWeight));\n                                        boats += pairs;\n                                        if (map.get(heavierWeight) == pairs && map.get(lighterWeight) == pairs) {\n                                                map.erase(heavierWeight);\n                                                map.erase(lighterWeight);\n                                                left++;\n                                                right--;\n                                        } else if (map.get(heavierWeight) == pairs) {\n                                                map.erase(heavierWeight);\n                                                map.put(lighterWeight, map.get(lighterWeight) - pairs);\n                                                right--;\n                                        } else {\n                                                map.erase(lighterWeight);\n                                                map.put(heavierWeight, map.get(heavierWeight) - pairs);\n                                                left++;\n                                        }\n                                } else {\n                                        boats += map.get(heavierWeight);\n                                        map.erase(heavierWeight);\n                                        right--;\n                                }\n                        }\n                        if (!map.empty()) {\n                                int weight = uniqWeights.get(left);\n                                int remainingPeople = map.get(weight);\n                                if (remainingPeople == 1) {\n                                        boats++;\n                                } else {\n                                        if (weight * 2 <= limit) {\n                                                boats += (remainingPeople / 2 + ((remainingPeople % 2 == 0) ? 0 : 1));\n                                        } else {\n                                                boats += remainingPeople;\n                                        }\n                                }\n                        }\n                        return boats;\n                }", "98": "int lengthOfLastWord(string s) {\n                        if (s == null || s.length() == 0) {\n                                return 0;\n                        }\n                        s = s.trim();\n                        int n = s.length() - 1;\n                        while (n >= 0 && s.charAt(n) != ' ') {\n                                n--;\n                        }\n                        return s.length() - n - 1;\n                }", "99": "vector<string> findOcurrences(string text, string first, string second) {\n    stringstream ss(text);\n    string curr;\n    \n    vector<string> words;\n    \n    while (ss >> curr) {\n        words.push_back(curr);\n    }\n    \n    vector<string> res;\n    \n    for (int i = 0; i < words.size() - 2; i++) {\n        if (words[i] == first && words[i + 1] == second) {\n            res.push_back(words[i + 2]);\n        }\n    }\n    \n    return res;\n}"}}, "C++ - Java": {"ID": {"0": 1217, "1": 1457, "2": 1769, "3": 479, "4": 1758, "5": 1904, "6": 910, "7": 212, "8": 491, "9": 1665, "10": 691, "11": 1590, "12": 1103, "13": 904, "14": 923, "15": 191, "16": 554, "17": 1254, "18": 456, "19": 661, "20": 474, "21": 911, "22": 104, "23": 424, "24": 495, "25": 4, "26": 592, "27": 1260, "28": 869, "29": 1400, "30": 1861, "31": 126, "32": 1830, "33": 521, "34": 71, "35": 670, "36": 882, "37": 1647, "38": 896, "39": 274, "40": 390, "41": 1654, "42": 1496, "43": 1909, "44": 1900, "45": 771, "46": 1051, "47": 1727, "48": 1886, "49": 2, "50": 473, "51": 889, "52": 899, "53": 1672, "54": 242, "55": 564, "56": 1315, "57": 430, "58": 1386, "59": 88, "60": 1578, "61": 1482, "62": 1203, "63": 107, "64": 516, "65": 1685, "66": 572, "67": 1143, "68": 609, "69": 1584, "70": 967, "71": 1340, "72": 1318, "73": 268, "74": 1471, "75": 765, "76": 878, "77": 1184, "78": 653, "79": 798, "80": 970, "81": 1822, "82": 1477, "83": 934, "84": 130, "85": 372, "86": 638, "87": 1169, "88": 1092, "89": 1639, "90": 80, "91": 453, "92": 717, "93": 1202, "94": 405, "95": 623, "96": 257, "97": 1443, "98": 1307, "99": 699}, "C++": {"0": "int minCostToMoveChips(vector<int>& chips) {\n                vector<int> count(2);\n                for (const auto& p : chips) {\n                        ++count[p % 2];\n                }\n                return min(count[0], count[1]);\n        }", "1": "int pseudoPalindromicPaths (TreeNode* root) {\n                int result = 0;\n                vector<pair<TreeNode *, int>> stk = {{root, 0}};\n                while (!stk.empty()) {\n                        auto [node, count] = stk.back(); stk.pop_back();\n                        if (!node) {\n                                continue;\n                        }\n                        count ^= 1 << node->val;\n                        result += int(!node->left && !node->right && (count & (count - 1)) == 0);\n                        stk.emplace_back(node->right, count);\n                        stk.emplace_back(node->left, count);\n                }\n                return result;\n        }", "2": "vector<int> minOperations(string boxes) {\n                vector<int> result(size(boxes)); \n                for (int i = 0, accu = 0, cnt = 0; i < size(boxes); ++i) {\n                result[i] += accu;\n                cnt += (boxes[i] == '1') ? 1 : 0;\n                accu += cnt;\n                }\n                for (int i = size(boxes) - 1, accu = 0, cnt = 0; i >= 0; --i) {\n                        result[i] += accu;\n                        cnt += (boxes[i] == '1') ? 1 : 0;\n                        accu += cnt;\n                }\n                return result;\n        }", "3": "int largestPalindrome(int n) {\n                if (n == 1) {\n                        return 9;\n                }\n                const int upper = pow(10, n) - 1;\n                for (int k = 2; k <= upper; ++k) {\n                        const int left = pow(10, n) - k;\n                        auto s = to_string(left);\n                        reverse(begin(s), end(s));\n                        const int right = stoi(s);\n                        const int d = k * k - right * 4;\n                        if (d < 0) {\n                                continue;\n                        }\n                        if (sqrt(d) == int(sqrt(d)) && k % 2 == int(sqrt(d)) % 2) {\n                                return (static_cast<uint64_t>(left * pow(10, n)) + right) % 1337;\n                        }\n                }\n                return -1;\n        }\nlong long buildPalindrome(int n) {\n                string s = to_string(n);\n                reverse(s.begin(), s.end());\n                return stoll(to_string(n) + s);\n        }", "4": "int minOperations(string s) {\n                int cnt = 0;\n                for (int i = 0; i < size(s); ++i) {\n                        if (s[i] - '0' == i % 2) {\n                                ++cnt;\n                        }\n                }\n                return min(cnt, int(size(s)) - cnt);\n        }", "5": "int numberOfRounds(string startTime, string finishTime) {\n                int start = stoi(startTime.substr(0, 2)) * 60 + stoi(startTime.substr(3));\n                int finish = stoi(finishTime.substr(0, 2)) * 60 + stoi(finishTime.substr(3));\n                if (start > finish) {\n                        finish += 1440;\n                }\n                return max(finish / 15 - (start + 15 - 1) / 15, 0);\n        }", "6": "int smallestRangeII(vector<int>& A, int K) {\n                sort(A.begin(), A.end());\n                int result = A.back() - A.front();\n                for (int i = 0; i < A.size() - 1; ++i) {\n                        result = min(result,\n                                                max(A.back() - K, A[i] + K) - \n                                                min(A.front() + K, A[i + 1] - K));\n                }\n                return result;\n        }", "7": "vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n                unordered_set<string> ret;\n                vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));\n                string cur;\n                TrieNode trie;\n                for (const auto& word : words) {\n                        trie.Insert(word);\n                }\n                for (int i = 0; i < board.size(); ++i) {\n                        for (int j = 0; j < board[0].size(); ++j) {\n                                findWordsDFS(board, visited, &trie, i, j, cur, ret);\n                        }\n                }\n                return vector<string>(ret.begin(), ret.end());\n        }\nvoid findWordsDFS(vector<vector<char>> &grid, vector<vector<bool>> &visited, TrieNode *trie, int i, int j, string cur, unordered_set<string> &ret) {\n                if (!trie || i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size()) {\n                        return;\n                }\n                if (!trie->leaves[grid[i][j] ] visited[i][j]) {\n                        return;\n                }\n                TrieNode *nextNode = trie->leaves[grid[i][j]];\n                cur.push_back(grid[i][j]);\n                if (nextNode->isString) {\n                        ret.insert(cur);\n                }\n                visited[i][j] = true;\n                const vector<pair<int, int>> directions{{0, -1}, {0, 1},\n                                                                                                {-1, 0}, {1, 0}};\n                for (const auto& d : directions) {\n                        findWordsDFS(grid, visited, nextNode, i + d.first, j + d.second, cur, ret); } visited[i][j] = false; }\nbool Insert(const string& s) {\n                        auto* p = this;\n                        for (const auto& c : s) {\n                                if (p->leaves.find(c) == p->leaves.cend()) {\n                                        p->leaves[c] = new TrieNode;\n                                }\n                                p = p->leaves[c];\n                        }\n                        if (p->isString) {\n                                return false;\n                        } else {\n                                p->isString = true;\n                                return true;\n                        }\n                }\n~TrieNode() {\n                        for (auto& kv : leaves) {\n                                if (kv.second) {\n                                        delete kv.second;\n                                }\n                        }\n                }", "8": "vector<vector<int>> findSubsequences(vector<int>& nums) {\n                vector<vector<int>> result;\n                vector<int> seq;\n                findSubsequencesHelper(nums, 0, &seq, &result);\n                return result;\n        }\nvoid findSubsequencesHelper(const vector<int>& nums, int i, vector<int> *seq, vector<vector<int>> *result) {\n                if (seq->size() >= 2) {\n                        result->emplace_back(*seq);\n                }\n                unordered_set<int> lookup;\n                for (; i < nums.size(); ++i) {\n                        if ((seq->empty() || nums[i] >= seq->back()) &&\n                                lookup.find(nums[i]) == lookup.end()) {\n                                lookup.emplace(nums[i]);\n                                seq->emplace_back(nums[i]);\n                                findSubsequencesHelper(nums, i + 1, seq, result);\n                                seq->pop_back();\n                        }\n                }\n        }", "9": "int minimumEffort(vector<vector<int>>& tasks) {\n                sort(begin(tasks), end(tasks),\n                        [](const auto& a, const auto& b) { return a[1] - a[0] < b[1] - b[0]; });\n                int result = 0;\n                for (const auto& task : tasks) { \n                        result = max(result + task[0], task[1]);\n                }\n                return result;\n        }", "10": "int minStickers(vector<string>& stickers, string target) {\n                vector<vector<int>> sticker_counts(stickers.size(), vector<int>(26));\n                unordered_map<string, int> dp;\n                for (int i = 0; i < stickers.size(); ++i) {\n                        for (const auto& c : stickers[i]) {\n                                ++sticker_counts[i][c - 'a'];\n                        }\n                }\n                dp[\"\"] = 0;\n                return minStickersHelper(sticker_counts, target, &dp);\n        }\nint minStickersHelper(const vector<vector<int>>& sticker_counts, const string& target, unordered_map<string, int> *dp) {\n                if (dp->count(target)) {\n                        return (*dp)[target];\n                }\n                int result = numeric_limits<int>::max();\n                vector<int> target_count(26);\n                for (const auto& c : target) {\n                        ++target_count[c - 'a'];\n                }\n                for (const auto& sticker_count : sticker_counts) {\n                        if (sticker_count[target[0] - 'a'] == 0) {\n                                continue; \n                        }\n                        string new_target;\n                        for (int i = 0; i < target_count.size(); ++i) {\n                                if (target_count[i] - sticker_count[i] > 0) {\n                                        new_target += string(target_count[i] - sticker_count[i], 'a' + i);\n                                }\n                        }\n                        if (new_target.length() != target.length()) {\n                                int num = minStickersHelper(sticker_counts, new_target, dp);\n                                if (num != -1) {\n                                        result = min(result, 1 + num);\n                                }\n                        }\n                }\n                (*dp)[target] = (result == numeric_limits<int>::max()) ? -1 : result;\n                return (*dp)[target];\n        }", "11": "int minSubarray(vector<int>& nums, int p) {\n                int residue = 0;\n                for (const auto& num : nums) {\n                        residue = (residue + num) % p;\n                }\n                if (!residue) {\n                        return 0;\n                }\n                int result = size(nums);\n                unordered_map<int, int> lookup = {{0, -1}};\n                for (int i = 0, curr = 0; i < size(nums); ++i) {\n                        curr = (curr + nums[i]) % p;\n                        lookup[curr] = i;\n                        if (lookup.count((curr - residue + p) % p)) {\n                                result = min(result, i - lookup[(curr - residue + p) % p]);\n                        }\n                }\n                return result < size(nums) ? result : -1;\n        }", "12": "vector<int> distributeCandies(int candies, int num_people) {\n                int p = int(sqrt(2 * candies + 0.25) - 0.5);\n                int remaining = candies - (p + 1) * p / 2;\n                int rows = p / num_people, cols = p % num_people;\n                vector<int> result(num_people);\n                for (int i = 0; i < num_people; ++i) {\n                        result[i] = (i < cols) ? (i + 1) * (rows + 1) + (rows * (rows + 1) / 2) * num_people\n                                                                : (i + 1) * rows + ((rows - 1) * rows / 2) * num_people;\n                }\n                result[cols] += remaining;\n                return result;\n        }", "13": "int totalFruit(vector<int>& tree) {\n                unordered_map<int, int> count;\n                int result = 0;\n                for (int i = 0, j = 0; j < tree.size(); ++j) {\n                        ++count[tree[j]];\n                        while (count.size() > 2) {\n                                --count[tree[i]];\n                                if (count[tree[i]] == 0) {\n                                        count.erase(tree[i]);\n                                }\n                                ++i;\n                        }\n                        result = max(result, j - i + 1);\n                }\n                return result;\n        }", "14": "int threeSumMulti(vector<int>& A, int target) {\n                unordered_map<int, uint64_t> count;\n                for (const auto& a : A) {\n                        ++count[a];\n                }\n                uint64_t result = 0;\n                for (const auto& kvp1 : count) {\n                        for (const auto& kvp2 : count) {\n                                int i = kvp1.first, j = kvp2.first, k = target - i - j;\n                                if (!count.count(k)) {\n                                        continue;\n                                }\n                                if (i == j && j == k) {\n                                        result += count[i] * (count[i] - 1) * (count[i] - 2) / 6;\n                                } else if (i == j && j != k) {\n                                        result += count[i] * (count[i] - 1) / 2 * count[k];\n                                } else if (i < j && j < k) {\n                                        result += count[i] * count[j] * count[k];\n                                }\n                        }\n                }\n                return result % static_cast<int>(1e9 + 7);\n        }", "15": "int hammingWeight(uint32_t n) {\n                n = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n                n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n                n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F);\n                n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF);\n                n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF);\n                return n;\n        }", "16": "int leastBricks(vector<vector<int>>& wall) {\n                unordered_map<int, int> widths;\n                auto result = wall.size();\n                for (const auto& row : wall) {\n                        for (auto i = 0, width = 0; i < row.size() - 1; ++i) {\n                                result = min(result, wall.size() - (++widths[width += row[i]]));\n                        }\n                }\n                return result;\n        }", "17": "int closedIsland(vector<vector<int>>& grid) {\n                for (int j = 0; j < grid[0].size(); ++j) {\n                        fill(&grid, 0, j);\n                        fill(&grid, grid.size() - 1, j);\n                }\n                for (int i = 1; i + 1 < grid.size(); ++i) {\n                        fill(&grid, i, 0);\n                        fill(&grid, i, grid[0].size() - 1);\n                }\n                int result = 0;\n                for (int i = 1; i + 1 < grid.size(); ++i) {\n                        for (int j = 1; j + 1 < grid[0].size(); ++j) {\n                                if (fill(&grid, i, j)) {\n                                        ++result;\n                                }\n                        }\n                }\n                return result;\n        }\nbool fill(vector<vector<int>> *grid, int i, int j) {\n                static vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n                if (i < 0 || j < 0 ||\n                        i >= grid->size() || j >= (*grid)[i].size() ||\n                        (*grid)[i][j]) {\n                        return false;\n                }\n                (*grid)[i][j] = 1;\n                for (const auto& [dx, dy] : directions) {\n                        fill(grid, i + dx, j + dy);\n                }\n                return true;\n        }", "18": "bool find132pattern(vector<int>& nums) {\n                int ak = numeric_limits<int>::min();\n                stack<int> st;\n                for (int i = nums.size() - 1; i >= 0; --i) {\n                        if (nums[i] < ak) {\n                                return true;\n                        } else {\n                                while (!st.empty() && nums[i] > st.top()) {\n                                        ak = st.top(), st.pop(); \n                                }\n                        }\n                        st.emplace(nums[i]);\n                }\n                return false;\n        }", "19": "vector<vector<int>> imageSmoother(vector<vector<int>>& M) {\n                const auto& m = M.size(), &n = M[0].size();\n                vector<vector<int>> result(M);\n                for (int i = 0; i < m; ++i) {\n                        for (int j = 0; j < n; ++j) {\n                                result[i][j] = getGray(M, i, j);\n                        }\n                }\n                return result;\n        }\nint getGray(const vector<vector<int>>& M, int i, int j) {\n                const auto& m = M.size(), &n = M[0].size();\n                double total = 0.0;\n                int count = 0;\n                for (int r = -1; r < 2; ++r) {\n                        for (int c = -1; c < 2; ++c) {\n                                const auto& ii = i + r;\n                                const auto& jj = j + c;\n                                if (0 <= ii && ii < m && 0 <= jj && jj < n) {\n                                        total += M[ii][jj];\n                                        ++count;\n                                }\n                        }\n                }\n                return static_cast<int>(total / count);\n        }", "20": "int findMaxForm(vector<string>& strs, int m, int n) {\n                vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n                for (const auto &str : strs) {\n                        int zero_count = 0, one_count = 0;\n                        for (const auto& c : str) {\n                                if (c == '0') {\n                                        ++zero_count;\n                                } else if (c == '1') {\n                                        ++one_count;\n                                }\n                        }\n                        for (int i = m; i - zero_count >= 0; --i) {\n                                for (int j = n; j - one_count >= 0; --j) {\n                                        dp[i][j] = max(dp[i][j], dp[i - zero_count][j - one_count] + 1);\n                                }\n                        }\n                }\n                return dp[m][n];\n        }", "21": "TopVotedCandidate(vector<int> persons, vector<int> times) {\n                int lead = -1;\n                unordered_map<int, int> count;\n                for (int i = 0; i < persons.size(); ++i) {\n                        if (++count[persons[i]] >= count[lead]) {\n                                lead = persons[i];\n                                lookup_.emplace_back(times[i], persons[i]);\n                        }\n                }\n        }\nint q(int t) {\n                return prev(upper_bound(lookup_.cbegin(), lookup_.cend(),\n                                                                make_pair(t, numeric_limits<int>::max())))->second;\n        }", "22": "int maxDepth(TreeNode* root) {\n                if (!root) {\n                        return 0;\n                }\n                return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n        }", "23": "int characterReplacement(string s, int k) {\n                int result = 0, max_count = 0;\n                unordered_map<char, int> count;\n                for (int i = 0; i < s.length(); ++i) {\n                        ++count[s[i]];\n                        max_count = max(max_count, count[s[i]]);\n                        if (result - max_count >= k) {\n                                --count[s[i-result]];\n                        } else {\n                                ++result;\n                        }\n                }\n                return result;\n        }", "24": "int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n                int result = duration * timeSeries.size();\n                for (int i = 1; i < timeSeries.size(); ++i){\n                        result -= max(0, duration - (timeSeries[i] - timeSeries[i - 1]));\n                }\n                return result;\n        }", "25": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n                if ((nums1.size() + nums2.size()) % 2 == 1) {\n                        return findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2 + 1);\n                } else {\n                        return (findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2) +\n                                        findKthInTwoSortedArrays(nums1, nums2, (nums1.size() + nums2.size()) / 2 + 1)) / 2.0;\n                }\n        }\nint findKthInTwoSortedArrays(const vector<int>& A, const vector<int>& B, int k) {\n                const int m = A.size();\n                const int n = B.size();\n                if (m > n) {\n                        return findKthInTwoSortedArrays(B, A, k);\n                }\n                int left = 0;\n                int right = m - 1;\n                while (left <= right) {\n                        int mid = left + (right - left) / 2;\n                        if (0 <= k - 1 - mid && k - 1 - mid < n && A[mid] >= B[k - 1 - mid]) {\n                                right = mid - 1;\n                        } else {\n                                left = mid + 1;\n                        }\n                }\n                int Ai_minus_1 = left - 1 >= 0 ? A[left - 1] : numeric_limits<int>::min();\n                int Bj = k - 1 - left >= 0 ? B[k - 1 - left] : numeric_limits<int>::min();\n                return max(Ai_minus_1, Bj);\n        }", "26": "string fractionAddition(string expression) {\n                istringstream iss(expression);\n                int A = 0, B = 1, a, b;\n                char _;\n                while (iss >> a >> _ >> b) {\n                        A = A * b + a * B;\n                        B *= b;\n                        auto g = abs(__gcd(A, B));\n                        A /= g;\n                        B /= g;\n                }\n                return to_string(A) + '/' + to_string(B);\n        }", "27": "vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\n                rotate(&grid, k);\n                return grid;\n        }\nvoid rotate(vector<vector<int>> *grid, int k) {\n                k %= grid->size() * (*grid)[0].size();\n                reverse(grid, 0, grid->size() * (*grid)[0].size());\n                reverse(grid, 0, k);\n                reverse(grid, k, grid->size() * (*grid)[0].size());\n        }\nvoid reverse(vector<vector<int>> *grid, int start, int end) {\n                for (; start < end; ++start, --end) {\n                        int start_r = start / (*grid)[0].size();\n                        int start_c = start % (*grid)[0].size();\n                        int end_r = (end - 1) / (*grid)[0].size();\n                        int end_c = (end - 1) % (*grid)[0].size();\n                        swap((*grid)[start_r][start_c], (*grid)[end_r][end_c]);\n                }\n        }", "28": "bool reorderedPowerOf2(int N) {\n                vector<int> count = counter(N);\n                for (int i = 0; i < 31; ++i) {\n                        if (count == counter(1 << i)) {\n                                return true;\n                        }\n                }\n                return false;\n        }\nvector<int> counter(int N) {\n                vector<int> result(10, 0);\n                for (; N; N /= 10) {\n                        ++result[N % 10];\n                }\n                return result;\n        }", "29": "bool canConstruct(string s, int k) {\n                bitset<26> odd;\n                for (const auto& c : s) {\n                        odd.flip(c - 'a');\n                }\n                return odd.count() <= k && k <= s.length();\n        }", "30": "vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {\n                vector<vector<char>> result(size(box[0]), vector<char>(size(box), '.'));\n                for (int i = 0; i < size(box); ++i) {\n                        for (int j = size(box[0]) - 1, k = size(box[0]) - 1; j >= 0; --j) {\n                                if (box[i][j] == '.') {\n                                        continue;\n                                }\n                                if (box[i][j] == '*') {\n                                        k = j;\n                                }\n                                result[k--][size(box) -1 - i] = box[i][j];\n                        }\n                }\n                return result;\n        }", "31": "vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n                unordered_set<string> words(cbegin(wordList), cend(wordList));\n                if (!words.count(endWord)) {\n                        return {};\n                }\n                unordered_map<string, unordered_set<string>> tree;\n                unordered_set<string> left = {beginWord}, right = {endWord};\n                bool is_found = false, is_reversed = false;\n                while (!empty(left)) {\n                        for (const auto& word : left) {\n                                words.erase(word);\n                        }\n                        unordered_set<string> new_left;\n                        for (const auto& word : left) {\n                                auto new_word = word;\n                                for (int i = 0; i < size(new_word); ++i) {\n                                        char prev = new_word[i];\n                                        for (int j = 0; j < 26; ++j) {\n                                                new_word[i] = 'a' + j;\n                                                if (!words.count(new_word)) {\n                                                        continue;\n                                                }\n                                                if (right.count(new_word)) {\n                                                        is_found = true;\n                                                } else {\n                                                        new_left.emplace(new_word);\n                                                }\n                                                if (!is_reversed) {\n                                                        tree[new_word].emplace(word);\n                                                } else {\n                                                        tree[word].emplace(new_word);\n                                                }\n                                        }\n                                        new_word[i] = prev;\n                                }\n                        }\n                        if (is_found) {\n                                break;\n                        }\n                        left = move(new_left);\n                        if (size(left) > size(right)) {\n                                swap(left, right);\n                                is_reversed = !is_reversed;\n                        }\n                }\n                return backtracking(tree, beginWord, endWord);\n        }\nvector<vector<string>> backtracking( const unordered_map<string, unordered_set<string>>& tree, const string& beginWord, const string& word) {\n                vector<vector<string>> result;\n                if (word == beginWord) {\n                        result.emplace_back(vector<string>({beginWord}));\n                } else {\n                        if (tree.count(word)) {\n                                for (const auto& new_word : tree.at(word)) {\n                                        if (word == new_word) {\n                                                continue;\n                                        }\n                                        auto paths = backtracking(tree, beginWord, new_word);\n                                        for (auto& path : paths) {\n                                                path.emplace_back(word);\n                                                result.emplace_back(move(path));\n                                        }\n                                }\n                        }\n                }\n                return result;\n        }", "32": "int makeStringSorted(string s) { \n                static const int MOD = 1e9 + 7;\n                array<int, 26> count = {0};\n                int result = 0, comb_total = 1;\n                for (int i = size(s) - 1; i >= 0; --i) {\n                        int num = s[i] - 'a';\n                        comb_total = ((comb_total * int64_t(size(s) - i) % MOD) * inverse(++count[num], MOD)) % MOD;\n                        result = (result + ((comb_total * accumulate(cbegin(count), cbegin(count) + num, 0LL) % MOD) * inverse(size(s) - i, MOD) % MOD)) % MOD;\n                }\n                return result;\n        }\nint inverse(int n, int m) {\n                static vector<int> inv = {0, 1};\n                for (int i = size(inv); i <= n; ++i) { \n                        inv.emplace_back(inv[m % i] * int64_t(m - m / i) % m); \n                }\n                return inv[n];\n        }", "33": "int findLUSlength(string a, string b) {\n                if (a == b) {\n                        return -1;\n                }\n                return max(a.length(), b.length());\n        }", "34": "string simplifyPath(string path) {\n                vector<string> names;\n                vector<string> tokens(move(split(path, '/')));\n                for (const auto& token : tokens) {\n                        if (token == \"..\" && !names.empty()) {\n                                names.pop_back();\n                        } else if (token != \"..\" && token != \".\" && !token.empty()) {\n                                names.emplace_back(token);\n                        }\n                }\n                return string(\"/\").append(join(names, '/'));\n        }\nvector<string> split(const string& s, const char delim) {\n                vector<string> tokens;\n                stringstream ss(s);\n                string token;\n                while (getline(ss, token, delim)) {\n                        tokens.emplace_back(token);\n                }\n                return tokens;\n        }\nstring join(const vector<string>& names, const char delim) {\n                ostringstream ss;\n                if (!names.empty()) {\n                        const string delim_str(1, delim);\n                        copy(names.cbegin(), prev(names.cend()),\n                                ostream_iterator<string>(ss, delim_str.c_str()));\n                        ss << names.back();\n                }\n                return ss.str();\n        }", "35": "int maximumSwap(int num) {\n                string digits = to_string(num);\n                int left = 0, right = 0;\n                int max_idx = digits.length() - 1;\n                for (int i = digits.length() - 1; i >= 0; --i) {\n                        if (digits[i] > digits[max_idx]) {\n                                max_idx = i;\n                        } else if (digits[max_idx] > digits[i]) {\n                                left = i;\n                                right = max_idx;\n                        }\n                }\n                swap(digits[left], digits[right]);\n                return stoi(digits);\n        }", "36": "int reachableNodes(vector<vector<int>>& edges, int M, int N) {\n                using P = pair<int, int>;\n                vector<vector<P>> adj(N);\n                for (const auto& edge: edges) {\n                        int u = edge[0], v = edge[1], w = edge[2];\n                        adj[u].emplace_back(v, w);\n                        adj[v].emplace_back(u, w);\n                }\n                unordered_map<int, int> best;\n                best[0] = 0;\n                unordered_map<int, unordered_map<int, int>> count;\n                int result = 0;\n                priority_queue<P, vector<P>, greater<P>> min_heap;\n                min_heap.emplace(0, 0);\n                while (!min_heap.empty()) {\n                        int curr_total, u;\n                        tie(curr_total, u) = min_heap.top(); min_heap.pop();\n                        if (best.count(u) && best[u] < curr_total) {\n                                continue;\n                        }\n                        ++result;\n                        for (const auto& kvp: adj[u]) {\n                                int v, w;\n                                tie(v, w) = kvp;\n                                count[u][v] = min(w, M - curr_total);\n                                int next_total = curr_total + w + 1;\n                                if (next_total <= M && \n                                        (!best.count(v) next_total < best[v])) {\n                                        best[v] = next_total;\n                                        min_heap.emplace(next_total, v);\n                                }\n                        }\n                }\n                for (const auto& edge: edges) {\n                        int u = edge[0], v = edge[1], w = edge[2];\n                        result += min(w, count[u][v] + count[v][u]);\n                }\n                return result;\n        }", "37": "int minDeletions(string s) {\n                vector<int> count(26);\n                for (const auto& c : s) {\n                        ++count[c - 'a'];\n                }\n                int result = 0;\n                unordered_set<int> lookup;\n                for (int i = 0; i < 26; ++i) {\n                        for (int c = count[i]; c > 0; --c, ++result) {\n                                if (!lookup.count(c)) {\n                                        lookup.emplace(c);\n                                        break;\n                                }\n                        }\n                }\n                return result;\n        }", "38": "bool isMonotonic(vector<int>& A) {\n                bool inc = false, dec = false;\n                for (int i = 0; i + 1 < A.size(); ++i) {\n                        if (A[i] < A[i + 1]) {\n                                inc = true;\n                        } else if (A[i] > A[i + 1]) {\n                                dec = true;\n                        }\n                }\n                return !inc || !dec;\n        }", "39": "int hIndex(vector<int>& citations) {\n                const auto n = citations.size();\n                vector<int> count(n + 1, 0);\n                for (const auto& x : citations) {\n                        if (x >= n) {\n                                ++count[n];\n                        } else {\n                                ++count[x];\n                        }\n                }\n                int h = 0;\n                for (int i = n; i >= 0; --i) {\n                        h += count[i];\n                        if (h >= i) {\n                                return i;\n                        }\n                }\n                return h;\n        }", "40": "int lastRemaining(int n) {\n                int start = 1;\n                for (int step = 2, direction = 1; n > 1; n /= 2, step *= 2, direction *= -1) {\n                        start += direction * (step * (n / 2) - step / 2);\n                }\n                return start;\n        }\n", "41": "int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\n                int max_f = *max_element(cbegin(forbidden), cend(forbidden));\n                int max_val = (a >= b) ? x + b : max(x, max_f) + a + b; \n                vector<unordered_set<int>> lookup(2); \n                for (const auto& pos : forbidden) {\n                        lookup[0].emplace(pos);\n                        lookup[1].emplace(pos);\n                }\n                int result = 0;\n                vector<pair<int, int>> q = {{0, true}};\n                lookup[0].emplace(0);\n                while (!empty(q)) {\n                        vector<pair<int, int>> new_q;\n                        for (const auto& [pos, can_back] : q) {\n                                if (pos == x) {\n                                        return result;\n                                }\n                                if (pos + a <= max_val && !lookup[0].count(pos + a)) {\n                                        lookup[0].emplace(pos + a);\n                                        new_q.emplace_back(pos + a, true);\n                                }\n                                if (!can_back) {\n                                        continue;\n                                }\n                                if (pos - b >= 0 && !lookup[1].count(pos - b)) {\n                                        lookup[1].emplace(pos - b);\n                                        new_q.emplace_back(pos - b, false);\n                                }\n                        }\n                        q = move(new_q);\n                        ++result;\n                }\n                return -1;\n        }", "42": "bool isPathCrossing(string path) {\n                unordered_set<pair<int, int>, PairHash<int>> lookup = {{0, 0}};\n                int x = 0, y = 0;\n                for (const auto& c : path) {\n                        switch(c) {\n                                case 'E':\n                                        ++x;\n                                        break;\n                                case 'W':\n                                        --x;\n                                        break;\n                                case 'N':\n                                        ++y;\n                                        break;\n                                case 'S':\n                                        --y;\n                                        break;\n                        }\n                        if (!lookup.emplace(x, y).second) {\n                                return true;\n                        }\n                }\n                return false;\n        }\nsize_t operator()(const pair<T, T>& p) const {\n                        size_t seed = 0;\n                        seed ^= std::hash<T>{}(p.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        seed ^= std::hash<T>{}(p.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        return seed;\n                }", "43": "bool canBeIncreasing(vector<int>& nums) {\n                bool deleted = false;\n                for (int i = 1; i < size(nums); ++i) {        \n                        if (nums[i] > nums[i - 1]) {\n                                continue;\n                        }\n                        if (deleted) {\n                                return false;\n                        }\n                        deleted = true;\n                        if (i >= 2 && nums[i - 2] > nums[i]) { \n                                nums[i] = nums[i - 1];\n                        }\n                }\n                return true;\n        }", "44": "vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n                Lookup lookup;\n                return memoization(n, firstPlayer - 1, n - secondPlayer, &lookup);\n        }\nvector<int> memoization(int t, int l, int r, Lookup *lookup) {\n                if (!lookup->count(tuple(t, l, r))) {\n                        if (l == r) {\n                                return {1, 1};\n                        }\n                        if (l > r) { \n                                swap(l, r);\n                        }\n                        vector<int> result = {numeric_limits<int>::max(), 0};\n                        for (int i = 0; i <= l; ++i) {\n                                const auto nt = (t + 1) / 2;\n                                const auto pair_cnt = t / 2;\n                                const auto l_lose_cnt = l - i;\n                                const auto l_win_cnt = i + 1;\n                                int min_j = max(l_lose_cnt, r - (pair_cnt - l_lose_cnt)); \n                                int max_j = min(r - l_win_cnt, (nt - l_win_cnt) - 1); \n                                for (int j = min_j; j <= max_j; ++j) {\n                                        const auto& tmp = memoization(nt, i, j, lookup);\n                                        result = {min(result[0], tmp[0] + 1), max(result[1], tmp[1] + 1)};\n                                }\n                        }\n                        (*lookup)[tuple(t, l, r)] = move(result);\n                }\n                return (*lookup)[tuple(t, l, r)];\n        }\nsize_t operator()(const tuple<A, B, C>& p) const {\n                        size_t seed = 0;\n                        A a; B b; C c;\n                        tie(a, b, c) = p;\n                        seed ^= std::hash<A>{}(a) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        seed ^= std::hash<B>{}(b) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        seed ^= std::hash<C>{}(c) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        return seed;\n                }", "45": "int numJewelsInStones(string J, string S) {\n                unordered_set<char> lookup;\n                for (const auto& j : J) {\n                        lookup.emplace(j);\n                }\n                int result = 0;\n                for (const auto& s : S) {\n                        result += lookup.count(s);\n                }\n                return result;\n        }", "46": "int heightChecker(vector<int>& heights) {\n                vector<int> sorted_heights{heights};\n                sort(sorted_heights.begin(), sorted_heights.end());\n                int result = 0;\n                for (int i = 0; i < heights.size(); ++i) {\n                        result += static_cast<int>(heights[i] != sorted_heights[i]);\n                }\n                return result;\n        }", "47": "int largestSubmatrix(vector<vector<int>>& matrix) {\n                int resuilt = 0;\n                for (int c = 0; c < size(matrix[0]); ++c) {\n                        int h = 0;\n                        for (int r = 0; r < size(matrix); ++r) {\n                                h = (matrix[r][c] == 1) ? h + 1 : 0;\n                                matrix[r][c] = h;\n                        }\n                }\n                int result = 0;\n                for (auto& row : matrix) {\n                        sort(begin(row), end(row));\n                        for (int c = 0; c < size(row); ++c) {\n                                result = max(result, int(size(row) - c) * row[c]);\n                        }\n                }\n                return result;\n        }", "48": "bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {\n                vector<function<bool (int, int)>> checks = {\n                        [&mat, &target](int i, int j) { return mat[i][j] == target[i][j]; },\n                        [&mat, &target](int i, int j) { return mat[i][j] == target[j][size(mat) - 1 - i]; },\n                        [&mat, &target](int i, int j) { return mat[i][j] == target[size(mat) - 1 - i][size(mat[0]) - 1 - j]; },\n                        [&mat, &target](int i, int j) { return mat[i][j] == target[size(mat[0]) - 1 - j][i]; },\n                };\n                const auto& traverse = [&mat, &target](const auto& check) {\n                        for (int i = 0; i < size(mat); ++i) {\n                                for (int j = 0; j < size(mat[0]); ++j) {\n                                        if (!check(i, j)) {\n                                                return false;\n                                        }\n                                }\n                        }\n                        return true;\n                };\n                for (const auto& check : checks) {\n                        if (traverse(check)) {\n                                return true;\n                        }\n                }\n                return false;\n        }", "49": "ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n                ListNode dummy{0};\n                auto curr = &dummy;\n                auto carry = 0;\n                while (l1 l2 carry) {\n                        auto a = l1? l1->val : 0, b = l2? l2->val : 0;\n                        auto val = carry + a + b;\n                        curr->next = new ListNode(val % 10);\n                        carry = val / 10;\n                        l1 = l1 ? l1->next : nullptr;\n                        l2 = l2 ? l2->next : nullptr;\n                        curr = curr->next;\n                }\n                return dummy.next;\n        }", "50": "bool makesquare(vector<int>& nums) {\n                int sum = accumulate(nums.begin(), nums.end(), 0);\n                if (sum % 4) {\n                        return false;\n                }\n                const auto side_len = sum / 4;\n                const auto all = (1 << nums.size()) - 1;\n                vector<int> used_subsets;\n                vector<bool> valid_half_subsets(1 << nums.size());\n                for (int subset = 0; subset <= all; ++subset) {\n                        int subset_sum = 0;\n                        for (int i = 0; i < nums.size(); ++i) {\n                                if (subset & (1 << i)) {\n                                        subset_sum += nums[i];\n                                }\n                        }\n                        if (subset_sum == side_len) {\n                                for (const auto& used_subset : used_subsets) {\n                                        if ((used_subset & subset) == 0) {\n                                                int valid_half_subset = used_subset | subset;\n                                                valid_half_subsets[valid_half_subset] = true;\n                                                if (valid_half_subsets[all ^ valid_half_subset]) {\n                                                        return true;\n                                                }\n                                        }\n                                }\n                                used_subsets.emplace_back(subset);\n                        }\n                }\n                return false;\n        }", "51": "TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\n                vector<TreeNode*> s;\n                s.emplace_back(new TreeNode(pre[0]));\n                for (int i = 1, j = 0; i < pre.size(); ++i) {\n                        auto node = new TreeNode(pre[i]);\n                        while (s.back()->val == post[j]) {\n                                s.pop_back(), ++j;\n                        }\n                        if (s.back()->left == nullptr) {\n                                s.back()->left = node;\n                        } else {\n                                s.back()->right = node;\n                        }\n                        s.emplace_back(node);\n                }\n                return s[0];\n        }", "52": "string orderlyQueue(string S, int K) {\n                if (K == 1) {\n                        auto result{S};\n                        for (int i = 1; i < S.length(); ++i) {\n                                result = min(result, S.substr(i) + S.substr(0, i));\n                        }\n                        return result;\n                }\n                sort(S.begin(), S.end());\n                return S;\n        }", "53": "int maximumWealth(vector<vector<int>>& accounts) {\n                int result = 0;\n                for (const auto& account : accounts) {\n                        int total = accumulate(cbegin(account), cend(account), 0);\n                        result = max(result, total);\n                }\n                return result;\n        }", "54": "bool isAnagram(string s, string t) {\n                if (size(s) != size(t)) {\n                        return false;\n                }\n                unordered_map<char, int> count;\n                for (const auto& c: s) {\n                        ++count[c];\n                }\n                for (const auto& c: t) {\n                        --count[c];\n                        if (count[c] < 0) {\n                                return false;\n                        }\n                }\n                return true;\n        }", "55": "string nearestPalindromic(string n) {\n                const auto l = n.size();\n                unordered_set<long long> candidates;\n                candidates.emplace(static_cast<long long>(pow(10, l)) + 1);\n                candidates.emplace(static_cast<long long>(pow(10, l - 1)) - 1);\n                auto prefix = stol(n.substr(0, (l + 1) / 2));\n                for (long long i = -1; i <= 1; ++i) {\n                        auto p = to_string(prefix + i);\n                        auto pp = p + string(p.rbegin() + (l % 2), p.rend());\n                        candidates.emplace(stol(pp));\n                }\n                long long num = stol(n), closest_val = numeric_limits<long long>::max();\n                candidates.erase(num);\n                for (const auto& val : candidates) {\n                        if (abs(val - num) < abs(closest_val - num)) {\n                                closest_val = val;\n                        } else if (abs(val - num) == abs(closest_val - num)) {\n                                closest_val = min(closest_val, val);\n                        }\n                }\n                return to_string(closest_val);\n        }", "56": "int sumEvenGrandparent(TreeNode* root) {\n                return sumEvenGrandparentHelper(root, 1, 1);\n        }\nint sumEvenGrandparentHelper(TreeNode *root, int p, int gp) {\n                return root\n                        ? sumEvenGrandparentHelper(root->left, root->val, p) +\n                                sumEvenGrandparentHelper(root->right, root->val, p) +\n                                (gp % 2 == 0 ? root->val : 0)\n                        : 0;\n        }", "57": "Node* flatten(Node* head) {\n                for (auto curr = head; curr; curr = curr->next) {\n                        if (!curr->child) {\n                                continue;\n                        }\n                        auto curr_next = curr->next;\n                        curr->child->prev = curr;\n                        curr->next = curr->child;\n                        auto last_child = curr;\n                        while (last_child->next) {\n                                last_child = last_child->next;\n                        }\n                        if (curr_next) {\n                                last_child->next = curr_next;\n                                curr_next->prev = last_child;\n                        }\n                        curr->child = nullptr;\n                }\n                return head;\n        }", "58": "int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats) {\n                unordered_map<int, unordered_map<int, bool>> lookup;\n                for (const auto& seat : reservedSeats) {\n                        if (2 <= seat[1] && seat[1] <= 5) {\n                                lookup[seat[0]][0] = true;\n                        }\n                        if (4 <= seat[1] && seat[1] <= 7) {\n                                lookup[seat[0]][1] = true;\n                        }\n                        if (6 <= seat[1] && seat[1] <= 9) {\n                                lookup[seat[0]][2] = true;\n                        }\n                }\n                int result = 2 * n;\n                for (auto& [_, reserved] : lookup) {\n                        if (!reserved[0] && !reserved[2]) {\n                                continue;\n                        }\n                        if (!reserved[0] !reserved[1] !reserved[2]) {\n                                --result;\n                                continue;\n                        }\n                        result -= 2;\n                }\n                return result;\n        }", "59": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n                int i = m + n;\n                while (m > 0 && n > 0) {\n                        if (nums1[m - 1] > nums2[n - 1]) {\n                                nums1[i - 1] = nums1[m - 1];\n                                --m;\n                        } else {\n                                nums1[i - 1] = nums2[n - 1];\n                                --n;\n                        }\n                        --i;\n                }\n                while (n > 0) {\n                        nums1[i - 1] = nums2[n - 1];\n                        --n;\n                        --i;\n                }\n        }", "60": "int minCost(string s, vector<int>& cost) {\n                int result = 0, accu = 0, max_cost = 0;\n                for (int i = 0; i < s.length(); ++i) {\n                        if (i && s[i] != s[i - 1]) {\n                                result += accu - max_cost;\n                                accu = max_cost = 0;\n                        }\n                        accu += cost[i];\n                        max_cost = max(max_cost, cost[i]);\n                }\n                result += accu - max_cost;\n                return result;\n        }", "61": "int minDays(vector<int>& bloomDay, int m, int k) {\n                if (m * k > bloomDay.size()) {\n                        return -1;\n                }\n                int left = 1, right = *max_element(cbegin(bloomDay), cend(bloomDay));\n                while (left <= right) {\n                        const auto& mid = left + (right - left) / 2;\n                        if (check(bloomDay, m, k, mid)) {\n                                right = mid - 1;\n                        } else {\n                                left = mid + 1;\n                        }\n                }\n                return left;\n        }\nbool check(const vector<int>& bloomDay, int m, int k, int x) {\n                int result = 0, count = 0;\n                for (const auto& d : bloomDay) {\n                        count = (d <= x) ? count + 1 : 0;\n                        if (count == k) {\n                                count = 0;\n                                if (++result == m) {\n                                        break;\n                                }\n                        }\n                }\n                return result >= m;\n        }", "62": "vector<int> sortItems(int n, int m, vector<int>& group_id, vector<vector<int>>& beforeItems) {\n                for (int i = 0; i < n; ++i) {\n                        if (group_id[i] == -1) {\n                                group_id[i] = m++;\n                        }\n                }\n                Topo global_group;\n                for (int i = 0; i < m; ++i) {\n                        global_group.addNode(i);\n                }\n                unordered_map<int, Topo> local_groups;\n                for (int i = 0; i < n; ++i) {\n                        local_groups[group_id[i]].addNode(i);\n                }\n                for (int i = 0; i < n; ++i) {\n                        for (const auto& j : beforeItems[i]) {\n                                if (group_id[i] == group_id[j]) {\n                                        local_groups[group_id[i]].addEdge(j, i);\n                                } else {\n                                        global_group.addEdge(group_id[j], group_id[i]);\n                                }\n                        }\n                }\n                vector<int> result;\n                const auto& global_order = global_group.sort();\n                if (!global_order) {\n                        return {};\n                }                \n                for (const auto& i : *global_order) {\n                        const auto& local_order = local_groups[i].sort();\n                        if (!local_order) {\n                                return {};\n                        }\n                        for (const auto& x : *local_order) {\n                                result.emplace_back(x);\n                        }\n                }\n                return result;\n        }\nvoid addNode(int node) {\n                        nodes_.emplace(node);\n                }\nvoid addEdge(int from, int to) {\n                        addNode(from), addNode(to);\n                        in_degree_[to].emplace(from);\n                        out_degree_[from].emplace(to);\n                }\nunique_ptr<vector<int>> sort() {\n                        queue<int> q;\n                        auto result = make_unique<vector<int>>();\n                        for (const auto& node : nodes_) {\n                                if (!in_degree_.count(node)) {\n                                        q.emplace(node);\n                                }\n                        }\n                        while (!q.empty()) {\n                                auto node = q.front(); q.pop();\n                                result->emplace_back(node);\n                                for (const auto& nei : out_degree_[node]) {\n                                        in_degree_[nei].erase(node);\n                                        if (in_degree_[nei].empty()) {\n                                                in_degree_.erase(nei);\n                                                q.emplace(nei);\n                                        }\n                                }\n                        }                        \n                        if (result->size() < nodes_.size()) {\n                                return nullptr;\n                        }\n                        return result;\n                }", "63": "vector<vector<int>> levelOrderBottom(TreeNode* root) {\n                vector<vector<int>> result;\n                queue<TreeNode *> que;\n                if (root != nullptr) {\n                        que.emplace(root);\n                }\n                while (!que.empty()) {\n                        vector<int> level;\n                        int size = que.size();\n                        for (int i = 0; i < size; i++) {\n                                auto *front = que.front();\n                                que.pop();\n                                level.emplace_back(front->val);\n                                if (front->left != nullptr) {\n                                        que.emplace(front->left);\n                                }\n                                if (front->right != nullptr) {\n                                        que.emplace(front->right);\n                                }\n                        }\n                        result.emplace_back(move(level));\n                }\n                reverse(result.begin(), result.end());\n                return result;\n        }", "64": "int longestPalindromeSubseq(string s) {\n                if (s == string(s.rbegin(), s.rend())) { \n                        return s.length();\n                }\n                vector<vector<int>> dp(2, vector<int>(s.size(), 1));\n                for (int i = s.length() - 2; i >= 0; --i) {\n                        for (int j = i + 1; j < s.length(); ++j) {\n                                if (s[i] == s[j]) {\n                                        dp[i % 2][j] = (i + 1 <= j - 1) ? 2 + dp[(i + 1) % 2][j - 1] : 2;\n                                } else {\n                                        dp[i % 2][j] = max(dp[(i + 1) % 2][j], dp[i % 2][j - 1]);\n                                }\n                        }\n                }\n                return dp[0][s.length() - 1];\n        }", "65": "vector<int> getSumAbsoluteDifferences(vector<int>& nums) {\n                int prefix = 0, suffix = accumulate(cbegin(nums), cend(nums), 0);\n                vector<int> result;\n                for (int i = 0; i < size(nums); ++i) {\n                        suffix -= nums[i];\n                        result.emplace_back((i * nums[i] - prefix) + (suffix - ((size(nums) - 1) - i) * nums[i]));\n                        prefix += nums[i];\n                }\n                return result;\n        }", "66": "bool isSubtree(TreeNode* s, TreeNode* t) {\n                return preOrderTraverse(s, t);\n        }\nbool preOrderTraverse(TreeNode *s, TreeNode *t) {\n                return s && (isSame(s, t) ||\n                                        preOrderTraverse(s->left, t) ||\n                                        preOrderTraverse(s->right, t));\n        }\nbool isSame(TreeNode *x,TreeNode *y) {\n                if (!x && !y) {\n                        return true;\n                }\n                if (!x !y) {\n                        return false;\n                }\n                return x->val == y->val &&\n                        isSame(x->left, y->left) &&\n                        isSame(x->right, y->right);\n        }", "67": "int longestCommonSubsequence(string text1, string text2) {\n                                if (text1.length() < text2.length()) {\n                        return longestCommonSubsequence(text2, text1);\n                }\n                vector<vector<int>> dp(2, vector<int>(text2.length() + 1));\n                for (int i = 1; i <= text1.length(); ++i) {\n                        for (int j = 1; j <= text2.length(); ++j) {\n                                dp[i % 2][j] = (text1[i - 1] == text2[j - 1])\n                                                        ? dp[(i - 1) % 2][j - 1] + 1\n                                                        : max(dp[(i - 1) % 2][j], dp[i % 2][j - 1]);\n                        }\n                }\n                return dp[text1.length() % 2][text2.length()]; }", "68": "vector<vector<string>> findDuplicate(vector<string>& paths) {\n                unordered_map<string, vector<string>> files;\n                for (const auto& path : paths) {\n                        stringstream ss(path);\n                        string root;\n                        string s;\n                        getline(ss, root, ' ');\n                        while (getline(ss, s, ' ')) {\n                                auto fileName = root + '/' + s.substr(0, s.find('('));\n                                auto fileContent = s.substr(s.find('(') + 1, s.find(')') - s.find('(') - 1);\n                                files[fileContent].emplace_back(fileName);\n                        }\n                }\n                vector<vector<string>> result;\n                for (const auto& file : files) {\n                        if (file.second.size() > 1) {\n                                result.emplace_back(file.second);\n                        }\n                }\n                return result;\n        }", "69": "int minCostConnectPoints(vector<vector<int>>& points) {\n                int result = 0, u = 0; \n                vector<int> dist(size(points), numeric_limits<int>::max());\n                unordered_set<int> lookup;\n                for (int i = 0; i < size(points) - 1; ++i) {\n                        int x0 = points[u][0], y0 = points[u][1];\n                        lookup.emplace(u);\n                        for (int v = 0; v < size(points); ++v) {\n                                if (lookup.count(v)) {\n                                        continue;\n                                }\n                                dist[v] = min(dist[v], abs(points[v][0] - x0) + abs(points[v][1] - y0));\n                        }\n                        int val = numeric_limits<int>::max();\n                        for (int v = 0; v < size(dist); ++v) {\n                                if (dist[v] < val) {\n                                        val = dist[v];\n                                        u = v;\n                                }\n                        }\n                        dist[u] = numeric_limits<int>::max(); \n                        result += val;\n                }\n                return result;\n        }", "70": "vector<int> numsSameConsecDiff(int N, int K) {\n                vector<int> curr(10);\n                iota(curr.begin(), curr.end(), 0);\n                for (int i = 0; i < N - 1; ++i) {\n                        vector<int> next;\n                        for (const auto& x : curr) {\n                                int y = x % 10;\n                                if (x > 0 && y + K < 10) {\n                                        next.emplace_back(x * 10 + y + K);\n                                }\n                                if (x > 0 && K > 0 && y - K >= 0) {\n                                        next.emplace_back(x * 10 + y - K);\n                                }\n                        }\n                        curr = move(next);\n                }\n                return curr;\n        }", "71": "int maxJumps(vector<int>& arr, int d) {\n                vector<vector<int>> left(arr.size());\n                deque<int> decreasing_dq;\n                for (int i = 0; i < arr.size(); ++i) {\n                        if (!decreasing_dq.empty() && i - decreasing_dq.front() == d + 1) {\n                                decreasing_dq.pop_front();\n                        }\n                        while (!decreasing_dq.empty() && arr[decreasing_dq.back()] < arr[i]) {\n                                if (!left[i].empty() && arr[left[i].back()] != arr[decreasing_dq.back()]) {\n                                        left[i].clear();\n                                }\n                                left[i].emplace_back(decreasing_dq.back());\n                                decreasing_dq.pop_back();\n                        }\n                        decreasing_dq.emplace_back(i);\n                }\n                vector<vector<int>> right(arr.size());\n                decreasing_dq.clear();\n                for (int i = arr.size() - 1; i >= 0; --i) {\n                        if (!decreasing_dq.empty() && decreasing_dq.front() - i == d + 1) {\n                                decreasing_dq.pop_front();\n                        }\n                        while (!decreasing_dq.empty() && arr[decreasing_dq.back()] < arr[i]) {\n                                if (!right[i].empty() && arr[right[i].back()] != arr[decreasing_dq.back()]) {\n                                        right[i].clear();\n                                }\n                                right[i].emplace_back(decreasing_dq.back());\n                                decreasing_dq.pop_back();\n                        }\n                        decreasing_dq.emplace_back(i);\n                }\n                int result = 0;\n                vector<int> lookup(arr.size());\n                for (int i = 0; i < arr.size(); ++i) {\n                        result = max(result, dp(arr, d, i, left, right, &lookup));\n                }\n                return result;\n        }\nint dp(const vector<int>& arr, int d, int i, const vector<vector<int>>& left, const vector<vector<int>>& right, vector<int> *lookup) {\n                if ((*lookup)[i]) {\n                        return (*lookup)[i];\n                }\n                (*lookup)[i] = 1;\n                for (const auto& j : left[i]) {\n                        (*lookup)[i] = max((*lookup)[i], dp(arr, d, j, left, right, lookup) + 1);\n                }\n                for (const auto& j : right[i]) {\n                        (*lookup)[i] = max((*lookup)[i], dp(arr, d, j, left, right, lookup) + 1);\n                }\n                return (*lookup)[i];\n        }", "72": "int minFlips(int a, int b, int c) {\n                return number_of_1_bits((a b) ^ c) + number_of_1_bits(a & b & ~c);\n        }\nint number_of_1_bits(int n) {\n                n = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n                n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n                n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F);\n                n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF);\n                n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF);\n                return n;\n        }", "73": "int missingNumber(vector<int>& nums) {\n        int num = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n        num ^= nums[i] ^ (i + 1);\n        }\n        return num;\n }", "74": "vector<int> getStrongest(vector<int>& arr, int k) {\n                nth_element(begin(arr), begin(arr) + (arr.size() - 1) / 2, end(arr));\n                const auto m = arr[(arr.size() -1) / 2];\n                nth_element(begin(arr), begin(arr) + k, end(arr), [&](int a, int b) { \n                        return abs(a - m) != abs(b - m) ? abs(a - m) > abs(b - m) : a > b; });\n                arr.resize(k);\n                return arr;\n        }", "75": "int minSwapsCouples(vector<int>& row) {\n                int N = row.size() / 2;\n                vector<vector<int>> couples(N);\n                for (int seat = 0; seat < row.size(); ++seat) {\n                        couples[row[seat] / 2].emplace_back(seat / 2);\n                }\n                vector<vector<int>> adj(N);\n                for (const auto& couple : couples) {\n                        adj[couple[0]].emplace_back(couple[1]);\n                        adj[couple[1]].emplace_back(couple[0]);\n                }\n                int result = 0;\n                for (int couch = 0; couch < N; ++couch) {\n                        if (adj[couch].empty()) {\n                                continue;\n                        }\n                        int couch1 = couch;\n                        int couch2 = adj[couch1].back(); adj[couch1].pop_back();\n                        while (couch2 != couch) {\n                                ++result;\n                                adj[couch2].erase(find(adj[couch2].begin(), adj[couch2].end(), couch1));\n                                couch1 = couch2;\n                                couch2 = adj[couch1].back(); adj[couch1].pop_back();\n                        }\n                }\n                return result; \n        }", "76": "int nthMagicalNumber(int N, int A, int B) {\n                static const int M = 1000000007;\n                const uint64_t a = A, b = B;\n                const auto lcm = a * b / gcd(a, b);\n                auto left = min(a, b), right = max(a, b) * N;\n                while (left <= right) {\n                        const auto mid = left + (right - left) / 2;\n                        if (check(A, B, N, lcm, mid)) {\n                                right = mid - 1;\n                        } else {\n                                left = mid + 1;\n                        }\n                }\n                return left % M;\n        }\nbool check(uint64_t a, uint64_t b, uint64_t N, uint64_t lcm, uint64_t target) {\n                return target / a + target / b - target / lcm >= N;\n        }\nuint64_t gcd(uint64_t a, uint64_t b) {\n                while (b != 0) {\n                        int tmp = b;\n                        b = a % b;\n                        a = tmp;\n                }\n                return a;\n        }", "77": "int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n                if (start > destination) {\n                        swap(start, destination);\n                }\n                const auto& s_to_d = accumulate(distance.cbegin() + start,\n                                                                                distance.cbegin() + destination, 0);\n                const auto& d_to_s = accumulate(distance.cbegin(),\n                                                                                distance.cbegin() + start, 0) +\n                                                        accumulate(distance.cbegin() + destination,\n                                                                                distance.cend(), 0);\n                return min(s_to_d, d_to_s);\n        }", "78": "bool findTarget(TreeNode* root, int k) {\n                if (!root) {\n                        return false;\n                }\n                BSTIterator left(root, true), right(root, false);\n                while (*left < *right) {\n                        if (*left + *right == k) {\n                                return true;\n                        } else if (*left + *right < k) {\n                                ++left;\n                        } else {\n                                ++right;\n                        }\n                }\n                return false;\n        }\nBSTIterator(TreeNode *root, bool forward) :\n                        node_(root),\n                        forward_(forward) {\n                        ++(*this);\n                }\nint operator*() {\n                        return cur_; \n                }\nvoid operator++() {\n                        while (node_ || !s_.empty()) {\n                                if (node_) {\n                                        s_.emplace(node_);\n                                        node_ = forward_ ? node_->left : node_->right;\n                                } else {\n                                        node_ = s_.top();\n                                        s_.pop();\n                                        cur_ = node_->val;\n                                        node_ = forward_ ? node_->right : node_->left;\n                                        break;\n                                }\n                        }\n                }", "79": "int bestRotation(vector<int>& A) {\n                const int N = A.size();\n                vector<int> change(N);\n                for (int i = 0; i < N; ++i) {\n                        --change[(i - A[i] + 1 + N) % N];\n                }\n                for (int i = 1; i < N; ++i) {\n                        change[i] += change[i - 1] + 1;\n                }\n                return distance(change.begin(), max_element(change.begin(), change.begin() + N));\n        }", "80": "vector<int> powerfulIntegers(int x, int y, int bound) {\n                unordered_set<int> result;\n                int log_x = (x != 1) ? int(floor(log(bound) / log(x))) + 1 : 1;\n                int log_y = (y != 1) ? int(floor(log(bound) / log(y))) + 1 : 1;\n                for (int i = 0, pow_x = 1; i < log_x; ++i, pow_x *= x) {\n                        for (int j = 0, pow_y = 1; j < log_y; ++j, pow_y *= y) {\n                                auto val = pow_x + pow_y;\n                                if (val <= bound) {\n                                        result.emplace(val);\n                                }\n                        }\n                }\n                return vector<int>(result.cbegin(), result.cend());\n        }", "81": "int arraySign(vector<int>& nums) {\n                uint8_t flag = 0;\n                for (const auto& x : nums) {\n                        if (x == 0) {\n                                return 0;\n                        }\n                        if (x < 0) {\n                                flag ^= 1;\n                        }\n                }\n                return flag % 2 ? -1 : 1;\n        }", "82": "int minSumOfLengths(vector<int>& arr, int target) {\n                unordered_map<int, int> prefix = {{0, -1}};\n                vector<int> dp(arr.size());\n                int result = numeric_limits<int>::max(), min_len = numeric_limits<int>::max();\n                int accu = 0;\n                for (int right = 0; right < arr.size(); ++right) {\n                        accu += arr[right];\n                        prefix[accu] = right;\n                        if (prefix.count(accu - target)) {\n                                auto left = prefix[accu - target];\n                                min_len = min(min_len, right - left);\n                                if (left != -1 && dp[left] != numeric_limits<int>::max()) {\n                                        result = min(result, dp[left] + (right - left));\n                                }\n                        }\n                        dp[right] = min_len;\n                }\n                return result != numeric_limits<int>::max() ? result : -1;\n        }", "83": "int shortestBridge(vector<vector<int>>& A) {\n                static const vector<pair<int, int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n                unordered_set<pair<int, int>, PairHash<int>> lookup;\n                unordered_set<pair<int, int>, PairHash<int>> target;\n                auto islands = get_islands(A);\n                lookup = move(islands[0]);\n                target = move(islands[1]);\n                queue<pair<pair<int, int>, int>> q;\n                for (const auto& node : lookup) {\n                        q.emplace(node, 0);\n                }\n                while (!q.empty()) {\n                        pair<int, int> node;\n                        int dis;\n                        tie(node, dis) = q.front(); q.pop();\n                        if (target.count(node)) {\n                                return dis - 1;\n                        }\n                        for (const auto& d : directions) {\n                                pair<int, int> nei = make_pair(node.first + d.first, node.second + d.second);\n                                if (0 > nei.first || nei.first >= A.size() ||\n                                        0 > nei.second || nei.second >= A[0].size() ||\n                                        lookup.count(nei)) {\n                                        continue;\n                                }\n                                q.emplace(nei, dis + 1);\n                                lookup.emplace(nei);\n                        }\n                }\n        }\nvector<unordered_set<pair<int, int>, PairHash<int>>> get_islands(const vector<vector<int>>& A) {\n                static const vector<pair<int, int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n                vector<unordered_set<pair<int, int>, PairHash<int>>> islands;\n                unordered_set<pair<int, int>, PairHash<int>> done;\n                for (int r = 0; r < A.size(); ++r) {\n                        for (int c = 0; c < A[0].size(); ++c) {\n                                if (A[r][c] == 0 || done.count(make_pair(r, c))) {\n                                        continue;\n                                }\n                                vector<pair<int, int>> s{{r, c}};\n                                unordered_set<pair<int, int>, PairHash<int>> lookup(s.cbegin(), s.cend());\n                                while (!s.empty()) {\n                                        auto node = s.back(); s.pop_back();\n                                        for (const auto& d : directions) {\n                                                pair<int, int> nei = make_pair(node.first + d.first, node.second + d.second);\n                                                if (0 > nei.first || nei.first >= A.size() ||\n                                                        0 > nei.second || nei.second >= A[0].size() ||\n                                                        lookup.count(nei) A[nei.first][nei.second] == 0) {\n                                                        continue;\n                                                }\n                                                s.emplace_back(nei);\n                                                lookup.emplace(nei);\n                                        }\n                                }\n                                for (const auto& node : lookup) {\n                                        done.emplace(node);\n                                }\n                                islands.emplace_back(move(lookup));\n                                if (islands.size() == 2) {\n                                        break;\n                                }\n                        }\n                }\n                return islands;\n        }\nsize_t operator()(const pair<T, T>& p) const {\n                        size_t seed = 0;\n                        seed ^= std::hash<T>{}(p.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        seed ^= std::hash<T>{}(p.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        return seed;\n                }", "84": "void solve(vector<vector<char>>& board) {\n                if (board.empty()) {\n                        return;\n                }\n                queue<pair<int, int>> q;\n                for (int i = 0; i < board.size(); ++i) {\n                        if (board[i][0] == 'O') {\n                                board[i][0] = 'V';\n                                q.emplace(i, 0);\n                        }\n                        if (board[i][board[0].size() - 1] == 'O') {\n                                board[i][board[0].size() - 1] = 'V';\n                                q.emplace(i, board[0].size() - 1);\n                        }\n                }\n                for (int j = 1; j < board[0].size() - 1; ++j) {\n                        if (board[0][j] == 'O') {\n                                board[0][j] = 'V';\n                                q.emplace(0, j);\n                        }\n                        if (board[board.size() - 1][j] == 'O') {\n                                board[board.size() - 1][j] = 'V';\n                                q.emplace(board.size() - 1, j);\n                        }\n                }\n                while (!q.empty()) {\n                        int i, j;\n                        tie(i, j) = q.front();\n                        q.pop();\n                        static const vector<pair<int, int>> directions{{0, -1}, {0, 1},\n                                                                                                                {-1, 0}, {1, 0}};\n                        for (const auto& d : directions) {\n                                const int x = i + d.first, y = j + d.second;\n                                if (0 <= x && x < board.size() &&\n                                        0 <= y && y < board[0].size() && board[x][y] == 'O') {\n                                        board[x][y] = 'V';\n                                        q.emplace(x, y);\n                                }\n                        }\n                }\n                for (int i = 0; i < board.size(); ++i) {\n                        for (int j = 0; j < board[0].size(); ++j) {\n                                if (board[i][j] != 'V') {\n                                        board[i][j] = 'X';\n                                } else {\n                                        board[i][j] = 'O';\n                                }\n                        }\n                }\n        }", "85": "int superPow(int a, vector<int>& b) {\n                int result = 1;\n                for (const auto& digit : b) {\n                        result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337;\n                }\n                return result;\n        }\nint myPow(int a, int n, int b) {\n                int result = 1;\n                int x = a % b;\n                while (n) {\n                        if (n & 1) {\n                                result = result * x % b;\n                        }\n                        n >>= 1;\n                        x = x * x % b;\n                }\n                return result % b;\n        }", "86": "int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\n                return shoppingOffersHelper(price, special, needs, 0);\n        }\nint shoppingOffersHelper(const vector<int>& price, const vector<vector<int>>& special, vector<int>& needs, int i) {\n                if (i == special.size()) {\n                        return inner_product(price.begin(), price.end(), needs.begin(), 0);\n                }\n                int result = shoppingOffersHelper(price, special, needs, i + 1);\n                for (int j = 0; j < needs.size(); ++j) {\n                        needs[j] -= special[i][j];\n                }\n                if (all_of(needs.begin(), needs.end(), [](int i) { return i >= 0; })) {\n                        result = min(result, special[i].back() + shoppingOffersHelper(price, special, needs, i));\n                }\n                for (int j = 0; j < needs.size(); ++j) {\n                        needs[j] += special[i][j];\n                }\n                return result;\n        }", "87": "vector<string> invalidTransactions(vector<string>& transactions) {\n                static const int AMOUNT = 1000;\n                static const int MINUTES = 60;\n                vector<tuple<string, int, int, string>> trans;\n                for (const auto& transaction : transactions) {\n                        const auto& t = split(transaction, ',');\n                        trans.emplace_back(t[0], stoi(t[1]), stoi(t[2]), t[3]);\n                }\n                sort(trans.begin(), trans.end(),\n                        [](const auto& a, const auto& b) {\n                                return get<1>(a) < get<1>(b); });\n                unordered_map<string, vector<int>> trans_indexes;\n                for (int i = 0; i < trans.size(); ++i) {\n                        trans_indexes[get<0>(trans[i])].emplace_back(i);\n                }\n                vector<string> result;\n                for (const auto& [name, indexes] : trans_indexes) {\n                        int left = 0, right = 0;\n                        for (int i = 0; i < indexes.size(); ++i) {\n                                const auto& t = trans[indexes[i]];\n                                if (get<2>(t) > AMOUNT) {\n                                        result.emplace_back(to_str(t));\n                                        continue;\n                                }\n                                while (left + 1 < indexes.size() &&\n                                        get<1>(trans[indexes[left]]) < get<1>(t) - MINUTES) {\n                                        ++left;\n                                }\n                                while (right + 1 < indexes.size() &&\n                                        get<1>(trans[indexes[right + 1]]) <= get<1>(t) + MINUTES) {\n                                        ++right;\n                                }\n                                for (int i = left; i <= right; ++i) {\n                                        if (get<3>(trans[indexes[i]]) != get<3>(t)) {\n                                                result.emplace_back(to_str(t));\n                                                break;\n                                        }\n                                }\n                        }\n                }\n                return result;\n        }\nvector<string> split(const string& s, const char delim) {\n                vector<string> result;\n                auto end = string::npos;\n                do {\n                        const auto& start = end + 1;\n                        end = s.find(delim, start);\n                        result.emplace_back(s.substr(start, end - start));\n                } while (end != string::npos); \n                return result;\n        }\nstring to_str(const T& t) {\n                stringstream ss;\n                ss << get<0>(t) << \",\" << get<1>(t) << \",\"\n                << get<2>(t) << \",\" << get<3>(t);\n                return ss.str();\n        }", "88": "string shortestCommonSupersequence(string str1, string str2) {\n                vector<vector<int>> dp(2, vector<int>(str2.size() + 1));\n                vector<vector<tuple<int, int, char>>> bt(str1.size() + 1,\n                                                                                                vector<tuple<int, int, char>>(str2.size() + 1));\n                for (int i = 0; i < str1.length(); ++i) {\n                        bt[i + 1][0] = {i, 0, str1[i]};\n                }\n                for (int j = 0; j < str2.length(); ++j) {\n                        bt[0][j + 1] = {0, j, str2[j]};\n                }\n                for (int i = 0; i < str1.length(); ++i) {\n                        for (int j = 0; j < str2.length(); ++j) {\n                                if (dp[i % 2][j + 1] > dp[(i + 1) % 2][j]) {\n                                        dp[(i + 1) % 2][j + 1] = dp[i % 2][j + 1];\n                                        bt[i + 1][j + 1] = {i, j + 1, str1[i]};\n                                } else {\n                                        dp[(i + 1) % 2][j + 1] = dp[(i + 1) % 2][j];\n                                        bt[i + 1][j + 1] = {i + 1, j, str2[j]};\n                                }\n                                if (str1[i] != str2[j]) {\n                                        continue;\n                                }\n                                if (dp[i % 2][j] + 1 > dp[(i + 1) % 2][j + 1]) {\n                                        dp[(i + 1) % 2][j + 1] = dp[i % 2][j] + 1;\n                                        bt[i + 1][j + 1] = {i, j, str1[i]};\n                                }\n                        }\n                }\n                int i = str1.length(), j = str2.length();\n                char c = 0;\n                string result;\n                while (i != 0 j != 0) {\n                        tie(i, j, c) = bt[i][j];\n                        result.push_back(c);\n                }\n                reverse(result.begin(), result.end());\n                return result;\n        }", "89": "int numWays(vector<string>& words, string target) {\n                static const int MOD = 1e9 + 7;\n                vector<uint64_t> dp(size(target) + 1); \n                dp[0] = 1;\n                for (int i = 0; i < size(words[0]); ++i) {\n                        vector<int> count(26);\n                        for (const auto& w : words) {\n                                ++count[w[i] - 'a'];\n                        }\n                        for (int j = size(target) - 1; j >= 0; --j) {\n                                dp[j + 1] += dp[j] * count[target[j] - 'a'] % MOD;\n                        }\n                }\n                return dp.back() % MOD;\n        }", "90": "int removeDuplicates(vector<int>& nums) {\n                if (nums.empty()) {\n                        return 0;\n                }\n                const int k = 2; \n                int left = 0;\n                int right = 1;\n                while (right < nums.size()) {\n                        if (nums[left] != nums[right] ||\n                                (left - k + 1 < 0 nums[left] != nums[left - k + 1])) {\n                                ++left;\n                                nums[left] = nums[right];\n                        }\n                        ++right;\n                }\n                return left + 1; \n        }", "91": "int minMoves(vector<int>& nums) {\n                return accumulate(nums.cbegin(), nums.cend(), 0) -\n                        nums.size() * *min_element(nums.cbegin(), nums.cend());\n        }", "92": "bool isOneBitCharacter(vector<int>& bits) {\n                auto parity = 0;\n                for (int i = static_cast<int>(bits.size()) - 2; i >= 0 && bits[i]; --i) {\n                        parity ^= bits[i];\n                }\n                return parity == 0;\n        }", "93": "string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) { \n                UnionFind union_find(s.length());\n                for (const auto& pair : pairs) {\n                        union_find.union_set(pair[0], pair[1]);\n                }\n                unordered_map<int, vector<char>> components;\n                for (int i = 0; i < s.length(); ++i) {\n                        components[union_find.find_set(i)].emplace_back(s[i]);\n                }\n                for (auto& [i, list] : components) {\n                        sort(list.begin(), list.end(), greater<char>());\n                }\n                for (int i = 0; i < s.length(); ++i) {\n                        const auto& j = union_find.find_set(i);\n                        s[i] = components[j].back();\n                        components[j].pop_back();\n                }\n                return s;\n        }", "94": "string toHex(int num) {\n                if (!num) {\n                        return \"0\";\n                }\n                string result;\n                while (num && result.length() != sizeof(int) * 2) {\n                        int hex = num & 15;\n                        if (hex < 10) {\n                                result.push_back('0' + hex);\n                        } else {\n                                result.push_back('a' + hex - 10);\n                        }\n                        num >>= 4;\n                }\n                reverse(result.begin(), result.end());\n                return result;\n        }", "95": "TreeNode* addOneRow(TreeNode* root, int v, int d) {\n                if (d == 0 d == 1) {\n                        auto node = new TreeNode(v);\n                        (d == 1 ? node->left : node->right) = root;\n                        return node;\n                }\n                if (root && d >= 2) {\n                        root->left = addOneRow(root->left, v, d > 2 ? d - 1 : 1);\n                        root->right = addOneRow(root->right, v, d > 2 ? d - 1 : 0);\n                }\n                return root;\n        }", "96": "vector<string> binaryTreePaths(TreeNode* root) {\n                vector<string> result;\n                vector<TreeNode *> path;\n                binaryTreePathsRecu(root, &path, &result);\n                return result;\n        }\nvoid binaryTreePathsRecu(TreeNode *node, vector<TreeNode *> *path, vector<string> *result) {\n                if (!node) {\n                        return;\n                }\n                if (!node->left && !node->right) {\n                        string ans = \"\";\n                        for (const auto& n : *path) {\n                                ans.append(to_string(n->val).append(\"->\"));\n                        }\n                        result->emplace_back(move(ans.append(to_string(node->val))));\n                }\n                if (node->left) {\n                        path->emplace_back(node);\n                        binaryTreePathsRecu(node->left, path, result);\n                        path->pop_back();\n                }\n                if (node->right) {\n                        path->emplace_back(node);\n                        binaryTreePathsRecu(node->right, path, result);\n                        path->pop_back();\n                }\n        }", "97": "int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n                unordered_map<int, vector<int>> graph;\n                for (const auto& edge : edges) {\n                        graph[edge[0]].emplace_back(edge[1]);\n                        graph[edge[1]].emplace_back(edge[0]);\n                }\n                using RET = pair<int, int>;\n                RET result{};\n                vector<tuple<int, int, int, shared_ptr<RET>, RET *>> stk = {{1, -1, 0, nullptr, &result}};\n                while (!stk.empty()) {\n                        const auto [step, par, node, new_ret, ret] = stk.back(); stk.pop_back();\n                        if (step == 1) {\n                                ret->second = int(hasApple[node]);\n                                for (const auto& nei : graph[node]) {\n                                        if (nei == par) {\n                                                continue;\n                                        }\n                                        const auto& new_ret = make_shared<RET>();\n                                        stk.emplace_back(2, -1, -1, new_ret, ret);\n                                        stk.emplace_back(1, node, nei, nullptr, new_ret.get());\n                                }\n                        } else {\n                                ret->first += new_ret->first + new_ret->second;\n                                ret->second |= bool(new_ret->first + new_ret->second);\n                        }\n                }\n                return 2 * result.first;\n        }", "98": "bool isSolvable(vector<string>& words, string result) {\n                for (auto& w : words) {\n                        reverse(w.begin(), w.end());\n                }\n                reverse(result.begin(), result.end());\n                unordered_map<char, int> lookup;\n                unordered_set<int> used;\n                return backtracking(words, result, 0, 0, 0, &lookup, &used);\n        }\nbool backtracking(const vector<string>& words, const string& result, int i, int j, int carry, unordered_map<char, int> *lookup, unordered_set<int> *used) {\n                if (j == result.length()) {\n                        return carry == 0;\n                }\n                if (i != words.size()) {\n                        if (j >= words[i].length() || lookup->count(words[i][j])) {\n                                return backtracking(words, result, i + 1, j, carry, lookup, used);\n                        }\n                        for (int val = 0; val < 10; ++val) {\n                                if (used->count(val) || (val == 0 && j == words[i].length() - 1)) {\n                                        continue;\n                                }\n                                (*lookup)[words[i][j]] = val;\n                                used->emplace(val);\n                                if (backtracking(words, result, i + 1, j, carry, lookup, used)) {\n                                        return true;\n                                }\n                                used->erase(val);\n                                lookup->erase(words[i][j]);\n                        }\n                        return false;\n                }\n                const auto& total = accumulate(words.cbegin(), words.cend(), carry,\n                                                                        [&j, &lookup](const auto& x, const auto& y) {\n                                                                                return (j < y.length()) ? x + (*lookup)[y[j]] : x; });\n                carry = total / 10;\n                int val = total % 10;\n                if (lookup->count(result[j])) {\n                        return val == (*lookup)[result[j]] &&\n                                backtracking(words, result, 0, j + 1, carry, lookup, used);\n                }\n                if (used->count(val) || (val == 0 && j == result.length() - 1)) {\n                        return false;\n                }\n                (*lookup)[result[j]] = val;\n                used->emplace(val);\n                if (backtracking(words, result, 0, j + 1, carry, lookup, used)) {\n                        return true;\n                }\n                used->erase(val);\n                lookup->erase(result[j]);\n                return false;\n        }", "99": "vector<int> fallingSquares(vector<vector<int>>& positions) {\n                vector<int> result;\n                map<int, int> heights;\n                int maxH = heights[-1] = 0;\n                for (const auto& p : positions) {\n                        auto it0 = heights.upper_bound(p[0]);\n                        auto it1 = heights.lower_bound(p[0] + p[1]);\n                        int h0 = prev(it0)->second;\n                        int h1 = prev(it1)->second;\n                        for (auto it = it0; it != it1; ++it) {\n                                h0 = max(h0, it->second);\n                        }\n                        heights.erase(it0, it1);\n                        heights[p[0]] = h0 + p[1];\n                        heights[p[0] + p[1]] = h1;\n                        maxH = max(maxH, h0 + p[1]);\n                        result.emplace_back(maxH);\n                }\n                return result;\n        }\n"}, "Java": {"0": "public int minCostToMoveChips(int[] chips) {\n        int[] count = new int[2];\n        for (int p : chips) {\n                ++count[p % 2];\n        }\n        return Math.min(count[0], count[1]);\n}", "1": "public int pseudoPalindromicPaths (TreeNode root) {\n        int result = 0;\n        Deque<Pair<TreeNode, Integer>> stk = new ArrayDeque<>();\n        stk.add(new Pair<>(root, 0));\n        while (!stk.isEmpty()) {\n                Pair<TreeNode, Integer> temp = stk.removeLast();\n                TreeNode node = temp.getKey();\n                int count = temp.getValue();\n                if (node == null) {\n                        continue;\n                }\n                count ^= 1 << node.val;\n                result += !node.left && !node.right && (count & (count - 1)) == 0 ? 1 : 0;\n                stk.add(new Pair<>(node.right, count));\n                stk.add(new Pair<>(node.left, count));\n        }\n        return result;\n}", "2": "public static ArrayList<Integer> minOperations(String boxes) {\n        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int i = 0, accu = 0, cnt = 0; i < boxes.length(); ++i) {\n        result.add(i,accu);\n        cnt += (boxes.charAt(i) == '1') ? 1 : 0;\n        accu += cnt;\n        }\n        for (int i = boxes.length() - 1, accu = 0, cnt = 0; i >= 0; --i) {\n                result.set(i,result.get(i)+accu);\n                cnt += (boxes.charAt(i) == '1') ? 1 : 0;\n                accu += cnt;\n        }\n        return result;\n}", "3": "public int largestPalindrome(int n) {\n        if (n == 1) {\n                return 9;\n        }\n        long upper = (long) Math.pow(10, n) - 1;\n        for (int k = 2; k <= upper; ++k) {\n                long left = (long) Math.pow(10, n) - k;\n                String s = Long.toString(left);\n                String reverse = new StringBuilder(s).reverse().toString();\n                long right = Long.valueOf(reverse);\n                long d = k * k - right * 4;\n                if (d < 0) {\n                        continue;\n                }\n                if (Math.sqrt(d) == (long) Math.sqrt(d) && k % 2 == (long) Math.sqrt(d) % 2) {\n                        return (int) ((left * (long) Math.pow(10, n)) + right) % 1337;\n                }\n        }\n        return -1;\n}\n\npublic long buildPalindrome(int n) {\n        String s = Integer.toString(n);\n        String reverse = new StringBuilder(s).reverse().toString();\n        return Long.valueOf(s + reverse);\n}", "4": "public static int minOperations(String s) {\n                int cnt = 0;\n                for (int i = 0; i < s.length(); ++i) {\n                        if (s.charAt(i) - '0' == i % 2) {\n                                ++cnt;\n                        }\n                }\n                return Math.min(cnt, s.length() - cnt);\n        }", "5": "public static int numberOfRounds(String startTime, String finishTime) {\n                int start = Integer.parseInt(startTime.substr(0, 2)) * 60 + Integer.parseInt(startTime.substr(3));\n                int finish = Integer.parseInt(finishTime.substr(0, 2)) * 60 + Integer.parseInt(finishTime.substr(3));\n                if (start > finish) {\n                        finish += 1440;\n                }\n                return Math.max(finish / 15 - (start + 15 - 1) / 15, 0);\n        }", "6": "public int smallestRangeII(int[] A, int K) {\n        Arrays.sort(A);\n        int result = A[A.length - 1] - A[0];\n        for (int i = 0; i < A.length - 1; ++i) {\n                result = Math.min(result, \n                                        Math.max(A[A.length - 1] - K, A[i] + K) - \n                                        Math.min(A[0] + K, A[i + 1] - K));\n        }\n        return result;\n}", "7": "public class TrieNode {\n        Map<Character, TrieNode> leaves = new HashMap<>();\n        boolean isString = false;\n\npublic boolean insert(String s) {\n        TrieNode* p = this;\n        for (char c : s.toCharArray()) {\n                if (!p.leaves.containsKey(c)) {\n                        p.leaves.put(c, new TrieNode());\n                }\n                p = p.leaves.get(c);\n        }\n        return !p.isString;\n}\n}\npublic class Solution {\npublic List<String> findWords(char[][] board, String[] words) {\n        List<String> ret = new ArrayList<>();\n        TrieNode trie = new TrieNode();\n        for (String word : words) {\n                if (!trie.insert(word)) {\n                        continue;\n                }\n                char[][] bd = board.clone();\n                if (exist(0, 0, word, bd, trie)) {\n                        ret.add(word);\n                }\n        }\n        return ret;\n}\n\npublic boolean exist(int i, int j, String word, char[][] board, TrieNode trie) {\n        if (trie == null || i < 0 || i >= board.length || j < 0 || j >= board[0].length) {\n                return false;\n        }\n        if (!trie.leaves.containsKey(board[i][j]) || board[i][j] == '#') {\n                return false;\n        }\n        TrieNode next = trie.leaves.get(board[i][j]);\n        if (next.isString) {\n                return word.length() == 1;\n        }\n        board[i][j] = '#';\n        boolean exist = exist(i - 1, j, word.substring(1), board, next)\n        || exist(i + 1, j, word.substring(1), board, next)\n        || exist(i, j - 1, word.substring(1), board, next)\n        || exist(i, j + 1, word.substring(1), board, next);\n        board[i][j] = word.charAt(0);\n        return exist;\n}\n}", "8": "public List<List<Integer>> findSubsequences(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> seq = new ArrayList<>();\n        findSubsequencesHelper(nums, 0, seq, result);\n        return result;\n}\n\npublic void findSubsequencesHelper(int[] nums, int i, List<Integer> seq, List<List<Integer>> result) {\n        if (seq.size() >= 2) {\n                result.add(seq);\n        }\n        Set<Integer> lookup = new HashSet<>();\n        for (; i < nums.length; ++i) {\n                if ((seq.isEmpty() || nums[i] >= seq.get(seq.size() - 1)) &&\n                        !lookup.contains(nums[i])) {\n                        lookup.add(nums[i]);\n                        seq.add(nums[i]);\n                        findSubsequencesHelper(nums, i + 1, seq, result);\n                        seq.remove(seq.size() - 1);\n                }\n        }\n}", "9": "public static int minimumEffort(List<List<Integer>> tasks) {\n        tasks.sort((a, b) -> { return a.get(1) - a.get(0) < b.get(1) - b.get(0); });\n        int result = 0;\n        for (List<Integer> task : tasks) {\n                result = Math.max(result + task.get(0), task.get(1));\n        }\n        return result;\n}", "10": "public static int minStickers(String[] stickers, String target) {\n        int N = target.length();\n        int[] targetCount = new int[26];\n        for (char c : target.toCharArray()) targetCount[c-'a']++;\n\n        int M = stickers.length;\n        int[][] stickerCount = new int[M][26];\n        for (int i = 0; i < M; i++)\n            for (char c : stickers[i].toCharArray())\n                stickerCount[i][c-'a']++;\n\n        Map<String, Integer> dp = new HashMap();\n        dp.put(\"\", 0);\n\n        Queue<String> queue = new LinkedList();\n        queue.add(\"\");\n        while (!queue.isEmpty()) {\n            String curr = queue.poll();\n            int currCount = dp.get(curr);\n            for (int i = 0; i < M; i++) {\n                // try to use sticker i\n                if (curr.indexOf(stickers[i].charAt(0)) == -1) {\n                    // optimization\n                    String next = curr;\n                    for (int k = 0; k < 26; k++)  // apply sticker i\n                        next = next + Math.max(0, stickerCount[i][k] - currCount[k]);\n\n                    if (!dp.containsKey(next)) {\n                        dp.put(next, currCount + 1);\n                        queue.add(next);\n                    }\n                }\n            }\n        }\n\n        return dp.getOrDefault(target, -1);\n    }", "11": "public static int minSubarray(List<Integer> nums, int p) {\n        int residue = 0;\n        for (int num : nums) {\n                residue = (residue + num) % p;\n        }\n        if (residue == 0) {\n                return 0;\n        }\n        int result = nums.size();\n        Map<Integer, Integer> lookup = new HashMap<>();\n        lookup.put(0, -1);\n        for (int i = 0, curr = 0; i < nums.size(); ++i) {\n                curr = (curr + nums.get(i)) % p;\n                lookup.put(curr, i);\n                if (lookup.containsKey((curr - residue + p) % p)) {\n                        result = Math.min(result, i - lookup.get((curr - residue + p) % p));\n                }\n        }\n        return result < nums.size() ? result : -1;\n}", "12": "public class Solution {\n    public List<Integer> distributeCandies(int candies, int num_people) {\n        int p = (int) (Math.sqrt(2*candies + 0.25) - 0.5);\n        int remaining = candies - (p + 1) * p / 2;\n        int rows = p / num_people, cols = p % num_people;\n        \n        List<Integer> result = new ArrayList<Integer>();\n        \n        for(int i = 0; i < num_people; i++) {\n            result.add((i < cols) ? (i + 1) * (rows + 1) + (rows * (rows + 1) / 2) * num_people\n                                                                : (i + 1) * rows + ((rows - 1) * rows / 2) * num_people);\n        }\n        \n        result.set(cols, result.get(cols) + remaining);\n        return result;\n    }\n}", "13": "public int totalFruit(int[] tree) {\n        HashMap<Integer, Integer> count = new HashMap<Integer, Integer>();\n        int result = 0;\n        for (int i = 0, j = 0; j < tree.length; ++j) {\n                count.put(tree[j], count.getOrDefault(tree[j], 0) + 1);\n                while (count.size() > 2) {\n                        count.put(tree[i], count.get(tree[i]) - 1);\n                        if (count.get(tree[i]) == 0) {\n                                count.remove(tree[i]);\n                        }\n                        ++i;\n                }\n                result = Math.max(result, j - i + 1);\n        }\n        return result;\n}", "14": "public static int threeSumMulti(int[] A, int target) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int a : A) {\n                count.put(a, count.getOrDefault(a, 0) + 1);\n        }\n        int result = 0;\n        for (Map.Entry<Integer, Integer> kvp1 : count.entrySet()) {\n                for (Map.Entry<Integer, Integer> kvp2 : count.entrySet()) {\n                        int i = kvp1.getKey(), j = kvp2.getKey(), k = target - i - j;\n                        if (!count.containsKey(k)) {\n                                continue;\n                        }\n                        if (i == j && j == k) {\n                                result += count.get(i) * (count.get(i) - 1) * (count.get(i) - 2) / 6;\n                        } else if (i == j && j != k) {\n                                result += count.get(i) * (count.get(i) - 1) / 2 * count.get(k);\n                        } else if (i < j && j < k) {\n                                result += count.get(i) * count.get(j) * count.get(k);\n                        }\n                }\n        }\n        return result % (int)(1e9 + 7);\n}", "15": "public static int hammingWeight(int n) {\n                n = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n                n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n                n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F);\n                n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF);\n                n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF);\n                return n;\n        }", "16": "public class Solution {\n    public int leastBricks(List<List<Integer>> wall) {\n        HashMap<Integer, Integer> widths = new HashMap<>();\n        int result = wall.size();\n        for (List<Integer> row : wall) {\n            for (int i = 0, width = 0; i < row.size() - 1; ++i) {\n                result = Math.min(result, wall.size() - (widths.getOrDefault(width += row[i], 0)++));\n            }\n        }\n        return result;\n    }\n}", "17": "public static int closedIsland(int[][] grid) {\n        for (int j = 0; j < grid[0].length; ++j) {\n                fill(grid, 0, j);\n                fill(grid, grid.length - 1, j);\n        }\n        for (int i = 1; i + 1 < grid.length; ++i) {\n                fill(grid, i, 0);\n                fill(grid, i, grid[0].length - 1);\n        }\n        int result = 0;\n        for (int i = 1; i + 1 < grid.length; ++i) {\n                for (int j = 1; j + 1 < grid[0].length; ++j) {\n                        if (fill(grid, i, j)) {\n                                ++result;\n                        }\n                }\n        }\n        return result;\n}\npublic static boolean fill(int[][] grid, int i, int j) {\n        static int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        if (i < 0 || j < 0 ||\n                i >= grid.length || j >= grid[i].length ||\n                grid[i][j]) {\n                return false;\n        }\n        grid[i][j] = 1;\n        for (int[] d : directions) {\n                fill(grid, i + d[0], j + d[1]);\n        }\n        return true;\n}", "18": "public class Main {\n        public static boolean find132pattern(int[] nums) {\n                int ak = Integer.MIN_VALUE;\n                Stack<Integer> st = new Stack<>();\n                for (int i = nums.length - 1; i >= 0; --i) {\n                        if (nums[i] < ak) {\n                                return true;\n                        } else {\n                                while (!st.isEmpty() && nums[i] > st.peek()) {\n                                        ak = st.peek();\n                                        st.pop();\n                                }\n                        }\n                        st.push(nums[i]);\n                }\n                return false;\n        }\n}", "19": "public List<List<Integer>> imageSmoother(int[][] M) {\n        int rows = M.length;\n        int cols = M[0].length;\n        \n        List<List<Integer>> result = new ArrayList<List<Integer>>(rows);\n        for (int i = 0; i < rows; i++) {\n                List<Integer> row = new ArrayList<Integer>(cols);\n                for (int j = 0; j < cols; j++) {\n                        row.add(getGray(M, i, j));\n                }\n                result.add(row);\n        }\n        \n        return result;\n}\n\npublic int getGray(int[][] M, int i, int j) {\n        int rows = M.length;\n        int cols = M[0].length;\n        \n        double total = 0.0;\n        int count = 0;\n        \n        for (int r = -1; r < 2; r++) {\n                for (int c = -1; c < 2; c++) {\n                        int ii = i + r;\n                        int jj = j + c;\n                        \n                        if (0 <= ii && ii < rows && 0 <= jj && jj < cols) {\n                                total += M[ii][jj];\n                                ++count;\n                        }\n                }\n        }\n        \n        return (int) (total / count);\n}", "20": "public class Main {\n\n        public static int findMaxForm(List<String> strs, int m, int n) {\n                int[][] dp = new int[m + 1][n + 1];\n\n                for (String str : strs) {\n                        int zero_count = 0, one_count = 0;\n                        for (int i = 0; i < str.length(); i++) {\n                                if (str.charAt(i) == '0') {\n                                        zero_count++;\n                                } else if (str.charAt(i) == '1') {\n                                        one_count++;\n                                }\n                        }\n\n                        for (int i = m; i >= zero_count; i--) {\n                                for (int j = n; j >= one_count; j--) {\n                                        dp[i][j] = Math.max(dp[i][j], dp[i - zero_count][j - one_count] + 1);\n                                }\n                        }\n                }\n                return dp[m][n];\n        }\n\n        public static void main(String[] args) {\n                List<String> strs = new ArrayList<>();\n                strs.add(\"10\");\n                strs.add(\"0001\");\n                strs.add(\"111001\");\n                strs.add(\"1\");\n                strs.add(\"0\");\n\n                System.out.println(findMaxForm(strs, 5, 3));\n        }\n}", "21": "public class TopVotedCandidate {\n    private List<Pair<Integer, Integer>> lookup;\n    \n    public TopVotedCandidate(int[] persons, int[] times) {\n        lookup = new ArrayList<>();\n        Map<Integer, Integer> count = new HashMap<>();\n        int lead = -1;\n        for (int i = 0; i < persons.length; i++) {\n            if (++count[persons[i]] >= count[lead]) {\n                lead = persons[i];\n                lookup.add(new Pair(times[i], persons[i]));\n            }\n        }\n    }\n    \n    public int q(int t) {\n        return lookup.get(Collections.binarySearch(lookup, new Pair<>(t, null), (a, b) -> a.getKey() - b.getKey())).getValue();\n    }\n}", "22": "public static int maxDepth(TreeNode root) {\n        if (!root) {\n                return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n}", "23": "public class Solution {\n    public int characterReplacement(String s, int k) {\n                int result = 0, max_count = 0;\n                Map<Character, Integer> count = new HashMap<>();\n                for (int i = 0; i < s.length(); ++i) {\n                        count.put(s.charAt(i), count.getOrDefault(s.charAt(i), 0) + 1);\n                        max_count = Math.max(max_count, count.get(s.charAt(i)));\n                        if (result - max_count >= k) {\n                                count.put(s.charAt(i-result), count.get(s.charAt(i-result))--);\n                        } else {\n                                ++result;\n                        }\n                }\n                return result;\n        }\n}", "24": "public int findPoisonedDuration(int[] timeSeries, int duration) {\n        int result = duration * timeSeries.length;\n        for (int i = 1; i < timeSeries.length; ++i){\n                result -= Math.max(0, duration - (timeSeries[i] - timeSeries[i - 1]));\n        }\n        return result;\n}", "25": "public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n                if ((nums1.length + nums2.length) % 2 == 1) {\n                        return findKthInTwoSortedArrays(nums1, nums2, (nums1.length + nums2.length) / 2 + 1);\n                } else {\n                        return (findKthInTwoSortedArrays(nums1, nums2, (nums1.length + nums2.length) / 2) +\n                                        findKthInTwoSortedArrays(nums1, nums2, (nums1.length + nums2.length) / 2 + 1)) / 2.0;\n                }\n        }\npublic int findKthInTwoSortedArrays(int[] A, int[] B, int k) {\n                int m = A.length;\n                int n = B.length;\n                if (m > n) {\n                        return findKthInTwoSortedArrays(B, A, k);\n                }\n                int left = 0;\n                int right = m - 1;\n                while (left <= right) {\n                        int mid = left + (right - left) / 2;\n                        if (0 <= k - 1 - mid && k - 1 - mid < n && A[mid] >= B[k - 1 - mid]) {\n                                right = mid - 1;\n                        } else {\n                                left = mid + 1;\n                        }\n                }\n                int Ai_minus_1 = left - 1 >= 0 ? A[left - 1] : Integer.MIN_VALUE;\n                int Bj = k - 1 - left >= 0 ? B[k - 1 - left] : Integer.MIN_VALUE;\n                return Math.max(Ai_minus_1, Bj);\n        }", "26": "public class FractionAddition {\n        public static String fractionAddition(String expression) {\n                Scanner iss = new Scanner(expression);\n                int A = 0, B = 1, a, b;\n                char _;\n                while (iss.hasNext()) {\n                        a = iss.nextInt();\n                        _ = iss.next().charAt(0);\n                        b = iss.nextInt();\n                        A = A * b + a * B;\n                        B *= b;\n                        int g = Math.abs(gcd(A, B));\n                        A /= g;\n                        B /= g;\n                }\n                return A + \"/\" + B;\n        }\n}", "27": "public class Main {\n    public static void main(String[] args) {\n        int[][] grid = {{1,2,3}, {4,5,6}, {7,8,9}};\n        int k = 1;\n        rotate(&grid, k);\n        return grid;\n    }\n    public static void rotate(int[][] *grid, int k) {\n                k %= grid->length * grid[0].length;\n                reverse(grid, 0, grid->length * grid[0].length);\n                reverse(grid, 0, k);\n                reverse(grid, k, grid->length * grid[0].length);\n        }\n    public static void reverse(int[][] *grid, int start, int end) {\n                for (; start < end; ++start, --end) {\n                        int start_r = start / grid[0].length;\n                        int start_c = start % grid[0].length;\n                        int end_r = (end - 1) / grid[0].length;\n                        int end_c = (end - 1) % grid[0].length;\n                        swap(grid[start_r][start_c], grid[end_r][end_c]);\n                }\n        }\n}", "28": "public class ReorderedPowerOf2 {\n        public static boolean reorderedPowerOf2(int N) {\n                ArrayList<Integer> count = counter(N);\n                for (int i = 0; i < 31; ++i) {\n                        if (count == counter(1 << i)) {\n                                return true;\n                        }\n                }\n                return false;\n        }\npublic static ArrayList<Integer> counter(int N) {\n                ArrayList<Integer> result = new ArrayList<Integer>();\n                for (int i = 0; i < 10; ++i) {\n                        result.add(0);\n                }\n                for (; N; N /= 10) {\n                        ++result.get(N % 10);\n                }\n                return result;\n        }\n}", "29": "public static boolean canConstruct(String s, int k){\n        if(k > s.length()) return false;\n        int[] count = new int[26];\n        for(int i = 0; i< s.length(); i++){\n                count[s.charAt(i) - 'a']++;\n        }\n        int oddCount = 0;\n        for(int c : count){\n                if(c % 2 == 1){\n                        oddCount++;\n                }\n        }\n        return oddCount <= k;\n}", "30": "public static char[][] rotateTheBox(char[][] box) {\n                char[][] result = new char[box[0].length][box.length];\n                for (int i = 0; i < box.length; ++i) {\n                        for (int j = box[0].length - 1, k = box[0].length - 1; j >= 0; --j) {\n                                if (box[i][j] == '.') {\n                                        continue;\n                                }\n                                if (box[i][j] == '*') {\n                                        k = j;\n                                }\n                                result[k--][box.length -1 - i] = box[i][j];\n                        }\n                }\n                return result;\n        }", "31": "public class Main {\n        public static void main(String[] args) {\n                String beginWord = \"hit\";\n                String endWord = \"cog\";\n                String[] wordList = {\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"};\n                List<List<String>> ladders = findLadders(beginWord, endWord, wordList);\n                for (List<String> ladder : ladders) {\n                        for (String word : ladder) {\n                                System.out.print(word + \" \");\n                        }\n                        System.out.println();\n                }\n        }\n}", "32": "public static int makeStringSorted(String s) { \n                final int MOD = 1e9 + 7;\n                int[] count = new int[26];\n                int result = 0, comb_total = 1;\n                for (int i = s.length() - 1; i >= 0; --i) {\n                        int num = s.charAt(i) - 'a';\n                        comb_total = (int)(((long)comb_total * (s.length() - i) % MOD) * inverse(++count[num], MOD)) % MOD;\n                        result = (result + ((comb_total * Arrays.stream(count).limit(num).sum() % MOD) * inverse(s.length() - i, MOD) % MOD)) % MOD;\n                }\n                return result;\n        }\npublic static int inverse(int n, int m) {\n                List<Integer> inv = new ArrayList<>(Arrays.asList(0, 1));\n                for (int i = inv.size(); i <= n; ++i) { \n                        inv.add(inv.get(m % i) * (m - m / i) % m); \n                }\n                return inv.get(n);\n        }", "33": "public static int findLUSlength(String a, String b) {\n        if (a.equals(b)) {\n                return -1;\n        }\n        return Math.max(a.length(), b.length());\n}", "34": "public String simplifyPath(String path) {\n        List<String> names = new ArrayList<>();\n        List<String> tokens = split(path, '/');\n        for (String token : tokens) {\n                if (token.equals(\"..\") && !names.isEmpty()) {\n                        names.pop();\n                } else if (!token.equals(\"..\") && !token.equals(\".\") && !token.isEmpty()) {\n                        names.add(token);\n                }\n        }\n        return \"/\".concat(join(names, '/'));\n}\nList<String> split(String s, char delim) {\n        List<String> tokens = new ArrayList<>();\n        StringTokenizer ss = new StringTokenizer(s, delim);\n        while (ss.hasMoreTokens()) {\n                tokens.add(ss.nextToken());\n        }\n        return tokens;\n}\nString join(List<String> names, char delim) {\n        StringBuilder ss = new StringBuilder();\n        if (!names.isEmpty()) {\n                for (int i = 0; i < names.size() - 1; ++i) {\n                        ss.append(names.get(i)).append(delim);\n                }\n                ss.append(names.get(names.size() - 1));\n        }\n        return ss.toString();\n}", "35": "public class Main {\n \n  public static int maximumSwap(int num) {\n                String digits = Integer.toString(num);\n                int left = 0, right = 0;\n                int max_idx = digits.length() - 1;\n                for (int i = digits.length() - 1; i >= 0; --i) {\n                        if (digits.charAt(i) > digits.charAt(max_idx)) {\n                                max_idx = i;\n                        } else if (digits.charAt(max_idx) > digits.charAt(i)) {\n                                left = i;\n                                right = max_idx;\n                        }\n                }\n                StringBuilder sb = new StringBuilder(digits);\n                sb.setCharAt(left, digits.charAt(right));\n                sb.setCharAt(right, digits.charAt(left));\n                return Integer.parseInt(sb.toString());\n        }\n \n  public static void main(String[] args) {\n    System.out.println(maximumSwap(2736));\n    System.out.println(maximumSwap(9973));\n  }\n}", "36": "public class reachableNodes {\n    public static int reachableNodes(vector<vector<int>>& edges, int M, int N) {\n                using P = pair<int, int>;\n                vector<vector<P>> adj(N);\n                for (const auto& edge: edges) {\n                        int u = edge[0], v = edge[1], w = edge[2];\n                        adj[u].emplace_back(v, w);\n                        adj[v].emplace_back(u, w);\n                }\n                unordered_map<int, int> best;\n                best[0] = 0;\n                unordered_map<int, unordered_map<int, int>> count;\n                int result = 0;\n                priority_queue<P, vector<P>, greater<P>> min_heap;\n                min_heap.emplace(0, 0);\n                while (!min_heap.empty()) {\n                        int curr_total, u;\n                        tie(curr_total, u) = min_heap.top(); min_heap.pop();\n                        if (best.count(u) && best[u] < curr_total) {\n                                continue;\n                        }\n                        ++result;\n                        for (const auto& kvp: adj[u]) {\n                                int v, w;\n                                tie(v, w) = kvp;\n                                count[u][v] = min(w, M - curr_total);\n                                int next_total = curr_total + w + 1;\n                                if (next_total <= M && \n                                        (!best.count(v) next_total < best[v])) {\n                                        best[v] = next_total;\n                                        min_heap.emplace(next_total, v);\n                                }\n                        }\n                }\n                for (const auto& edge: edges) {\n                        int u = edge[0], v = edge[1], w = edge[2];\n                        result += min(w, count[u][v] + count[v][u]);\n                }\n                return result;\n        }\n}", "37": "public static int minDeletions(String s) {\n                int[] count = new int[26];\n                for (char c : s.toCharArray()) {\n                        ++count[c - 'a'];\n                }\n                int result = 0;\n                Set<Integer> lookup = new HashSet<>();\n                for (int i = 0; i < 26; ++i) {\n                        for (int c = count[i]; c > 0; --c, ++result) {\n                                if (!lookup.contains(c)) {\n                                        lookup.add(c);\n                                        break;\n                                }\n                        }\n                }\n                return result;\n        }", "38": "public static boolean isMonotonic(int[] A) {\n        boolean inc = false, dec = false;\n        for (int i = 0; i + 1 < A.length; ++i) {\n                if (A[i] < A[i + 1]) {\n                        inc = true;\n                } else if (A[i] > A[i + 1]) {\n                        dec = true;\n                }\n        }\n        return !inc || !dec;\n}", "39": "public int hIndex(int[] citations) {\n        int n = citations.length;\n        int[] count = new int[n+1];\n        for (int i = 0; i < n; i++) {\n            if (citations[i] >= n) {\n                count[n]++;\n            } else {\n                count[citations[i]]++;\n            }\n        }\n        int h = 0;\n        for (int i = n; i >= 0; i--) {\n            h += count[i];\n            if (h >= i) {\n                return i;\n            }\n        }\n        return h;\n    }", "40": "public int lastRemaining(int n) {\n        int start = 1;\n        for (int step = 2, direction = 1; n > 1; n /= 2, step *= 2, direction *= -1) {\n                start += direction * (step * (n / 2) - step / 2);\n        }\n        return start;\n}", "41": "public int minimumJumps(int[] forbidden, int a, int b, int x) {\n                int max_f = Arrays.stream(forbidden).max().getAsInt();\n                int max_val = (a >= b) ? x + b : Math.max(x, max_f) + a + b; \n                List<Set<Integer>> lookup = new ArrayList<>(2); \n                lookup.add(0, new HashSet<Integer>());\n                lookup.add(1, new HashSet<Integer>());\n                for (int pos : forbidden) {\n                        lookup.get(0).add(pos);\n                        lookup.get(1).add(pos);\n                }\n                int result = 0;\n                List<Pair<Integer, Boolean>> q = new ArrayList<>();\n                q.add(new Pair(0, true));\n                lookup.get(0).add(0);\n                while (!q.isEmpty()) {\n                        List<Pair<Integer, Boolean>> new_q = new ArrayList<>();\n                        for (Pair<Integer, Boolean> p : q) {\n                                int pos = p.getKey();\n                                boolean can_back = p.getValue();\n                                if (pos == x) {\n                                        return result;\n                                }\n                                if (pos + a <= max_val && !lookup.get(0).contains(pos + a)) {\n                                        lookup.get(0).add(pos + a);\n                                        new_q.add(new Pair(pos + a, true));\n                                }\n                                if (!can_back) {\n                                        continue;\n                                }\n                                if (pos - b >= 0 && !lookup.get(1).contains(pos - b)) {\n                                        lookup.get(1).add(pos - b);\n                                        new_q.add(new Pair(pos - b, false));\n                                }\n                        }\n                        q = new_q;\n                        ++result;\n                }\n                return -1;\n        }", "42": "public boolean isPathCrossing(String path) {\n        HashSet<Pair> lookup = new HashSet<Pair>();\n        int x = 0;\n        int y = 0;\n        lookup.add(new Pair(x,y));\n        for (char c : path.toCharArray()) {\n                switch(c) {\n                        case 'E':\n                                x++;\n                                break;\n                        case 'W':\n                                x--;\n                                break;\n                        case 'N':\n                                y++;\n                                break;\n                        case 'S':\n                                y--;\n                                break;\n                }\n                if (!lookup.add(new Pair(x,y))) {\n                        return true;\n                }\n        }\n        return false;\n}", "43": "public boolean canBeIncreasing(vector<int> nums) {\n                boolean deleted = false;\n                for (int i = 1; i < size(nums); ++i) {        \n                        if (nums[i] > nums[i - 1]) {\n                                continue;\n                        }\n                        if (deleted) {\n                                return false;\n                        }\n                        deleted = true;\n                        if (i >= 2 && nums[i - 2] > nums[i]) { \n                                nums[i] = nums[i - 1];\n                        }\n                }\n                return true;\n        }", "44": "public static Vector earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n                Lookup lookup = new Lookup();\n                return memoization(n, firstPlayer - 1, n - secondPlayer, lookup);\n        }\npublic static Vector memoization(int t, int l, int r, Lookup lookup) {\n                if (!lookup.contains(tuple(t, l, r))) {\n                        if (l == r) {\n                                return new Vector(1, 1);\n                        }\n                        if (l > r) { \n                                int temp = l;\n                                l = r;\n                                r = temp;\n                        }\n                        Vector result = new Vector(numeric_limits<int>.max(), 0);\n                        for (int i = 0; i <= l; ++i) {\n                                int nt = (t + 1) / 2;\n                                int pair_cnt = t / 2;\n                                int l_lose_cnt = l - i;\n                                int l_win_cnt = i + 1;\n                                int min_j = Math.max(l_lose_cnt, r - (pair_cnt - l_lose_cnt)); \n                                int max_j = Math.min(r - l_win_cnt, (nt - l_win_cnt) - 1); \n                                for (int j = min_j; j <= max_j; ++j) {\n                                        Vector tmp = memoization(nt, i, j, lookup);\n                                        result.set(0, Math.min(result.get(0), tmp.get(0) + 1));\n                                        result.set(1, Math.max(result.get(1), tmp.get(1) + 1));\n                                }\n                        }\n                        lookup.put(tuple(t, l, r), result);\n                }\n                return lookup.get(tuple(t, l, r));\n        }\npublic int hashCode(Object o) {\n                        if (o == null) {\n                          return 0;\n                        }\n                        int seed = 0;\n                        if (o instanceof tuple<?, ?, ?>) {\n                                tuple<A, B, C> p = (tuple<A, B, C>) o;\n                                A a; B b; C c;\n                                tie(a, b, c) = p;\n                                seed ^= Objects.hashCode(a) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                                seed ^= Objects.hashCode(b) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                                seed ^= Objects.hashCode(c) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                        }\n                        return seed;\n                }", "45": "public class Solution {\n    public int numJewelsInStones(String J, String S) {\n        HashSet<Character> lookup = new HashSet<>();\n        for(char j: J.toCharArray()){\n            lookup.add(j);\n        }\n        int result = 0;\n        for(char s: S.toCharArray()){\n            if(lookup.contains(s)){\n                result++;\n            }\n        }\n        return result;\n    }\n}", "46": "public static int heightChecker(int[] heights) {\n        int[] sorted_heights = heights;\n        Arrays.sort(sorted_heights);\n        int result = 0;\n        for (int i = 0; i < heights.length; ++i) {\n                result += static_cast<int>(heights[i] != sorted_heights[i]);\n        }\n        return result;\n}", "47": "public static int largestSubmatrix(int[][] matrix) {\n        int result = 0;\n        for (int c = 0; c < matrix[0].length; ++c) {\n                int h = 0;\n                for (int r = 0; r < matrix.length; ++r) {\n                        h = (matrix[r][c] == 1) ? h + 1 : 0;\n                        matrix[r][c] = h;\n                }\n        }\n        for (int[] row : matrix) {\n                Arrays.sort(row);\n                for (int c = 0; c < row.length; ++c) {\n                        result = Math.max(result, (row.length - c) * row[c]);\n                }\n        }\n        return result;\n}", "48": "public class Main { \n  \n    // A utility function to print a 2D array  \n    // mat[][] \n    static void printMatrix(int mat[][]) \n    { \n        for (int i = 0; i < N; i++) \n        { \n            for (int j = 0; j < N; j++) \n                System.out.print(\" \" + mat[i][j]); \n  \n            System.out.print(\"\\n\"); \n        } \n        System.out.print(\"\\n\"); \n    } \n  \n    // This function generates all 4 rotation \n    // of a given matrix by 90 degree \n    public static void rotateby90(int mat[][]) \n    { \n        // Traverse each cycle \n        for (int i = 0; i < N / 2; i++) \n        { \n            for (int j = i; j < N - i - 1; j++) \n            { \n  \n                // Swap elements of each cycle \n                // in clockwise direction \n                int temp = mat[i][j]; \n                mat[i][j] = mat[N - 1 - j][i]; \n                mat[N - 1 - j][i] = mat[N - 1 - i][N - 1 - j]; \n                mat[N - 1 - i][N - 1 - j] = mat[j][N - 1 - i]; \n                mat[j][N - 1 - i] = temp; \n            } \n        } \n    } \n  \n    // Function for do transpose of matrix \n    public static void transpose(int mat[][]) \n    { \n        for (int i = 0; i < N; i++) \n            for (int j = i; j < N; j++) \n            { \n                int temp = mat[i][j]; \n                mat[i][j] = mat[j][i]; \n                mat[j][i] = temp; \n            } \n    } \n  \n    /* rotated[][] will be used for storing rotated \n    matrix by 90, 180 and 270 degrees */\n    public static void rotateMatrix(int mat[][], \n                                    int angle) \n    { \n        // angle must be multiple of 90 degree \n        // (otherwise we can't get a round \n        // rotated matrix) \n        if (angle % 90 != 0) { \n            System.out.print(\"Invalid angle\\n\"); \n            return; \n        } \n  \n        // Let us take angle = 90 \n        // angle = 90 \n        if (angle == 90) { \n            transpose(mat); \n            rotateby90(mat); \n        } \n  \n        // Let us take angle = 180 \n        else if (angle == 180) { \n            rotateby90(mat); \n            rotateby90(mat); \n        } \n  \n        // Let us take angle = 270 \n        else if (angle == 270) { \n            rotateby90(mat); \n            rotateby90(mat); \n            rotateby90(mat); \n        } \n    } \n  \n    // Driver Program \n    public static void main(String[] args) \n    { \n        // Test Case 1 \n        int mat[][] = \n        { \n            {1, 2, 3, 4}, \n            {5, 6, 7, 8}, \n            {9, 10, 11, 12}, \n            {13, 14, 15, 16} \n        }; \n  \n        // Tese Case 2 \n        /* int mat[][] = new int {{1, 2, 3}, \n                                {4, 5, 6}, \n                                {7, 8, 9} \n                               }; */\n        rotateMatrix(mat, 90); \n  \n        // Print rotated matrix \n        printMatrix(mat); \n    } \n}", "49": "public class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        int carry = 0;\n        while (l1 != null || l2 != null || carry != 0) {\n                int a = (l1 != null) ? l1.val : 0;\n                int b = (l2 != null) ? l2.val : 0;\n                int val = carry + a + b;\n                curr.next = new ListNode(val % 10);\n                carry = val / 10;\n                l1 = (l1 != null) ? l1.next : null;\n                l2 = (l2 != null) ? l2.next : null;\n                curr = curr.next;\n        }\n        return dummy.next;\n}", "50": "public class Solution {\n    public boolean makesquare(int[] nums) {\n                int sum = 0;\n                for (int num : nums) {\n                    sum += num;\n                }\n                if (sum % 4) {\n                        return false;\n                }\n                const auto side_len = sum / 4;\n                const auto all = (1 << nums.length) - 1;\n                List<Integer> used_subsets = new ArrayList<Integer>();\n                boolean[] valid_half_subsets = new boolean[1 << nums.length];\n                for (int subset = 0; subset <= all; ++subset) {\n                        int subset_sum = 0;\n                        for (int i = 0; i < nums.length; ++i) {\n                                if (subset & (1 << i)) {\n                                        subset_sum += nums[i];\n                                }\n                        }\n                        if (subset_sum == side_len) {\n                                for (int used_subset : used_subsets) {\n                                        if ((used_subset & subset) == 0) {\n                                                int valid_half_subset = used_subset | subset;\n                                                valid_half_subsets[valid_half_subset] = true;\n                                                if (valid_half_subsets[all ^ valid_half_subset]) {\n                                                        return true;\n                                                }\n                                        }\n                                }\n                                used_subsets.add(subset);\n                        }\n                }\n                return false;\n        }\n}", "51": "public TreeNode constructFromPrePost(int[] pre, int[] post) {\n                Stack<TreeNode> s = new Stack<>();\n                s.push(new TreeNode(pre[0]));\n                for (int i = 1, j = 0; i < pre.length; ++i) {\n                        TreeNode node = new TreeNode(pre[i]);\n                        while (s.peek().val == post[j]) {\n                                s.pop(), ++j;\n                        }\n                        if (s.peek().left == null) {\n                                s.peek().left = node;\n                        } else {\n                                s.peek().right = node;\n                        }\n                        s.push(node);\n                }\n                return s.peek();\n        }", "52": "public static String orderlyQueue(String S, int K) {\n        if (K == 1) {\n                String result = S;\n                for (int i = 1; i < S.length(); ++i) {\n                        result = min(result, S.substring(i) + S.substring(0, i));\n                }\n                return result;\n        }\n        Arrays.sort(S.toCharArray());\n        return S;\n}", "53": "public static int maximumWealth(int[][] accounts) {\n                int result = 0;\n                for (const int[] account : accounts) {\n                        int total = Arrays.stream(account).sum();\n                        result = Math.max(result, total);\n                }\n                return result;\n        }", "54": "public boolean isAnagram(String s, String t) {\n                if (s.length() != t.length()) {\n                        return false;\n                }\n                HashMap<Character, Integer> count = new HashMap<>();\n                for (char c : s.toCharArray()) {\n                        count.put(c, count.getOrDefault(c, 0) + 1);\n                }\n                for (char c : t.toCharArray()) {\n                        count.put(c, count.getOrDefault(c, 0) - 1);\n                        if (count.get(c) < 0) {\n                                return false;\n                        }\n                }\n                return true;\n        }", "55": "public class Solution {\n    public String nearestPalindromic(String n) {\n        long num = Long.parseLong(n);\n        long closest_val = Long.MAX_VALUE;\n        int l = n.length();\n        long prefix = Long.parseLong(n.substring(0, (l+1)/2));\n        for (int i = -1; i <= 1; i++) {\n            String p = Long.toString(prefix + i);\n            String pp = p + new StringBuffer(p).reverse().toString().substring((l%2==0) ? 0 : 1);\n            long curr = Long.parseLong(pp);\n            if (Math.abs(curr - num) < Math.abs(closest_val - num) || (Math.abs(curr - num) == Math.abs(closest_val - num) && curr < closest_val)) {\n                closest_val = curr;\n            }\n        }\n        long ans = closest_val;\n        long base = (long) Math.pow(10, l);\n        for (int j = 0; j <= 9; j++) {\n            long right = base/10*j;\n            long left = base*j + 1;\n            if (Math.abs(left - num) < Math.abs(ans - num) || (Math.abs(left - num) == Math.abs(ans - num) && left < ans)) {\n                ans = left;\n            }\n            if (Math.abs(right - num) < Math.abs(ans - num) || (Math.abs(right - num) == Math.abs(ans - num) && right < ans)) {\n                ans = right;\n            }\n        }\n        return Long.toString(ans);\n    }\n}", "56": "public static int sumEvenGrandparent(TreeNode root) {\n        return sumEvenGrandparentHelper(root, 1, 1);\n}\npublic static int sumEvenGrandparentHelper(TreeNode root, int p, int gp) {\n        return root\n                ? sumEvenGrandparentHelper(root.left, root.val, p) +\n                        sumEvenGrandparentHelper(root.right, root.val, p) +\n                        (gp % 2 == 0 ? root.val : 0)\n                : 0;\n}", "57": "public class Node {\n        Node* flatten(Node* head) {\n                for (Node curr = head; curr != null; curr = curr.next) {\n                        if (curr.child == null) {\n                                continue;\n                        }\n                        Node curr_next = curr.next;\n                        curr.child.prev = curr;\n                        curr.next = curr.child;\n                        Node last_child = curr;\n                        while (last_child.next != null) {\n                                last_child = last_child.next;\n                        }\n                        if (curr_next != null) {\n                                last_child.next = curr_next;\n                                curr_next.prev = last_child;\n                        }\n                        curr.child = null;\n                }\n                return head;\n        }\n}", "58": "public static int maxNumberOfFamilies(int n, int[][] reservedSeats) {\n        Map<Integer, Map<Integer, Boolean>> lookup = new HashMap<>();\n        for (int[] seat : reservedSeats) {\n                if (2 <= seat[1] && seat[1] <= 5) {\n                        lookup.computeIfAbsent(seat[0], k -> new HashMap<>()).put(0, true);\n                }\n                if (4 <= seat[1] && seat[1] <= 7) {\n                        lookup.computeIfAbsent(seat[0], k -> new HashMap<>()).put(1, true);\n                }\n                if (6 <= seat[1] && seat[1] <= 9) {\n                        lookup.computeIfAbsent(seat[0], k -> new HashMap<>()).put(2, true);\n                }\n        }\n        int result = 2 * n;\n        for (Map<Integer, Boolean> reserved : lookup.values()) {\n                if (!reserved.getOrDefault(0, false) && !reserved.getOrDefault(2, false)) {\n                        continue;\n                }\n                if (!reserved.getOrDefault(0, false) && !reserved.getOrDefault(1, false) && !reserved.getOrDefault(2, false)) {\n                        --result;\n                        continue;\n                }\n                result -= 2;\n        }\n        return result;\n}", "59": "public static void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m + n;\n        while (m > 0 && n > 0) {\n                if (nums1[m - 1] > nums2[n - 1]) {\n                        nums1[i - 1] = nums1[m - 1];\n                        --m;\n                } else {\n                        nums1[i - 1] = nums2[n - 1];\n                        --n;\n                }\n                --i;\n        }\n        while (n > 0) {\n                nums1[i - 1] = nums2[n - 1];\n                --n;\n                --i;\n        }\n}", "60": "public static int minCost(String s, ArrayList<Integer> cost) {\n                int result = 0, accu = 0, max_cost = 0;\n                for (int i = 0; i < s.length(); ++i) {\n                        if (i && s.charAt(i) != s.charAt(i - 1)) {\n                                result += accu - max_cost;\n                                accu = max_cost = 0;\n                        }\n                        accu += cost.get(i);\n                        max_cost = Math.max(max_cost, cost.get(i));\n                }\n                result += accu - max_cost;\n                return result;\n        }", "61": "public static int minDays(int[] bloomDay, int m, int k) {\n        if (m * k > bloomDay.length) {\n                return -1;\n        }\n        int left = 1, right = 0;\n        for (int x : bloomDay) {\n                right = Math.max(right, x);\n        }\n        while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (check(bloomDay, m, k, mid)) {\n                        right = mid - 1;\n                } else {\n                        left = mid + 1;\n                }\n        }\n        return left;\n}\npublic static boolean check(int[] bloomDay, int m, int k, int x) {\n        int result = 0, count = 0;\n        for (int d : bloomDay) {\n                count = (d <= x) ? count + 1 : 0;\n                if (count == k) {\n                        count = 0;\n                        if (++result == m) {\n                                break;\n                        }\n                }\n        }\n        return result >= m;\n}", "62": "public class Topo {\n        private Map<Integer, Set<Integer>> in_degree_;\n        private Map<Integer, Set<Integer>> out_degree_;\n        private Set<Integer> nodes_;\n        public void addNode(int node) {\n                nodes_.add(node);\n        }\n        public void addEdge(int from, int to) {\n                addNode(from);\n                addNode(to);\n                in_degree_.get(to).add(from);\n                out_degree_.get(from).add(to);\n        }\n        public ArrayList<Integer> sort() {\n                Queue<Integer> q = new LinkedList<>();\n                ArrayList<Integer> result = new ArrayList<>();\n                for (int node : nodes_) {\n                        if (!in_degree_.containsKey(node)) {\n                                q.add(node);\n                        }\n                }\n                while (!q.isEmpty()) {\n                        int node = q.remove();\n                        result.add(node);\n                        for (int nei : out_degree_.get(node)) {\n                                in_degree_.get(nei).remove(node);\n                                if (in_degree_.get(nei).isEmpty()) {\n                                        in_degree_.remove(nei);\n                                        q.add(nei);\n                                }\n                        }\n                }\n                if (result.size() < nodes_.size()) {\n                        return null;\n                }\n                return result;\n        }\n}", "63": "public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> result = new LinkedList<>();\n        Queue<TreeNode> que = new LinkedList<>();\n        if (root != null) {\n                que.add(root);\n        }\n        while (!que.isEmpty()) {\n                List<Integer> level = new ArrayList<>();\n                int size = que.size();\n                for (int i = 0; i < size; i++) {\n                        TreeNode front = que.poll();\n                        level.add(front.val);\n                        if (front.left != null) {\n                                que.add(front.left);\n                        }\n                        if (front.right != null) {\n                                que.add(front.right);\n                        }\n                }\n                result.add(0, level);\n        }\n        return result;\n}", "64": "int longestPalindromeSubseq(String s) {\n        if (s == string(s.rbegin(), s.rend())) { \n                return s.length();\n        }\n        int[][] dp = new int[2][s.size()];\n        for (int i = s.length() - 2; i >= 0; --i) {\n                for (int j = i + 1; j < s.length(); ++j) {\n                        if (s[i] == s[j]) {\n                                dp[i % 2][j] = (i + 1 <= j - 1) ? 2 + dp[(i + 1) % 2][j - 1] : 2;\n                        } else {\n                                dp[i % 2][j] = max(dp[(i + 1) % 2][j], dp[i % 2][j - 1]);\n                        }\n                }\n        }\n        return dp[0][s.length() - 1];\n}", "65": "public class Main {\n        public static void main(String[] args) {\n                int[] nums = new int[] { 1, 2, 3 };\n                int[] result = getSumAbsoluteDifferences(nums);\n\n                System.out.println(Arrays.toString(result));\n        }\n\n        public static int[] getSumAbsoluteDifferences(int[] nums) {\n                int prefix = 0, suffix = 0;\n                for (int i = 0; i < nums.length; i++) {\n                        suffix += nums[i];\n                }\n                int[] result = new int[nums.length];\n                for (int i = 0; i < nums.length; i++) {\n                        suffix -= nums[i];\n                        result[i] = (i * nums[i] - prefix) + (suffix - ((nums.length - 1) - i) * nums[i]);\n                        prefix += nums[i];\n                }\n                return result;\n        }\n}", "66": "public boolean isSubtree(TreeNode s, TreeNode t) {\n                return preOrderTraverse(s, t);\n        }\npublic boolean preOrderTraverse(TreeNode s, TreeNode t) {\n                return s && (isSame(s, t) ||\n                                        preOrderTraverse(s.left, t) ||\n                                        preOrderTraverse(s.right, t));\n        }\npublic boolean isSame(TreeNode x,TreeNode y) {\n                if (!x && !y) {\n                        return true;\n                }\n                if (!x !y) {\n                        return false;\n                }\n                return x.val == y.val &&\n                        isSame(x.left, y.left) &&\n                        isSame(x.right, y.right);\n        }", "67": "public static int longestCommonSubsequence(String text1, String text2) {\n                if (text1.length() < text2.length()) {\n                        return longestCommonSubsequence(text2, text1);\n                }\n                int[][] dp = new int[2][text2.length() + 1];\n                for (int i = 1; i <= text1.length(); ++i) {\n                        for (int j = 1; j <= text2.length(); ++j) {\n                                dp[i % 2][j] = (text1.charAt(i - 1) == text2.charAt(j - 1))\n                                                        ? dp[(i - 1) % 2][j - 1] + 1\n                                                        : Math.max(dp[(i - 1) % 2][j], dp[i % 2][j - 1]);\n                        }\n                }\n                return dp[text1.length() % 2][text2.length()]; }", "68": "public class Main { \n  \n    // Function to find duplicate files \n    static void findDuplicate(String[] paths) \n    { \n  \n        // key -> content \n        // value -> list of files with the same content \n        Map<String, List<String>> map = new HashMap<>(); \n  \n        for (int i = 0; i < paths.length; i++) { \n  \n            String[] values = paths[i].split(\" \"); \n  \n            for (int j = 1; j < values.length; j++) { \n  \n                String[] name_content = values[j].split(\"\\\\(\"); \n                name_content[1] = name_content[1].replace(\")\", \"\"); \n  \n                List<String> list = map.getOrDefault(name_content[1], new ArrayList<>()); \n                list.add(values[0] + \"/\" + name_content[0]); \n                map.put(name_content[1], list); \n            } \n        } \n  \n        System.out.println(\"Duplicate files are :\"); \n  \n        for (String key : map.keySet()) { \n            if (map.get(key).size() > 1) \n                System.out.println(map.get(key)); \n        } \n    } \n  \n    public static void main(String[] args) \n    { \n  \n        String[] paths = { \"root/a 1.txt(abcd) 2.txt(efsfgh)\", \"root/c 3.txt(abdfcd)\", \"root/c/d 4.txt(efggdfh)\" }; \n        findDuplicate(paths); \n    } \n}", "69": "public static int minCostConnectPoints(int[][] points) {\n        int result = 0, u = 0; \n        int[] dist = new int[points.length];\n        HashSet<Integer> lookup = new HashSet<Integer>();\n        for (int i = 0; i < points.length - 1; ++i) {\n                int x0 = points[u][0], y0 = points[u][1];\n                lookup.add(u);\n                for (int v = 0; v < points.length; ++v) {\n                        if (lookup.contains(v)) {\n                                continue;\n                        }\n                        dist[v] = Math.min(dist[v], Math.abs(points[v][0] - x0) + Math.abs(points[v][1] - y0));\n                }\n                int val = Integer.MAX_VALUE;\n                for (int v = 0; v < dist.length; ++v) {\n                        if (dist[v] < val) {\n                                val = dist[v];\n                                u = v;\n                        }\n                }\n                dist[u] = Integer.MAX_VALUE; \n                result += val;\n        }\n        return result;\n}", "70": "public List<Integer> numsSameConsecDiff(int N, int K) {\n        List<Integer> curr = new ArrayList<>();\n        for(int i = 0; i < 10; i++) {\n                curr.add(i);\n        }\n        for (int i = 0; i < N - 1; ++i) {\n                List<Integer> next = new ArrayList<>();\n                for (int x : curr) {\n                        int y = x % 10;\n                        if (x > 0 && y + K < 10) {\n                                next.add(x * 10 + y + K);\n                        }\n                        if (x > 0 && K > 0 && y - K >= 0) {\n                                next.add(x * 10 + y - K);\n                        }\n                }\n                curr = next;\n        }\n        return curr;\n}", "71": "public static int maxJumps(int[] arr, int d) {\n                ArrayList<ArrayList<Integer>> left = new ArrayList<>();\n                Deque<Integer> decreasing_dq = new ArrayDeque<>();\n                for (int i = 0; i < arr.length; ++i) {\n                        if (!decreasing_dq.isEmpty() && i - decreasing_dq.getFirst() == d + 1) {\n                                decreasing_dq.pop();\n                        }\n                        while (!decreasing_dq.isEmpty() && arr[decreasing_dq.getLast()] < arr[i]) {\n                                if (!left.get(i).isEmpty() && arr[left.get(i).get(left.size()-1)] != arr[decreasing_dq.getLast()]) {\n                                        left.get(i).clear();\n                                }\n                                left.get(i).add(decreasing_dq.getLast());\n                                decreasing_dq.removeLast();\n                        }\n                        decreasing_dq.add(i);\n                }\n                ArrayList<ArrayList<Integer>> right = new ArrayList<>();\n                decreasing_dq.clear();\n                for (int i = arr.length - 1; i >= 0; --i) {\n                        if (!decreasing_dq.isEmpty() && decreasing_dq.getFirst() - i == d + 1) {\n                                decreasing_dq.pop();\n                        }\n                        while (!decreasing_dq.isEmpty() && arr[decreasing_dq.getLast()] < arr[i]) {\n                                if (!right.get(i).isEmpty() && arr[right.get(i).get(right.size()-1)] != arr[decreasing_dq.getLast()]) {\n                                        right.get(i).clear();\n                                }\n                                right.get(i).add(decreasing_dq.getLast());\n                                decreasing_dq.removeLast();\n                        }\n                        decreasing_dq.add(i);\n                }\n                int result = 0;\n                int[] lookup = new int[arr.length];\n                for (int i = 0; i < arr.length; ++i) {\n                        result = Math.max(result, dp(arr, d, i, left, right, lookup));\n                }\n                return result;\n        }\npublic static int dp(int[] arr, int d, int i, ArrayList<ArrayList<Integer>> left, ArrayList<ArrayList<Integer>> right, int[] lookup) {\n                if (lookup[i]) {\n                        return lookup[i];\n                }\n                lookup[i] = 1;\n                for (int j : left.get(i)) {\n                        lookup[i] = Math.max(lookup[i], dp(arr, d, j, left, right, lookup) + 1);\n                }\n                for (int j : right.get(i)) {\n                        lookup[i] = Math.max(lookup[i], dp(arr, d, j, left, right, lookup) + 1);\n                }\n                return lookup[i];\n        }", "72": "public static int minFlips(int a, int b, int c) {\n                return Integer.bitCount((a b) ^ c) + Integer.bitCount(a & b & ~c);\n        }", "73": "public int missingNumber(int[] nums) {\n        int num = 0;\n        for (int i = 0; i < nums.length; ++i) {\n        num ^= nums[i] ^ (i + 1);\n        }\n        return num;\n }", "74": "public static List<Integer> getStrongest(List<Integer> arr, int k) {\n        Collections.sort(arr);\n        int m = arr.get((arr.size() - 1) / 2);\n        arr.sort((a, b) -> {\n                if (Math.abs(a - m) != Math.abs(b - m)) {\n                        return Math.abs(a - m) > Math.abs(b - m) ? 1 : -1;\n                } else {\n                        return a > b ? 1 : -1;\n                }\n        });\n        arr = arr.subList(0, k);\n        return arr;\n}", "75": "public class Solution {\n    public int minSwapsCouples(int[] row) {\n                int N = row.length / 2;\n                int[][] couples = new int[N][];\n                for (int seat = 0; seat < row.length; ++seat) {\n                        couples[row[seat] / 2] = new int[] {seat / 2, row[seat] / 2};\n                }\n                int[][] adj = new int[N][];\n                for (int i = 0; i < couples.length; i++) {\n                        for (int j = 0; j < couples[i].length; j++) {\n                                adj[i][j] = couples[i][j];\n                        }\n                }\n                int result = 0;\n                for (int couch = 0; couch < N; ++couch) {\n                        if (adj[couch].length == 0) {\n                                continue;\n                        }\n                        int couch1 = couch;\n                        int couch2 = adj[couch1][adj[couch1].length - 1]; \n                        adj[couch1] = Arrays.copyOf(adj[couch1], adj[couch1].length - 1);\n                        while (couch2 != couch) {\n                                ++result;\n                                adj[couch2] = Arrays.copyOf(adj[couch2], adj[couch2].length - 1);\n                                int index = 0;\n                                for (int i = 0; i < adj[couch2].length; i++) {\n                                        if (adj[couch2][i] == couch1) {\n                                                index = i;\n                                                break;\n                                        }\n                                }\n                                System.arraycopy(adj[couch2], index + 1, adj[couch2], index, adj[couch2].length - index - 1);\n                                couch1 = couch2;\n                                couch2 = adj[couch1][adj[couch1].length - 1]; \n                                adj[couch1] = Arrays.copyOf(adj[couch1], adj[couch1].length - 1);\n                        }\n                }\n                return result; \n        }\n}", "76": "public class NthMagicalNumber {\n    public static int nthMagicalNumber(int N, int A, int B) {\n        static const int M = 1000000007;\n        const uint64_t a = A, b = B;\n        const auto lcm = a * b / gcd(a, b);\n        auto left = min(a, b), right = max(a, b) * N;\n        while (left <= right) {\n            const auto mid = left + (right - left) / 2;\n            if (check(A, B, N, lcm, mid)) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left % M;\n    }\n    public static boolean check(uint64_t a, uint64_t b, uint64_t N, uint64_t lcm, uint64_t target) {\n        return target / a + target / b - target / lcm >= N;\n    }\n    public static uint64_t gcd(uint64_t a, uint64_t b) {\n        while (b != 0) {\n            int tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n        return a;\n    }\n}", "77": "public int distanceBetweenBusStops(int[] distance, int start, int destination) {\n                if (start > destination) {\n                        int temp = start;\n                        start = destination;\n                        destination = temp;\n                }\n                int s_to_d = 0;\n                for(int i = start; i < destination; i++) {\n                        s_to_d += distance[i];\n                }\n                int d_to_s = 0;\n                for(int i = 0; i < start; i++) {\n                        d_to_s += distance[i];\n                }\n                for(int i = destination; i < distance.length; i++) {\n                        d_to_s += distance[i];\n                }\n                return Math.min(s_to_d, d_to_s);\n        }", "78": "public class Main {\n    \n    public static boolean findTarget(TreeNode root, int k) {\n        if (root == null) {\n            return false;\n        }\n        \n        BSTIterator left = new BSTIterator(root, true);\n        BSTIterator right = new BSTIterator(root, false);\n        \n        while (left.curr < right.curr) {\n            if (left.curr + right.curr == k) {\n                return true;\n            } else if (left.curr + right.curr < k) {\n                left.next();\n            } else {\n                right.next();\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(5);\n        root.left = new TreeNode(3);\n        root.right = new TreeNode(6);\n        root.left.left = new TreeNode(2);\n        root.left.right = new TreeNode(4);\n        root.right.right = new TreeNode(7);\n        \n        System.out.println(findTarget(root, 9)); // True\n        System.out.println(findTarget(root, 28)); // False\n    }\n}\n\nclass BSTIterator {\n    public TreeNode node;\n    public boolean forward;\n    public int curr;\n    public Stack<TreeNode> stack = new Stack<>();\n    \n    public BSTIterator(TreeNode root, boolean forward) {\n        this.node = root;\n        this.forward = forward;\n        next();\n    }\n    \n    public int next() {\n        while (node != null || !stack.empty()) {\n            if (node != null) {\n                stack.push(node);\n                node = forward ? node.left : node.right;\n            } else {\n                node = stack.pop();\n                curr = node.val;\n                node = forward ? node.right : node.left;\n                break;\n            }\n        }\n        return curr;\n    }\n}", "79": "public static int bestRotation(int[] A) {\n                int N = A.length;\n                int[] change = new int[N];\n                for (int i = 0; i < N; ++i) {\n                        --change[(i - A[i] + 1 + N) % N];\n                }\n                for (int i = 1; i < N; ++i) {\n                        change[i] += change[i - 1] + 1;\n                }\n                return Arrays.asList(change).indexOf(Collections.max(Arrays.asList(change));\n        }", "80": "public class PowerfulIntegers {\n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\n                Set<Integer> result = new HashSet<>();\n                int log_x = (x != 1) ? (int)(Math.floor(Math.log(bound) / Math.log(x))) + 1 : 1;\n                int log_y = (y != 1) ? (int)(Math.floor(Math.log(bound) / Math.log(y))) + 1 : 1;\n                for (int i = 0, pow_x = 1; i < log_x; ++i, pow_x *= x) {\n                        for (int j = 0, pow_y = 1; j < log_y; ++j, pow_y *= y) {\n                                int val = pow_x + pow_y;\n                                if (val <= bound) {\n                                        result.add(val);\n                                }\n                        }\n                }\n                return new ArrayList<Integer>(result);\n        }\n}", "81": "public static int arraySign(int[] nums) {\n                int flag = 0;\n                for (int x : nums) {\n                        if (x == 0) {\n                                return 0;\n                        }\n                        if (x < 0) {\n                                flag ^= 1;\n                        }\n                }\n                return flag % 2 == 0 ? 1 : -1;\n        }", "82": "public static int minSumOfLengths(int[] arr, int target) {\n                HashMap<Integer, Integer> prefix = new HashMap<Integer, Integer>();\n                int[] dp = new int[arr.length];\n                int result = Integer.MAX_VALUE, min_len = Integer.MAX_VALUE;\n                int accu = 0;\n                for (int right = 0; right < arr.length; ++right) {\n                        accu += arr[right];\n                        prefix.put(accu, right);\n                        if (prefix.containsKey(accu - target)) {\n                                int left = prefix.get(accu - target);\n                                min_len = Math.min(min_len, right - left);\n                                if (left != -1 && dp[left] != Integer.MAX_VALUE) {\n                                        result = Math.min(result, dp[left] + (right - left));\n                                }\n                        }\n                        dp[right] = min_len;\n                }\n                return result != Integer.MAX_VALUE ? result : -1;\n        }", "83": "int shortestBridge(int[][] A) {\n        static final int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        Map<Pair<Integer, Integer>, Integer> lookup = new HashMap<>();\n        Map<Pair<Integer, Integer>, Integer> target = new HashMap<>();\n        List<Set<Pair<Integer, Integer>>> islands = getIslands(A);\n        lookup.putAll(islands.get(0).stream().collect(Collectors.toMap(Function.identity(), x -> 0)));\n        target.putAll(islands.get(1).stream().collect(Collectors.toMap(Function.identity(), x -> 0)));\n        Queue<Pair<Pair<Integer, Integer>, Integer>> queue = new LinkedList<>();\n        for (Pair<Integer, Integer> node : lookup.keySet()) {\n                queue.add(new Pair<>(node, 0));\n        }\n        while (!queue.isEmpty()) {\n                Pair<Integer, Integer> node = queue.peek().getKey();\n                int dis = queue.poll().getValue();\n                if (target.containsKey(node)) {\n                        return dis - 1;\n                }\n                for (int[] d : directions) {\n                        Pair<Integer, Integer> nei = new Pair<>(node.getKey() + d[0], node.getValue() + d[1]);\n                        if (nei.getKey() < 0 || nei.getKey() >= A.length || nei.getValue() < 0 || nei.getValue() >= A[0].length || lookup.containsKey(nei)) {\n                                continue;\n                        }\n                        queue.add(new Pair<>(nei, dis + 1));\n                        lookup.put(nei, dis + 1);\n                }\n        }\n        return -1;\n}\n\nList<Set<Pair<Integer, Integer>>> getIslands(int[][] A) {\n        List<Set<Pair<Integer, Integer>>> islands = new ArrayList<>();\n        Set<Pair<Integer, Integer>> done = new HashSet<>();\n        for (int r = 0; r < A.length; ++r) {\n                for (int c = 0; c < A[0].length; ++c) {\n                        if (A[r][c] == 0 || done.contains(new Pair<>(r, c))) {\n                                continue;\n                        }\n                        List<Pair<Integer, Integer>> stack = new ArrayList<>();\n                        stack.add(new Pair<>(r, c));\n                        Set<Pair<Integer, Integer>> lookup = new HashSet<>(stack);\n                        while (!stack.isEmpty()) {\n                                Pair<Integer, Integer> node = stack.remove(stack.size() - 1);\n                                for (int[] d : directions) {\n                                        Pair<Integer, Integer> nei = new Pair<>(node.getKey() + d[0], node.getValue() + d[1]);\n                                        if (nei.getKey() < 0 || nei.getKey() >= A.length || nei.getValue() < 0 || nei.getValue() >= A[0].length || lookup.contains(nei) || A[nei.getKey()][nei.getValue()] == 0) {\n                                                continue;\n                                        }\n                                        stack.add(nei);\n                                        lookup.add(nei);\n                                }\n                        }\n                        for (Pair<Integer, Integer> node : lookup) {\n                                done.add(node);\n                        }\n                        islands.add(lookup);\n                        if (islands.size() == 2) {\n                                break;\n                        }\n                }\n        }\n        return islands;\n}\n\nclass PairHash<T> {\n        public int operator()(const pair<T, T>& p) const {\n                int seed = 0;\n                seed ^= std::hash<T>{}(p.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                seed ^= std::hash<T>{}(p.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n                return seed;\n        }\n}", "84": "public class SurroundedRegions {\n    public void solve(char[][] board) {\n        if (board.length == 0) {\n            return;\n        }\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\n        for (int i = 0; i < board.length; ++i) {\n            if (board[i][0] == 'O') {\n                board[i][0] = 'V';\n                q.add(new Pair<>(i, 0));\n            }\n            if (board[i][board[0].length - 1] == 'O') {\n                board[i][board[0].length - 1] = 'V';\n                q.add(new Pair<>(i, board[0].length - 1));\n            }\n        }\n        for (int j = 1; j < board[0].length - 1; ++j) {\n            if (board[0][j] == 'O') {\n                board[0][j] = 'V';\n                q.add(new Pair<>(0, j));\n            }\n            if (board[board.length - 1][j] == 'O') {\n                board[board.length - 1][j] = 'V';\n                q.add(new Pair<>(board.length - 1, j));\n            }\n        }\n        while (!q.isEmpty()) {\n            int i, j;\n            Pair<Integer, Integer> p = q.poll();\n            i = p.getKey();\n            j = p.getValue();\n            List<Pair<Integer, Integer>> directions = Arrays.asList(\n                new Pair<>(0, -1), new Pair<>(0, 1),\n                new Pair<>(-1, 0), new Pair<>(1, 0)\n            );\n            for (Pair<Integer, Integer> d : directions) {\n                int x = i + d.getKey(), y = j + d.getValue();\n                if (0 <= x && x < board.length &&\n                        0 <= y && y < board[0].length && board[x][y] == 'O') {\n                    board[x][y] = 'V';\n                    q.add(new Pair<>(x, y));\n                }\n            }\n        }\n        for (int i = 0; i < board.length; ++i) {\n            for (int j = 0; j < board[0].length; ++j) {\n                if (board[i][j] != 'V') {\n                    board[i][j] = 'X';\n                } else {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n    }\n}", "85": "public class SuperPow {\n        public int superPow(int a, ArrayList<Integer> b) {\n                int result = 1;\n                for (const auto& digit : b) {\n                        result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337;\n                }\n                return result;\n        }\n        int myPow(int a, int n, int b) {\n                int result = 1;\n                int x = a % b;\n                while (n) {\n                        if (n & 1) {\n                                result = result * x % b;\n                        }\n                        n >>= 1;\n                        x = x * x % b;\n                }\n                return result % b;\n        }\n}", "86": "public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\n                return shoppingOffersHelper(price, special, needs, 0);\n        }\npublic int shoppingOffersHelper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int i) {\n                if (i == special.size()) {\n                        int result = 0;\n                        for(int j = 0; j < price.size(); j++) {\n                                result += price.get(j) * needs.get(j);\n                        }\n                        return result;\n                }\n                int result = shoppingOffersHelper(price, special, needs, i + 1);\n                for (int j = 0; j < needs.size(); ++j) {\n                        needs.set(j, needs.get(j) - special.get(i).get(j));\n                }\n                if (!needs.contains(new Integer(-1))) {\n                        result = Math.min(result, special.get(i).get(special.get(i).size() - 1) + shoppingOffersHelper(price, special, needs, i));\n                }\n                for (int j = 0; j < needs.size(); ++j) {\n                        needs.set(j, needs.get(j) + special.get(i).get(j));\n                }\n                return result;\n        }", "87": "public class Solution {\n    public List<String> invalidTransactions(String[] transactions) {\n        int AMOUNT = 1000;\n        int MINUTES = 60;\n        List<tuple<String, Integer, Integer, String>> trans = new ArrayList<tuple<String, Integer, Integer, String>>();\n        for (String transaction : transactions) {\n            String[] t = transaction.split(\",\");\n            trans.add(new tuple<String, Integer, Integer, String>(t[0], Integer.parseInt(t[1]), Integer.parseInt(t[2]), t[3]));\n        }\n        Collections.sort(trans, new Comparator<tuple<String, Integer, Integer, String>>() {\n            public int compare(tuple<String, Integer, Integer, String> a, tuple<String, Integer, Integer, String> b) {\n                return get<1>(a).compareTo(get<1>(b));\n            }\n        });\n        Map<String, List<Integer>> trans_indexes = new HashMap<String, List<Integer>>();\n        for (int i = 0; i < trans.size(); ++i) {\n            trans_indexes.get(get<0>(trans.get(i))).add(i);\n        }\n        List<String> result = new ArrayList<String>();\n        for (Map.Entry<String, List<Integer>> name : trans_indexes.entrySet()) {\n            int left = 0;\n            int right = 0;\n            for (int i = 0; i < indexes.size(); ++i) {\n                tuple<String, Integer, Integer, String> t = trans.get(indexes.get(i));\n                if (get<2>(t) > AMOUNT) {\n                    result.add(to_str(t));\n                    continue;\n                }\n                while (left + 1 < indexes.size() && get<1>(trans.get(indexes.get(left))) < get<1>(t) - MINUTES) {\n                    ++left;\n                }\n                while (right + 1 < indexes.size() && get<1>(trans.get(indexes.get(right + 1))) <= get<1>(t) + MINUTES) {\n                    ++right;\n                }\n                for (int i = left; i <= right; ++i) {\n                    if (get<3>(trans.get(indexes.get(i))) != get<3>(t)) {\n                        result.add(to_str(t));\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    public List<String> split(String s, char delim) {\n        List<String> result = new ArrayList<String>();\n        int end = String.npos;\n        do {\n            int start = end + 1;\n            end = s.find(delim, start);\n            result.add(s.substr(start, end - start));\n        } while (end != String.npos);\n        return result;\n    }\n\n    public String to_str(tuple<String, Integer, Integer, String> t) {\n        StringBuilder ss = new StringBuilder();\n        ss.append(get<0>(t)).append(\",\").append(get<1>(t)).append(\",\")\n          .append(get<2>(t)).append(\",\").append(get<3>(t));\n        return ss.toString();\n    }\n}", "88": "public static String shortestCommonSupersequence(String str1, String str2) {\n        int[][] dp = new int[2][str2.length() + 1];\n        Tuple[][] bt = new Tuple[str1.length() + 1][str2.length() + 1];\n        for (int i = 0; i < str1.length(); ++i) {\n                bt[i + 1][0] = new Tuple(i, 0, str1.charAt(i));\n        }\n        for (int j = 0; j < str2.length(); ++j) {\n                bt[0][j + 1] = new Tuple(0, j, str2.charAt(j));\n        }\n        for (int i = 0; i < str1.length(); ++i) {\n                for (int j = 0; j < str2.length(); ++j) {\n                        if (dp[i % 2][j + 1] > dp[(i + 1) % 2][j]) {\n                                dp[(i + 1) % 2][j + 1] = dp[i % 2][j + 1];\n                                bt[i + 1][j + 1] = new Tuple(i, j + 1, str1.charAt(i));\n                        } else {\n                                dp[(i + 1) % 2][j + 1] = dp[(i + 1) % 2][j];\n                                bt[i + 1][j + 1] = new Tuple(i + 1, j, str2.charAt(j));\n                        }\n                        if (str1.charAt(i) != str2.charAt(j)) {\n                                continue;\n                        }\n                        if (dp[i % 2][j] + 1 > dp[(i + 1) % 2][j + 1]) {\n                                dp[(i + 1) % 2][j + 1] = dp[i % 2][j] + 1;\n                                bt[i + 1][j + 1] = new Tuple(i, j, str1.charAt(i));\n                        }\n                }\n        }\n        int i = str1.length(), j = str2.length();\n        char c = 0;\n        StringBuilder result = new StringBuilder();\n        while (i != 0 && j != 0) {\n                c = (char)bt[i][j].third;\n                result.append(c);\n                i = (int)bt[i][j].first;\n                j = (int)bt[i][j].second;\n        }\n        result.reverse();\n        return result.toString();\n}", "89": "public static int numWays(List<String> words, String target) {\n        int MOD = 1e9 + 7;\n        int[] dp = new int[target.length() + 1]; \n        dp[0] = 1;\n        for (int i = 0; i < words.get(0).length(); ++i) {\n                int[] count = new int[26];\n                for (String w : words) {\n                        ++count[w.charAt(i) - 'a'];\n                }\n                for (int j = target.length() - 1; j >= 0; --j) {\n                        dp[j + 1] += dp[j] * count[target.charAt(j) - 'a'] % MOD;\n                }\n        }\n        return dp[target.length()] % MOD;\n}", "90": "public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) {\n                return 0;\n        }\n        const int k = 2;\n        int left = 0;\n        int right = 1;\n        while (right < nums.length) {\n                if (nums[left] != nums[right] ||\n                        (left - k + 1 < 0 && nums[left] != nums[left - k + 1])) {\n                        ++left;\n                        nums[left] = nums[right];\n                }\n                ++right;\n        }\n        return left + 1;\n}", "91": "public static int minMoves(int[] nums) {\n        return Arrays.stream(nums).sum() - nums.length * Arrays.stream(nums).min().getAsInt();\n}", "92": "public boolean isOneBitCharacter(int[] bits) {\n        int parity = 0;\n        for (int i = bits.length - 2; i >= 0 && bits[i]; --i) {\n                parity ^= bits[i];\n        }\n        return parity == 0;\n}", "93": "public class smallestStringWithSwaps { \n                UnionFind union_find(string s.length());\n                for (const auto& pair : pairs) {\n                        union_find.union_set(pair[0], pair[1]);\n                }\n                unordered_map<int, vector<char>> components;\n                for (int i = 0; i < s.length(); ++i) {\n                        components[union_find.find_set(i)].emplace_back(s[i]);\n                }\n                for (auto& [i, list] : components) {\n                        sort(list.begin(), list.end(), greater<char>());\n                }\n                for (int i = 0; i < s.length(); ++i) {\n                        const auto& j = union_find.find_set(i);\n                        s[i] = components[j].back();\n                        components[j].pop_back();\n                }\n                return s;\n        }", "94": "public static String toHex(int num) {\n        if (num == 0) {\n                return \"0\";\n        }\n        String result = \"\";\n        while (num != 0 && result.length() != 8) {\n                int hex = num & 15;\n                if (hex < 10) {\n                        result = hex + '0' + result;\n                } else {\n                        result = (char)(hex - 10 + 'a') + result;\n                }\n                num >>>= 4;\n        }\n        return result;\n}", "95": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic TreeNode addOneRow(TreeNode root, int v, int d) {\n    if (d == 0 || d == 1) {\n        TreeNode node = new TreeNode(v);\n        if (d == 0) {\n            node.right = root;\n        } else {\n            node.left = root;\n        }\n        return node;\n    }\n    if (root != null && d >= 2) {\n        root.left = addOneRow(root.left, v, d > 2 ? d - 1 : 1);\n        root.right = addOneRow(root.right, v, d > 2 ? d - 1 : 0);\n    }\n    return root;\n}", "96": "public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<String>();\n        List<TreeNode> path = new ArrayList<TreeNode>();\n        binaryTreePathsRecu(root, path, result);\n        return result;\n}\n\npublic void binaryTreePathsRecu(TreeNode node, List<TreeNode> path, List<String> result) {\n        if (node == null) {\n                return;\n        }\n        if (node.left == null && node.right == null) {\n                String ans = \"\";\n                for (const auto& n : path) {\n                        ans.append(Integer.toString(n.val).append(\"->\"));\n                }\n                result.add(ans.append(Integer.toString(node.val)));\n        }\n        if (node.left != null) {\n                path.add(node);\n                binaryTreePathsRecu(node.left, path, result);\n                path.remove(path.size() - 1);\n        }\n        if (node.right != null) {\n                path.add(node);\n                binaryTreePathsRecu(node.right, path, result);\n                path.remove(path.size() - 1);\n        }\n}", "97": "public static int minTime(int n, int[][] edges, boolean[] hasApple) {\n                Map<Integer, List<Integer>> graph = new HashMap<>();\n                for (int[] edge : edges) {\n                        graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\n                        graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);\n                }\n                return 2 * postOrder(1, -1, hasApple, graph, new int[2]);\n        }\n\n        private static int postOrder(int node, int par, boolean[] hasApple, Map<Integer, List<Integer>> graph, int[] res) {\n                res[1] = hasApple[node] ? 1 : 0;\n                for (int nei : graph.getOrDefault(node, Collections.emptyList())) {\n                        if (nei == par) {\n                                continue;\n                        }\n                        res[1] |= postOrder(nei, node, hasApple, graph, new int[2]);\n                        res[0] += res[1];\n                }\n                return res[0];\n        }", "98": "public class Main {\n        public static void main(String[] args) {\n                Scanner in = new Scanner(System.in);\n                int t = in.nextInt();\n                while (t-- > 0) {\n                        int n = in.nextInt();\n                        String[] words = new String[n];\n                        for (int i = 0; i < n; i++) {\n                                words[i] = in.next();\n                        }\n                        String res = in.next();\n                        System.out.println(isSolvable(words, res));\n                }\n        }\n \n        public static boolean isSolvable(String[] words, String result) {\n                for (String w : words) {\n                        StringBuilder sb = new StringBuilder(w);\n                        w = sb.reverse().toString();\n                }\n                StringBuilder sb = new StringBuilder(result);\n                result = sb.reverse().toString();\n                Map<Character, Integer> lookup = new HashMap<>();\n                Set<Integer> used = new HashSet<>();\n                return backtracking(words, result, 0, 0, 0, lookup, used);\n        }\n \n        public static boolean backtracking(String[] words, String result, int i, int j, int carry, Map<Character, Integer> lookup,\n                        Set<Integer> used) {\n                if (j == result.length()) {\n                        return carry == 0;\n                }\n                if (i != words.length) {\n                        if (j >= words[i].length() || lookup.containsKey(words[i].charAt(j))) {\n                                return backtracking(words, result, i + 1, j, carry, lookup, used);\n                        }\n                        for (int val = 0; val < 10; ++val) {\n                                if (used.contains(val) || (val == 0 && j == words[i].length() - 1)) {\n                                        continue;\n                                }\n                                lookup.put(words[i].charAt(j), val);\n                                used.add(val);\n                                if (backtracking(words, result, i + 1, j, carry, lookup, used)) {\n                                        return true;\n                                }\n                                used.remove(val);\n                                lookup.remove(words[i].charAt(j));\n                        }\n                        return false;\n                }\n                int total = carry;\n                for (String word : words) {\n                        if (j < word.length()) {\n                                total += lookup.get(word.charAt(j));\n                        }\n                }\n                carry = total / 10;\n                int val = total % 10;\n                if (lookup.containsKey(result.charAt(j))) {\n                        return val == lookup.get(result.charAt(j)) && backtracking(words, result, 0, j + 1, carry, lookup, used);\n                }\n                if (used.contains(val) || (val == 0 && j == result.length() - 1)) {\n                        return false;\n                }\n                lookup.put(result.charAt(j), val);\n                used.add(val);\n                if (backtracking(words, result, 0, j + 1, carry, lookup, used)) {\n                        return true;\n                }\n                used.remove(val);\n                lookup.remove(result.charAt(j));\n                return false;\n        }\n}", "99": "public Vector<Integer> fallingSquares(Vector<Vector<Integer>>& positions) {\n                Vector<Integer> result;\n                Map<Integer, Integer> heights;\n                int maxH = heights.put(-1, 0);\n                for (Vector<Integer> p : positions) {\n                        Iterator<Integer> it0 = heights.keySet().iterator();\n                        while (it0.hasNext() && it0.next() < p.get(0)) ;\n                        Iterator<Integer> it1 = heights.keySet().iterator();\n                        while (it1.hasNext() && it1.next() < p.get(0) + p.get(1)) ;\n                        int h0 = heights.get(it0.prev());\n                        int h1 = heights.get(it1.prev());\n                        for (Iterator<Integer> it = it0; it.hasNext() && it.next() < it1.prev(); ) {\n                                h0 = Math.max(h0, heights.get(it.next()));\n                        }\n                        heights.keySet().removeAll(it0.next(), it1.prev());\n                        heights.put(p.get(0), h0 + p.get(1));\n                        heights.put(p.get(0) + p.get(1), h1);\n                        maxH = Math.max(maxH, h0 + p.get(1));\n                        result.add(maxH);\n                }\n                return result;\n        }"}}}