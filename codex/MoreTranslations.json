{"C++ - C": {"Id": {"0": 13431, "1": 9290, "2": 2114, "3": 8795, "4": 1998, "5": 1428, "6": 1871, "7": 1695, "8": 1795, "9": 1694, "10": 2120, "11": 1537, "12": 2308, "13": 14022, "14": 1696, "15": 821, "16": 7071, "17": 1853, "18": 2121, "19": 7051, "20": 1535, "21": 2026, "22": 2079, "23": 2025, "24": 12639, "25": 13575, "26": 14020, "27": 9457, "28": 2127, "29": 14023, "30": 13140, "31": 13430, "32": 4855, "33": 7052, "34": 2132, "35": 4847, "36": 7068, "37": 12716, "38": 12794, "39": 2130}, "C++": {"0": "void printDivisors(int n)\n{\n        for (int i = 1; i <= n; i++)\n                if (n % i == 0)\n                        cout <<\" \" << i;\n}", "1": "float Perimeter(float s, int n)\n{\n        float perimeter = 1;\n        perimeter = n * s;\n        return perimeter;\n}", "2": "unsigned int countSetBits(unsigned int n)\n{\n        unsigned int count = 0;\n        while (n) {\n                count += n & 1;\n                n >>= 1;\n        }\n        return count;\n}", "3": "void reverse(string str)\n{\n        if(str.size() == 0)\n        {\n                return;\n        }\n        reverse(str.substr(1));\n        cout << str[0];\n}", "4": "int multiply(int x, int y)\n{\n        if(y == 0)\n        return 0;\n        if(y > 0 )\n        return (x + multiply(x, y-1));\n        if(y < 0 )\n        return -multiply(x, -y);\n}", "5": "void leftRotatebyOne(int arr[], int n)\n{\n        int temp = arr[0], i;\n        for (i = 0; i < n - 1; i++)\n                arr[i] = arr[i + 1];\n        arr[n-1] = temp;\n}\nvoid leftRotate(int arr[], int d, int n)\n{\n        for (int i = 0; i < d; i++)\n                leftRotatebyOne(arr, n);\n}\nvoid printArray(int arr[], int n)\n{\n        for (int i = 0; i < n; i++)\n                cout << arr[i] << \" \";\n}", "6": "int un_kp(int price[], int length[], int Max_len, int n)\n{\n        if (n == 0 || Max_len == 0)\n        {\n                return 0;\n        }\n        if (length[n - 1] <= Max_len)\n        {\n                t[n][Max_len]\n                        = max(price[n - 1]\n                                        + un_kp(price, length, Max_len - length[n - 1], n),\n                                un_kp(price, length, Max_len, n - 1));\n        }\n        else\n        {\n                t[n][Max_len]\n                        = un_kp(price, length, Max_len, n - 1);\n        }\n        return t[n][Max_len];\n}", "7": "int _binarySearch(int arr[], int low, int high, int x)\n{\n        if (high >= low)\n        {\n                int mid = (low + high)/2; \n                if ((mid == 0 || x > arr[mid - 1]) &&\n                        (arr[mid] == x) )\n                        return mid;\n                else if (x > arr[mid])\n                        return _binarySearch(arr, (mid + 1), high, x);\n                else\n                        return _binarySearch(arr, low, \n                                                                (mid - 1), x);\n        }\n        return -1;\n}\nbool isMajority(int arr[], int n, int x)\n{\n        int i = _binarySearch(arr, 0, n - 1, x);\n        if (i == -1)\n                return false;\n        if (((i + n / 2) <= (n - 1)) && arr[i + n / 2] == x)\n                return true;\n        else\n                return false;\n}", "8": "void swap(int *xp, int *yp) \n{ \n        int temp = *xp; \n        *xp = *yp; \n        *yp = temp; \n}\nvoid selectionSort(int arr[], int n) \n{ \n        int i, j, min_idx; \n        for (i = 0; i < n-1; i++) \n        { \n                min_idx = i; \n                for (j = i+1; j < n; j++) \n                if (arr[j] < arr[min_idx]) \n                        min_idx = j; \n                swap(&arr[min_idx], &arr[i]); \n        } \n}\nvoid printArray(int arr[], int size) \n{ \n        int i; \n        for (i=0; i < size; i++) \n                cout << arr[i] << \" \"; \n        cout << endl; \n}", "9": "bool isMajority(int arr[], int n, int x)\n{\n        int i;\n        int last_index = n % 2 ? (n / 2 + 1): (n / 2);\n        for (i = 0; i < last_index; i++)\n        {\n                if (arr[i] == x && arr[i + n / 2] == x)\n                        return 1;\n        }\n        return 0;\n}", "10": "unsigned int countSetBitsRec(unsigned int num)\n{\n        int nibble = 0;\n        if (0 == num)\n                return num_to_bits[0];\n        nibble = num & 0xf;\n        return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}", "11": "int FindMaxSum(vector<int> arr, int n)\n{\n        int incl = arr[0];\n        int excl = 0;\n        int excl_new;\n        int i;\n        for (i = 1; i < n; i++)\n        {\n                excl_new = (incl > excl) ? incl : excl;\n                incl = excl + arr[i];\n                excl = excl_new;\n        }}", "12": "void printTwoOdd(int arr[], int size)\n{\n        int xor2 = arr[0]; \n        int set_bit_no; \n        int i;\n        int n = size - 2;\n        int x = 0, y = 0;\n        for(i = 1; i < size; i++)\n                xor2 = xor2 ^ arr[i];\n        set_bit_no = xor2 & ~(xor2-1);\n        for(i = 0; i < size; i++)\n        {\n                if(arr[i] & set_bit_no)\n                x = x ^ arr[i];\n                else\n                y = y ^ arr[i];\n        }\n        cout << \"The two ODD elements are \" << x << \" & \" << y;\n}", "13": "int subtract(int x, int y)\n{\n        while (y != 0)\n        {\n                int borrow = (~x) & y;\n                x = x ^ y;\n                y = borrow << 1;\n        }\n        return x;\n}", "14": "bool isMajorityElement(int arr[], int n, int key)\n{\n        if (arr[n / 2] == key)\n                return true;\n        else\n                return false;\n}", "15": "void Kroneckerproduct(int A[][cola], int B[][colb])\n{\n        int C[rowa * rowb][cola * colb];\n        for (int i = 0; i < rowa; i++) {\n                for (int k = 0; k < rowb; k++) {\n                        for (int j = 0; j < cola; j++) {\n                                for (int l = 0; l < colb; l++) {\n                                        C[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n                                        cout << C[i + l + 1][j + k + 1] << \" \";\n                                }\n                        }\n                        cout << endl;\n                }\n        }\n}", "16": "int count(int S[], int m, int n)\n{\n        if (n == 0)\n                return 1;\n        if (n < 0)\n                return 0;\n        if (m <= 0 && n >= 1)\n                return 0;\n        return count(S, m - 1, n) +\n                count(S, m, n - S[m - 1]);\n}", "17": "int MatrixChainOrder(int p[], int n)\n{\n        int m[n][n];\n        int i, j, k, L, q;\n        for (i = 1; i < n; i++)\n                m[i][i] = 0;\n        for (L = 2; L < n; L++)\n        {\n                for (i = 1; i < n - L + 1; i++)\n                {\n                        j = i + L - 1;\n                        m[i][j] = INT_MAX;\n                        for (k = i; k <= j - 1; k++)\n                        {\n                                q = m[i][k] + m[k + 1][j]\n                                        + p[i - 1] * p[k] * p[j];\n                                if (q < m[i][j])\n                                        m[i][j] = q;\n                        }\n                }\n        }\n        return m[1][n - 1];\n}", "18": "int countSetBits(int N)\n{\n        int count = 0;\n        for (int i = 0; i < sizeof(int) * 8; i++) {\n                if (N & (1 << i))\n                        count++;\n        }\n        return count;\n}", "19": "int max(int a, int b) { return (a > b)? a : b;}\nint cutRod(int price[], int n)\n{\n int val[n+1];\n val[0] = 0;\n int i, j;\n for (i = 1; i<=n; i++)\n {\n        int max_val = INT_MIN;\n        for (j = 0; j < i; j++)\n                max_val = max(max_val, price[j] + val[i-j-1]);\n        val[i] = max_val;\n }\n return val[n];\n}", "20": "int findFirstMissing(int array[], int start, int end)\n{\n        if (start > end)\n                return end + 1;\n        if (start != array[start])\n                return start;\n        int mid = (start + end) / 2;\n        if (array[mid] == mid)\n                return findFirstMissing(array, mid+1, end);\n        return findFirstMissing(array, start, mid);\n}", "21": "void printPascal(int n)\n{\nfor (int line = 1; line <= n; line++)\n{\nint C = 1; \n        for (int i = 1; i <= line; i++)\n        {\n                cout<< C<<\" \";\n                C = C * (line - i) / i;\n        }\n        cout<<\"\\n\";\n}\n}", "22": "int Add(int x, int y)\n{\n        while (y != 0)\n        {\n                int carry = x & y;\n                x = x ^ y;\n                y = carry << 1;\n        }\n        return x;\n}", "23": "void printPascal(int n)\n{\n        int arr[n][n];\n        for (int line = 0; line < n; line++)\n        {\n                for (int i = 0; i <= line; i++)\n                {\n                if (line == i || i == 0)\n                        arr[line][i] = 1;\n                else\n                        arr[line][i] = arr[line - 1][i - 1] +\n                                                        arr[line - 1][i];\n                cout << arr[line][i] << \" \";\n                }\n                cout << \"\\n\";\n        }\n}", "24": "int averageEven(int n)\n{\n        if (n % 2 != 0) {\n                cout<<\"Invalid Input\";\n                return -1;\n        }\n        return (n + 2) / 2;\n}", "25": "int reversDigits(int num)\n{\n        static int rev_num = 0;\n        static int base_pos = 1;\n        if (num > 0) {\n                reversDigits(num / 10);\n                rev_num += (num % 10) * base_pos;\n                base_pos *= 10;\n        }\n        return rev_num;\n}", "26": "int multiplyBySevenByEight(int n)\n{\n        return (n - (n >> 3));\n}", "27": "double Area(int b1, int b2, int h)\n{\n        return ((b1 + b2) / 2) * h;\n}", "28": "bool getParity(unsigned int n)\n{\n        bool parity = 0;\n        while (n)\n        {\n                parity = !parity;\n                n        = n & (n - 1);\n        }        \n        return parity;\n}", "29": "int subtract(int x, int y)\n{\n        if (y == 0)\n                return x;\n        return subtract(x ^ y, (~x & y) << 1);\n}", "30": "int fact(int n)\n{\n        if (n == 0)\n                return 1;\n        return n * fact(n - 1);\n}\nint div(int x)\n{\n        int ans = 0;\n        for (int i = 1; i<= x; i++)\n                if (x % i == 0)\n                        ans += i;\n        return ans;\n}\nint sumFactDiv(int n)\n{\n        return div(fact(n));\n}", "31": "void printDivisors(int n)\n{\n        int i;\n        for (i = 1; i * i < n; i++) {\n                if (n % i == 0)\n                        cout<<i<<\" \";\n        }\n        if (i - (n / i) == 1) {\n                i--;\n        }\n        for (; i >= 1; i--) {\n                if (n % i == 0)\n                        cout<<n / i<<\" \";\n        }\n}", "32": "void insertionSort(int arr[], int n)\n{\n        int i, key, j;\n        for (i = 1; i < n; i++)\n        {\n                key = arr[i];\n                j = i - 1;\n                while (j >= 0 && arr[j] > key)\n                {\n                        arr[j + 1] = arr[j];\n                        j = j - 1;\n                }\n                arr[j + 1] = key;\n        }\n}\nvoid printArray(int arr[], int n)\n{\n        int i;\n        for (i = 0; i < n; i++)\n                cout << arr[i] << \" \";\n        cout << endl;\n}", "33": "int un_kp(int price[], int length[], int Max_len, int n)\n{\n        if (n == 0 || Max_len == 0)\n        {\n                return 0;\n        }\n        if (length[n - 1] <= Max_len)\n        {\n                t[n][Max_len]\n                        = max(price[n - 1]\n                                        + un_kp(price, length, Max_len - length[n - 1], n),\n                                un_kp(price, length, Max_len, n - 1));\n        }\n        else\n        {\n                t[n][Max_len]\n                        = un_kp(price, length, Max_len, n - 1);\n        }\n        return t[n][Max_len];\n}", "34": "bool isPowerOfTwo (int x)\n{\n        return x && (!(x&(x-1)));\n}", "35": "int binarySearch(int a[], int item, int low, int high)\n{\n        while (low <= high) {\n                int mid = low + (high - low) / 2;\n                if (item == a[mid])\n                        return mid + 1;\n                else if (item > a[mid])\n                        low = mid + 1;\n                else\n                        high = mid - 1;\n        }\n        return low;\n}\nvoid insertionSort(int a[], int n)\n{\n        int i, loc, j, k, selected;\n        for (i = 1; i < n; ++i) {\n                j = i - 1;\n                selected = a[i];\n                loc = binarySearch(a, selected, 0, j);\n                while (j >= loc) {\n                        a[j + 1] = a[j];\n                        j--;\n                }\n                a[j + 1] = selected;\n        }\n}", "36": "int MatrixChainOrder(int p[], int i, int j)\n{\n        if (i == j)\n                return 0;\n        int k;\n        int min = INT_MAX;\n        int count;\n        for (k = i; k < j; k++)\n        {\n                count = MatrixChainOrder(p, i, k)\n                                + MatrixChainOrder(p, k + 1, j)\n                                + p[i - 1] * p[k] * p[j];\n                if (count < min)\n                        min = count;\n        }\n        return min;\n}", "37": "int Series(int n)\n{\n        int i;\n        int sums = 0;\n        for (i = 1; i <= n; i++)\n                sums += (i * i);\n        return sums;\n}", "38": "double Convert(double radian)\n{\n        double pi = 3.14159;\n        return(radian * (180 / pi));\n}", "39": "bool isPowerOfTwo(int n)\n{\n        if (n == 0)\n                return 0;\n        while (n != 1)\n        {\n                if (n%2 != 0)\n                        return 0;\n                n = n/2;\n        }\n        return 1;\n}"}, "C": {"0": "void printDivisors(int n)\n{\n        for (int i = 1; i <= n; i++)\n                if (n % i == 0)\n                        printf(\"%d\", i);\n}", "1": "float Perimeter(float s, int n)\n{\n        float perimeter = 1;\n        perimeter = n * s;\n        return perimeter;\n}", "2": "unsigned int countSetBits(unsigned int n)\n{\n\tunsigned int count = 0;\n\twhile (n) {\n\t\tcount += n & 1;\n\t\tn >>= 1;\n\t}\n\treturn count;\n}", "3": "void reverse(string str)\n{\n        if(str.size() == 0)\n        {\n                return;\n        }\n        reverse(str.substr(1));\n        printf(\"%c\", str[0]);\n}", "4": "void printDivisors(int n)\n{\n        for (int i = 1; i <= n; i++)\n                if (n % i == 0)\n                        cout <<\" \" << i;\n}", "5": "void leftRotatebyOne(int *arr, int n)\n{\n        int temp = arr[0], i;\n        for (i = 0; i < n - 1; i++)\n                arr[i] = arr[i + 1];\n        arr[n-1] = temp;\n}\nvoid leftRotate(int *arr, int d, int n)\n{\n        for (int i = 0; i < d; i++)\n                leftRotatebyOne(arr, n);\n}\nvoid printArray(int *arr, int n)\n{\n        for (int i = 0; i < n; i++)\n                printf(\"%d \", arr[i]);\n}", "6": "int un_kp(int price[], int length[], int Max_len, int n)\n{\n        if (n == 0 || Max_len == 0)\n        {\n                return 0;\n        }\n        if (length[n - 1] <= Max_len)\n        {\n                t[n][Max_len]\n                        = max(price[n - 1]\n                                        + un_kp(price, length, Max_len - length[n - 1], n),\n                                un_kp(price, length, Max_len, n - 1));\n        }\n        else\n        {\n                t[n][Max_len]\n                        = un_kp(price, length, Max_len, n - 1);\n        }\n        return t[n][Max_len];\n}", "7": "int binarySearch(int arr[], int low, int high, int x) {\n    if (high >= low) {\n        int mid = (low + high)/2; \n        if ((mid == 0 || x > arr[mid - 1]) &&\n            (arr[mid] == x) )\n            return mid;\n        else if (x > arr[mid])\n            return binarySearch(arr, (mid + 1), high, x);\n        else\n            return binarySearch(arr, low, \n                                                (mid - 1), x);\n    }\n    return -1;\n}\nbool isMajority(int arr[], int n, int x) {\n    int i = binarySearch(arr, 0, n - 1, x);\n    if (i == -1)\n        return false;\n    if (((i + n / 2) <= (n - 1)) && arr[i + n / 2] == x)\n        return true;\n    else\n        return false;\n}", "8": "void swap(int *xp, int *yp) \n{ \n        int temp = *xp; \n        *xp = *yp; \n        *yp = temp; \n}\nvoid selectionSort(int arr[], int n) \n{ \n        int i, j, min_idx; \n        for (i = 0; i < n-1; i++) \n        { \n                min_idx = i; \n                for (j = i+1; j < n; j++) \n                if (arr[j] < arr[min_idx]) \n                        min_idx = j; \n                swap(&arr[min_idx], &arr[i]); \n        } \n}\nvoid printArray(int arr[], int size) \n{ \n        int i; \n        for (i=0; i < size; i++) \n                printf(\"%d \", arr[i]); \n        printf(\"\\n\"); \n}", "9": "bool isMajority(int arr[], int n, int x)\n{\n        int i;\n        int last_index = n % 2 ? (n / 2 + 1): (n / 2);\n        for (i = 0; i < last_index; i++)\n        {\n                if (arr[i] == x && arr[i + n / 2] == x)\n                        return 1;\n        }\n        return 0;\n}", "10": "unsigned int countSetBits(unsigned int num)\n{\n        return countSetBitsRec(num);\n}\n\nunsigned int countSetBitsRec(unsigned int num)\n{\n        int nibble = 0;\n        if (0 == num)\n                return num_to_bits[0];\n        nibble = num & 0xf;\n        return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}\n\n\nunsigned int countSetBits(unsigned int num)\n{\n        return countSetBitsRec(num);\n}", "11": "int FindMaxSum(int arr[], int n)\n{\n        int incl = arr[0];\n        int excl = 0;\n        int excl_new;\n        int i;\n        for (i = 1; i < n; i++)\n        {\n                excl_new = (incl > excl) ? incl : excl;\n                incl = excl + arr[i];\n                excl = excl_new;\n        }\n}", "12": "void printTwoOdd(int arr[], int size)\n{\n        int xor2 = arr[0]; \n        int set_bit_no; \n        int i;\n        int n = size - 2;\n        int x = 0, y = 0;\n        for(i = 1; i < size; i++)\n                xor2 = xor2 ^ arr[i];\n        set_bit_no = xor2 & ~(xor2-1);\n        for(i = 0; i < size; i++)\n        {\n                if(arr[i] & set_bit_no)\n                x = x ^ arr[i];\n                else\n                y = y ^ arr[i];\n        }\n        printf(\"The two ODD elements are %d & %d\", x, y);\n}", "13": "int subtract(int x, int y)\n{\n        while (y != 0)\n        {\n                int borrow = (~x) & y;\n                x = x ^ y;\n                y = borrow << 1;\n        }\n        return x;\n}", "14": "bool isMajorityElement(int arr[], int n, int key)\n{\n        if (arr[n / 2] == key)\n                return true;\n        else\n                return false;\n}", "15": "void Kroneckerproduct(int A[][cola], int B[][colb])\n{\n        int C[rowa * rowb][cola * colb];\n        for (int i = 0; i < rowa; i++) {\n                for (int k = 0; k < rowb; k++) {\n                        for (int j = 0; j < cola; j++) {\n                                for (int l = 0; l < colb; l++) {\n                                        C[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n                                        printf(\"%d \", C[i + l + 1][j + k + 1]);\n                                }\n                        }\n                        printf(\"\\n\");\n                }\n        }\n}", "16": "int count(int S[], int m, int n)\n{\n        int i, j, x, y;\n        int table[n + 1][m];\n\n        for (i = 0; i < m; i++)\n                table[0][i] = 1;\n\n        for (i = 1; i < n + 1; i++) {\n                for (j = 0; j < m; j++) {\n                        if (i - S[j] < 0)\n                                x = 0;\n                        else\n                                x = table[i - S[j]][j];\n\n                        if (j >= 1)\n                                y = table[i][j - 1];\n                        else\n                                y = 0;\n\n                        table[i][j] = x + y;\n                }\n        }\n        return table[n][m - 1];\n}", "17": "int MatrixChainOrder(int p[], int n)\n{\n \n    int m[n][n];\n \n    int i, j, k, L, q;\n \n    for (i = 1; i < n; i++)\n        m[i][i] = 0;\n \n    for (L=2; L<n; L++)\n    {\n        for (i=1; i<n-L+1; i++)\n        {\n            j = i+L-1;\n            m[i][j] = INT_MAX;\n            for (k=i; k<=j-1; k++)\n            {\n                q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];\n                if (q < m[i][j])\n                    m[i][j] = q;\n            }\n        }\n    }\n \n    return m[1][n-1];\n}\n \nint main()\n{\n    int arr[] = {1, 2, 3, 4, 3};\n    int size = sizeof(arr)/sizeof(arr[0]);\n \n    printf(\"Minimum number of multiplications is %d \",\n                       MatrixChainOrder(arr, size));\n \n    getchar();\n    return 0;\n}", "18": "int countSetBits(int N)\n{\n        int count = 0;\n        for (int i = 0; i < sizeof(int) * 8; i++) {\n                if (N & (1 << i))\n                        count++;\n        }\n        return count;\n}", "19": "int max(int a, int b) { return (a > b)? a : b;}\nint cutRod(int price[], int n)\n{\n int val[n+1];\n val[0] = 0;\n int i, j;\n for (i = 1; i<=n; i++)\n {\n        int max_val = INT_MIN;\n        for (j = 0; j < i; j++)\n                max_val = max(max_val, price[j] + val[i-j-1]);\n        val[i] = max_val;\n }\n return val[n];\n}", "20": "int findFirstMissing(int array[], int start, int end){\n        if (start > end)\n                return end + 1;\n        if (start != array[start])\n                return start;\n        int mid = (start + end) / 2;\n        if (array[mid] == mid)\n                return findFirstMissing(array, mid+1, end);\n        return findFirstMissing(array, start, mid);\n}", "21": "void printPascal(int n)\n{\nfor (int line = 1; line <= n; line++)\n{\nint C = 1; \n        for (int i = 1; i <= line; i++)\n        {\n                printf(\"%d \", C);\n                C = C * (line - i) / i;\n        }\n        printf(\"\\n\");\n}\n}", "22": "int add(int x, int y)\n{\n        while (y != 0)\n        {\n                int carry = x & y;\n                x = x ^ y;\n                y = carry << 1;\n        }\n        return x;\n}", "23": "void printPascal(int n)\n{\n        int arr[n][n];\n        int i, j, line;\n        for (line = 0; line < n; line++)\n        {\n                for (i = 0; i <= line; i++)\n                {\n                if (line == i || i == 0)\n                        arr[line][i] = 1;\n                else\n                        arr[line][i] = arr[line - 1][i - 1] +\n                                                        arr[line - 1][i];\n                printf(\"%d \", arr[line][i]);\n                }\n                printf(\"\\n\");\n        }\n}", "24": "int averageEven(int n)\n{\n        if (n % 2 != 0) {\n                printf(\"Invalid Input\");\n                return -1;\n        }\n        return (n + 2) / 2;\n}", "25": "int reversDigits(int num)\n{\n        static int rev_num = 0;\n        static int base_pos = 1;\n        if (num > 0) {\n                reversDigits(num / 10);\n                rev_num += (num % 10) * base_pos;\n                base_pos *= 10;\n        }\n        return rev_num;\n}", "26": "nt multiplyBySevenByEight(int n)\n{\n        return (n - (n >> 3));\n}", "27": "double Area(int s1, int s2, int s3)\n{\n        double p = (s1 + s2 + s3) / 2;\n        return sqrt(p * (p - s1) * (p - s2) * (p - s3));\n}\n\ndouble Area(double r)\n{\n        return 3.14 * r * r;\n}\n\n#include <math.h>\n\ndouble Area(int b1, int b2, int h)\n{\n        return ((b1 + b2) / 2) * h;\n}\n\n\ndouble Area(int s1, int s2, int s3)\n{\n        double p = (s1 + s2 + s3) / 2;\n        return sqrt(p * (p - s1) * (p - s2) * (p - s3));\n}\n\ndouble Area(double r)\n{\n        return 3.14 * r * r;\n}", "28": "bool getParity(unsigned int n)\n{\n        bool parity = 0;\n        while (n)\n        {\n                parity = !parity;\n                n        = n & (n - 1);\n        }        \n        return parity;\n}", "29": "int subtract(int x, int y){\n\n        if(y == 0){\n                return x;\n        }\n        return subtract(x^y, (~x & y) << 1);\n}", "30": "int fact(int n)\n{\n        if (n == 0)\n                return 1;\n        return n * fact(n - 1);\n}\nint div(int x)\n{\n        int ans = 0;\n        for (int i = 1; i<= x; i++)\n                if (x % i == 0)\n                        ans += i;\n        return ans;\n}\nint sumFactDiv(int n)\n{\n        return div(fact(n));\n}", "31": "void printDivisors(int n)\n{\n        int i;\n        for (i = 1; i * i < n; i++) {\n                if (n % i == 0)\n                        printf(\"%d \", i);\n        }\n        if (i - (n / i) == 1) {\n                i--;\n        }\n        for (; i >= 1; i--) {\n                if (n % i == 0)\n                        printf(\"%d \", n / i);\n        }\n}", "32": "void insertionSort(int arr[], int n)\n{\n        int i, key, j;\n        for (i = 1; i < n; i++)\n        {\n                key = arr[i];\n                j = i - 1;\n                while (j >= 0 && arr[j] > key)\n                {\n                        arr[j + 1] = arr[j];\n                        j = j - 1;\n                }\n                arr[j + 1] = key;\n        }\n}\nvoid printArray(int arr[], int n)\n{\n        int i;\n        for (i = 0; i < n; i++)\n                printf(\"%d \", arr[i]);\n        printf(\"\\n\");\n}", "33": "int un_kp(int price[], int length[], int Max_len, int n)\n{\n        if (n == 0 || Max_len == 0)\n        {\n                return 0;\n        }\n        if (length[n - 1] <= Max_len)\n        {\n                t[n][Max_len]\n                        = max(price[n - 1]\n                                        + un_kp(price, length, Max_len - length[n - 1], n),\n                                un_kp(price, length, Max_len, n - 1));\n        }\n        else\n        {\n                t[n][Max_len]\n                        = un_kp(price, length, Max_len, n - 1);\n        }\n        return t[n][Max_len];\n}", "34": "bool isPowerOfTwo (int x)\n{\n        return x && (!(x&(x-1)));\n}", "35": "int binarySearch(int a[], int item, int low, int high)\n{\n        while (low <= high) {\n                int mid = low + (high - low) / 2;\n                if (item == a[mid])\n                        return mid + 1;\n                else if (item > a[mid])\n                        low = mid + 1;\n                else\n                        high = mid - 1;\n        }\n        return low;\n}\nvoid insertionSort(int a[], int n)\n{\n        int i, loc, j, k, selected;\n        for (i = 1; i < n; ++i) {\n                j = i - 1;\n                selected = a[i];\n                loc = binarySearch(a, selected, 0, j);\n                while (j >= loc) {\n                        a[j + 1] = a[j];\n                        j--;\n                }\n                a[j + 1] = selected;\n        }\n}", "36": "// Matrix Ai has dimension p[i-1] x p[i] for i = 1..n \nint MatrixChainOrder(int p[], int i, int j) \n{ \n\tif (i == j) \n\t\treturn 0; \n\tint k; \n\tint min = INT_MAX; \n\tint count; \n\t\n\t// place parenthesis at different places between first \n\t// and last matrix, recursively calculate count of \n\t// multiplications for each placement and return the \n\t// minimum count \n\tfor (k = i; k < j; k++) \n\t{ \n\t\tcount = MatrixChainOrder(p, i, k) + \n\t\t\t\tMatrixChainOrder(p, k+1, j) + \n\t\t\t\tp[i-1]*p[k]*p[j]; \n\n\t\tif (count < min) \n\t\t\tmin = count; \n\t} \n\n\t// Return minimum count \n\treturn min; \n} \n\n// Driver program to test above function \nint main() \n{ \n\tint arr[] = {1, 2, 3, 4}; \n\tint n = sizeof(arr)/sizeof(arr[0]); \n\n\tprintf(\"Minimum number of multiplications is %d \", \n\t\t\t\t\t\tMatrixChainOrder(arr, 1, n-1)); \n\t\n\tgetchar(); \n\treturn 0; \n}", "37": "int Series(int n)\n{\n        int i;\n        int sums = 0;\n        for (i = 1; i <= n; i++)\n                sums += (i * i);\n        return sums;\n}", "38": "double Convert(double radian)\n{\n        double pi = 3.14159;\n        return(radian * (180 / pi));\n}", "39": "bool isPowerOfTwo(int n)\n{\n        if (n == 0)\n                return 0;\n        while (n != 1)\n        {\n                if (n%2 != 0)\n                        return 0;\n                n = n/2;\n        }\n        return 1;\n}"}}, "Java - C#": {"Id": {"0": 1869, "1": 12550, "2": 8501, "3": 12638, "4": 4624, "5": 10345, "6": 5512, "7": 6210, "8": 9574, "9": 11204, "10": 11707, "11": 12750, "12": 13453, "13": 5946, "14": 2129, "15": 10539, "16": 1590, "17": 3375, "18": 6068, "19": 7735, "20": 10474, "21": 12486, "22": 10885, "23": 13049, "24": 3601, "25": 4570, "26": 6395, "27": 11627, "28": 5995, "29": 3704, "30": 7788, "31": 7051, "32": 5621, "33": 5772, "34": 11315, "35": 9114, "36": 6471, "37": 12639, "38": 3932, "39": 5675, "40": 9147, "41": 1517, "42": 9505, "43": 8213, "44": 9804, "45": 9948, "46": 13501, "47": 9070, "48": 6712, "49": 4847, "50": 12765, "51": 1813, "52": 7622, "53": 13048, "54": 12794, "55": 9329, "56": 11217, "57": 10568, "58": 8855}, "Java": {"0": "static int cutRod(int price[], int n)\n        {\n                if (n <= 0)\n                        return 0;\n                int max_val = Integer.MIN_VALUE;\n                for (int i = 0; i<n; i++)\n                        max_val = Math.max(max_val,\n                                                        price[i] + cutRod(price, n-i-1));\n                return max_val;\n        }", "1": "public static boolean checkdigit(int n, int k)\n        {\n                while (n != 0)\n                {\n                        int rem = n % 10;\n                        if (rem == k)\n                                return true;\n                        n = n / 10;\n                }\n                return false;\n        }\npublic static int findNthNumber(int n, int k)\n        {\n                for (int i = k + 1, count = 1; count < n; i++)\n                {\n                if (checkdigit(i, k) || (i % k == 0))\n                        count++;\n                if (count == n)\n                return i;\n                }\n        return -1;\n        }", "2": "static boolean isNumber(String s)\n        {\n                for (int i = 0; i < s.length(); i++)\n                        if (Character.isDigit(s.charAt(i)) == false)\n                                return false;\n                return true;\n        }", "3": "static int averageEven(int n)\n        {\n                if (n % 2 != 0) {\n                System.out.println(\"Invalid Input\");\n                        return -1;\n                }\n                int sum = 0, count = 0;\n                while (n >= 2) {\n                count++;\n                sum += n;\n                n = n - 2;\n                }\n                return sum / count;\n        }", "4": "static void sortByRow(int[][] mat, int n, boolean descending)\n{\n        int temp = 0;\n        for (int i = 0; i < n; i++)\n        {\n                if (descending == true)\n                {\n                        int t = i;\n                        for (int p = 0; p < n; p++)\n                        {\n                                for (int j = p + 1; j < n; j++)\n                                {\n                                        if (mat[t][p] < mat[t][j])\n                                        {\n                                                temp = mat[t][p];\n                                                mat[t][p] = mat[t][j];\n                                                mat[t][j] = temp;\n                                        }\n                                }\n                        }\n                }\n                else\n                        Arrays.sort(mat[i]);\n        }\n}\nstatic void transpose(int mat[][], int n)\n{\n        int temp = 0;\n        for (int i = 0; i < n; i++)\n        {\n                for (int j = i + 1; j < n; j++)\n                {\n                        temp = mat[i][j];\n                        mat[i][j] = mat[j][i];\n                        mat[j][i] = temp;\n                }\n        }\n}\nstatic void sortMatRowAndColWise(int mat[][], int n)\n{\n        sortByRow(mat, n, true);\n        transpose(mat, n);\n        sortByRow(mat, n, false);\n        transpose(mat, n);\n}\nstatic void printMat(int mat[][], int n)\n{\n        for (int i = 0; i < n; i++)\n        {\n                for (int j = 0; j < n; j++)\n                        System.out.print(mat[i][j] + \" \");\n                System.out.println();\n        }\n}", "5": "static boolean isDNum(int n)\n{\n        if (n < 4)\n                return false;\n        int numerator = 0, hcf = 0;\n        for(int k = 2; k <= n; k++)\n        {\n        numerator = (int)(Math.pow(k, n - 2) - k);\n        hcf = __gcd(n, k);\n        }\n        if (hcf == 1 && (numerator % n) != 0)\n                return false;\n        return true;\n}\nstatic int __gcd(int a, int b)\n{\n        return b == 0 ? a : __gcd(b, a % b);        \n}", "6": "static int minOperations(int a[], int b[], int n)\n{\n        int minA = Arrays.stream(a).min().getAsInt();\n        for (int x = minA; x >= 0; x--)\n        {\n                boolean check = true;\n                int operations = 0;\n                for (int i = 0; i < n; i++)\n                {\n                        if (x % b[i] == a[i] % b[i])\n                        {\n                                operations += (a[i] - x) / b[i];\n                        }\n                        else\n                        {\n                                check = false;\n                                break;\n                        }\n                }\n                if (check)\n                        return operations;\n        }\n        return -1;\n}", "7": "static void largestSquare(int matrix[][], int R, int C, int q_i[], int q_j[], int K, int Q)\n{\n        int [][]countDP = new int[R][C];\n        countDP[0][0] = matrix[0][0];\n        for(int i = 1; i < R; i++)\n                countDP[i][0] = countDP[i - 1][0] + \n                                                        matrix[i][0];\n        for(int j = 1; j < C; j++)\n                countDP[0][j] = countDP[0][j - 1] +\n                                                matrix[0][j];\n        for(int i = 1; i < R; i++)\n                for(int j = 1; j < C; j++)\n                        countDP[i][j] = matrix[i][j] +\n                                                countDP[i - 1][j] +\n                                                countDP[i][j - 1] -\n                                                countDP[i - 1][j - 1];\n        for(int q = 0; q < Q; q++)\n        {\n                int i = q_i[q];\n                int j = q_j[q];\n                int min_dist = Math.min(Math.min(i, j), \n                                        Math.min(R - i - 1, C - j - 1));\n                int ans = -1;\n                for(int k = 0; k <= min_dist; k++)\n                {\n                        int x1 = i - k, x2 = i + k;\n                        int y1 = j - k, y2 = j + k;\n                        int count = countDP[x2][y2];\n                        if (x1 > 0)\n                                count -= countDP[x1 - 1][y2];\n                        if (y1 > 0)\n                                count -= countDP[x2][y1 - 1];\n                        if (x1 > 0 && y1 > 0)\n                                count += countDP[x1 - 1][y1 - 1];\n                        if (count > K)\n                                break;\n                        ans = 2 * k + 1;\n                }\n                System.out.print(ans + \"\\n\");\n        }\n}", "8": "static int countSubsequences(int arr[], int N)\n        {\n                int odd = 0;\n                for (int i = 0; i < N; i++) {\n                        if ((arr[i] & 1) % 2 == 1)\n                                odd++;\n                }\n                return (1 << odd) - 1;\n        }", "9": "static long power(int p)\n        {\n                long res = 1;\n                for (int i = 1; i <= p; ++i)\n                {\n                        res *= 2;\n                        res %= mod;\n                }\n                return res % mod;\n        }\nstatic long subset_square_sum(int A[])\n        {\n                int n = A.length;\n                long ans = 0;\n                for (int i : A)\n                {\n                        ans += (1 * i * i) % mod;\n                        ans %= mod;\n                }\n                return (1 * ans * power(n - 1)) % mod;\n        }", "10": "static boolean digitWell(int n, int m, int k)\n{\n        int cnt = 0;\n        while (n > 0)\n        {\n                if (n % 10 == m)\n                        ++cnt;\n                n /= 10;\n        }\n        return cnt == k;\n}\nstatic int findInt(int n, int m, int k)\n{\n        int i = n + 1;\n        while (true)\n        {\n                if (digitWell(i, m, k))\n                        return i;\n                i++;\n        }\n}", "11": "static int gcd(int a, int b)\n        {\n                if (a == 0 || b == 0)\n                        return 0;\n                if (a == b)\n                        return a;\n                if (a > b)\n                        return gcd(a - b, b);\n                return gcd(a, b - a);\n        }\nstatic int cpFact(int x, int y)\n        {\n                while (gcd(x, y) != 1) {\n                        x = x / gcd(x, y);\n                }\n                return x;\n        }", "12": "static int SieveOfAtkin(int limit)\n        {\n                if (limit > 2)\n                        System.out.print(2 + \" \");\n                if (limit > 3)\n                        System.out.print(3 + \" \");\n                boolean sieve[] = new boolean[limit];\n                for (int i = 0; i < limit; i++)\n                        sieve[i] = false;\n                for (int x = 1; x * x < limit; x++) {\n                        for (int y = 1; y * y < limit; y++) {\n                                int n = (4 * x * x) + (y * y);\n                                if (n <= limit && (n % 12 == 1 || n % 12 == 5))\n                                        sieve[n] ^= true;\n                                n = (3 * x * x) + (y * y);\n                                if (n <= limit && n % 12 == 7)\n                                        sieve[n] ^= true;\n                                n = (3 * x * x) - (y * y);\n                                if (x > y && n <= limit && n % 12 == 11)\n                                        sieve[n] ^= true;\n                        }\n                }\n                for (int r = 5; r * r < limit; r++) {\n                        if (sieve[r]) {\n                                for (int i = r * r; i < limit; i += r * r)\n                                        sieve[i] = false;\n                        }\n                }\n                for (int a = 5; a < limit; a++)\n                        if (sieve[a])\n                                System.out.print(a + \" \");\n                return 0;\n        }", "13": "static int MaxSubsetlength(String arr[], int A, int B)\n{\n        int dp[][] = new int[A + 1][B + 1];\n        for(String str : arr)\n        {\n                int zeros = 0, ones = 0;\n                for(char ch : str.toCharArray())\n                {\n                        if (ch == '0')\n                                zeros++;\n                        else\n                                ones++;\n                }\n                for(int i = A; i >= zeros; i--)\n                        for(int j = B; j >= ones; j--)\n                                dp[i][j] = Math.max( dp[i][j], dp[i - zeros][j - ones] + 1);\n        }\n        return dp[A][B];\n}", "14": "static boolean isPowerOfTwo(int n)\n{\n        if(n==0)\n        return false;\nreturn (int)(Math.ceil((Math.log(n) / Math.log(2)))) ==\n        (int)(Math.floor(((Math.log(n) / Math.log(2)))));\n}\n\n", "15": "static int productPairs(int arr[], int n)\n{\n        int product = 1;\n        for(int i = 0; i < n; i++)\n        {\n        for(int j = 0; j < n; j++)\n        {\n                product *= (arr[i] % mod * arr[j] % mod) % mod;\n                product = product % mod;\n        }\n        }\n        return product % mod;\n}", "16": "static int findMaxAverage(int []arr, int n, int k)\n        {\n                if (k > n)\n                        return -1;\n                int []csum = new int[n];\n                csum[0] = arr[0];\n                for (int i = 1; i < n; i++)\n                csum[i] = csum[i - 1] + arr[i];\n                int max_sum = csum[k - 1],\n                                        max_end = k - 1;\n                for (int i = k; i < n; i++)\n                {\n                        int curr_sum = csum[i] -\n                                        csum[i - k];\n                        if (curr_sum > max_sum)\n                        {\n                                max_sum = curr_sum;\n                                max_end = i;\n                        }\n                }\n                return max_end - k + 1;\n        }", "17": "static void countSubarrays(int a[], int n, int k)\n{\n        HashMap<Integer, Integer> cnt = new HashMap<>();\n        long ans = 0;\n        ArrayList<Integer> pref = new ArrayList<>();\n        pref.add(0);\n        for(int i = 0; i < n; i++)\n                pref.add((a[i] + pref.get(i)) % k);\n        cnt.put(0, 1);\n        for(int i = 1; i <= n; i++)\n        {\n                int remIdx = i - k;\n                if (remIdx >= 0)\n                {\n                        if (cnt.containsKey((pref.get(remIdx) - remIdx % k + k) % k))\n                                cnt.put((pref.get(remIdx) - remIdx % k + k) % k,\n                                cnt.get((pref.get(remIdx) - remIdx % k + k) % k) - 1);\n                        else\n                                cnt.put((pref.get(remIdx) - remIdx % k + k) % k, -1);\n                }\n                if (cnt.containsKey((pref.get(i) - i % k + k) % k))\n                        ans += cnt.get((pref.get(i) - i % k + k) % k);\n                if (cnt.containsKey((pref.get(i) - i % k + k) % k))\n                        cnt.put((pref.get(i) - i % k + k) % k,\n                        cnt.get((pref.get(i) - i % k + k) % k) + 1);\n                else\n                        cnt.put((pref.get(i) - i % k + k) % k, 1);\n        }\n        System.out.println(ans);\n}", "18": "static void Calculate_factorial()\n        {\n                fact[0] = 1;\n                for (int i = 1; i <= mx; i++) {\n                        fact[i] = i * fact[i - 1];\n                        fact[i] %= mod;\n                }\n        }\nstatic int UniModal_per(int a, int b)\n        {\n                int res = 1;\n                while (b > 0) {\n                        if (b % 2 != 0)\n                                res = res * a;\n                        res %= mod;\n                        a = a * a;\n                        a %= mod;\n                        b /= 2;\n                }\n                return res;\n        }\nstatic void countPermutations(int n)\n        {\n                Calculate_factorial();\n                int uni_modal = UniModal_per(2, n - 1);\n                int nonuni_modal = fact[n] - uni_modal;\n                System.out.print(uni_modal + \" \" + nonuni_modal);\n                return;\n        }", "19": "static String removeChars(char arr[], int k)\n{\n        int []hash = new int[MAX_CHAR];\n        int n = arr.length;\n        for (int i = 0; i < n; ++i)\n                hash[arr[i] - 'a']++;\n        String ans = \"\";\n        for (int i = 0; i < n; ++i) {\n                if (hash[arr[i] - 'a'] != k) {\n                        ans += arr[i];\n                }\n        }\n        return ans;\n}", "20": "static int enneacontahexagonNum(int n)\n{\n        return (94 * n * n - 92 * n) / 2;\n}", "21": "static void possibleTripletInRange(int L, int R)\n{\n        boolean flag = false;\n        int possibleA = 0,\n                possibleB = 0,\n                possibleC = 0;\n        int numbersInRange = (R - L + 1);\n        if (numbersInRange < 3)\n        {\n                flag = false;\n        }\n        else if (numbersInRange > 3)\n        {\n                flag = true;\n                if (L % 2 > 0)\n                {\n                        L++;\n                }\n                possibleA = L;\n                possibleB = L + 1;\n                possibleC = L + 2;\n        }\n        else\n        {\n                if (!(L % 2 > 0))\n                {\n                        flag = true;\n                        possibleA = L;\n                        possibleB = L + 1;\n                        possibleC = L + 2;\n                }\n                else\n                {\n                        flag = false;\n                }\n        }\n        if (flag == true)\n        {\n                System.out.println(\"(\" + possibleA + \", \" + possibleB + \", \" + possibleC + \")\" + \" is one such possible\" + \" triplet between \" + L + \" and \" + R );\n        }\n        else {\n                System.out.println(\"No Such Triplet\" + \" exists between \" + L + \" and \" + R);\n        }\n}", "22": "static int largest_sum(int arr[], int n)\n        {\n                int maximum = -1;\n                HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n                for (int i = 0; i < n; i++) {\n                        if (m.containsKey(arr[i])){\n                        m.put(arr[i], m.get(arr[i]) + 1);\n                        }\n                        else{\n                                m.put(arr[i], 1);\n                        }\n                }\n                for(int i = 0; i < n; i++){\n                        if (m.get(arr[i]) > 1) {\n                                if (m.containsKey(2*arr[i]))\n                                {\n                                        m.put(2*arr[i],m.get(2 * arr[i])+ m.get(arr[i]) / 2);\n                                }\n                                else\n                                {\n                                        m.put(2*arr[i],m.get(arr[i]) / 2);\n                                }\n                                if (2 * arr[i] > maximum)\n                                        maximum = 2 * arr[i];\n                        }\n                        }\n                return maximum;\n        }", "23": "static void sieveOfEratostheneses()\n{\n        isPrime[1] = true;\n        for (int i = 2; i * i < MAX; i++)\n        {\n                if (!isPrime[i])\n                {\n                        for (int j = 2 * i; j < MAX; j += i)\n                                isPrime[j] = true;\n                }\n        }\n}\nstatic int findPrime(int n)\n{\n        int num = n + 1;\n        while (num > 0)\n        {\n                if (!isPrime[num])\n                        return num;\n                num = num + 1;\n        }\n        return 0;\n}\nstatic int minNumber(int arr[], int n)\n{\n        sieveOfEratostheneses();\n        int sum = 0;\n        for (int i = 0; i < n; i++)\n                sum += arr[i];\n        if (!isPrime[sum])\n                return 0;\n        int num = findPrime(sum);\n        return num - sum;\n}", "24": "static boolean possible(long mid, int[] a)\n{\n        long n = a.length;\n        long total = (n * (n - 1)) / 2;\n        long need = (total + 1) / 2;\n        long count = 0;\n        long start = 0, end = 1;\n        while (end < n)\n        {\n                if (a[(int)end] - a[(int)start] <= mid)\n                {\n                        end++;\n                }\n                else\n                {\n                        count += (end - start - 1);\n                        start++;\n                }\n        }\n        if (end == n && start < end &&\n                a[(int)end - 1] - a[(int)start] <= mid)\n        {\n                long t = end - start - 1;\n                count += (t * (t + 1) / 2);\n        }\n        if (count >= need)\n                return true;\n        else\n                return false;\n}\nstatic long findMedian(int[] a)\n{\n        long n = a.length;\n        long low = 0, high = a[(int)n - 1] - a[0];\n        while (low <= high)\n        {\n                long mid = (low + high) / 2;\n                if (possible(mid, a))\n                        high = mid - 1;\n                else\n                        low = mid + 1;\n        }\n        return high + 1;\n}", "25": "static int MinimizeleftOverSum(int a[], int n)\n{\n        Vector<Integer> v1 = new Vector<Integer>(),\n                                        v2 = new Vector<Integer>();\n        for (int i = 0; i < n; i++)\n        {\n                if (a[i] % 2 == 1)\n                        v1.add(a[i]);\n                else\n                        v2.add(a[i]);\n        }\n        if (v1.size() > v2.size())\n        {\n                Collections.sort(v1);\n                Collections.sort(v2);\n                int x = v1.size() - v2.size() - 1;\n                int sum = 0;\n                int i = 0;\n                while (i < x)\n                {\n                        sum += v1.get(i++);\n                }\n                return sum;\n        }\n        else if (v2.size() > v1.size())\n        {\n                Collections.sort(v1);\n                Collections.sort(v2);\n                int x = v2.size() - v1.size() - 1;\n                int sum = 0;\n                int i = 0;\n                while (i < x)\n                {\n                        sum += v2.get(i++);\n                }\n                return sum;\n        }\n        else\n                return 0;\n}", "26": "static int gcd(int a, int b)\n        {\n                if (b == 0)\n                        return a;\n                return gcd(b, a % b);\n        }\nstatic int MaxGCD(int a[], int n)\n        {\n                int Prefix[] = new int[n + 2];\n                int Suffix[] = new int[n + 2] ;\n                Prefix[1] = a[0];\n                for (int i = 2; i <= n; i += 1)\n                {\n                        Prefix[i] = gcd(Prefix[i - 1], a[i - 1]);\n                }\n                Suffix[n] = a[n - 1];\n                for (int i = n - 1; i >= 1; i -= 1)\n                {\n                        Suffix[i] = gcd(Suffix[i + 1], a[i - 1]);\n                }\n                int ans = Math.max(Suffix[2], Prefix[n - 1]);\n                for (int i = 2; i < n; i += 1)\n                {\n                        ans = Math.max(ans, gcd(Prefix[i - 1], Suffix[i + 1]));\n                }\n                return ans;\n        }", "27": "static int countWays(int N)\n{\n        int E = (N * (N - 1)) / 2;\n        if (N == 1)\n                return 0;\n        return (int)Math.pow(2, E - 1);\n}", "28": "static int power(int X, int Y)\n {\n        int res = 1;\n        X = X % M;\n        if (X == 0)\n        return 0;\n        while (Y > 0)\n        {\n        if ((Y & 1) != 0)\n        {\n                res = (res * X) % M;\n        }\n        Y = Y >> 1;\n        X = (X * X) % M;\n        }\n        return res;\n }\nstatic int findValue(int n)\n {\n        int X = 0;\n        int pow_10 = 1;\n        while (n != 0)\n        {\n        if ((n & 1) != 0)\n        {\n                X += pow_10;\n        }\n        pow_10 *= 10;\n        n /= 2;\n        }\n        X = (X * 2) % M;\n        int res = power(2, X);\n        return res;\n }", "29": "static void printNum(int L, int R)\n{\n        for(int i = L; i <= R; i++)\n        {\n                int temp = i;\n                int c = 10;\n                int flag = 0;\n                while (temp > 0)\n                {\n                        if (temp % 10 >= c)\n                        {\n                                flag = 1;\n                                break;\n                        }\n                        c = temp % 10;\n                        temp /= 10;\n                }\n                if (flag == 0)\n                        System.out.print(i + \" \");\n        }\n}", "30": "static void sub_segments(String str, int n)\n{\n        int l = str.length();\n        for (int x = 0; x < l; x += n)\n        {\n                String newlist = str.substring(x, x + n);\n                List<Character> arr = new ArrayList<Character>();\n                for (char y : newlist.toCharArray())\n                {\n                        if (!arr.contains(y))\n                                arr.add(y);\n                }\n                for (char y : arr)\n                        System.out.print(y);\n                System.out.println();\n        }\n}", "31": "static int cutRod(int price[],int n)\n        {\n                int val[] = new int[n+1];\n                val[0] = 0;\n                for (int i = 1; i<=n; i++)\n                {\n                        int max_val = Integer.MIN_VALUE;\n                        for (int j = 0; j < i; j++)\n                                max_val = Math.max(max_val, price[j] + val[i-j-1]);\n                        val[i] = max_val;\n                }\n                return val[n];\n        }", "32": "static void find_distinct(int a[], int n, int q, int queries[])\n{\n        int []check = new int[MAX];\n        int []idx = new int[MAX];\n        int cnt = 1;\n        for (int i = n - 1; i >= 0; i--)\n        {\n                if (check[a[i]] == 0)\n                {\n                        idx[i] = cnt;\n                        check[a[i]] = 1;\n                        cnt++;\n                }\n                else\n                {\n                        idx[i] = cnt - 1;\n                }\n        }\n        for (int i = 0; i < q; i++)\n        {\n                        int m = queries[i];\n                        System.out.print(idx[m] + \" \");\n        }\n}", "33": "static boolean possibility(HashMap<Integer, Integer> m, int length, String s)\n{\n int countodd = 0;\n for (int i = 0; i < length; i++)\n {\n        if (m.get(s.charAt(i) - '0') % 2 == 1)\n        countodd++;\n        if (countodd > 1)\n        return false;\n }\n return true;\n}\nstatic void largestPalindrome(String s)\n{\n int l = s.length();\n HashMap<Integer,\n                Integer> m = new HashMap<>();\n for (int i = 0; i < l; i++)\n        if(m.containsKey(s.charAt(i) - '0'))\n        m.put(s.charAt(i) - '0',\n        m.get(s.charAt(i) - '0') + 1);\n else\n        m.put(s.charAt(i) - '0', 1);\n if (possibility(m, l, s) == false)\n {\n        System.out.print(\"Palindrome cannot be formed\");\n        return;\n }\n char []largest = new char[l];\n int front = 0;\n for (int i = 9; i >= 0; i--)\n {\n        if (m.containsKey(i) &&\n                m.get(i)%2==1)\n        {\n        largest[l / 2] = (char)(i + 48);\n        m.put(i, m.get(i)-1);\n        while (m.get(i) > 0)\n        {\n                largest[front] = (char)(i + 48);\n                largest[l - front - 1] =\n                                        (char)(i + 48);\n                m.put(i, m.get(i) - 2);\n                front++;\n        }\n        }\n        else\n        {\n        while (m.containsKey(i) &&\n                        m.get(i) > 0)\n        {\n                largest[front] = (char)(i + 48);\n                largest[l - front - 1] =\n                        (char)(i + 48);\n                m.put(i, m.get(i) - 2);\n                front++;\n        }\n        }\n }\n for (int i = 0; i < l; i++)\n        System.out.print(largest[i]);\n}", "34": "static int Wedderburn(int n)\n{\n        if (n <= 2)\n                return store.get(n);\n        else if (n % 2 == 0)\n        {\n                int x = n / 2, ans = 0;\n                for (int i = 1; i < x; i++)\n                {\n                        ans += store.get(i) * store.get(n - i);\n                }\n                ans += (store.get(x) * (store.get(x) + 1)) / 2;\n                store. put(n, ans);\n                return ans;\n        }\n        else\n        {\n                int x = (n + 1) / 2, ans = 0;\n                for (int i = 1; i < x; i++)\n                {\n                        ans += store.get(i) * store.get(n - i);\n                }\n                store. put(n, ans);\n                return ans;\n        }\n}\nstatic void Wedderburn_Etherington(int n)\n{\n        store. put(0, 0);\n        store. put(1, 1);\n        store. put(2, 1);\n        for (int i = 0; i < n; i++)\n        {\n                System.out.print(Wedderburn(i));\n                if(i != n - 1)\n                        System.out.print(\" \");\n        }\n}", "35": "static int Icosihenagonal_num(int n)\n{\n        return (19 * n * n - 17 * n) / 2;\n}", "36": "static int noOfBinaryStrings(int N, int k)\n{\n        int dp[] = new int[100002];\n        for (int i = 1; i <= k - 1; i++)\n        {\n                dp[i] = 1;\n        }\n        dp[k] = 2;\n        for (int i = k + 1; i <= N; i++)\n        {\n                dp[i] = (dp[i - 1] + dp[i - k]) % mod;\n        }\n        return dp[N];\n}", "37": "static int averageEven(int n)\n        {\n                if (n % 2 != 0) {\n                System.out.println(\"Invalid Input\");\n                        return -1;\n                }\n                return (n + 2) / 2;\n        }", "38": "static int LowerInsertionPoint(int arr[], int n, int X)\n        {\n        if (X < arr[0])\n                return 0;\n        else if (X > arr[n - 1])\n                return n;\n        int lowerPnt = 0;\n        int i = 1;\n        while (i < n && arr[i] < X) {\n                lowerPnt = i;\n                i = i * 2;\n        }\n        while (lowerPnt < n && arr[lowerPnt] < X)\n                lowerPnt++;\n        return lowerPnt;\n        }", "39": "static String encryptString(String str, int n)\n{\n        int i = 0, cnt = 0;\n        String encryptedStr = \"\";\n        while (i < n)\n        {\n                cnt = i + 1;\n                while (cnt-- >0)\n                        encryptedStr += str.charAt(i);\n                i++;\n        }\n        return encryptedStr;\n}", "40": "static int countIntersections(int n)\n        {\n                return n * (n - 1) / 2;\n        }", "41": "static void findElements(int arr[], int n)\n{\n        int first = Integer.MIN_VALUE;\n        int second = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++)\n        {\n                if (arr[i] > first)\n                {\n                        second = first;\n                        first = arr[i];\n                }\n                else if (arr[i] > second)\n                        second = arr[i];\n        }\n        for (int i = 0; i < n; i++)\n                if (arr[i] < second)\n                        System.out.print(arr[i] + \" \") ;\n}", "42": "static void findRightAngle(double A, double H)\n        {\n                double D = Math.pow(H, 4) - 16 * A * A;\n                if (D >= 0)\n                {\n                        double root1 = (H * H + Math.sqrt(D)) / 2;\n                        double root2 = (H * H - Math.sqrt(D)) / 2;\n                        double a = Math.sqrt(root1);\n                        double b = Math.sqrt(root2);\n                        if (b >= a)\n                                System.out.print(a + \" \" + b + \" \" + H);\n                        else\n                                System.out.print(b + \" \" + a + \" \" + H);\n                }\n                else\n                        System.out.print(\"-1\");\n        }", "43": "static boolean check(String s, int m)\n{\n        int l = s.length();\n        int c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < l; i++)\n        {\n                if (s.charAt(i) == '0')\n                {\n                        c2 = 0;\n                        c1++;\n                }\n                else\n                {\n                        c1 = 0;\n                        c2++;\n                }\n                if (c1 == m || c2 == m)\n                        return true;\n        }\n        return false;\n}", "44": "static void findbitwiseOR(int[] a, int n)\n        {\n                int res = 0;\n                for (int i = 0; i < n; i++) {\n                        int curr_sub_array = a[i];\n                        res = res | curr_sub_array;\n                        for (int j = i; j < n; j++) {\n                                curr_sub_array = curr_sub_array & a[j];\n                                res = res | curr_sub_array;\n                        }\n                }\n                System.out.println(res);\n        }", "45": "static long multiplyByMersenne(long N, long M)\n{\n        long x = (int)(Math.log(M + 1) / Math.log(2));\n        return ((N << x) - N);\n}", "46": "static int eval(int a, char op, int b)\n        {\n                if (op == '+')\n                {\n                        return a + b;\n                }\n                if (op == '-')\n                {\n                        return a - b;\n                }\n                if (op == '*')\n                {\n                        return a * b;\n                }\n                return Integer.MAX_VALUE;\n        }\nstatic Vector<Integer> evaluateAll(String expr, int low, int high)\n        {\n                Vector<Integer> res = new Vector<Integer>();\n                if (low == high)\n                {\n                        res.add(expr.charAt(low) - '0');\n                        return res;\n                }\n                if (low == (high - 2))\n                {\n                        int num = eval(expr.charAt(low) - '0',\n                                                expr.charAt(low + 1),\n                                                expr.charAt(low + 2) - '0');\n                        res.add(num);\n                        return res;\n                }\n                for (int i = low + 1; i <= high; i += 2)\n                {\n                        Vector<Integer> l = evaluateAll(expr, low, i - 1);\n                        Vector<Integer> r = evaluateAll(expr, i + 1, high);\n                        for (int s1 = 0; s1 < l.size(); s1++)\n                        {\n                                for (int s2 = 0; s2 < r.size(); s2++)\n                                {\n                                        int val = eval(l.get(s1), expr.charAt(i), r.get(s2));\n                                        res.add(val);\n                                }\n                        }\n                }\n                return res;\n        }", "47": "static int areaOfSquare(int S)\n{\n        int area = S * S;\n        return area;\n}", "48": "public static int longOddEvenIncSeq(int arr[], int n)\n        {\n                int[] lioes = new int[n];\n                int maxLen = 0;\n                for (int i = 0; i < n; i++)\n                        lioes[i] = 1;\n                for (int i = 1; i < n; i++)\n                        for (int j = 0; j < i; j++)\n                                if (arr[i] > arr[j] &&\n                                (arr[i] + arr[j]) % 2 != 0 && lioes[i] < lioes[j] + 1)\n                                        lioes[i] = lioes[j] + 1;\n                for (int i = 0; i < n; i++)\n                        if (maxLen < lioes[i])\n                                maxLen = lioes[i];\n                return maxLen;\n        }", "49": "static int binarySearch(int a[], int item, int low, int high)\n{\n        while (low <= high) {\n                int mid = low + (high - low) / 2;\n                if (item == a[mid])\n                        return mid + 1;\n                else if (item > a[mid])\n                        low = mid + 1;\n                else\n                        high = mid - 1;\n        }\n        return low;\n}\nstatic void insertionSort(int a[], int n)\n{\n        int i, loc, j, k, selected;\n        for (i = 1; i < n; ++i) {\n                j = i - 1;\n                selected = a[i];\n                loc = binarySearch(a, selected, 0, j);\n                while (j >= loc) {\n                        a[j + 1] = a[j];\n                        j--;\n                }\n                a[j + 1] = selected;\n        }\n}", "50": "public static int counLastDigitK(int low, int high, int k)\n        {\n                int mlow = 10 * (int)\n                                        Math.ceil(low/10.0);\n                int mhigh = 10 * (int)\n                                        Math.floor(high/10.0);\n                int count = (mhigh - mlow)/10;\n                if (high % 10 >= k)\n                        count++;\n                if (low % 10 <= k && (low%10) > 0)\n                        count++;\n                return count;\n        }", "51": "int findCrossOver(int arr[], int low, int high, int x)\n        {\nif (arr[high] <= x) \n                        return high;\nif (arr[low] > x) \n                        return low;\n                int mid = (low + high)/2; \n                if (arr[mid] <= x && arr[mid+1] > x)\n                        return mid;\n                if(arr[mid] < x)\n                        return findCrossOver(arr, mid+1, high, x);\n                return findCrossOver(arr, low, mid - 1, x);\n        }\nvoid printKclosest(int arr[], int x, int k, int n)\n        {\n                int l = findCrossOver(arr, 0, n-1, x);\nint r = l+1; \nint count = 0; \n                if (arr[l] == x) l--;\n                while (l >= 0 && r < n && count < k)\n                {\n                        if (x - arr[l] < arr[r] - x)\n                                System.out.print(arr[l--]+\" \");\n                        else\n                                System.out.print(arr[r++]+\" \");\n                        count++;\n                }\n                while (count < k && l >= 0)\n                {\n                        System.out.print(arr[l--]+\" \");\n                        count++;\n                }\n                while (count < k && r < n)\n                {\n                        System.out.print(arr[r++]+\" \");\n                        count++;\n                }\n        }", "52": "static boolean check(String s, int n)\n{\n        Stack<Character> st = new Stack<Character>();\n        for(int i = 0; i < n; i++)\n        {\n        if (!st.isEmpty() &&\n                        st.peek() == s.charAt(i))\n                st.pop();\n        else\n                st.add(s.charAt(i));\n        }\n        if (st.isEmpty())\n        {\n                return true;\n        }\n        else\n        {\n                return false;\n        }\n}", "53": "static boolean isPrime(int n)\n                {\n                        if (n <= 1)\n                                return false;\n                        for (int i = 2; i < n; i++)\n                                if (n % i == 0)\n                                        return false;\n                        return true;\n                }\nstatic int findPrime(int n)\n                {\n                        int num = n + 1;\n                        while (num > 0)\n                                {\n                                        if (isPrime(num))\n                                                return num;\n                                        num = num + 1;\n                                }\n                        return 0;\n                }\nstatic int minNumber(int arr[], int n)\n                {\n                        int sum = 0;\n                        for (int i = 0; i < n; i++)\n                                sum += arr[i];\n                        if (isPrime(sum))\n                                return 0;\n                        int num = findPrime(sum);\n                        return num - sum;\n                }", "54": "static double Convert(double radian){\n                double pi = 3.14159;\n                return(radian * (180/pi));\n        }", "55": "static double longestRodInCuboid(int length, int breadth, int height)\n{\n        double result;\n        int temp;\n        temp = length * length + breadth *\n                breadth + height * height;\n        result = Math.sqrt(temp);\n        return result;\n}", "56": "static void least_prime_factor()\n{\n        for (int i = 2; i < N; i++)\n                if (lpf[i] == 0)\n                        for (int j = i; j < N; j += i)\n                                if (lpf[j] == 0)\n                                        lpf[j] = i;\n}\nstatic void Mobius()\n{\n        for (int i = 1; i < N; i++)\n        {\n                if (i == 1)\n                        mobius[i] = 1;\n                else\n                {\n                        if (lpf[i / lpf[i]] == lpf[i])\n                                mobius[i] = 0;\n                        else\n                                mobius[i] = -1 * mobius[i / lpf[i]];\n                }\n        }\n}\nstatic int gcd_pairs(int a[], int n)\n{\n        int maxi = 0;\n        int []fre = new int[N];\n        for (int i = 0; i < n; i++)\n        {\n                fre[a[i]]++;\n                maxi = Math.max(a[i], maxi);\n        }\n        least_prime_factor();\n        Mobius();\n        int ans = 0;\n        for (int i = 1; i <= maxi; i++)\n        {\n                if (mobius[i] == 0)\n                        continue;\n                int temp = 0;\n                for (int j = i; j <= maxi; j += i)\n                        temp += fre[j];\n                ans += temp * (temp - 1) / 2 * mobius[i];\n        }\n        return ans;\n}", "57": "static boolean isPrime(int n)\n{\n        if (n <= 1)\n                return false;\n        for (int i = 2; i < n; i++)\n                if (n % i == 0)\n                        return false;\n        return true;\n}\nstatic int countSubsequences(int arr[], int n)\n{\n        int totalSubsequence = (int)(Math.pow(2, n) - 1);\n        int countPrime = 0, countOnes = 0;\n        for (int i = 0; i < n; i++)\n        {\n                if (arr[i] == 1)\n                        countOnes++;\n                else if (isPrime(arr[i]))\n                        countPrime++;\n        }\n        int compositeSubsequence;\n        int onesSequence = (int)(Math.pow(2, countOnes) - 1);\n        compositeSubsequence = totalSubsequence -\n                                                                countPrime -\n                                                        onesSequence -\n                                                        onesSequence *\n                                                        countPrime;\n        return compositeSubsequence;\n}", "58": "static void dfs(int u, int count)\n{\n        visited[u] = true;\n        int temp = 0;\n        for (int i = 0; i < adjacent.get(u).size(); i++)\n        {\n                if (!visited[adjacent.get(u).get(i)])\n                {\n                        temp++;\n                        dfs(adjacent.get(u).get(i), count + 1);\n                }\n        }\n        if (temp == 0)\n        {\n                if (maxi < count)\n                {\n                        maxi = count;\n                        startnode = u;\n                }\n        }\n}\nstatic void dfs1(int u, int count)\n{\n        visited[u] = true;\n        int temp = 0;\n        for (int i = 0; i < adjacent.get(u).size(); i++)\n        {\n                if (!visited[adjacent.get(u).get(i)])\n                {\n                        temp++;\n                        parent[adjacent.get(u).get(i)] = u;\n                        dfs1(adjacent.get(u).get(i), count + 1);\n                }\n        }\n        if (temp == 0)\n        {\n                if (maxi < count)\n                {\n                        maxi = count;\n                        endnode = u;\n                }\n        }\n}\nstatic void dfs2(int u, int count)\n{\n        visited[u] = true;\n        int temp = 0;\n        for (int i = 0; i < adjacent.get(u).size(); i++)\n        {\n                if (!visited[adjacent.get(u).get(i)] &&\n                        !vis[adjacent.get(u).get(i)])\n                {\n                        temp++;\n                        dfs2(adjacent.get(u).get(i), count + 1);\n                }\n        }\n        if (temp == 0)\n        {\n                if (maxi < count)\n                {\n                        maxi = count;\n                        thirdnode = u;\n                }\n        }\n}\nstatic void findNodes()\n{\n        dfs(1, 0);\n        for (int i = 0; i <= N; i++)\n                visited[i] = false;\n        maxi = -1;\n        dfs1(startnode, 0);\n        for (int i = 0; i <= N; i++)\n                visited[i] = false;\n        int x = endnode;\n        vis[startnode] = true;\n        while (x != startnode)\n        {\n                vis[x] = true;\n                x = parent[x];\n        }\n        maxi = -1;\n        for (int i = 1; i <= N; i++)\n        {\n                if (vis[i])\n                        dfs2(i, 0);\n        }\n}"}, "C#": {"0": "static int cutRod(int price[], int n)\n        {\n                if (n <= 0)\n                        return 0;\n                int max_val = Int32.MinValue;\n                for (int i = 0; i<n; i++)\n                        max_val = Math.Max(max_val,\n                                                        price[i] + cutRod(price, n-i-1));\n                return max_val;\n        }", "1": "public static bool checkdigit(int n, int k)\n        {\n                while (n != 0)\n                {\n                        int rem = n % 10;\n                        if (rem == k)\n                                return true;\n                        n = n / 10;\n                }\n                return false;\n        }\npublic static int findNthNumber(int n, int k)\n        {\n                for (int i = k + 1, count = 1; count < n; i++)\n                {\n                if (checkdigit(i, k) || (i % k == 0))\n                        count++;\n                if (count == n)\n                return i;\n                }\n        return -1;\n        }", "2": "static bool isNumber(string s)\n        {\n                for (int i = 0; i < s.length(); i++)\n                        if (Char.IsDigit(s.charAt(i)) == false)\n                                return false;\n                return true;\n        }", "3": "static int averageEven(int n)\n        {\n                if (n % 2 != 0) {\n                System.out.println(\"Invalid Input\");\n                        return -1;\n                }\n                int sum = 0, count = 0;\n                while (n >= 2) {\n                count++;\n                sum += n;\n                n = n - 2;\n                }\n                return sum / count;\n        }", "4": "static void sortByRow(int[][] mat, int n, bool descending)\n{\n        int temp = 0;\n        for (int i = 0; i < n; i++)\n        {\n                if (descending == true)\n                {\n                        int t = i;\n                        for (int p = 0; p < n; p++)\n                        {\n                                for (int j = p + 1; j < n; j++)\n                                {\n                                        if (mat[t][p] < mat[t][j])\n                                        {\n                                                temp = mat[t][p];\n                                                mat[t][p] = mat[t][j];\n                                                mat[t][j] = temp;\n                                        }\n                                }\n                        }\n                }\n                else\n                        Array.Sort(mat[i]);\n        }\n}\nstatic void transpose(int mat[][], int n)\n{\n        int temp = 0;\n        for (int i = 0; i < n; i++)\n        {\n                for (int j = i + 1; j < n; j++)\n                {\n                        temp = mat[i][j];\n                        mat[i][j] = mat[j][i];\n                        mat[j][i] = temp;\n                }\n        }\n}\nstatic void sortMatRowAndColWise(int mat[][], int n)\n{\n        sortByRow(mat, n, true);\n        transpose(mat, n);\n        sortByRow(mat, n, false);\n        transpose(mat, n);\n}\nstatic void printMat(int mat[][], int n)\n{\n        for (int i = 0; i < n; i++)\n        {\n                for (int j = 0; j < n; j++)\n                        Console.Write(mat[i][j] + \" \");\n                Console.WriteLine();\n        }\n}", "5": "static bool isDNum(int n)\n{\n        if (n < 4)\n                return false;\n        int numerator = 0, hcf = 0;\n        for(int k = 2; k <= n; k++)\n        {\n        numerator = (int)(Math.Pow(k, n - 2) - k);\n        hcf = __gcd(n, k);\n        }\n        if (hcf == 1 && (numerator % n) != 0)\n                return false;\n        return true;\n}\nstatic int __gcd(int a, int b)\n{\n        return b == 0 ? a : __gcd(b, a % b);        \n}", "6": "static int minOperations(int[] a, int[] b, int n)\n{\n        int minA = Arrays.Min(a);\n        for (int x = minA; x >= 0; x--)\n        {\n                bool check = true;\n                int operations = 0;\n                for (int i = 0; i < n; i++)\n                {\n                        if (x % b[i] == a[i] % b[i])\n                        {\n                                operations += (a[i] - x) / b[i];\n                        }\n                        else\n                        {\n                                check = false;\n                                break;\n                        }\n                }\n                if (check)\n                        return operations;\n        }\n        return -1;\n}", "7": "static void largestSquare(int matrix[][], int R, int C, int q_i[], int q_j[], int K, int Q)\n{\n        int [][]countDP = new int[R][C];\n        countDP[0][0] = matrix[0][0];\n        for(int i = 1; i < R; i++)\n                countDP[i][0] = countDP[i - 1][0] + \n                                                        matrix[i][0];\n        for(int j = 1; j < C; j++)\n                countDP[0][j] = countDP[0][j - 1] +\n                                                matrix[0][j];\n        for(int i = 1; i < R; i++)\n                for(int j = 1; j < C; j++)\n                        countDP[i][j] = matrix[i][j] +\n                                                countDP[i - 1][j] +\n                                                countDP[i][j - 1] -\n                                                countDP[i - 1][j - 1];\n        for(int q = 0; q < Q; q++)\n        {\n                int i = q_i[q];\n                int j = q_j[q];\n                int min_dist = Math.Min(Math.Min(i, j), \n                                        Math.Min(R - i - 1, C - j - 1));\n                int ans = -1;\n                for(int k = 0; k <= min_dist; k++)\n                {\n                        int x1 = i - k, x2 = i + k;\n                        int y1 = j - k, y2 = j + k;\n                        int count = countDP[x2][y2];\n                        if (x1 > 0)\n                                count -= countDP[x1 - 1][y2];\n                        if (y1 > 0)\n                                count -= countDP[x2][y1 - 1];\n                        if (x1 > 0 && y1 > 0)\n                                count += countDP[x1 - 1][y1 - 1];\n                        if (count > K)\n                                break;\n                        ans = 2 * k + 1;\n                }\n                System.out.print(ans + \"\\n\");\n        }\n}", "8": "static int countSubsequences(int[] arr, int N)\n        {\n                int odd = 0;\n                for (int i = 0; i < N; i++) {\n                        if ((arr[i] & 1) % 2 == 1)\n                                odd++;\n                }\n                return (1 << odd) - 1;\n        }", "9": "static long power(int p)\n        {\n                long res = 1;\n                for (int i = 1; i <= p; ++i)\n                {\n                        res *= 2;\n                        res %= mod;\n                }\n                return res % mod;\n        }\nstatic long subset_square_sum(int A[])\n        {\n                int n = A.length;\n                long ans = 0;\n                for (int i : A)\n                {\n                        ans += (1 * i * i) % mod;\n                        ans %= mod;\n                }\n                return (1 * ans * power(n - 1)) % mod;\n        }", "10": "static bool DigitWell(int n, int m, int k)\n{\n        int cnt = 0;\n        while (n > 0)\n        {\n                if (n % 10 == m)\n                        ++cnt;\n                n /= 10;\n        }\n        return cnt == k;\n}\nstatic int FindInt(int n, int m, int k)\n{\n        int i = n + 1;\n        while (true)\n        {\n                if (DigitWell(i, m, k))\n                        return i;\n                i++;\n        }\n}", "11": "static int GCD(int a, int b)\n        {\n                if (a == 0 || b == 0)\n                        return 0;\n                if (a == b)\n                        return a;\n                if (a > b)\n                        return GCD(a - b, b);\n                return GCD(a, b - a);\n        }\nstatic int CpFact(int x, int y)\n        {\n                while (GCD(x, y) != 1) {\n                        x = x / GCD(x, y);\n                }\n                return x;\n        }", "12": "static int SieveOfAtkin(int limit)\n        {\n                if (limit > 2)\n                        System.out.print(2 + \" \");\n                if (limit > 3)\n                        System.out.print(3 + \" \");\n                bool[] sieve = new bool[limit];\n                for (int i = 0; i < limit; i++)\n                        sieve[i] = false;\n                for (int x = 1; x * x < limit; x++) {\n                        for (int y = 1; y * y < limit; y++) {\n                                int n = (4 * x * x) + (y * y);\n                                if (n <= limit && (n % 12 == 1 || n % 12 == 5))\n                                        sieve[n] ^= true;\n                                n = (3 * x * x) + (y * y);\n                                if (n <= limit && n % 12 == 7)\n                                        sieve[n] ^= true;\n                                n = (3 * x * x) - (y * y);\n                                if (x > y && n <= limit && n % 12 == 11)\n                                        sieve[n] ^= true;\n                        }\n                }\n                for (int r = 5; r * r < limit; r++) {\n                        if (sieve[r]) {\n                                for (int i = r * r; i < limit; i += r * r)\n                                        sieve[i] = false;\n                        }\n                }\n                for (int a = 5; a < limit; a++)\n                        if (sieve[a])\n                                System.out.print(a + \" \");\n                return 0;\n        }", "13": "static int MaxSubsetlength(String arr[], int A, int B)\n{\n        int dp[][] = new int[A + 1][B + 1];\n        for(String str : arr)\n        {\n                int zeros = 0, ones = 0;\n                for(char ch : str.toCharArray())\n                {\n                        if (ch == '0')\n                                zeros++;\n                        else\n                                ones++;\n                }\n                for(int i = A; i >= zeros; i--)\n                        for(int j = B; j >= ones; j--)\n                                dp[i][j] = Math.max( dp[i][j], dp[i - zeros][j - ones] + 1);\n        }\n        return dp[A][B];\n}", "14": "static bool isPowerOfTwo(int n)\n        {\n            if (n == 0)\n                return false;\n            return (int)(Math.Ceil((Math.Log(n) / Math.Log(2)))) ==\n                (int)(Math.Floor(((Math.Log(n) / Math.Log(2)))));\n        }", "15": "static int productPairs(int arr[], int n)\n{\n        int product = 1;\n        for(int i = 0; i < n; i++)\n        {\n        for(int j = 0; j < n; j++)\n        {\n                product *= (arr[i] % mod * arr[j] % mod) % mod;\n                product = product % mod;\n        }\n        }\n        return product % mod;\n}", "16": "public static int FindMaxAverage(int []arr, int n, int k)\n{\n        if (k > n)\n                return -1;\n        int []csum = new int[n];\n        csum[0] = arr[0];\n        for (int i = 1; i < n; i++)\n        csum[i] = csum[i - 1] + arr[i];\n        int max_sum = csum[k - 1],\n                                max_end = k - 1;\n        for (int i = k; i < n; i++)\n        {\n                int curr_sum = csum[i] -\n                                csum[i - k];\n                if (curr_sum > max_sum)\n                {\n                        max_sum = curr_sum;\n                        max_end = i;\n                }\n        }\n        return max_end - k + 1;\n}", "17": "static void countSubarrays(int[] a, int n, int k)\n{\n        Dictionary<int, int> cnt = new Dictionary<>();\n        long ans = 0;\n        List<int> pref = new List<>();\n        pref.Add(0);\n        for(int i = 0; i < n; i++)\n                pref.Add((a[i] + pref.get(i)) % k);\n        cnt.Add(0, 1);\n        for(int i = 1; i <= n; i++)\n        {\n                int remIdx = i - k;\n                if (remIdx >= 0)\n                {\n                        if (cnt.ContainsKey((pref.get(remIdx) - remIdx % k + k) % k))\n                                cnt.Add((pref.get(remIdx) - remIdx % k + k) % k,\n                                cnt.get((pref.get(remIdx) - remIdx % k + k) % k) - 1);\n                        else\n                                cnt.Add((pref.get(remIdx) - remIdx % k + k) % k, -1);\n                }\n                if (cnt.ContainsKey((pref.get(i) - i % k + k) % k))\n                        ans += cnt.get((pref.get(i) - i % k + k) % k);\n                if (cnt.ContainsKey((pref.get(i) - i % k + k) % k))\n                        cnt.Add((pref.get(i) - i % k + k) % k,\n                        cnt.get((pref.get(i) - i % k + k) % k) + 1);\n                else\n                        cnt.Add((pref.get(i) - i % k + k) % k, 1);\n        }\n        System.out.println(ans);\n}", "18": "static void Calculate_factorial()\n        {\n                fact[0] = 1;\n                for (int i = 1; i <= mx; i++) {\n                        fact[i] = i * fact[i - 1];\n                        fact[i] %= mod;\n                }\n        }\nstatic int UniModal_per(int a, int b)\n        {\n                int res = 1;\n                while (b > 0) {\n                        if (b % 2 != 0)\n                                res = res * a;\n                        res %= mod;\n                        a = a * a;\n                        a %= mod;\n                        b /= 2;\n                }\n                return res;\n        }\nstatic void countPermutations(int n)\n        {\n                Calculate_factorial();\n                int uni_modal = UniModal_per(2, n - 1);\n                int nonuni_modal = fact[n] - uni_modal;\n                System.out.print(uni_modal + \" \" + nonuni_modal);\n                return;\n        }", "19": "static string RemoveChars(char[] arr, int k)\n{\n        int []hash = new int[MAX_CHAR];\n        int n = arr.Length;\n        for (int i = 0; i < n; ++i)\n                hash[arr[i] - 'a']++;\n        string ans = \"\";\n        for (int i = 0; i < n; ++i) {\n                if (hash[arr[i] - 'a'] != k) {\n                        ans += arr[i];\n                }\n        }\n        return ans;\n}", "20": "static int enneacontahexagonNum(int n)\n{\n        return (94 * n * n - 92 * n) / 2;\n}", "21": "static void possibleTripletInRange(int L, int R)\n{\n        bool flag = false;\n        int possibleA = 0,\n                possibleB = 0,\n                possibleC = 0;\n        int numbersInRange = (R - L + 1);\n        if (numbersInRange < 3)\n        {\n                flag = false;\n        }\n        else if (numbersInRange > 3)\n        {\n                flag = true;\n                if (L % 2 > 0)\n                {\n                        L++;\n                }\n                possibleA = L;\n                possibleB = L + 1;\n                possibleC = L + 2;\n        }\n        else\n        {\n                if (!(L % 2 > 0))\n                {\n                        flag = true;\n                        possibleA = L;\n                        possibleB = L + 1;\n                        possibleC = L + 2;\n                }\n                else\n                {\n                        flag = false;\n                }\n        }\n        if (flag == true)\n        {\n                Console.WriteLine(\"(\" + possibleA + \", \" + possibleB + \", \" + possibleC + \")\" + \" is one such possible\" + \" triplet between \" + L + \" and \" + R );\n        }\n        else {\n                Console.WriteLine(\"No Such Triplet\" + \" exists between \" + L + \" and \" + R);\n        }\n}", "22": "static int largest_sum(int arr[], int n)\n        {\n                int maximum = -1;\n                HashMap<int, int> m = new HashMap<int, int>();\n                for (int i = 0; i < n; i++) {\n                        if (m.containsKey(arr[i])){\n                        m.put(arr[i], m.get(arr[i]) + 1);\n                        }\n                        else{\n                                m.put(arr[i], 1);\n                        }\n                }\n                for(int i = 0; i < n; i++){\n                        if (m.get(arr[i]) > 1) {\n                                if (m.containsKey(2*arr[i]))\n                                {\n                                        m.put(2*arr[i],m.get(2 * arr[i])+ m.get(arr[i]) / 2);\n                                }\n                                else\n                                {\n                                        m.put(2*arr[i],m.get(arr[i]) / 2);\n                                }\n                                if (2 * arr[i] > maximum)\n                                        maximum = 2 * arr[i];\n                        }\n                        }\n                return maximum;\n        }", "23": "static void sieveOfEratosthenes()\n{\n        isPrime[1] = true;\n        for (int i = 2; i * i < MAX; i++)\n        {\n                if (!isPrime[i])\n                {\n                        for (int j = 2 * i; j < MAX; j += i)\n                                isPrime[j] = true;\n                }\n        }\n}\nstatic int findPrime(int n)\n{\n        int num = n + 1;\n        while (num > 0)\n        {\n                if (!isPrime[num])\n                        return num;\n                num = num + 1;\n        }\n        return 0;\n}\nstatic int minNumber(int arr[], int n)\n{\n        sieveOfEratostheneses();\n        int sum = 0;\n        for (int i = 0; i < n; i++)\n                sum += arr[i];\n        if (!isPrime[sum])\n                return 0;\n        int num = findPrime(sum);\n        return num - sum;\n}", "24": "static bool possible(long mid, int[] a)\n{\n        long n = a.Length;\n        long total = (n * (n - 1)) / 2;\n        long need = (total + 1) / 2;\n        long count = 0;\n        long start = 0, end = 1;\n        while (end < n)\n        {\n                if (a[(int)end] - a[(int)start] <= mid)\n                {\n                        end++;\n                }\n                else\n                {\n                        count += (end - start - 1);\n                        start++;\n                }\n        }\n        if (end == n && start < end &&\n                a[(int)end - 1] - a[(int)start] <= mid)\n        {\n                long t = end - start - 1;\n                count += (t * (t + 1) / 2);\n        }\n        if (count >= need)\n                return true;\n        else\n                return false;\n}\nstatic long findMedian(int[] a)\n{\n        long n = a.Length;\n        long low = 0, high = a[(int)n - 1] - a[0];\n        while (low <= high)\n        {\n                long mid = (low + high) / 2;\n                if (possible(mid, a))\n                        high = mid - 1;\n                else\n                        low = mid + 1;\n        }\n        return high + 1;\n}", "25": "static int MinimizeleftOverSum(int[] a, int n)\n{\n        List<int> v1 = new List<int>();\n        List<int> v2 = new List<int>();\n\n        for (int i = 0; i < n; i++)\n        {\n                if (a[i] % 2 == 1)\n                        v1.Add(a[i]);\n                else\n                        v2.Add(a[i]);\n        }\n\n        if (v1.Count > v2.Count)\n        {\n                v1.Sort();\n                v2.Sort();\n                int x = v1.Count - v2.Count - 1;\n                int sum = 0;\n                int i = 0;\n\n                while (i < x)\n                {\n                        sum += v1[i];\n                        i++;\n                }\n                return sum;\n        }\n        else if (v2.Count > v1.Count)\n        {\n                v1.Sort();\n                v2.Sort();\n                int x = v2.Count - v1.Count - 1;\n                int sum = 0;\n                int i = 0;\n\n                while (i < x)\n                {\n                        sum += v2[i];\n                        i++;\n                }\n                return sum;\n        }\n        else\n                return 0;\n}", "26": "int gcd(int a, int b)\n{\n        if (b == 0)\n                return a;\n        return gcd(b, a % b);\n}\nint MaxGCD(int a[], int n)\n{\n        int Prefix[] = new int[n + 2];\n        int Suffix[] = new int[n + 2] ;\n        Prefix[1] = a[0];\n        for (int i = 2; i <= n; i += 1)\n        {\n                Prefix[i] = gcd(Prefix[i - 1], a[i - 1]);\n        }\n        Suffix[n] = a[n - 1];\n        for (int i = n - 1; i >= 1; i -= 1)\n        {\n                Suffix[i] = gcd(Suffix[i + 1], a[i - 1]);\n        }\n        int ans = Math.max(Suffix[2], Prefix[n - 1]);\n        for (int i = 2; i < n; i += 1)\n        {\n                ans = Math.max(ans, gcd(Prefix[i - 1], Suffix[i + 1]));\n        }\n        return ans;\n}", "27": "static int CountWays(int N)\n{\n        int E = (N * (N - 1)) / 2;\n        if (N == 1)\n                return 0;\n        return (int)Math.Pow(2, E - 1);\n}", "28": " static int power(int X, int Y)\n {\n        int res = 1;\n        X = X % M;\n        if (X == 0)\n        return 0;\n        while (Y > 0)\n        {\n        if ((Y & 1) != 0)\n        {\n                res = (res * X) % M;\n        }\n        Y = Y >> 1;\n        X = (X * X) % M;\n        }\n        return res;\n }\nstatic int findValue(int n)\n {\n        int X = 0;\n        int pow_10 = 1;\n        while (n != 0)\n        {\n        if ((n & 1) != 0)\n        {\n                X += pow_10;\n        }\n        pow_10 *= 10;\n        n /= 2;\n        }\n        X = (X * 2) % M;\n        int res = power(2, X);\n        return res;\n }", "29": "static void printNum(int L, int R)\n{\n        for(int i = L; i <= R; i++)\n        {\n                int temp = i;\n                int c = 10;\n                int flag = 0;\n                while (temp > 0)\n                {\n                        if (temp % 10 >= c)\n                        {\n                                flag = 1;\n                                break;\n                        }\n                        c = temp % 10;\n                        temp /= 10;\n                }\n                if (flag == 0)\n                        Console.Write(i + \" \");\n        }\n}", "30": "static void sub_segments(String str, int n)\n{\n        int l = str.length();\n        for (int x = 0; x < l; x += n)\n        {\n                String newlist = str.substring(x, x + n);\n                List<Character> arr = new List<Character>();\n                for (char y : newlist.toCharArray())\n                {\n                        if (!arr.contains(y))\n                                arr.add(y);\n                }\n                for (char y : arr)\n                        System.out.print(y);\n                System.out.println();\n        }\n}", "31": "static int cutRod(int price[],int n)\n        {\n                int val[] = new int[n+1];\n                val[0] = 0;\n                for (int i = 1; i<=n; i++)\n                {\n                        int max_val = Integer.MIN_VALUE;\n                        for (int j = 0; j < i; j++)\n                                max_val = Math.max(max_val, price[j] + val[i-j-1]);\n                        val[i] = max_val;\n                }\n                return val[n];\n        }", "32": "static void find_distinct(int[] a, int n, int q, int[] queries)\n{\n        int[] check = new int[MAX];\n        int[] idx = new int[MAX];\n        int cnt = 1;\n        for (int i = n - 1; i >= 0; i--)\n        {\n                if (check[a[i]] == 0)\n                {\n                        idx[i] = cnt;\n                        check[a[i]] = 1;\n                        cnt++;\n                }\n                else\n                {\n                        idx[i] = cnt - 1;\n                }\n        }\n        for (int i = 0; i < q; i++)\n        {\n                        int m = queries[i];\n                        Console.Write(idx[m] + \" \");\n        }\n}", "33": "static bool possibility(Dictionary<int, int> m, int length, string s)\n{\n int countodd = 0;\n for (int i = 0; i < length; i++)\n {\n        if (m[s[i] - '0'] % 2 == 1)\n        countodd++;\n        if (countodd > 1)\n        return false;\n }\n return true;\n}\nstatic void largestPalindrome(string s)\n{\n int l = s.length();\n Dictionary<int,\n                int> m = new Dictionary<int, int>();\n for (int i = 0; i < l; i++)\n        if(m.ContainsKey(s[i] - '0'))\n        m[s[i] - '0'] =\n        m[s[i] - '0'] + 1;\n else\n        m.Add(s[i] - '0', 1);\n if (possibility(m, l, s) == false)\n {\n        Console.WriteLine(\"Palindrome cannot be formed\");\n        return;\n }\n char []largest = new char[l];\n int front = 0;\n for (int i = 9; i >= 0; i--)\n {\n        if (m.ContainsKey(i) &&\n                m.get(i)%2==1)\n        {\n        largest[l / 2] = (char)(i + 48);\n        m[i] = m[i]-1;\n        while (m[i] > 0)\n        {\n                largest[front] = (char)(i + 48);\n                largest[l - front - 1] =\n                                        (char)(i + 48);\n                m[i] = m[i] - 2;\n                front++;\n        }\n        }\n        else\n        {\n        while (m.ContainsKey(i) &&\n                        m[i] > 0)\n        {\n                largest[front] = (char)(i + 48);\n                largest[l - front - 1] =\n                        (char)(i + 48);\n                m[i] = m[i] - 2;\n                front++;\n        }\n        }\n }\n for (int i = 0; i < l; i++)\n        Console.Write(largest[i]);\n}", "34": "static int Wedderburn(int n)\n{\n        if (n <= 2)\n                return store.get(n);\n        else if (n % 2 == 0)\n        {\n                int x = n / 2, ans = 0;\n                for (int i = 1; i < x; i++)\n                {\n                        ans += store.get(i) * store.get(n - i);\n                }\n                ans += (store.get(x) * (store.get(x) + 1)) / 2;\n                store. put(n, ans);\n                return ans;\n        }\n        else\n        {\n                int x = (n + 1) / 2, ans = 0;\n                for (int i = 1; i < x; i++)\n                {\n                        ans += store.get(i) * store.get(n - i);\n                }\n                store. put(n, ans);\n                return ans;\n        }\n}\nstatic void Wedderburn_Etherington(int n)\n{\n        store. put(0, 0);\n        store. put(1, 1);\n        store. put(2, 1);\n        for (int i = 0; i < n; i++)\n        {\n                System.out.print(Wedderburn(i));\n                if(i != n - 1)\n                        System.out.print(\" \");\n        }\n}", "35": "static int Icosihenagonal_num(int n)\n{\n        return (19 * n * n - 17 * n) / 2;\n}", "36": "static int noOfBinaryStrings(int N, int k)\n{\n        int dp[] = new int[100002];\n        for (int i = 1; i <= k - 1; i++)\n        {\n                dp[i] = 1;\n        }\n        dp[k] = 2;\n        for (int i = k + 1; i <= N; i++)\n        {\n                dp[i] = (dp[i - 1] + dp[i - k]) % mod;\n        }\n        return dp[N];\n}", "37": "static int averageEven(int n)\n        {\n                if (n % 2 != 0) {\n                System.out.println(\"Invalid Input\");\n                        return -1;\n                }\n                return (n + 2) / 2;\n        }", "38": "static int LowerInsertionPoint(int arr[], int n, int X)\n        {\n        if (X < arr[0])\n                return 0;\n        else if (X > arr[n - 1])\n                return n;\n        int lowerPnt = 0;\n        int i = 1;\n        while (i < n && arr[i] < X) {\n                lowerPnt = i;\n                i = i * 2;\n        }\n        while (lowerPnt < n && arr[lowerPnt] < X)\n                lowerPnt++;\n        return lowerPnt;\n        }", "39": "static string EncryptString(string str, int n)\n{\n        int i = 0, cnt = 0;\n        string encryptedStr = \"\";\n        while (i < n)\n        {\n                cnt = i + 1;\n                while (cnt-- >0)\n                        encryptedStr += str[i];\n                i++;\n        }\n        return encryptedStr;\n}", "40": "static int CountIntersections(int n)\n        {\n                return n * (n - 1) / 2;\n        }", "41": "static void findElements(int arr[], int n)\n{\n        int first = Int32.MinValue;\n        int second = Int32.MaxValue;\n        for (int i = 0; i < n; i++)\n        {\n                if (arr[i] > first)\n                {\n                        second = first;\n                        first = arr[i];\n                }\n                else if (arr[i] > second)\n                        second = arr[i];\n        }\n        for (int i = 0; i < n; i++)\n                if (arr[i] < second)\n                        Console.Write(arr[i] + \" \") ;\n}", "42": "static void findRightAngle(double A, double H)\n{\n        double D = Math.Pow(H, 4) - 16 * A * A;\n        if (D >= 0)\n        {\n                double root1 = (H * H + Math.Sqrt(D)) / 2;\n                double root2 = (H * H - Math.Sqrt(D)) / 2;\n                double a = Math.Sqrt(root1);\n                double b = Math.Sqrt(root2);\n                if (b >= a)\n                        System.out.Print(a + \" \" + b + \" \" + H);\n                else\n                        System.out.Print(b + \" \" + a + \" \" + H);\n        }\n        else\n                System.out.Print(\"-1\");\n}", "43": "static bool check(string s, int m)\n{\n        int l = s.Length;\n        int c1 = 0;\n        int c2 = 0;\n        for (int i = 0; i < l; i++)\n        {\n                if (s[i] == '0')\n                {\n                        c2 = 0;\n                        c1++;\n                }\n                else\n                {\n                        c1 = 0;\n                        c2++;\n                }\n                if (c1 == m || c2 == m)\n                        return true;\n        }\n        return false;\n}", "44": "static void findbitwiseOR(int[] a, int n)\n        {\n                int res = 0;\n                for (int i = 0; i < n; i++) {\n                        int curr_sub_array = a[i];\n                        res = res | curr_sub_array;\n                        for (int j = i; j < n; j++) {\n                                curr_sub_array = curr_sub_array & a[j];\n                                res = res | curr_sub_array;\n                        }\n                }\n                Console.WriteLine(res);\n        }", "45": "static long multiplyByMersenne(long N, long M)\n{\n        long x = (int)(Math.Log(M + 1) / Math.Log(2));\n        return ((N << x) - N);\n}", "46": "public static int eval(int a, char op, int b)\n        {\n                if (op == '+')\n                {\n                        return a + b;\n                }\n                if (op == '-')\n                {\n                        return a - b;\n                }\n                if (op == '*')\n                {\n                        return a * b;\n                }\n                return Integer.MAX_VALUE;\n        }\npublic static Vector<int> evaluateAll(string expr, int low, int high)\n        {\n                Vector<int> res = new Vector<int>();\n                if (low == high)\n                {\n                        res.add(expr.charAt(low) - '0');\n                        return res;\n                }\n                if (low == (high - 2))\n                {\n                        int num = eval(expr.charAt(low) - '0',\n                                                expr.charAt(low + 1),\n                                                expr.charAt(low + 2) - '0');\n                        res.add(num);\n                        return res;\n                }\n                for (int i = low + 1; i <= high; i += 2)\n                {\n                        Vector<int> l = evaluateAll(expr, low, i - 1);\n                        Vector<int> r = evaluateAll(expr, i + 1, high);\n                        for (int s1 = 0; s1 < l.size(); s1++)\n                        {\n                                for (int s2 = 0; s2 < r.size(); s2++)\n                                {\n                                        int val = eval(l.get(s1), expr.charAt(i), r.get(s2));\n                                        res.add(val);\n                                }\n                        }\n                }\n                return res;\n        }", "47": "static int AreaOfSquare(int s)\n{\n        int area = s * s;\n        return area;\n}", "48": "public static int LongOddEvenIncSeq(int[] arr, int n)\n        {\n                int[] lioes = new int[n];\n                int maxLen = 0;\n                for (int i = 0; i < n; i++)\n                        lioes[i] = 1;\n                for (int i = 1; i < n; i++)\n                        for (int j = 0; j < i; j++)\n                                if (arr[i] > arr[j] &&\n                                (arr[i] + arr[j]) % 2 != 0 && lioes[i] < lioes[j] + 1)\n                                        lioes[i] = lioes[j] + 1;\n                for (int i = 0; i < n; i++)\n                        if (maxLen < lioes[i])\n                                maxLen = lioes[i];\n                return maxLen;\n        }", "49": "static int binarySearch(int a[], int item, int low, int high)\n{\n        while (low <= high) {\n                int mid = low + (high - low) / 2;\n                if (item == a[mid])\n                        return mid + 1;\n                else if (item > a[mid])\n                        low = mid + 1;\n                else\n                        high = mid - 1;\n        }\n        return low;\n}\nstatic void insertionSort(int a[], int n)\n{\n        int i, loc, j, k, selected;\n        for (i = 1; i < n; ++i) {\n                j = i - 1;\n                selected = a[i];\n                loc = binarySearch(a, selected, 0, j);\n                while (j >= loc) {\n                        a[j + 1] = a[j];\n                        j--;\n                }\n                a[j + 1] = selected;\n        }\n}", "50": "public static int countLastDigitK(int low, int high, int k)\n        {\n                int mlow = 10 * (int)\n                                        Math.Ceiling(low/10.0);\n                int mhigh = 10 * (int)\n                                        Math.Floor(high/10.0);\n                int count = (mhigh - mlow)/10;\n                if (high % 10 >= k)\n                        count++;\n                if (low % 10 <= k && (low%10) > 0)\n                        count++;\n                return count;\n        }", "51": "int findCrossOver(int arr[], int low, int high, int x)\n        {\nif (arr[high] <= x) \n                        return high;\nif (arr[low] > x) \n                        return low;\n                int mid = (low + high)/2; \n                if (arr[mid] <= x && arr[mid+1] > x)\n                        return mid;\n                if(arr[mid] < x)\n                        return findCrossOver(arr, mid+1, high, x);\n                return findCrossOver(arr, low, mid - 1, x);\n        }\nvoid printKclosest(int arr[], int x, int k, int n)\n        {\n                int l = findCrossOver(arr, 0, n-1, x);\nint r = l+1; \nint count = 0; \n                if (arr[l] == x) l--;\n                while (l >= 0 && r < n && count < k)\n                {\n                        if (x - arr[l] < arr[r] - x)\n                                System.out.print(arr[l--]+\" \");\n                        else\n                                System.out.print(arr[r++]+\" \");\n                        count++;\n                }\n                while (count < k && l >= 0)\n                {\n                        System.out.print(arr[l--]+\" \");\n                        count++;\n                }\n                while (count < k && r < n)\n                {\n                        System.out.print(arr[r++]+\" \");\n                        count++;\n                }\n        }", "52": "static bool check(string s, int n)\n{\n        Stack<char> st = new Stack<char>();\n        for(int i = 0; i < n; i++)\n        {\n        if (!st.isEmpty() &&\n                        st.Peek() == s[i])\n                st.Pop();\n        else\n                st.Add(s[i]);\n        }\n        if (st.isEmpty())\n        {\n                return true;\n        }\n        else\n        {\n                return false;\n        }\n}", "53": "static bool isPrime(int n)\n                {\n                        if (n <= 1)\n                                return false;\n                        for (int i = 2; i < n; i++)\n                                if (n % i == 0)\n                                        return false;\n                        return true;\n                }\nstatic int findPrime(int n)\n                {\n                        int num = n + 1;\n                        while (num > 0)\n                                {\n                                        if (isPrime(num))\n                                                return num;\n                                        num = num + 1;\n                                }\n                        return 0;\n                }\nstatic int minNumber(int[] arr, int n)\n                {\n                        int sum = 0;\n                        for (int i = 0; i < n; i++)\n                                sum += arr[i];\n                        if (isPrime(sum))\n                                return 0;\n                        int num = findPrime(sum);\n                        return num - sum;\n                }", "54": "public static double Convert(double radian)\n        {\n                double pi = 3.14159;\n                return(radian * (180/pi));\n        }", "55": "static double longestRodInCuboid(int length, int breadth, int height)\n{\n        double result;\n        int temp;\n        temp = length * length + breadth *\n                breadth + height * height;\n        result = Math.Sqrt(temp);\n        return result;\n}", "56": "static void least_prime_factor()\n{\n        for (int i = 2; i < N; i++)\n                if (lpf[i] == 0)\n                        for (int j = i; j < N; j += i)\n                                if (lpf[j] == 0)\n                                        lpf[j] = i;\n}\nstatic void Mobius()\n{\n        for (int i = 1; i < N; i++)\n        {\n                if (i == 1)\n                        mobius[i] = 1;\n                else\n                {\n                        if (lpf[i / lpf[i]] == lpf[i])\n                                mobius[i] = 0;\n                        else\n                                mobius[i] = -1 * mobius[i / lpf[i]];\n                }\n        }\n}\nstatic int gcd_pairs(int a[], int n)\n{\n        int maxi = 0;\n        int []fre = new int[N];\n        for (int i = 0; i < n; i++)\n        {\n                fre[a[i]]++;\n                maxi = Math.max(a[i], maxi);\n        }\n        least_prime_factor();\n        Mobius();\n        int ans = 0;\n        for (int i = 1; i <= maxi; i++)\n        {\n                if (mobius[i] == 0)\n                        continue;\n                int temp = 0;\n                for (int j = i; j <= maxi; j += i)\n                        temp += fre[j];\n                ans += temp * (temp - 1) / 2 * mobius[i];\n        }\n        return ans;\n}", "57": "static bool isPrime(int n)\n{\n        if (n <= 1)\n                return false;\n        for (int i = 2; i < n; i++)\n                if (n % i == 0)\n                        return false;\n        return true;\n}\nstatic int countSubsequences(int arr[], int n)\n{\n        int totalSubsequence = (int)(Math.Pow(2, n) - 1);\n        int countPrime = 0, countOnes = 0;\n        for (int i = 0; i < n; i++)\n        {\n                if (arr[i] == 1)\n                        countOnes++;\n                else if (isPrime(arr[i]))\n                        countPrime++;\n        }\n        int compositeSubsequence;\n        int onesSequence = (int)(Math.Pow(2, countOnes) - 1);\n        compositeSubsequence = totalSubsequence -\n                                                                countPrime -\n                                                        onesSequence -\n                                                        onesSequence *\n                                                        countPrime;\n        return compositeSubsequence;\n}", "58": "static void dfs(int u, int count)\n{\n        visited[u] = true;\n        int temp = 0;\n        for (int i = 0; i < adjacent.get(u).size(); i++)\n        {\n                if (!visited[adjacent.get(u).get(i)])\n                {\n                        temp++;\n                        dfs(adjacent.get(u).get(i), count + 1);\n                }\n        }\n        if (temp == 0)\n        {\n                if (maxi < count)\n                {\n                        maxi = count;\n                        startnode = u;\n                }\n        }\n}\nstatic void dfs1(int u, int count)\n{\n        visited[u] = true;\n        int temp = 0;\n        for (int i = 0; i < adjacent.get(u).size(); i++)\n        {\n                if (!visited[adjacent.get(u).get(i)])\n                {\n                        temp++;\n                        parent[adjacent.get(u).get(i)] = u;\n                        dfs1(adjacent.get(u).get(i), count + 1);\n                }\n        }\n        if (temp == 0)\n        {\n                if (maxi < count)\n                {\n                        maxi = count;\n                        endnode = u;\n                }\n        }\n}\nstatic void dfs2(int u, int count)\n{\n        visited[u] = true;\n        int temp = 0;\n        for (int i = 0; i < adjacent.get(u).size(); i++)\n        {\n                if (!visited[adjacent.get(u).get(i)] &&\n                        !vis[adjacent.get(u).get(i)])\n                {\n                        temp++;\n                        dfs2(adjacent.get(u).get(i), count + 1);\n                }\n        }\n        if (temp == 0)\n        {\n                if (maxi < count)\n                {\n                        maxi = count;\n                        thirdnode = u;\n                }\n        }\n}\nstatic void findNodes()\n{\n        dfs(1, 0);\n        for (int i = 0; i <= N; i++)\n                visited[i] = false;\n        maxi = -1;\n        dfs1(startnode, 0);\n        for (int i = 0; i <= N; i++)\n                visited[i] = false;\n        int x = endnode;\n        vis[startnode] = true;\n        while (x != startnode)\n        {\n                vis[x] = true;\n                x = parent[x];\n        }\n        maxi = -1;\n        for (int i = 1; i <= N; i++)\n        {\n                if (vis[i])\n                        dfs2(i, 0);\n        }\n}"}}, "Java - C": {"Id": {"0": 13431, "1": 9290, "2": 2114, "3": 8795, "4": 12646, "5": 1998, "6": 1428, "7": 14021, "8": 1695, "9": 1795, "10": 1694, "11": 2120, "12": 1537, "13": 2308, "14": 14022, "15": 1696, "16": 821, "17": 7071, "18": 1853, "19": 2121, "20": 7051, "21": 1535, "22": 2026, "23": 2079, "24": 12639, "25": 13575, "26": 14020, "27": 9457, "28": 2127, "29": 14023, "30": 13140, "31": 13430, "32": 4855, "33": 2132, "34": 4847, "35": 7068, "36": 12716, "37": 12794, "38": 2130}, "Java": {"0": "static void printDivisors(int n)\n        {\n                for (int i=1;i<=n;i++)\n                        if (n%i==0)\n                                System.out.print(i+\" \");\n        }", "1": "static double Perimeter(double s, int n)\n        {\n                double perimeter = 1;\n                perimeter = n * s;\n                return perimeter;\n        }", "2": "static int countSetBits(int n)\n        {\n                int count = 0;\n                while (n > 0) {\n                        count += n & 1;\n                        n >>= 1;\n                }\n                return count;\n        }", "3": "void reverse(String str)\n        {\n                if ((str==null)||(str.length() <= 1))\n                System.out.println(str);\n                else\n                {\n                        System.out.print(str.charAt(str.length()-1));\n                        reverse(str.substring(0,str.length()-1));\n                }\n        }", "4": "static int averageOdd(int n)\n        {\n                if (n % 2 == 0)\n                {\n                        System.out.println(\"Invalid Input\");\n                        return -1;\n                }\n                return (n + 1) / 2;\n        }", "5": "static int multiply(int x, int y) {\n                if (y == 0)\n                        return 0;\n                if (y > 0)\n                        return (x + multiply(x, y - 1));\n                if (y < 0)\n                        return -multiply(x, -y);\n                return -1;\n        }", "6": "void leftRotatebyOne(int arr[], int n)\n        {\n                int i, temp;\n                temp = arr[0];\n                for (i = 0; i < n - 1; i++)\n                        arr[i] = arr[i + 1];\n                arr[n-1] = temp;\n        }\nvoid leftRotate(int arr[], int d, int n)\n        {\n                for (int i = 0; i < d; i++)\n                        leftRotatebyOne(arr, n);\n        }\nvoid printArray(int arr[], int n)\n        {\n                for (int i = 0; i < n; i++)\n                        System.out.print(arr[i] + \" \");\n        }", "7": "static int multiplyBySevenByEight(int n)\n        {\n                return ((n << 3) -n) >> 3;\n        }", "8": "static int _binarySearch(int arr[], int low, int high, int x)\n        {\n                if (high >= low)\n                {\n                        int mid = (low + high)/2; \n                        if ( (mid == 0 || x > arr[mid-1]) && (arr[mid] == x) )\n                                return mid;\n                        else if (x > arr[mid])\n                                return _binarySearch(arr, (mid + 1), high, x);\n                        else\n                                return _binarySearch(arr, low, (mid -1), x);\n                }\n                return -1;\n        }\nstatic boolean isMajority(int arr[], int n, int x)\n        {\n                int i = _binarySearch(arr, 0, n-1, x);\n                if (i == -1)\n                        return false;\n                if (((i + n/2) <= (n -1)) && arr[i + n/2] == x)\n                        return true;\n                else\n                        return false;\n        }", "9": "void sort(int arr[])\n        {\n                int n = arr.length;\n                for (int i = 0; i < n-1; i++)\n                {\n                        int min_idx = i;\n                        for (int j = i+1; j < n; j++)\n                                if (arr[j] < arr[min_idx])\n                                        min_idx = j;\n                        int temp = arr[min_idx];\n                        arr[min_idx] = arr[i];\n                        arr[i] = temp;\n                }\n        }\nvoid printArray(int arr[])\n        {\n                int n = arr.length;\n                for (int i=0; i<n; ++i)\n                        System.out.print(arr[i]+\" \");\n                System.out.println();\n        }", "10": "static boolean isMajority(int arr[], int n, int x)\n        {\n                int i, last_index = 0;\n                last_index = (n%2==0)? n/2: n/2+1;\n                for (i = 0; i < last_index; i++)\n                {\n                        if (arr[i] == x && arr[i+n/2] == x)\n                                return true;\n                }\n                return false;\n        }", "11": "static int countSetBitsRec(int num)\n        {\n                int nibble = 0;\n                if (0 == num)\n                        return num_to_bits[0];\n                nibble = num & 0xf;\n                return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n        }", "12": "int FindMaxSum(int arr[], int n)\n        {\n                int incl = arr[0];\n                int excl = 0;\n                int excl_new;\n                int i;\n                for (i = 1; i < n; i++)\n                {\n                        excl_new = (incl > excl) ? incl : excl;\n                        incl = excl + arr[i];\n                        excl = excl_new;\n                }\n                return ((incl > excl) ? incl : excl);\n        }", "13": "static void printTwoOdd(int arr[], int size)\n        {\n        int xor2 = arr[0];\n        int set_bit_no; \n        int i;\n        int n = size - 2;\n        int x = 0, y = 0;\n        for(i = 1; i < size; i++)\n                xor2 = xor2 ^ arr[i];\n        set_bit_no = xor2 & ~(xor2-1);\n        for(i = 0; i < size; i++)\n        {\n                if((arr[i] & set_bit_no)>0)\n                x = x ^ arr[i];\n                else\n                y = y ^ arr[i];\n        }\n        System.out.println(\"The two ODD elements are \"+ x + \" & \" + y);\n        }", "14": "static int subtract(int x, int y)\n        {\n        while (y != 0)\n        {\n                int borrow = (~x) & y;\n                x = x ^ y;\n                y = borrow << 1;\n        }\n        return x;\n}", "15": "static boolean isMajorityElement(int arr[], int n, int key)\n{\n        if (arr[n / 2] == key)\n                return true;\n        else\n                return false;\n}", "16": "static void Kroneckerproduct(int A[][], int B[][])\n        {\n                int[][] C= new int[rowa * rowb][cola * colb];\n                for (int i = 0; i < rowa; i++)\n                {\n                        for (int k = 0; k < rowb; k++)\n                        {\n                                for (int j = 0; j < cola; j++)\n                                {\n                                        for (int l = 0; l < colb; l++)\n                                        {\n                                                C[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n                                                System.out.print( C[i + l + 1][j + k + 1]+\" \");\n                                        }\n                                }\n                                System.out.println();\n                        }\n                }\n        }", "17": "static int count(int S[], int m, int n)\n{\n        if (n == 0)\n                return 1;\n        if (n < 0)\n                return 0;\n        if (m <= 0 && n >= 1)\n                return 0;\n        return count(S, m - 1, n) +\n                count(S, m, n - S[m - 1]);\n}", "18": "static int MatrixChainOrder(int p[], int n)\n        {\n                int m[][] = new int[n][n];\n                int i, j, k, L, q;\n                for (i = 1; i < n; i++)\n                        m[i][i] = 0;\n                for (L = 2; L < n; L++)\n                {\n                        for (i = 1; i < n - L + 1; i++)\n                        {\n                                j = i + L - 1;\n                                if (j == n)\n                                        continue;\n                                m[i][j] = Integer.MAX_VALUE;\n                                for (k = i; k <= j - 1; k++)\n                                {\n                                        q = m[i][k] + m[k + 1][j]\n                                                + p[i - 1] * p[k] * p[j];\n                                        if (q < m[i][j])\n                                                m[i][j] = q;\n                                }\n                        }\n                }\n                return m[1][n - 1];\n        }", "19": "static int countSetBits(int N)\n {\n        int count = 0;\n        for (int i = 0; i < 4 * 8; i++)\n        {\n        if ((N & (1 << i)) != 0)\n                count++;\n        }\n        return count;\n }", "20": "static int cutRod(int price[],int n)\n        {\n                int val[] = new int[n+1];\n                val[0] = 0;\n                for (int i = 1; i<=n; i++)\n                {\n                        int max_val = Integer.MIN_VALUE;\n                        for (int j = 0; j < i; j++)\n                                max_val = Math.max(max_val, price[j] + val[i-j-1]);\n                        val[i] = max_val;\n                }\n                return val[n];\n        }", "21": "int findFirstMissing(int array[], int start, int end)\n        {\n                if (start > end)\n                        return end + 1;\n                if (start != array[start])\n                        return start;\n                int mid = (start + end) / 2;\n                if (array[mid] == mid)\n                        return findFirstMissing(array, mid+1, end);\n                return findFirstMissing(array, start, mid);\n        }", "22": "public static void printPascal(int n)\n{\n        for(int line = 1; line <= n; line++)\n        {\nint C=1;\n        for(int i = 1; i <= line; i++)\n        {\n                System.out.print(C+\" \");\n                C = C * (line - i) / i;\n        }\n        System.out.println();\n        }\n}", "23": "static int Add(int x, int y)\n        {\n                while (y != 0)\n                {\n                        int carry = x & y;\n                        x = x ^ y;\n                        y = carry << 1;\n                }\n                return x;\n        }", "24": "static int averageEven(int n)\n        {\n                if (n % 2 != 0) {\n                System.out.println(\"Invalid Input\");\n                        return -1;\n                }\n                return (n + 2) / 2;\n        }", "25": "static int reversDigits(int num)\n        {\n                if (num > 0) {\n                        reversDigits(num / 10);\n                        rev_num += (num % 10) * base_pos;\n                        base_pos *= 10;\n                }\n                return rev_num;\n        }", "26": "static int multiplyBySevenByEight(int n)\n        {\n                return (n - (n >> 3));\n        }", "27": "static double Area(int b1, int b2, int h)\n        {\n                return ((b1 + b2) / 2) * h;\n        }", "28": "static boolean getParity(int n)\n        {\n                boolean parity = false;\n                while(n != 0)\n                {\n                        parity = !parity;\n                        n = n & (n-1);\n                }\n                return parity;\n        }", "29": "static int subtract(int x, int y)\n        {\n                if (y == 0)\n                        return x;\n                return subtract(x ^ y, (~x & y) << 1);\n        }", "30": "static int fact(int n)\n        {\n                if (n == 0)\n                        return 1;\n                return n*fact(n-1);\n        }\nstatic int div(int x)\n        {\n                int ans = 0;\n                for (int i = 1; i<= x; i++)\n                        if (x%i == 0)\n                                ans += i;\n                return ans;\n        }\nstatic int sumFactDiv(int n)\n        {\n                return div(fact(n));\n        }", "31": "public static void printDivisors(int n)\n{ int i;\n        for( i = 1; i * i < n; i++)\n        {\n                if (n % i == 0)\n                        System.out.print(i + \" \");\n        }\n        if(i-(n/i)==1)\n        {\n        i--;\n        }\n        for(; i >= 1; i--)\n        {\n                if (n % i == 0)\n                        System.out.print(n / i + \" \");\n        }\n}", "32": "void sort(int arr[])\n        {\n                int n = arr.length;\n                for (int i = 1; i < n; ++i) {\n                        int key = arr[i];\n                        int j = i - 1;\n                        while (j >= 0 && arr[j] > key) {\n                                arr[j + 1] = arr[j];\n                                j = j - 1;\n                        }\n                        arr[j + 1] = key;\n                }\n        }\nstatic void printArray(int arr[])\n        {\n                int n = arr.length;\n                for (int i = 0; i < n; ++i)\n                        System.out.print(arr[i] + \" \");\n                System.out.println();\n        }", "33": "static boolean isPowerOfTwo (int x)\n        {\n                return x!=0 && ((x&(x-1)) == 0);\n        }", "34": "static int binarySearch(int a[], int item, int low, int high)\n{\n        while (low <= high) {\n                int mid = low + (high - low) / 2;\n                if (item == a[mid])\n                        return mid + 1;\n                else if (item > a[mid])\n                        low = mid + 1;\n                else\n                        high = mid - 1;\n        }\n        return low;\n}\nstatic void insertionSort(int a[], int n)\n{\n        int i, loc, j, k, selected;\n        for (i = 1; i < n; ++i) {\n                j = i - 1;\n                selected = a[i];\n                loc = binarySearch(a, selected, 0, j);\n                while (j >= loc) {\n                        a[j + 1] = a[j];\n                        j--;\n                }\n                a[j + 1] = selected;\n        }\n}", "35": "static int MatrixChainOrder(int p[], int i, int j)\n        {\n                if (i == j)\n                        return 0;\n                int min = Integer.MAX_VALUE;\n                for (int k = i; k < j; k++)\n                {\n                        int count = MatrixChainOrder(p, i, k)\n                                                + MatrixChainOrder(p, k + 1, j)\n                                                + p[i - 1] * p[k] * p[j];\n                        if (count < min)\n                                min = count;\n                }\n                return min;\n        }", "36": "static int Series(int n)\n        {\n                int i;\n                int sums = 0;\n                for (i = 1; i <= n; i++)\n                        sums += (i * i);\n                return sums;\n        }", "37": "static double Convert(double radian){\n                double pi = 3.14159;\n                return(radian * (180/pi));\n        }", "38": "static boolean isPowerOfTwo(int n)\n        {\n                if (n == 0)\n                        return false;\n                while (n != 1)\n                {\n                        if (n % 2 != 0)\n                                return false;\n                        n = n / 2;\n                }\n                return true;\n        }"}, "C": {"0": "static void printDivisors(int n)\n        {\n                for (int i=1;i<=n;i++)\n                        if (n%i==0)\n                                printf(\"%d\",i);\n        }", "1": "double Perimeter(double s, int n)\n        {\n                double perimeter = 1;\n                perimeter = n * s;\n                return perimeter;\n        }", "2": "static int countSetBits(int n)\n        {\n                int count = 0;\n                while (n > 0) {\n                        count += n & 1;\n                        n >>= 1;\n                }\n                return count;\n        }", "3": "void reverse(char* str)\n        {\n                if ((str==null)||(sizeof(str) <= 1))\n                printf(\"%s\", str);\n                else\n                {\n                        printf(\"%c\", str[sizeof(str)-1]);\n                        reverse(str.substring(0,sizeof(str)-1));\n                }\n        }", "4": "int averageOdd(int n)\n        {\n                if (n % 2 == 0)\n                {\n                        printf(\"Invalid Input\");\n                        return -1;\n                }\n                return (n + 1) / 2;\n        }", "5": "static int multiply(int x, int y) {\n                if (y == 0)\n                        return 0;\n                if (y > 0)\n                        return (x + multiply(x, y - 1));\n                if (y < 0)\n                        return -multiply(x, -y);\n                return -1;\n        }", "6": "void leftRotate(int arr[], int d, int n)\n{\n  int i, j, k, temp;\n  for (i = 0; i < gcd(d, n); i++)\n  {\n    /* move i-th values of blocks */\n    temp = arr[i];\n    j = i;\n    while(1)\n    {\n      k = j + d;\n      if (k >= n)\n        k = k - n;\n      if (k == i)\n        break;\n      arr[j] = arr[k];\n      j = k;\n    }\n    arr[j] = temp;\n  }\n}\n \n/*UTILITY FUNCTIONS*/\n/* function to print an array */\nvoid printArray(int arr[], int size)\n{\n  int i;\n  for(i = 0; i < size; i++)\n    printf(\"%d \", arr[i]);\n  printf(\"\\n\");\n}\n \n/*Fuction to get gcd of a and b*/\nint gcd(int a,int b)\n{\n   if(b==0)\n     return a;\n   else\n     return gcd(b,a%b);\n}\n \n/*Driver program to test above functions */\nint main()\n{\n   int arr[] = {1, 2, 3, 4, 5, 6, 7};\n   leftRotate(arr, 2, 7);\n   printArray(arr, 7);\n   getchar();\n   return 0;\n}", "7": "int multiplyBySevenByEight(int n)\n{\n        return ((n << 3) -n) >> 3;\n}", "8": "bool _binarySearch(int arr[], int low, int high, int x)\n{\n\tif (high >= low)\n\t{\n\t\tint mid = (low + high)/2; \n\t\tif ( (mid == 0 || x > arr[mid-1]) && (arr[mid] == x) )\n\t\t\treturn mid;\n\t\telse if (x > arr[mid])\n\t\t\treturn _binarySearch(arr, (mid + 1), high, x);\n\t\telse\n\t\t\treturn _binarySearch(arr, low, (mid -1), x);\n\t}\n\treturn -1;\n}\nbool isMajority(int arr[], int n, int x)\n{\n\tint i = _binarySearch(arr, 0, n-1, x);\n\tif (i == -1)\n\t\treturn false;\n\tif (((i + n/2) <= (n -1)) && arr[i + n/2] == x)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "9": "void sort(int *arr, int size)\n{\n        for (int i = 0; i < size - 1; i++)\n        {\n                int min_idx = i;\n                for (int j = i + 1; j < size; j++)\n                {\n                        if (arr[j] < arr[min_idx])\n                        {\n                                min_idx = j;\n                        }\n                }\n                int temp = arr[min_idx];\n                arr[min_idx] = arr[i];\n                arr[i] = temp;\n        }\n}\n\nvoid printArray(int arr[], int size)\n{\n        for (int i = 0; i < size; ++i)\n        {\n                printf(\"%d \", arr[i]);\n        }\n        printf(\"\\n\");\n}", "10": "bool isMajority(int arr[], int n, int x)\n{\n        int i, last_index = 0;\n        last_index = (n%2==0)? n/2: n/2+1;\n        for (i = 0; i < last_index; i++)\n        {\n                if (arr[i] == x && arr[i+n/2] == x)\n                        return true;\n        }\n        return false;\n}", "11": "int countSetBits(int num)\n{\n        // base case\n        if (num == 0)\n            return num_to_bits[0];\n\n        // extract last digit\n        int nibble =  num & 0xf;\n\n        // return last digit + recursion over remaining digits\n        return num_to_bits[nibble] + countSetBits(num >> 4);\n}", "12": "int FindMaxSum(int arr[], int n)\n        {\n                int incl = arr[0];\n                int excl = 0;\n                int excl_new;\n                int i;\n                for (i = 1; i < n; i++)\n                {\n                        excl_new = (incl > excl) ? incl : excl;\n                        incl = excl + arr[i];\n                        excl = excl_new;\n                }\n                return ((incl > excl) ? incl : excl);\n        }", "13": "static void printTwoOdd(int arr[], int size)\n        {\n        int xor2 = arr[0];\n        int set_bit_no;\n        int i;\n        int n = size - 2;\n        int x = 0, y = 0;\n        for(i = 1; i < size; i++)\n                xor2 = xor2 ^ arr[i];\n        set_bit_no = xor2 & ~(xor2-1);\n        for(i = 0; i < size; i++)\n        {\n                if((arr[i] & set_bit_no)>0)\n                x = x ^ arr[i];\n                else\n                y = y ^ arr[i];\n        }\n        printf(\"The two ODD elements are %d & %d\", x, y);\n        }", "14": "static int subtract(int x, int y)\n{\n    while (y != 0)\n    {\n        int borrow = (~x) & y;\n        x = x ^ y;\n        y = borrow << 1;\n    }\n    return x;\n}", "15": "static bool isMajorityElement(int arr[], int n, int key)\n{\n        if (arr[n / 2] == key)\n                return true;\n        else\n                return false;\n}", "16": "static void Kroneckerproduct(int A[][], int B[][])\n        {\n                int[][] C= new int[rowa * rowb][cola * colb];\n                for (int i = 0; i < rowa; i++)\n                {\n                        for (int k = 0; k < rowb; k++)\n                        {\n                                for (int j = 0; j < cola; j++)\n                                {\n                                        for (int l = 0; l < colb; l++)\n                                        {\n                                                C[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n                                                printf(\"%d \", C[i + l + 1][j + k + 1]);\n                                        }\n                                }\n                                printf(\"\\n\");\n                        }\n                }\n        }", "17": "int count(int S[], int m, int n)\n{\n        if (n == 0)\n                return 1;\n        if (n < 0)\n                return 0;\n        if (m <= 0 && n >= 1)\n                return 0;\n        return count(S, m - 1, n) +\n                count(S, m, n - S[m - 1]);\n}", "18": "// Matrix Ai has dimension p[i-1] x p[i] for i = 1..n \nint MatrixChainOrder(int p[], int n) \n{ \n  \n    /* For simplicity of the program, one  \n    extra row and one extra column are \n    allocated in m[][].  0th row and 0th \n    column of m[][] are not used */\n    int m[n][n]; \n  \n    int i, j, k, L, q; \n  \n    /* m[i,j] = Minimum number of scalar  \n    multiplications needed to compute \n    the matrix A[i]A[i+1]...A[j] = A[i..j]  \n    where dimension of A[i] is p[i-1] x p[i] */\n  \n    // cost is zero when multiplying \n    // one matrix. \n    for (i = 1; i < n; i++) \n        m[i][i] = 0; \n  \n    // L is chain length. \n    for (L = 2; L < n; L++) \n    { \n        for (i = 1; i < n - L + 1; i++) \n        { \n            j = i + L - 1; \n            if (j == n) \n                continue; \n            m[i][j] = INT_MAX; \n  \n            for (k = i; k <= j - 1; k++) \n            { \n                // q = cost/scalar multiplications \n                q = m[i][k] + m[k + 1][j] +  \n                    p[i - 1] * p[k] * p[j]; \n                if (q < m[i][j]) \n                    m[i][j] = q; \n            } \n        } \n    } \n  \n    return m[1][n - 1]; \n} \n  \nint main() \n{ \n    int arr[] = {1, 2, 3, 4}; \n    int size = sizeof(arr) / sizeof(arr[0]); \n  \n    printf(\"Minimum number of multiplications is %d \", \n                       MatrixChainOrder(arr, size)); \n  \n    getchar(); \n    return 0; \n}", "19": " static int countSetBits(int N)\n {\n        int count = 0;\n        for (int i = 0; i < 4 * 8; i++)\n        {\n        if ((N & (1 << i)) != 0)\n                count++;\n        }\n        return count;\n }", "20": "static int cutRod(int price[], int n)\n{\n        int val[n+1];\n        val[0] = 0;\n        for (int i = 1; i <= n; i++)\n        {\n                int max_val = INT_MIN;\n                for (int j = 0; j < i; j++)\n                        max_val = max(max_val, price[j] + val[i-j-1]);\n                val[i] = max_val;\n        }\n        return val[n];\n}", "21": "int findFirstMissing(int array[], int start, int end)\n        {\n                if (start > end)\n                        return end + 1;\n                if (start != array[start])\n                        return start;\n                int mid = (start + end) / 2;\n                if (array[mid] == mid)\n                        return findFirstMissing(array, mid+1, end);\n                return findFirstMissing(array, start, mid);\n        }", "22": "void printPascal(int n)\n{\n    for(int line = 1; line <= n; line++)\n    {\n        int C=1;\n        for(int i = 1; i <= line; i++)\n        {\n            printf(\"%d \",C);\n            C = C * (line - i) / i;\n        }\n        printf(\"\\n\");\n    }\n}", "23": "int Add(int x, int y)\n{\n\twhile (y != 0)\n\t{\n\t\tint carry = x & y;\n\t\tx = x ^ y;\n\t\ty = carry << 1;\n\t}\n\treturn x;\n}", "24": "int averageEven(int n)\n{\n\tif (n % 2 != 0) {\n\tprintf(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\treturn (n + 2) / 2;\n}", "25": "int reversDigits(int num)\n        {\n                if (num > 0) {\n                        reversDigits(num / 10);\n                        rev_num += (num % 10) * base_pos;\n                        base_pos *= 10;\n                }\n                return rev_num;\n        }", "26": "int multiplyBySevenByEight(int n)\n{\n        return (n - (n >> 3));\n}", "27": "double Area(int b1, int b2, int h)\n{\n        return ((b1 + b2) / 2) * h;\n}", "28": "bool getParity(int n) {\n\tbool parity = false;\n\twhile (n != 0) {\n\t\tparity = !parity;\n\t\tn = n&(n - 1);\n\t}\n\treturn parity;\n}", "29": "static int subtract(int x, int y)\n        {\n                if (y == 0)\n                        return x;\n                return subtract(x ^ y, (~x & y) << 1);\n        }", "30": "int fact(int n)\n{\n        if (n == 0)\n                return 1;\n        return n*fact(n-1);\n}\nint div(int x)\n{\n        int ans = 0;\n        for (int i = 1; i<= x; i++)\n                if (x%i == 0)\n                        ans += i;\n        return ans;\n}\nint sumFactDiv(int n)\n{\n        return div(fact(n));\n}", "31": "void printDivisors(int n)\n{ int i;\n        for( i = 1; i * i < n; i++)\n        {\n                if (n % i == 0)\n                        printf(\"%d \",i);\n        }\n        if(i-(n/i)==1)\n        {\n        i--;\n        }\n        for(; i >= 1; i--)\n        {\n                if (n % i == 0)\n                        printf(\"%d \",n/i);\n        }\n}", "32": "void sort(int arr[], int n)\n{\n        for (int i = 1; i < n; ++i) {\n                int key = arr[i];\n                int j = i - 1;\n                while (j >= 0 && arr[j] > key) {\n                        arr[j + 1] = arr[j];\n                        j = j - 1;\n                }\n                arr[j + 1] = key;\n        }\n}\n\nvoid printArray(int arr[], int n)\n{\n        for (int i = 0; i < n; ++i)\n                printf(\"%d \", arr[i]);\n        printf(\"\\n\");\n}", "33": "bool isPowerOfTwo(int x) {\n\treturn x != 0 && ((x&(x - 1)) == 0);\n}", "34": "static int binarySearch(int a[], int item, int low, int high){\n        while (low <= high){\n                int mid = low + (high - low) / 2;\n                if (item == a[mid])\n                        return mid + 1;\n                else if (item > a[mid])\n                        low = mid + 1;\n                else\n                        high = mid - 1;\n        }\n        return low;\n}\nstatic void insertionSort(int a[], int n){\n        int i, loc, j, k, selected;\n        for (i = 1; i < n; ++i){\n                j = i - 1;\n                selected = a[i];\n                loc = binarySearch(a, selected, 0, j);\n                while (j >= loc){\n                        a[j + 1] = a[j];\n                        j--;\n                }\n                a[j + 1] = selected;\n        }\n}", "35": "int MatrixChainOrder(int p[], int i, int j)\n{\n\tif (i == j)\n\t\treturn 0;\n\tint min = MAX_INT;\n\tfor (int k = i; k < j; k++)\n\t{\n\t\tint count = MatrixChainOrder(p, i, k)\n\t\t\t+ MatrixChainOrder(p, k + 1, j)\n\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\tif (count < min)\n\t\t\tmin = count;\n\t}\n\treturn min;\n}", "36": "int Series(int n)\n{\n        int i;\n        int sums = 0;\n        for (i = 1; i <= n; i++)\n                sums += (i * i);\n        return sums;\n}", "37": "double Convert(double radian){\n                double pi = 3.14159;\n                return(radian * (180/pi));\n        }", "38": "bool isPowerOfTwo(int n)\n{\n        if (n == 0)\n                return false;\n        while (n != 1)\n        {\n                if (n % 2 != 0)\n                        return false;\n                n = n / 2;\n        }\n        return true;\n}"}}, "Python - C++": {"Id": {"0": 1869, "1": 12550, "2": 8501, "3": 12638, "4": 4624, "5": 10345, "6": 5512, "7": 6210, "8": 9574, "9": 11204, "10": 11707, "11": 12750, "12": 13453, "13": 5946, "14": 2129, "15": 10539, "16": 1590, "17": 6068, "18": 7735, "19": 10474, "20": 12486, "21": 10885, "22": 3503, "23": 13049, "24": 3601, "25": 4570, "26": 6395, "27": 11627, "28": 5995, "29": 3704, "30": 7788, "31": 7051, "32": 5621, "33": 5772, "34": 11315, "35": 9114, "36": 6471, "37": 12639, "38": 3932, "39": 5675, "40": 9147, "41": 1517, "42": 8213, "43": 9804, "44": 9948, "45": 9608, "46": 9070, "47": 6712, "48": 12765, "49": 1813, "50": 3463, "51": 7622, "52": 13048, "53": 12794, "54": 9329, "55": 11217, "56": 10568, "57": 8855, "58": 10071}, "Python": {"0": "def max(a, b):\n        return a if (a > b) else b\ndef cutRod(price, n):\n        if(n <= 0):\n                return 0\n        max_val = -sys.maxsize-1\n        for i in range(0, n):\n                max_val = max(max_val, price[i] +\n                                        cutRod(price, n - i - 1))\n        return max_val", "1": "def checkdigit(n, k):\n        while (n):\n                rem = n % 10\n                if (rem == k):\n                        return 1\n                n = n / 10\n        return 0\ndef findNthNumber(n, k):\n        i = k + 1\n        count = 1\n        while(count < n):\n                if (checkdigit(i, k) or (i % k == 0)):\n                        count += 1\n                if (count == n):\n                        return i\n                i += 1\n        return -1", "2": "def isNumber(s):\n        for i in range(len(s)):\n                if s[i].isdigit() != True:\n                        return False\n        return True", "3": "def averageEven(n) :\n        if (n % 2 != 0) :\n                print(\"Invalid Input\")\n                return -1\n        sm = 0\n        count = 0\n        while (n >= 2) :\n                count = count + 1\n                sm = sm + n\n                n = n - 2\n        return sm // count", "4": "def sortByRow(mat, n, descending):\n        for i in range(n):\n                if (descending == True):\n                        mat[i].sort(reverse = True)\n                else:\n                        mat[i].sort()\ndef transpose(mat, n):\n        for i in range(n):\n                for j in range(i + 1, n):\n                        mat[i][j], mat[j][i] = mat[j][i], mat[i][j]\ndef sortMatRowAndColWise(mat, n):\n        sortByRow(mat, n, True)\n        transpose(mat, n)\n        sortByRow(mat, n, False)\n        transpose(mat, n);\ndef printMat(mat, n):\n        for i in range(n):\n                for j in range( n):\n                        print(mat[i][j], end = \" \")\n                print()", "5": "def isDNum(n):\n        if n < 4:\n                return False\n        for k in range(2, n):\n                numerator = pow(k, n - 2) - k\n                hcf = math.gcd(n, k)\n                if(hcf ==1 and (numerator % n) != 0):\n                        return False\n        return True", "6": "def minOperations(a, b, n):\n        minA = min(a);\n        for x in range(minA, -1, -1):\n                check = True;\n                operations = 0;\n                for i in range(n):\n                        if (x % b[i] == a[i] % b[i]):\n                                operations += (a[i] - x) / b[i];\n                        else:\n                                check = False;\n                                break;\n                if (check):\n                        return operations;\n        return -1;", "7": "def largestSquare(matrix, R, C, q_i, q_j, K, Q):\n        countDP = [[0 for x in range(C)] for x in range(R)] \n        countDP[0][0] = matrix[0][0] \n        for i in range(1, R):\n                countDP[i][0] = (countDP[i - 1][0] + matrix[i][0])\n        for j in range(1, C):\n                countDP[0][j] = (countDP[0][j - 1] + matrix[0][j])\n        for i in range(1, R):\n                for j in range(1, C):\n                        countDP[i][j] = (matrix[i][j] + countDP[i - 1][j] + countDP[i][j - 1] - countDP[i - 1][j - 1])\n        for q in range(0, Q):\n                i = q_i[q]\n                j = q_j[q]\n                min_dist = min(i, j, R - i - 1, C - j - 1)\n                ans = -1\n                for k in range(0, min_dist + 1): \n                        x1 = i - k\n                        x2 = i + k\n                        y1 = j - k\n                        y2 = j + k \n                        count = countDP[x2][y2]; \n                        if (x1 > 0): \n                                        count -= countDP[x1 - 1][y2]\n                        if (y1 > 0):\n                                        count -= countDP[x2][y1 - 1]\n                        if (x1 > 0 and y1 > 0):\n                                        count += countDP[x1 - 1][y1 - 1]\n                        if (count > K):\n                                        break\n                        ans = 2 * k + 1\n                print(ans)", "8": "def countSubsequences(arr):\n        odd = 0\n        for x in arr:\n                if (x & 1):\n                        odd = odd + 1\n        return (1 << odd) - 1", "9": "def power(p):\n        res = 1\n        for i in range(1, p + 1):\n                res *= 2\n                res %= mod\n        return res % mod\ndef subset_square_sum(A):\n        n = len(A)\n        ans = 0\n        for i in A:\n                ans += i * i % mod\n                ans %= mod\n        return ans * power(n - 1) % mod", "10": "def digitWell(n, m, k):\n        cnt = 0\n        while (n > 0):\n                if (n % 10 == m):\n                        cnt = cnt + 1;\n                n = (int)(n / 10);\n        return cnt == k;\ndef findInt(n, m, k):\n        i = n + 1;\n        while (True):\n                if (digitWell(i, m, k)):\n                        return i;\n                i = i + 1;", "11": "def gcd (a, b):\n        if a == 0 or b == 0:\n                return 0\n        if a == b:\n                return a\n        if a > b:\n                return gcd(a - b, b)\n        return gcd(a, b - a)\ndef cpFact(x, y):\n        while gcd(x, y) != 1:\n                x = x / gcd(x, y)\n        return int(x)", "12": "def SieveOfAtkin(limit):\n        if (limit > 2):\n                print(2 , end = \" \")\n        if (limit > 3):\n                print(3 , end = \" \")\n        sieve = [False] * limit\n        for i in range( 0 , limit ):\n                sieve[i] = False\n        x = 1\n        while(x * x < limit ) :\n                y = 1\n                while(y * y < limit ) :\n                        n = (4 * x * x) + (y * y)\n                        if (n <= limit and (n % 12 == 1 or n % 12 == 5)):\n                                sieve[n] ^= True\n                        n = (3 * x * x) + (y * y)\n                        if (n <= limit and n % 12 == 7):\n                                sieve[n] ^= True\n                        n = (3 * x * x) - (y * y)\n                        if (x > y and n <= limit and n % 12 == 11):\n                                sieve[n] ^= True\n                        y += 1\n                x += 1\n        r = 5\n        while(r * r < limit) :\n                if (sieve[r]) :\n                        for i in range(r * r, limit, r * r):\n                                sieve[i] = False\n        for a in range(5 , limit ):\n                if (sieve[a]):\n                        print(a , end = \" \")", "13": "def MaxSubsetlength(arr, A, B):\n        dp = [[0 for i in range(B + 1)] for i in range(A + 1)]\n        for str in arr:\n                zeros = str.count('0')\n                ones = str.count('1')\n                for i in range(A, zeros - 1, -1):\n                        for j in range(B, ones - 1, -1):\n                                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[A][B]", "14": "def Log2(x):\n        if x == 0:\n                return false;\n        return (math.log10(x) /\n                        math.log10(2));\ndef isPowerOfTwo(n):\n        return (math.ceil(Log2(n)) ==\n                        math.floor(Log2(n)));", "15": "def productPairs(arr, n):\n        product = 1;\n        for i in range(n):\n                for j in range(n):\n                        product *= (arr[i] % mod * arr[j] % mod) % mod;\n                        product = product % mod;\n        return product % mod;", "16": "def findMaxAverage(arr, n, k):\n        if k > n:\n                return -1\n        csum = [0]*n\n        csum[0] = arr[0]\n        for i in range(1, n):\n                csum[i] = csum[i-1] + arr[i];\n        max_sum = csum[k-1]\n        max_end = k-1\n        for i in range(k, n):\n                curr_sum = csum[i] - csum[i-k]\n                if curr_sum > max_sum:\n                        max_sum = curr_sum\n                        max_end = i\n        return max_end - k + 1", "17": "def Calculate_factorial():\n        fact[0] = 1\n        for i in range(1, mx + 1):\n                fact[i] = i * fact[i - 1]\n                fact[i] %= mod\ndef UniModal_per(a, b):\n        res = 1\n        while (b != 0):\n                if (b % 2 != 0):\n                        res = res * a\n                res %= mod\n                a = a * a\n                a %= mod\n                b //= 2\n        return res\ndef countPermutations(n):\n        Calculate_factorial()\n        uni_modal = UniModal_per(2, n - 1)\n        nonuni_modal = fact[n] - uni_modal\n        print(int(uni_modal), \"\",\n                int(nonuni_modal))\n        return", "18": "def removeChars(arr, k):\n        hash = [0]*MAX_CHAR\n        n = len(arr)\n        for i in range( n):\n                hash[ord(arr[i]) - ord('a')] += 1\n        ans = \"\"\n        index = 0\n        for i in range(n):\n                if (hash[ord(arr[i]) - ord('a')] != k):\n                        ans += arr[i]\n        return ans", "19": "def EnneacontahexagonNum(n):\n        return (94 * n * n - 92 * n) // 2;", "20": "def possibleTripletInRange(L, R):\n        flag = False;\n        possibleA = 0;\n        possibleB = 0;\n        possibleC = 0;\n        numbersInRange = (R - L + 1);\n        if (numbersInRange < 3):\n                flag = False;\n        elif (numbersInRange > 3):\n                flag = True;\n                if ((L % 2) > 0):\n                        L += 1;\n                possibleA = L;\n                possibleB = L + 1;\n                possibleC = L + 2;\n        else:\n                if ((L % 2) == 0):\n                        flag = True;\n                        possibleA = L;\n                        possibleB = L + 1;\n                        possibleC = L + 2;\n                else:\n                        flag = False;\n        if (flag == True):\n                print(\"(\", possibleA, \",\", possibleB, \",\", possibleC, \") is one such\", \"possible triplet between\", L, \"and\", R);\n        else:\n                print(\"No Such Triplet exists between\", L, \"and\", R);", "21": "def largest_sum(arr, n):\n        maximum = -1\n        m = dict()\n        for i in arr:\n                m[i] = m.get(i,0) + 1\n        for j in list(m):\n                if ((j in m) and m[j] > 1):\n                        x, y = 0, 0\n                        if 2*j in m:\n                                m[2*j] = m[2 * j]+ m[j]// 2\n                        else:\n                                m[2*j] = m[j]//2\n                        if (2 * j > maximum):\n                                maximum = 2 * j\n        return maximum", "22": "def addEdge(a, b):\n        global tree\n        tree[a].append(b)\n        tree[b].append(a)\ndef dfs(x):\n        global vis\n        global subtreeSize\n        global tree\n        vis[x] = True\n        subtreeSize[x] = 1\n        for i in tree[x]:\n                if (vis[i] == False):\n                        dfs(i)\n                        subtreeSize[x] += subtreeSize[i]\ndef countPairs(a, b):\n        global subtreeSize\n        sub = min(subtreeSize[a], subtreeSize[b])\n        print(sub * (n - sub))", "23": "def sieveOfEratostheneses():\n        isPrime[1] = False\n        i = 2\n        while i * i < 100005:\n                if(isPrime[i]):\n                        j = 2 * i\n                        while j < 100005:\n                                isPrime[j] = False\n                                j += i\n                i += 1\n        return\ndef findPrime(n):\n        num = n + 1\n        while(num):\n                if isPrime[num]:\n                        return num\n                num += 1\n        return 0\ndef minNumber(arr):\n        sieveOfEratostheneses()\n        s = 0\n        for i in range(0, len(arr)):\n                s += arr[i]\n        if isPrime[s] == True:\n                return 0\n        num = findPrime(s)\n        return num - s", "24": "def possible(mid, a):\n        n = len(a);\n        total = (n * (n - 1)) // 2;\n        need = (total + 1) // 2;\n        count = 0;\n        start = 0; end = 1;\n        while (end < n):\n                if (a[end] - a[start] <= mid):\n                        end += 1;\n                else:\n                        count += (end - start - 1);\n                        start += 1;\n        if (end == n and start < end and a[end - 1] - a[start] <= mid):\n                t = end - start - 1;\n                count += (t * (t + 1) // 2);\n        if (count >= need):\n                return True;\n        else:\n                return False;\ndef findMedian(a):\n        n = len(a);\n        low = 0; high = a[n - 1] - a[0];\n        while (low <= high):\n                mid = (low + high) // 2;\n                if (possible(mid, a)):\n                        high = mid - 1;\n                else :\n                        low = mid + 1;\n        return high + 1;", "25": "def MinimizeleftOverSum(a, n) :\n        v1, v2 = [], [];\n        for i in range(n) :\n                if (a[i] % 2) :\n                        v1.append(a[i]);\n                else :\n                        v2.append(a[i]);\n        if (len(v1) > len(v2)) :\n                v1.sort();\n                v2.sort();\n                x = len(v1) - len(v2) - 1;\n                sum = 0;\n                i = 0;\n                while (i < x) :\n                        sum += v1[i];\n                        i += 1\n                return sum;\n        elif (len(v2) > len(v1)) :\n                v1.sort();\n                v2.sort();\n                x = len(v2) - len(v1) - 1;\n                sum = 0;\n                i = 0;\n                while (i < x) :\n                        sum += v2[i];\n                        i += 1\n                return sum;\n        else :\n                return 0;", "26": "def MaxGCD(a, n):\n        Prefix=[0 for i in range(n + 2)]\n        Suffix=[0 for i in range(n + 2)]\n        Prefix[1] = a[0]\n        for i in range(2,n+1):\n                Prefix[i] = mt.gcd(Prefix[i - 1], a[i - 1])\n        Suffix[n] = a[n - 1]\n        for i in range(n-1,0,-1):\n                Suffix[i] =mt.gcd(Suffix[i + 1], a[i - 1])\n        ans = max(Suffix[2], Prefix[n - 1])\n        for i in range(2,n):\n                ans = max(ans, mt.gcd(Prefix[i - 1], Suffix[i + 1]))\n        return ans", "27": "def countWays(N):\n        E = (N * (N - 1)) / 2\n        if (N == 1):\n                return 0\n        return int(pow(2, E - 1))", "28": "def power(X, Y):\n        res = 1\n        X = X % M\n        if (X == 0):\n                return 0\n        while (Y > 0):\n                if (Y & 1):\n                        res = (res * X) % M\n                Y = Y >> 1\n                X = (X * X) % M\n        return res\ndef findValue(n):\n        X = 0\n        pow_10 = 1\n        while(n):\n                if (n & 1):\n                        X += pow_10\n                pow_10 *= 10\n                n //= 2\n        X = (X * 2) % M\n        res = power(2, X)\n        return res", "29": "def printNum(L, R):\n        for i in range(L, R + 1):\n                temp = i\n                c = 10\n                flag = 0\n                while (temp > 0):\n                        if (temp % 10 >= c):\n                                flag = 1\n                                break\n                        c = temp % 10\n                        temp //= 10\n                if (flag == 0):\n                        print(i, end = \" \")", "30": "def sub_segments (string, n):\n        l = len (string)\n        for x in range (0, l, n):\n                newlist = string[x : x + n]\n                arr = []\n                for y in newlist:\n                        if y not in arr:\n                                arr.append (y)\n                print (''.join (arr))", "31": "def cutRod(price, n):\n        val = [0 for x in range(n+1)]\n        val[0] = 0\n        for i in range(1, n+1):\n                max_val = INT_MIN\n                for j in range(i):\n                        max_val = max(max_val, price[j] + val[i-j-1])\n                val[i] = max_val\n        return val[n]", "32": "def find_distinct(a, n, q, queries):\n        check = [0] * MAX;\n        idx = [0] * MAX;\n        cnt = 1;\n        for i in range(n - 1, -1, -1):\n                if (check[a[i]] == 0):\n                        idx[i] = cnt;\n                        check[a[i]] = 1;\n                        cnt += 1;\n                else:\n                        idx[i] = cnt - 1;\n        for i in range(0, q):\n                m = queries[i];\n                print(idx[m], end = \" \");", "33": "def possibility(m, length, s):\n        countodd = 0\n        for i in range(0, length):\n                if m[int(s[i])] & 1:\n                        countodd += 1\n                if countodd > 1:\n                        return False\n        return True\ndef largestPalindrome(s):\n        l = len(s)\n        m = defaultdict(lambda:0)\n        for i in range(0, l):\n                m[int(s[i])] += 1\n        if possibility(m, l, s) == False:\n                print(\"Palindrome cannot be formed\")\n                return\n        largest = [None] * l\n        front = 0\n        for i in range(9, -1, -1):\n                if m[i] & 1:\n                        largest[l // 2] = chr(i + 48)\n                        m[i] -= 1\n                        while m[i] > 0:\n                                largest[front] = chr(i + 48)\n                                largest[l - front - 1] = chr(i + 48)\n                                m[i] -= 2\n                                front += 1\n                else:\n                        while m[i] > 0:\n                                largest[front] = chr(i + 48)\n                                largest[l - front - 1] = chr(i + 48)\n                                m[i] -= 2\n                                front += 1\n        for i in range(0, l):\n                print(largest[i], end = \"\")", "34": "def Wedderburn(n):\n        if (n <= 2):\n                return store[n]\n        elif (n % 2 == 0):\n                x = n // 2\n                ans = 0\n                for i in range(1, x):\n                        ans += store[i] * store[n - i]\n                ans += (store[x] * (store[x] + 1)) // 2\n                store[n] = ans\n                return ans\n        else:\n                x = (n + 1) // 2\n                ans = 0\n                for i in range(1, x):\n                        ans += store[i] * store[n - i]\n                store[n] = ans\n                return ans\ndef Wedderburn_Etherington(n):\n        store[0] = 0\n        store[1] = 1\n        store[2] = 1\n        for i in range(n):\n                print(Wedderburn(i), end = \"\")\n                if(i != n - 1):\n                        print(end = \", \")", "35": "def Icosihenagonal_num(n):\n        return (19 * n * n - 17 * n) / 2", "36": "def noOfBinaryStrings(N, k) :\n        dp = [0] * 100002;\n        for i in range(1, K) :\n                dp[i] = 1;\n        dp[k] = 2;\n        for i in range(k + 1, N + 1) :\n                dp[i] = (dp[i - 1] + dp[i - k]) % mod;\n        return dp[N];", "37": "def averageEven(n) :\n        if (n % 2 != 0) :\n                print(\"Invalid Input\")\n                return -1\n        return (n + 2) // 2", "38": "def LowerInsertionPoint(arr, n, X) :\n        if (X < arr[0]) :\n                return 0;\n        elif (X > arr[n - 1]) :\n                return n\n        lowerPnt = 0\n        i = 1\n        while (i < n and arr[i] < X) :\n                lowerPnt = i\n                i = i * 2\n        while (lowerPnt < n and arr[lowerPnt] < X) :\n                lowerPnt += 1\n        return lowerPnt", "39": "def encryptString(string, n):\n        i, cnt = 0, 0\n        encryptedStr = \"\"\n        while i < n:\n                cnt = i + 1\n                while cnt > 0:\n                        encryptedStr += string[i]\n                        cnt -= 1\n                i += 1\n        return encryptedStr", "40": "def countIntersections(n):\n        return n * (n - 1) // 2", "41": "def findElements(arr, n):\n        first = -sys.maxsize\n        second = -sys.maxsize\n        for i in range(0, n):\n                if (arr[i] > first):\n                        second = first\n                        first = arr[i]\n                elif (arr[i] > second):\n                        second = arr[i]\n        for i in range(0, n):\n                if (arr[i] < second):\n                        print(arr[i], end =\" \")", "42": "def check(s, m):\n        l = len(s);\n        c1 = 0;\n        c2 = 0;\n        for i in range(0, l - 1):\n                if (s[i] == '0'):\n                        c2 = 0;\n                        c1 = c1 + 1;\n                else :\n                        c1 = 0;\n                        c2 = c2 + 1;\n                if (c1 == m or c2 == m):\n                        return True;\n        return False;", "43": "def findbitwiseOR(a, n):\n        res = 0\n        for i in range(n):\n                curr_sub_array = a[i]\n                res = res | curr_sub_array\n                for j in range(i, n):\n                        curr_sub_array = curr_sub_array & a[j]\n                        res = res | curr_sub_array\n        print (res)", "44": "def multiplyByMersenne(N, M) :\n        x = int(math.log2(M + 1))\n        return ((N << x) - N)", "45": "def performQuery(arr, Q):\n        for i in range (0, len(Q)):\n                orr = 0\n                x = Q[i][0]\n                arr[x - 1] = Q[i][1]\n                for j in range(0,len(arr)):\n                        orr = orr | arr[j]\n                print(orr ,end= \" \")", "46": "def areaOfSquare(S):\n        area = S * S\n        return area", "47": "def longOddEvenIncSeq( arr , n ):\n        lioes = list()\n        maxLen = 0\n        for i in range(n):\n                lioes.append(1)\n        i=1\n        for i in range(n):\n                for j in range(i):\n                        if (arr[i] > arr[j] and\n                                (arr[i] + arr[j]) % 2 != 0 and lioes[i] < lioes[j] + 1):\n                                        lioes[i] = lioes[j] + 1\n        for i in range(n):\n                if maxLen < lioes[i]:\n                        maxLen = lioes[i]\n        return maxLen", "48": "def counLastDigitK(low, high, k):\n        mlow = 10 * math.ceil(low/10.0)\n        mhigh = 10 * int(high/10.0)\n        count = (mhigh - mlow)/10\n        if (high % 10 >= k):\n                count += 1\n        if (low % 10 <= k and \\\n                (low%10) > 0):\n                count += 1\n        return int(count)", "49": "def findCrossOver(arr, low, high, x) :\n        if (arr[high] <= x) : \n                        return high\n        if (arr[low] > x) : \n                        return low\n        mid = (low + high) // 2 \n        if (arr[mid] <= x and arr[mid + 1] > x) :\n                return mid\n        if(arr[mid] < x) :\n                return findCrossOver(arr, mid + 1, high, x)\n        return findCrossOver(arr, low, mid - 1, x)\ndef printKclosest(arr, x, k, n) :\n        l = findCrossOver(arr, 0, n - 1, x)\n        r = l + 1 \n        count = 0 \n        if (arr[l] == x) :\n                l -= 1\n        while (l >= 0 and r < n and count < k) :\n                if (x - arr[l] < arr[r] - x) :\n                        print(arr[l], end = \" \")\n                        l -= 1\n                else :\n                        print(arr[r], end = \" \")\n                        r += 1\n                count += 1\n        while (count < k and l >= 0) :\n                print(arr[l], end = \" \")\n                l -= 1\n                count += 1\n        while (count < k and r < n) :\n                print(arr[r], end = \" \")\n                r += 1\n                count += 1", "50": "def SieveOfEratosthenes():\n        global isPrime\n        p = 2\n        while p * p <= MAX:\n                if (isPrime[p] == True):\n                        for i in range (p * p, MAX + 1, p):\n                                isPrime[i] = False\n                p += 1\n        for p in range (2, MAX + 1):\n                if (isPrime[p]):\n                        primes.append(p)\ndef prime_search(primes, diff):\n        low = 0\n        high = len(primes) - 1\n        while (low <= high):\n                mid = (low + high) // 2\n                if (primes[mid] == diff):\n                        return primes[mid]\n                elif (primes[mid] < diff):\n                        low = mid + 1\n                else:\n                        res = primes[mid]\n                        high = mid - 1\n        return res\ndef minCost(arr, n):\n        SieveOfEratosthenes()\n        res = 0\n        for i in range (1, n):\n                if (arr[i] < arr[i - 1]):\n                        diff = arr[i - 1] - arr[i]\n                        closest_prime = prime_search(primes, diff)\n                        res += closest_prime\n                        arr[i] += closest_prime\n        return res", "51": "def check(s, n):\n        st = []\n        for i in range(n):\n                if (len(st) != 0 and\n                st[len(st) - 1] == s[i]):\n                        st.pop();\n                else:\n                        st.append(s[i]);\n        if (len(st) == 0):\n                return True;\n        else:\n                return False;", "52": "def isPrime(n):\n        if n <= 1:\n                return False\n        for i in range(2, n):\n                if n % i == 0:\n                        return False\n        return True\ndef findPrime(n):\n        num = n + 1\n        while (num):\n                if isPrime(num):\n                        return num\n                num += 1\n        return 0\ndef minNumber(arr):\n        s = 0\n        for i in range(0, len(arr)):\n                s += arr[i]\n        if isPrime(s) :\n                return 0\n        num = findPrime(s)\n        return num - s", "53": "def Convert(radian):\n        pi = 3.14159\n        degree = radian * (180/pi)\n        return degree", "54": "def longestRodInCuboid(length, breadth, height) :\n        temp = length * length + breadth * breadth + height * height\n        result = sqrt(temp)\n        return result", "55": "def least_prime_factor():\n        for i in range(2, N):\n                if (lpf[i] == 0):\n                        for j in range(i, N, i):\n                                if (lpf[j] == 0):\n                                        lpf[j] = i\ndef Mobius():\n        for i in range(1, N):\n                if (i == 1):\n                        mobius[i] = 1\n                else:\n                        if (lpf[ (i // lpf[i]) ] == lpf[i]):\n                                mobius[i] = 0\n                        else:\n                                mobius[i] = -1 * mobius[i // lpf[i]]\ndef gcd_pairs(a, n):\n        maxi = 0\n        fre = [0 for i in range(N)]\n        for i in range(n):\n                fre[a[i]] += 1\n                maxi = max(a[i], maxi)\n        least_prime_factor()\n        Mobius()\n        ans = 0\n        for i in range(1, maxi + 1):\n                if (mobius[i] == 0):\n                        continue\n                temp = 0\n                for j in range(i, maxi + 1, i):\n                        temp += fre[j]\n                ans += temp * (temp - 1) // 2 * mobius[i]\n        return ans", "56": "def isPrime(n):\n        if (n <= 1):\n                return False;\n        for i in range(2, n):\n                if (n % i == 0):\n                        return False;\n        return True;\ndef countSubsequences(arr, n):\n        totalSubsequence = (int)(pow(2, n) - 1);\n        countPrime = 0;\n        countOnes = 0;\n        for i in range(n):\n                if (arr[i] == 1):\n                        countOnes += 1;\n                elif (isPrime(arr[i])):\n                        countPrime += 1;\n        compositeSubsequence = 0;\n        onesSequence = (int)(pow(2, countOnes) - 1);\n        compositeSubsequence = (totalSubsequence - countPrime - onesSequence - onesSequence * countPrime);\n        return compositeSubsequence;", "57": "def dfs(u, count):\n        visited[u] = True\n        temp = 0\n        global startnode, maxi\n        for i in range(0, len(adjacent[u])):\n                if not visited[adjacent[u][i]]:\n                        temp += 1\n                        dfs(adjacent[u][i], count + 1)\n        if temp == 0:\n                if maxi < count:\n                        maxi = count\n                        startnode = u\ndef dfs1(u, count):\n        visited[u] = True\n        temp = 0\n        global endnode, maxi\n        for i in range(0, len(adjacent[u])):\n                if not visited[adjacent[u][i]]:\n                        temp += 1\n                        parent[adjacent[u][i]] = u\n                        dfs1(adjacent[u][i], count + 1)\n        if temp == 0:\n                if maxi < count:\n                        maxi = count\n                        endnode = u\ndef dfs2(u, count):\n        visited[u] = True\n        temp = 0\n        global thirdnode, maxi\n        for i in range(0, len(adjacent[u])):\n                if (not visited[adjacent[u][i]] and not vis[adjacent[u][i]]):\n                        temp += 1\n                        dfs2(adjacent[u][i], count + 1)\n        if temp == 0:\n                if maxi < count:\n                        maxi = count\n                        thirdnode = u\ndef findNodes():\n        dfs(1, 0)\n        global maxi\n        for i in range(0, N+1):\n                visited[i] = False\n        maxi = -1\n        dfs1(startnode, 0)\n        for i in range(0, N+1):\n                visited[i] = False\n        x = endnode\n        vis[startnode] = True\n        while x != startnode:\n                vis[x] = True\n                x = parent[x]\n        maxi = -1\n        for i in range(1, N+1):\n                if vis[i]:\n                        dfs2(i, 0)", "58": "def minimumIncrement(arr, N):\n        if (N % 2 != 0):\n                print(\"-1\")\n                return\n        cntEven = 0\n        cntOdd = 0\n        for i in range(N):\n                if (arr[i] % 2 == 0):\n                        cntEven += 1\n        cntOdd = N - cntEven\n        return abs(cntEven - cntOdd) // 2"}, "C++": {"0": "int cutRod(int price[], int n)  \n{  \n    if (n <= 0)  \n    return 0;  \n    int max_val = INT_MIN;  \n      \n    // Recursively cut the rod in different pieces and compare different  \n    // configurations  \n    for (int i = 0; i<n; i++)  \n    max_val = max(max_val, price[i] + cutRod(price, n-i-1));  \n  \n    return max_val;  \n}", "1": "int checkdigit(int n, int k) \n{ \n    while (n) \n    { \n        rem = n % 10; \n        if (rem == k) \n            return 1; \n        n = n / 10; \n    } \n    return 0; \n} \n  \nint findNthNumber(int n, int k) \n{ \n    int i = k + 1; \n    int count = 1; \n    while(count < n) \n    { \n        if (checkdigit(i, k) || (i % k == 0)) \n            count += 1; \n        if (count == n) \n            return i; \n        i += 1; \n    } \n    return -1; \n}", "2": "bool isNumber(string s) {\n        for (int i = 0; i < s.length(); i++) {\n                if (!isdigit(s[i])) {\n                        return false;\n                }\n        }\n        return true;\n}", "3": "double averageEven(double n) {\n        if (fmod(n, 2) != 0) {\n                cout << \"Invalid Input\";\n                return -1;\n        }\n        double sm = 0;\n        double count = 0;\n        while (n >= 2) {\n                count = count + 1;\n                sm = sm + n;\n                n = n - 2;\n        }\n        return sm / count;\n}", "4": "void sortByRow(int** mat, int n, bool descending) {\n        for (int i = 0; i < n; i++) {\n                if (descending == true) {\n                        sort(mat[i], mat[i] + n, greater<int>());\n                }\n                else {\n                        sort(mat[i], mat[i] + n);\n                }\n        }\n}\nvoid transpose(int** mat, int n) {\n        for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                        swap(mat[i][j], mat[j][i]);\n                }\n        }\n}\nvoid sortMatRowAndColWise(int** mat, int n) {\n        sortByRow(mat, n, true);\n        transpose(mat, n);\n        sortByRow(mat, n, false);\n        transpose(mat, n);\n}\nvoid printMat(int** mat, int n) {\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                        cout << mat[i][j] << \" \";\n                }\n                cout << endl;\n        }\n}\n\n\nint main() {\n        int n = 4;\n        int** mat = new int*[n];\n        for (int i = 0; i < n; i++) {\n                mat[i] = new int[n];\n        }\n        int count = 1;\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                        mat[i][j] = count++;\n                }\n        }\n        sortMatRowAndColWise(mat, n);\n        printMat(mat, n);\n        return 0;\n}", "5": "int isDNum(int n)\n{\n        if n < 4\n                return false;\n        for (int k = 2; k < n; k++)\n        {\n                int numerator = pow(k, n - 2) - k;\n                int hcf = math.gcd(n, k);\n                if(hcf == 1 && (numerator % n) != 0)\n                        return false;\n        }\n        return true;\n}", "6": "int minOperations(int a, int b, int n)\n{\n        int minA = min(a);\n        for (int x = minA; x > -1; x--)\n        {\n                bool check = true;\n                int operations = 0;\n                for (int i = 0; i < n; i++)\n                {\n                        if ((x % b[i]) == (a[i] % b[i]))\n                        {\n                                operations += ((a[i] - x) / b[i]);\n                        }\n                        else\n                        {\n                                check = false;\n                                break;\n                        }\n                if (check)\n                {\n                        return operations;\n                }\n        }\n        return -1;\n}", "7": "int largestSquare(int** matrix, int R, int C, int q_i, int q_j, int K, int Q){\n        int countDP[R][C]; \n        countDP[0][0] = matrix[0][0]; \n        for (int i = 1; i < R; i++){\n                countDP[i][0] = (countDP[i - 1][0] + matrix[i][0]);\n        }\n        for (int j = 1; j < C; j++){\n                countDP[0][j] = (countDP[0][j - 1] + matrix[0][j]);\n        }\n        for (int i = 1; i < R; i++){\n                for (int j = 1; j < C; j++){\n                        countDP[i][j] = (matrix[i][j] + countDP[i - 1][j] + countDP[i][j - 1] - countDP[i - 1][j - 1]);\n                }\n        }\n        for (int q = 0; q < Q; q++){\n                int i = q_i[q];\n                int j = q_j[q];\n                int min_dist = min(i, j, R - i - 1, C - j - 1);\n                ans = -1;\n                for (int k = 0; k < min_dist + 1; k++){ \n                        int x1 = i - k;\n                        int x2 = i + k;\n                        int y1 = j - k;\n                        int y2 = j + k; \n                        int count = countDP[x2][y2]; \n                        if (x1 > 0){ \n                                        count -= countDP[x1 - 1][y2]\n                        }\n                        if (y1 > 0){\n                                        count -= countDP[x2][y1 - 1]\n                        }\n                        if (x1 > 0 && y1 > 0){\n                                        count += countDP[x1 - 1][y1 - 1]\n                        }\n                        if (count > K){\n                                        break\n                        }\n                        ans = 2 * k + 1\n                }\n                cout << ans << \"\\n\";\n        }\n}", "8": "int countSubsequences(int arr[], int n) \n{ \n    int odd = 0; \n  \n    for (int i = 0; i < n; i++) { \n        if (arr[i] & 1) \n            odd++; \n    } \n  \n    return (1 << odd) - 1; \n}", "9": "int power(int p){\n        int res = 1;\n        for (int i = 1; i < p + 1; i++){\n                res *= 2;\n                res %= mod;\n        }\n        return res % mod;\n}\nint subset_square_sum(vector<int> A){\n        int n = A.size();\n        int ans = 0;\n        for (int i: A){\n                ans += i * i % mod;\n                ans %= mod;\n        }\n        return ans * power(n - 1) % mod;\n}", "10": "int digitWell(int n, int m, int k)\n{\n        int cnt = 0;\n        while (n > 0)\n        {\n                if (n % 10 == m)\n                {\n                        cnt = cnt + 1;\n                }\n                n = (int)(n / 10);\n        }\n        return cnt == k;\n}\nint findInt(int n, int m, int k)\n{\n        int i = n + 1;\n        while (true)\n        {\n                if (digitWell(i, m, k))\n                {\n                        return i;\n                }\n                i = i + 1;\n        }\n}", "11": "int gcd (int a, int b){\n        if a == 0 or b == 0{\n                return 0;\n        }\n        if a == b{\n                return a;\n        }\n        if a > b{\n                return gcd(a - b, b);\n        }\n        return gcd(a, b - a);\n}\n\nint cpFact(int x, int y){\n        while (gcd(x, y) != 1){\n                x = x / gcd(x, y);\n        }\n        return int(x);\n}", "12": "int SieveOfAtkin (int limit)\n{\n        if (limit > 2)\n                {print(2 , end = \" \")}\n        if (limit > 3)\n                {print(3 , end = \" \")}\n        sieve = [False] * limit\n        for (int i = 0; i < limit; ++i)\n                {sieve[i] = False;}\n        int x = 1;\n        while(x * x < limit)\n        {\n                int y = 1;\n                while(y * y < limit)\n                {\n                        int n = (4 * x * x) + (y * y);\n                        if (n <= limit && (n % 12 == 1 || n % 12 == 5))\n                                {sieve[n] ^= true;}\n                        n = (3 * x * x) + (y * y);\n                        if (n <= limit && n % 12 == 7)\n                                {sieve[n] ^= true;}\n                        n = (3 * x * x) - (y * y);\n                        if (x > y && n <= limit && n % 12 == 11)\n                                {sieve[n] ^= true;}\n                        y += 1;\n                }\n                x += 1;\n        }\n        int r = 5;\n        while(r * r < limit)\n        {\n                if (sieve[r])\n                {\n                        for (int i = r * r; i < limit; i += r * r)\n                                {sieve[i] = false;}\n                }\n                ++r;\n        }\n        for (int a = 5; a < limit; ++a)\n        {\n                if (sieve[a])\n                {print(a , end = \" \");}\n        }\n}", "13": "int MaxSubsetlength(arr, A, B)\n{\n        dp = [[0 for i in range(B + 1)] for i in range(A + 1)]\n        for str in arr:\n                zeros = str.count('0')\n                ones = str.count('1')\n                for i in range(A, zeros - 1, -1):\n                        for j in range(B, ones - 1, -1):\n                                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[A][B]\n}", "14": "bool Log2(int x){\n        if (x == 0)\n                return false;\n        return (log10(x) /\n                        log10(2));\n}\nbool isPowerOfTwo(int n){\n        return (ceil(Log2(n)) ==\n                        floor(Log2(n)));\n}", "15": "int productPairs(int arr[], int n) {\n        int product = 1;\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                        product = (product * ((arr[i] % mod) * (arr[j] % mod))) % mod;\n                }\n        }\n        return product % mod;\n}", "16": "int main() {\n\tint n, k;\n\tcin >> n >> k;\n\tint arr[n];\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> arr[i];\n\tcout << findMaxAverage(arr, n, k);\n\treturn 0;\n}", "17": "int Calculate_factorial(int n) {\n\tint fact[n+1]\n\tfact[0] = 1;\n\tfor (int i=1; i<=mx; i++) \n\t\tfact[i] = i * fact[i-1]; \n\t\tfact[i] %= mod; \n\treturn fact[n];\n}\nint UniModal_per(int a, int b) {\n\tint res = 1;\n\twhile (b != 0) {\n\t\tif (b % 2 != 0) \n\t\t\tres = res * a; \n\t\tres %= mod; \n\t\ta = a * a; \n\t\ta %= mod; \n\t\tb //= 2; \n\t}\n\treturn res;\n}\nvoid countPermutations(int n) {\n\tCalculate_factorial();\n\tint uni_modal = UniModal_per(2, n - 1);\n\tint nonuni_modal = fact[n] - uni_modal;\n\tcout << int(uni_modal) << \" \"\n\t\t<< int(nonuni_modal);\n\treturn;\n}", "18": "void removeChars(string &arr, int k) {\n        int hash[MAX_CHAR] = {0};\n        int n = arr.length();\n        for (int i = 0; i < n; i++) {\n                hash[arr[i] - 'a'] += 1;\n        }\n        string ans = \"\";\n        int index = 0;\n        for (int i = 0; i < n; i++) {\n                if (hash[arr[i] - 'a'] != k) {\n                        ans += arr[i];\n                }\n        }\n        arr = ans;\n        return;\n}", "19": "int EnneacontahexagonNum(int n)\n{\n\treturn (94 * n * n - 92 * n) / 2;\n}", "20": "bool possibleTripletInRange(int L, int R)\n{\n\tbool flag = false;\n\tint possibleA = 0;\n\tint possibleB = 0;\n\tint possibleC = 0;\n\tint numbersInRange = (R - L + 1);\n\tif (numbersInRange < 3)\n\t{\n\t\tflag = false;\n\t}\n\telse if (numbersInRange > 3)\n\t{\n\t\tflag = true;\n\t\tif ((L % 2) > 0)\n\t\t{\n\t\t\tL += 1;\n\t\t}\n\t\tpossibleA = L;\n\t\tpossibleB = L + 1;\n\t\tpossibleC = L + 2;\n\t}\n\telse\n\t{\n\t\tif ((L % 2) == 0)\n\t\t{\n\t\t\tflag = true;\n\t\t\tpossibleA = L;\n\t\t\tpossibleB = L + 1;\n\t\t\tpossibleC = L + 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag = false;\n\t\t}\n\t}\n\tif (flag == true)\n\t{\n\t\tcout << \"(\" << possibleA << \",\" << possibleB << \",\" << possibleC << \") is one such\" << \"possible triplet between\" << L << \"and\" << R << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"No Such Triplet exists between\" << L << \"and\" << R << endl;\n\t}\n\treturn flag;\n}", "21": "int largest_sum(int arr[], int n) \n{ \n    // Initialize maximum to -1 \n    int maximum = -1; \n  \n    // HashMap to store frequency \n    unordered_map<int, int> m; \n  \n    // Traverse the given array \n    for (int i = 0; i < n; i++) { \n  \n        // If already exists in hashmap, \n        // increment count \n        if (m.find(arr[i]) != m.end()) \n            m[arr[i]]++; \n  \n        // Else insert this element with \n        // count as 1 in hash map \n        else\n            m[arr[i]] = 1; \n  \n        // If this sum is seen before, \n        // update max if required \n        if (m.find(2 * arr[i]) != m.end()) { \n  \n            // Update maximum if it is \n            // less than new count \n            if (maximum < 2 * arr[i]) \n                maximum = 2 * arr[i]; \n        } \n    } \n  \n    // Return maximum of twice of any \n    // element with odd count \n    return maximum; \n}", "22": "void addEdge(int a, int b){\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n}\nvoid dfs(int x){\n        vis[x] = true;\n        subtreeSize[x] = 1;\n        for (int i : tree[x]){\n                if (vis[i] == false){\n                        dfs(i);\n                        subtreeSize[x] += subtreeSize[i];\n                }\n        }\n}\nvoid countPairs(int a, int b){\n        int sub = min(subtreeSize[a], subtreeSize[b]);\n        cout << sub * (n - sub) << endl;\n}", "23": "void sieveOfEratostheneses()\n{\n        isPrime[1] = false;\n        int i = 2;\n        while(i * i < 100005)\n        {\n                if(isPrime[i])\n                {\n                        int j = 2 * i;\n                        while(j < 100005)\n                        {\n                                isPrime[j] = false;\n                                j += i;\n                        }\n                }\n                i++;\n        }\n        return;\n}\nint findPrime(int n)\n{\n        int num = n + 1;\n        while(num)\n        {\n                if(isPrime[num])\n                {\n                        return num;\n                }\n                num++;\n        }\n        return 0;\n}\nint minNumber(int arr[], int n)\n{\n        sieveOfEratostheneses();\n        int s = 0;\n        for(int i = 0; i < n; i++)\n        {\n                s += arr[i];\n        }\n        if(isPrime[s] == true)\n        {\n                return 0;\n        }\n        int num = findPrime(s);\n        return num - s;\n}\nint main()\n{\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL);\n        int n;\n        cin >> n;\n        int arr[n];\n        for(int i = 0; i < n; i++)\n        {\n                cin >> arr[i];\n        }\n        cout << minNumber(arr, n) << \"\\n\";\n        return 0;\n}", "24": "bool possible(int mid, vector<int>& a){\n        int n = a.size();\n        int total = (n * (n - 1)) / 2;\n        int need = (total + 1) / 2;\n        int count = 0;\n        int start = 0; int end = 1;\n        while (end < n){\n                if (a[end] - a[start] <= mid){\n                        end += 1;\n                }\n                else {\n                        count += (end - start - 1);\n                        start += 1;\n                }\n        }\n        if (end == n && start < end && a[end - 1] - a[start] <= mid){\n                int t = end - start - 1;\n                count += (t * (t + 1) / 2);\n        }\n        if (count >= need){\n                return true;\n        }\n        else {\n                return false;\n        }\n}\n\nint findMedian(vector<int>& a){\n        int n = a.size();\n        int low = 0; int high = a[n - 1] - a[0];\n        while (low <= high){\n                int mid = (low + high) / 2;\n                if (possible(mid, a)){\n                        high = mid - 1;\n                }\n                else {\n                        low = mid + 1;\n                }\n        }\n        return high + 1;\n}\n\n\nint main() {\n        vector<int> a = {1, 2, 3, 4, 5};\n        cout << findMedian(a);\n}", "25": "int MinimizeleftOverSum(int a[], int n)\n{\n        int v1[], v2[];\n        for (int i = 0; i < n; i++)\n        {\n                if (a[i] % 2)\n                {\n                        v1.append(a[i]);\n                }\n                else\n                {\n                        v2.append(a[i]);\n                }\n        }\n        if (v1.size() > v2.size())\n        {\n                v1.sort();\n                v2.sort();\n                int x = v1.size() - v2.size() - 1;\n                int sum = 0;\n                int i = 0;\n                while (i < x)\n                {\n                        sum += v1[i];\n                        i += 1\n                }\n                return sum;\n        }\n        else if (v2.size() > v1.size())\n        {\n                v1.sort();\n                v2.sort();\n                int x = v2.size() - v1.size() - 1;\n                int sum = 0;\n                int i = 0;\n                while (i < x)\n                {\n                        sum += v2[i];\n                        i += 1\n                }\n                return sum;\n        }\n        else\n        {\n                return 0;\n        }\n}", "26": "int MaxGCD(int a[], int n){\n        int Prefix[n + 2];\n        int Suffix[n + 2];\n        Prefix[1] = a[0];\n        for(int i = 2; i <= n + 1; i++){\n                Prefix[i] = __gcd(Prefix[i - 1], a[i - 1]);\n        }\n        Suffix[n] = a[n - 1];\n        for(int i = n - 1; i >= 0; i--){\n                Suffix[i] = __gcd(Suffix[i + 1], a[i - 1]);\n        }\n        int ans = max(Suffix[2], Prefix[n - 1]);\n        for(int i = 2; i < n; i++){\n                ans = max(ans, __gcd(Prefix[i - 1], Suffix[i + 1]));\n        }\n        return ans;\n}", "27": "def countWays(N) {\n        E = (N * (N - 1)) / 2\n        if (N == 1) {\n                return 0\n        }\n        return int(pow(2, E - 1))\n}", "28": "int power(int X, int Y){\n        res = 1\n        X = X % M\n        if (X == 0){\n                return 0\n        }\n        while (Y > 0){\n                if (Y & 1){\n                        res = (res * X) % M\n                }\n                Y = Y >> 1\n                X = (X * X) % M\n        }\n        return res\n}\nint findValue(int n){\n        X = 0\n        pow_10 = 1\n        while(n){\n                if (n & 1){\n                        X += pow_10\n                }\n                pow_10 *= 10\n                n //= 2\n        }\n        X = (X * 2) % M\n        res = power(2, X)\n        return res\n}", "29": "void printNum(int L, int R)\n{\n        for (int i = L; i <= R; i++)\n        {\n                int temp = i;\n                int c = 10;\n                int flag = 0;\n                while (temp > 0)\n                {\n                        if (temp % 10 >= c)\n                        {\n                                flag = 1;\n                                break;\n                        }\n                        c = temp % 10;\n                        temp /= 10;\n                }\n                if (flag == 0)\n                {\n                        cout << i << \" \";\n                }\n        }\n}", "30": "void sub_segments(string s, int n){\n        int l = s.length();\n        for (int x = 0; x < l; x+=n){\n                string newlist = s.substr(x, n);\n                arr = {};\n                for (int y = 0; y < newlist.length(); y++){\n                        if (newlist[y] not in arr){\n                                arr.push_back (newlist[y]);\n                        }\n                }\n                cout << ''.join (arr) << endl;\n        }\n}", "31": "int cutRod(int price[], int n)\n{\n   int val[n+1];\n   val[0] = 0;\n   int i, j;\n \n   for (i = 1; i<=n; i++)\n   {\n       int max_val = INT_MIN;\n       for (j = 0; j < i; j++)\n         max_val = max(max_val,  price[j] + val[i-j-1]);\n       val[i] = max_val;\n   }\n \n   return val[n];\n}", "32": "int find_distinct(int a[], int n, int q, int queries[]){\n        int check[MAX] = {0};\n        int idx[MAX] = {0};\n        int cnt = 1;\n        for (int i=n-1; i>=0; i--){\n                if (check[a[i]] == 0){\n                        idx[i] = cnt;\n                        check[a[i]] = 1;\n                        cnt += 1;\n                }\n                else{\n                        idx[i] = cnt - 1;\n                }\n        }\n        for (int i=0; i<q; i++){\n                int m = queries[i];\n                cout << idx[m] << \" \";\n        }\n}", "33": "int largestPalindrome(string s) {\n        l = len(s);\n        m = defaultdict(lambda:0);\n        for i in range(0, l):\n                m[int(s[i])] += 1;\n        if possibility(m, l, s) == false:\n                print(\"Palindrome cannot be formed\");\n                return;\n        largest = [None] * l;\n        front = 0;\n        for i in range(9, -1, -1):\n                if m[i] & 1:\n                        largest[l // 2] = chr(i + 48);\n                        m[i] -= 1;\n                        while m[i] > 0:\n                                largest[front] = chr(i + 48);\n                                largest[l - front - 1] = chr(i + 48);\n                                m[i] -= 2;\n                                front += 1;\n                else:\n                        while m[i] > 0:\n                                largest[front] = chr(i + 48);\n                                largest[l - front - 1] = chr(i + 48);\n                                m[i] -= 2;\n                                front += 1;\n        for i in range(0, l):\n                print(largest[i], end = \"\");", "34": "int Wedderburn(int n, vector<int> &store) {\n        if (n <= 2) {\n                return store[n];\n        }\n        else if (n % 2 == 0) {\n                int x = n / 2;\n                int ans = 0;\n                for (int i = 1; i < x; ++i) {\n                        ans += store[i] * store[n - i];\n                }\n                ans += (store[x] * (store[x] + 1)) / 2;\n                store[n] = ans;\n                return ans;\n        }\n        else {\n                int x = (n + 1) / 2;\n                int ans = 0;\n                for (int i = 1; i < x; ++i) {\n                        ans += store[i] * store[n - i];\n                }\n                store[n] = ans;\n                return ans;\n        }\n}\nvoid Wedderburn_Etherington(int n) {\n        vector<int> store(n + 1);\n        store[0] = 0;\n        store[1] = 1;\n        store[2] = 1;\n        for (int i = 0; i < n; ++i) {\n                cout << Wedderburn(i, store);\n                if (i != n - 1) {\n                        cout << \", \";\n                }\n        }\n}", "35": "int icosihenagonal_num(int n)\n{\n        return (19 * n * n - 17 * n) / 2;\n}", "36": "int noOfBinaryStrings(int N, int k) \n{\n        int dp[100002];\n        for(int i=1; i<K; i++)\n                dp[i] = 1;\n        dp[k] = 2;\n        for(int i=k+1; i<N+1; i++)\n                dp[i] = (dp[i-1] + dp[i-k]) % mod;\n        return dp[N];\n}", "37": "int averageEven(int n) {\n    if (n % 2 != 0) {\n        cout << \"Invalid Input\";\n        return -1;\n    }\n    return (n + 2) / 2;\n}", "38": "int LowerInsertionPoint(int arr[], int n, int X) \n{ \n    if (X < arr[0]) \n        return 0; \n    elif (X > arr[n - 1]) \n        return n; \n    int lowerPnt = 0; \n    int i = 1; \n    while (i < n && arr[i] < X) \n    { \n        lowerPnt = i; \n        i = i * 2; \n    } \n    while (lowerPnt < n && arr[lowerPnt] < X) \n    { \n        lowerPnt += 1; \n    } \n    return lowerPnt; \n}", "39": "string encryptString(string string, int n)\n{\n        int i = 0; \n        int cnt = 0;\n        string encryptedStr = \"\";\n        while (i < n)\n        {\n                cnt = i + 1;\n                while (cnt > 0)\n                {\n                        encryptedStr += string[i];\n                        cnt -= 1;\n                }\n                i += 1;\n        }\n        return encryptedStr;\n}", "40": "int countIntersections(int n)\n{\n        return n * (n - 1) / 2;\n}", "41": "void findElements(int* arr, int n){\n        int first = INT_MIN;\n        int second = INT_MIN;\n        for(int i = 0; i < n; i++){\n                if(arr[i] > first){\n                        second = first;\n                        first = arr[i];\n                }\n                else if(arr[i] > second){\n                        second = arr[i];\n                }\n        }\n        for(int i = 0; i < n; i++){\n                if(arr[i] < second){\n                        cout<<arr[i]<<\" \";\n                }\n        }\n}", "42": "bool check(string s, int m)\n{\n        int l = s.length();\n        int c1 = 0, c2 = 0;\n        for (int i = 0; i < l - 1; i++)\n        {\n                if (s[i] == '0')\n                {\n                        c2 = 0;\n                        c1 = c1 + 1;\n                }\n                else\n                {\n                        c1 = 0;\n                        c2 = c2 + 1;\n                }\n                if (c1 == m or c2 == m)\n                        return true;\n        }\n        return false;\n}", "43": "int findbitwiseOR(int a[], int n)\n{\n        int res = 0;\n        for(int i = 0; i < n; i++)\n        {\n                int curr_sub_array = a[i];\n                res = res | curr_sub_array;\n                for(int j = i; j < n; j++)\n                {\n                        curr_sub_array = curr_sub_array & a[j];\n                        res = res | curr_sub_array;\n                }\n        }\n        cout << res;\n}", "44": "int multiplyByMersenne(int N, int M) {\n    int x = int(log2(M + 1));\n    return ((N << x) - N);\n}", "45": "void performQuery(int* arr, int** Q, int Q_size){\n        for(int i = 0; i < Q_size; i++){\n                int orr = 0;\n                int x = Q[i][0];\n                arr[x - 1] = Q[i][1];\n                for(int j = 0; j < sizeof(arr); j++){\n                        orr = orr | arr[j];\n                }\n                printf(\"%d \", orr);\n        }\n}", "46": "int areaOfSquare(int S) {\n        int area = S * S;\n        return area;\n}\n\nint main() {\n        int S;\n        cin >> S;\n        cout << areaOfSquare(S) << endl;\n        return 0;\n}", "47": "int longOddEvenIncSeq(int arr[], int n) \n{ \n    int lioes[n]; \n  \n    // Initialize all LIOES values as 1 \n    for (int i = 0; i < n; i++) \n        lioes[i] = 1; \n  \n    // Compute optimized LIS values in \n    // bottom up manner \n    for (int i = 1; i < n; i++) \n        for (int j = 0; j < i; j++) \n            if (arr[i] > arr[j] && \n                (arr[i] + arr[j]) % 2 != 0 && \n                lioes[i] < lioes[j] + 1) \n                lioes[i] = lioes[j] + 1; \n  \n    // Return the maximum value \n    return *max_element(lioes, lioes+n); \n}", "48": "int counLastDigitK(int low, int high, int k){\n        int mlow = 10 * math.ceil(low/10.0);\n        int mhigh = 10 * int(high/10.0);\n        int count = (mhigh - mlow)/10;\n        if (high % 10 >= k){\n                count += 1;\n        }\n        if (low % 10 <= k && \\\n                (low%10) > 0){\n                count += 1;\n        }\n        return int(count);\n}", "49": "int findCrossOver(int arr[], int low, int high, int x) \n{ \n    if (arr[high] <= x) \n            return high; \n    if (arr[low] > x) \n            return low; \n    int mid = (low + high)/2;  \n    if (arr[mid] <= x && arr[mid+1] > x) \n            return mid; \n    if(arr[mid] < x) \n            return findCrossOver(arr, mid+1, high, x); \n    return findCrossOver(arr, low, mid-1, x); \n} \n\nvoid printKclosest(int arr[], int x, int k, int n) \n{ \n    int l = findCrossOver(arr, 0, n-1, x); \n    int r = l+1;  \n    int count = 0; \n    if (arr[l] == x) \n            l--; \n    while (l >= 0 && r < n && count < k) \n    { \n        if (x - arr[l] < arr[r] - x) \n            cout << arr[l--] << \" \"; \n        else\n            cout << arr[r++] << \" \"; \n        count++; \n    } \n    while (count < k && l >= 0) \n        cout << arr[l--] << \" \"; \n    while (count < k && r < n) \n        cout << arr[r++] << \" \"; \n}", "50": "int SieveOfEratosthenes() \n{ \n\tint p = 2; \n\twhile (p * p <= MAX) \n\t{ \n\t\tif (isPrime[p]) \n\t\t{ \n\t\t\tfor (int i = p * p; i <= MAX; i += p) \n\t\t\t\tisPrime[i] = false; \n\t\t} \n\t\tp++; \n\t} \n\tfor (int p = 2; p <= MAX; p++) \n\tif (isPrime[p]) \n\t\tprimes.push_back(p); \n} \n\nint prime_search(vector<int> &primes, int diff) \n{ \n\tint low = 0, high = primes.size() - 1; \n\twhile (low <= high) \n\t{ \n\t\tint mid = (low + high) / 2; \n\t\tif (primes[mid] == diff) \n\t\t\treturn primes[mid]; \n\t\telse if (primes[mid] < diff) \n\t\t\tlow = mid + 1; \n\t\telse\n\t\t{ \n\t\t\tint res = primes[mid]; \n\t\t\thigh = mid - 1; \n\t\t} \n\t} \n\treturn res; \n} \n\nint minCost(int arr[], int n) \n{ \n\tSieveOfEratosthenes(); \n\tint res = 0; \n\tfor (int i = 1; i < n; i++) \n\t{ \n\t\tif (arr[i] < arr[i - 1]) \n\t\t{ \n\t\t\tint diff = arr[i - 1] - arr[i]; \n\t\t\tint closest_prime = prime_search(primes, diff); \n\t\t\tres += closest_prime; \n\t\t\tarr[i] += closest_prime; \n\t\t} \n\t} \n\treturn res; \n}", "51": "bool check(string s, int n) \n{ \n    // Create a stack of characters \n    stack<char> st; \n  \n    // Iterate through all characters of input string \n    for (int i = 0; i < n; i++) \n    { \n        // If the character is opening parenthesis \n        // then push it to stack \n        if (s[i] == '(' || s[i] == '{' || s[i] == '[') \n            st.push(s[i]); \n  \n        // If the scanned character is a closing parenthesis \n        // then pop from stack and if the popped character is not a \n        // matching parenthesis then return false \n        else if (st.empty()) \n           return false; \n  \n        else if ( (s[i] == ')' && st.top() != '(') ||\n                (s[i] == '}' && st.top() != '{') ||\n                (s[i] == ']' && st.top() != '[') ) \n            return false; \n  \n        else\n            st.pop(); \n    } \n  \n    // If there is something left in expression \n    // then there is a starting parenthesis without \n    // a closing parenthesis \n    return st.empty(); \n}", "52": "int isPrime(int n) {\n        if (n <= 1) {\n                return false;\n        }\n        for (int i = 2; i < n; i++) {\n                if (n % i == 0) {\n                        return false;\n                }\n        }\n        return true;\n}\nint findPrime(int n) {\n        int num = n + 1;\n        while (num) {\n                if (isPrime(num)) {\n                        return num;\n                }\n                num += 1;\n        }\n        return 0;\n}\nint minNumber(int arr[], int len) {\n        int s = 0;\n        for (int i = 0; i < len; i++) {\n                s += arr[i];\n        }\n        if (isPrime(s)) {\n                return 0;\n        }\n        int num = findPrime(s);\n        return num - s;\n}", "53": "double Convert(double radian)\n{\n        const double pi = 3.14159;\n        double degree = radian * (180/pi);\n        return degree;\n}", "54": "def longestRodInCuboid(length, breadth, height) :\n        temp = length * length + breadth * breadth + height * height\n        result = sqrt(temp)\n        return result", "55": "void least_prime_factor(){\n        for(int i=2;i<N;i++){\n                if(lpf[i]==0){\n                        for(int j=i;j<N;j+=i){\n                                if(lpf[j]==0){\n                                        lpf[j]=i;\n                                }\n                        }\n                }\n        }\n}\n \nvoid Mobius(){\n        for(int i=1;i<N;i++){\n                if(i==1){\n                        mobius[i]=1;\n                }\n                else{\n                        if(lpf[(i/lpf[i])]==lpf[i]){\n                                mobius[i]=0;\n                        }\n                        else{\n                                mobius[i]=-1*mobius[i/lpf[i]];\n                        }\n                }\n        }\n}\n \nint gcd_pairs(int a[],int n){\n        int maxi=0;\n        int fre[N];\n        for(int i=0;i<N;i++){\n                fre[i]=0;\n        }\n        for(int i=0;i<n;i++){\n                fre[a[i]]++;\n                maxi=max(a[i],maxi);\n        }\n        least_prime_factor();\n        Mobius();\n        int ans=0;\n        for(int i=1;i<=maxi;i++){\n                if(mobius[i]==0){\n                        continue;\n                }\n                int temp=0;\n                for(int j=i;j<=maxi;j+=i){\n                        temp+=fre[j];\n                }\n                ans+=temp*(temp-1)/2*mobius[i];\n        }\n        return ans;\n}", "56": "bool isPrime(int n){\n        if (n <= 1){\n                return false;\n        }\n        for (int i = 2; i < n; i++){\n                if (n % i == 0){\n                        return false;\n                }\n        }\n        return true;\n}\nint countSubsequences(int arr[], int n){\n        int totalSubsequence = (int)(pow(2, n) - 1);\n        int countPrime = 0;\n        int countOnes = 0;\n        for (int i = 0; i < n; i++){\n                if (arr[i] == 1){\n                        countOnes += 1;\n                }\n                elif (isPrime(arr[i])){\n                        countPrime += 1;\n                }\n        }\n        int compositeSubsequence = 0;\n        int onesSequence = (int)(pow(2, countOnes) - 1);\n        compositeSubsequence = (totalSubsequence - countPrime - onesSequence - onesSequence * countPrime);\n        return compositeSubsequence;\n\n}", "57": "int dfs(int u, int count){\n        visited[u] = true;\n        temp = 0;\n        startnode = 0;\n        maxi = 0;\n        for(int i = 0; i < adjacent[u].size(); i++){\n                if(!visited[adjacent[u][i]]){\n                        temp += 1;\n                        dfs(adjacent[u][i], count + 1);\n                }\n        }\n        if(temp == 0){\n                if(maxi < count){\n                        maxi = count;\n                        startnode = u;\n                }\n        }\n}\nint dfs1(int u, int count){\n        visited[u] = true;\n        temp = 0;\n        endnode = 0;\n        maxi = 0;\n        for(int i = 0; i < adjacent[u].size(); i++){\n                if(!visited[adjacent[u][i]]){\n                        temp += 1;\n                        parent[adjacent[u][i]] = u;\n                        dfs1(adjacent[u][i], count + 1);\n                }\n        }\n        if(temp == 0){\n                if(maxi < count){\n                        maxi = count;\n                        endnode = u;\n                }\n        }\n}\nint dfs2(int u, int count){\n        visited[u] = true;\n        temp = 0;\n        thirdnode = 0;\n        maxi = 0;\n        for(int i = 0; i < adjacent[u].size(); i++){\n                if((!visited[adjacent[u][i]]) && (!vis[adjacent[u][i]])){\n                        temp += 1;\n                        dfs2(adjacent[u][i], count + 1);\n                }\n        }\n        if(temp == 0){\n                if(maxi < count){\n                        maxi = count;\n                        thirdnode = u;\n                }\n        }\n}\nint findNodes(){\n        dfs(1, 0);\n        maxi = 0;\n        for(int i = 0; i < N+1; i++){\n                visited[i] = false;\n        }\n        dfs1(startnode, 0);\n        for(int i = 0; i < N+1; i++){\n                visited[i] = false;\n        }\n        int x = endnode;\n        vis[startnode] = true;\n        while(x != startnode){\n                vis[x] = true;\n                x = parent[x];\n        }\n        maxi = 0;\n        for(int i = 1; i < N+1; i++){\n                if(vis[i]){\n                        dfs2(i, 0);\n                }\n\n        }\n}", "58": "int minimumIncrement(vector<int>& A) {\n        int N = A.size();\n        if (N % 2 != 0) {\n                return -1;\n        }\n        int cntEven = 0;\n        int cntOdd = 0;\n        for (int i = 0; i < N; i++) {\n                if (A[i] % 2 == 0) {\n                        cntEven += 1;\n                }\n        }\n        cntOdd = N - cntEven;\n        return abs(cntEven - cntOdd) / 2;\n}"}}, "Python -  Java": {"Id": {"0": 1869, "1": 12550, "2": 8501, "3": 12638, "4": 4624, "5": 10345, "6": 5512, "7": 6210, "8": 9574, "9": 11204, "10": 11707, "11": 12750, "12": 13453, "13": 5946, "14": 2129, "15": 10539, "16": 1590, "17": 3375, "18": 6068, "19": 7735, "20": 10474, "21": 12486, "22": 10885, "23": 13049, "24": 3601, "25": 4570, "26": 6395, "27": 11627, "28": 5995, "29": 3704, "30": 7788, "31": 7051, "32": 5621, "33": 5772, "34": 11315, "35": 9114, "36": 6471, "37": 12639, "38": 3932, "39": 5675, "40": 9147, "41": 1517, "42": 8213, "43": 9804, "44": 9948, "45": 9608, "46": 9070, "47": 6712, "48": 12765, "49": 1813, "50": 3463, "51": 7622, "52": 13048, "53": 12794, "54": 9329, "55": 11217, "56": 10568}, "Python": {"0": "def max(a, b):\n        return a if (a > b) else b\ndef cutRod(price, n):\n        if(n <= 0):\n                return 0\n        max_val = -sys.maxsize-1\n        for i in range(0, n):\n                max_val = max(max_val, price[i] +\n                                        cutRod(price, n - i - 1))\n        return max_val", "1": "def checkdigit(n, k):\n        while (n):\n                rem = n % 10\n                if (rem == k):\n                        return 1\n                n = n / 10\n        return 0\ndef findNthNumber(n, k):\n        i = k + 1\n        count = 1\n        while(count < n):\n                if (checkdigit(i, k) or (i % k == 0)):\n                        count += 1\n                if (count == n):\n                        return i\n                i += 1\n        return -1", "2": "def isNumber(s):\n        for i in range(len(s)):\n                if s[i].isdigit() != True:\n                        return False\n        return True", "3": "def averageEven(n) :\n        if (n % 2 != 0) :\n                print(\"Invalid Input\")\n                return -1\n        sm = 0\n        count = 0\n        while (n >= 2) :\n                count = count + 1\n                sm = sm + n\n                n = n - 2\n        return sm // count", "4": "def sortByRow(mat, n, descending):\n        for i in range(n):\n                if (descending == True):\n                        mat[i].sort(reverse = True)\n                else:\n                        mat[i].sort()\ndef transpose(mat, n):\n        for i in range(n):\n                for j in range(i + 1, n):\n                        mat[i][j], mat[j][i] = mat[j][i], mat[i][j]\ndef sortMatRowAndColWise(mat, n):\n        sortByRow(mat, n, True)\n        transpose(mat, n)\n        sortByRow(mat, n, False)\n        transpose(mat, n);\ndef printMat(mat, n):\n        for i in range(n):\n                for j in range( n):\n                        print(mat[i][j], end = \" \")\n                print()", "5": "def isDNum(n):\n        if n < 4:\n                return False\n        for k in range(2, n):\n                numerator = pow(k, n - 2) - k\n                hcf = math.gcd(n, k)\n                if(hcf ==1 and (numerator % n) != 0):\n                        return False\n        return True", "6": "def minOperations(a, b, n):\n        minA = min(a);\n        for x in range(minA, -1, -1):\n                check = True;\n                operations = 0;\n                for i in range(n):\n                        if (x % b[i] == a[i] % b[i]):\n                                operations += (a[i] - x) / b[i];\n                        else:\n                                check = False;\n                                break;\n                if (check):\n                        return operations;\n        return -1;", "7": "def largestSquare(matrix, R, C, q_i, q_j, K, Q):\n\tcountDP = [[0 for x in range(C)] for x in range(R)] \n\tcountDP[0][0] = matrix[0][0] \n\tfor i in range(1, R):\n\t\tcountDP[i][0] = (countDP[i - 1][0] + matrix[i][0])\n\tfor j in range(1, C):\n\t\tcountDP[0][j] = (countDP[0][j - 1] + matrix[0][j])\n\tfor i in range(1, R):\n\t\tfor j in range(1, C):\n\t\t\tcountDP[i][j] = (matrix[i][j] + countDP[i - 1][j] + countDP[i][j - 1] - countDP[i - 1][j - 1])\n\tfor q in range(0, Q):\n\t\ti = q_i[q]\n\t\tj = q_j[q]\n\t\tmin_dist = min(i, j, R - i - 1, C - j - 1)\n\t\tans = -1\n\t\tfor k in range(0, min_dist + 1): \n\t\t\tx1 = i - k\n\t\t\tx2 = i + k\n\t\t\ty1 = j - k\n\t\t\ty2 = j + k \n\t\t\tcount = countDP[x2][y2]; \n\t\t\tif (x1 > 0): \n\t\t\t\t\tcount -= countDP[x1 - 1][y2]\n\t\t\tif (y1 > 0):\n\t\t\t\t\tcount -= countDP[x2][y1 - 1]\n\t\t\tif (x1 > 0 and y1 > 0):\n\t\t\t\t\tcount += countDP[x1 - 1][y1 - 1]\n\t\t\tif (count > K):\n\t\t\t\t\tbreak\n\t\t\tans = 2 * k + 1\n\t\tprint(ans)", "8": "def countSubsequences(arr):\n\todd = 0\n\tfor x in arr:\n\t\tif (x & 1):\n\t\t\todd = odd + 1\n\treturn (1 << odd) - 1", "9": "def power(p):\n\tres = 1\n\tfor i in range(1, p + 1):\n\t\tres *= 2\n\t\tres %= mod\n\treturn res % mod\ndef subset_square_sum(A):\n\tn = len(A)\n\tans = 0\n\tfor i in A:\n\t\tans += i * i % mod\n\t\tans %= mod\n\treturn ans * power(n - 1) % mod", "10": "def digitWell(n, m, k):\n\tcnt = 0\n\twhile (n > 0):\n\t\tif (n % 10 == m):\n\t\t\tcnt = cnt + 1;\n\t\tn = (int)(n / 10);\n\treturn cnt == k;\ndef findInt(n, m, k):\n\ti = n + 1;\n\twhile (True):\n\t\tif (digitWell(i, m, k)):\n\t\t\treturn i;\n\t\ti = i + 1;", "11": "def gcd (a, b):\n\tif a == 0 or b == 0:\n\t\treturn 0\n\tif a == b:\n\t\treturn a\n\tif a > b:\n\t\treturn gcd(a - b, b)\n\treturn gcd(a, b - a)\ndef cpFact(x, y):\n\twhile gcd(x, y) != 1:\n\t\tx = x / gcd(x, y)\n\treturn int(x)", "12": "def SieveOfAtkin(limit):\n        if (limit > 2):\n                print(2 , end = \" \")\n        if (limit > 3):\n                print(3 , end = \" \")\n        sieve = [False] * limit\n        for i in range( 0 , limit ):\n                sieve[i] = False\n        x = 1\n        while(x * x < limit ) :\n                y = 1\n                while(y * y < limit ) :\n                        n = (4 * x * x) + (y * y)\n                        if (n <= limit and (n % 12 == 1 or n % 12 == 5)):\n                                sieve[n] ^= True\n                        n = (3 * x * x) + (y * y)\n                        if (n <= limit and n % 12 == 7):\n                                sieve[n] ^= True\n                        n = (3 * x * x) - (y * y)\n                        if (x > y and n <= limit and n % 12 == 11):\n                                sieve[n] ^= True\n                        y += 1\n                x += 1\n        r = 5\n        while(r * r < limit) :\n                if (sieve[r]) :\n                        for i in range(r * r, limit, r * r):\n                                sieve[i] = False\n        for a in range(5 , limit ):\n                if (sieve[a]):\n                        print(a , end = \" \")", "13": "def MaxSubsetlength(arr, A, B):\n        dp = [[0 for i in range(B + 1)] for i in range(A + 1)]\n        for str in arr:\n                zeros = str.count('0')\n                ones = str.count('1')\n                for i in range(A, zeros - 1, -1):\n                        for j in range(B, ones - 1, -1):\n                                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[A][B]", "14": "def Log2(x):\n        if x == 0:\n                return false;\n        return (math.log10(x) /\n                        math.log10(2));\ndef isPowerOfTwo(n):\n        return (math.ceil(Log2(n)) ==\n                        math.floor(Log2(n)));", "15": "def productPairs(arr, n):\n        product = 1;\n        for i in range(n):\n                for j in range(n):\n                        product *= (arr[i] % mod * arr[j] % mod) % mod;\n                        product = product % mod;\n        return product % mod;", "16": "def findMaxAverage(arr, n, k):\n        if k > n:\n                return -1\n        csum = [0]*n\n        csum[0] = arr[0]\n        for i in range(1, n):\n                csum[i] = csum[i-1] + arr[i];\n        max_sum = csum[k-1]\n        max_end = k-1\n        for i in range(k, n):\n                curr_sum = csum[i] - csum[i-k]\n                if curr_sum > max_sum:\n                        max_sum = curr_sum\n                        max_end = i\n        return max_end - k + 1", "17": "def countSubarrays(a, n, k):\n        cnt = {}\n        ans = 0\n        pref = []\n        pref.append(0)\n        for i in range(n):\n                pref.append((a[i] + pref[i]) % k)\n        cnt[0] = 1\n        for i in range(1, n + 1):\n                remIdx = i - k\n                if (remIdx >= 0):\n                        if ((pref[remIdx] - remIdx % k + k) % k in cnt):\n                                cnt[(pref[remIdx] - remIdx % k + k) % k] -= 1\n                        else:\n                                cnt[(pref[remIdx] - remIdx % k + k) % k] = -1\n                if (pref[i] - i % k + k) % k in cnt:\n                        ans += cnt[(pref[i] - i % k + k) % k]\n                if (pref[i] - i % k + k) % k in cnt:\n                        cnt[(pref[i] - i % k + k) % k] += 1\n                else:\n                        cnt[(pref[i] - i % k + k) % k] = 1\n        print(ans, end = ' ')", "18": "def Calculate_factorial():\n        fact[0] = 1\n        for i in range(1, mx + 1):\n                fact[i] = i * fact[i - 1]\n                fact[i] %= mod\ndef UniModal_per(a, b):\n        res = 1\n        while (b != 0):\n                if (b % 2 != 0):\n                        res = res * a\n                res %= mod\n                a = a * a\n                a %= mod\n                b //= 2\n        return res\ndef countPermutations(n):\n        Calculate_factorial()\n        uni_modal = UniModal_per(2, n - 1)\n        nonuni_modal = fact[n] - uni_modal\n        print(int(uni_modal), \"\",\n                int(nonuni_modal))\n        return", "19": "def removeChars(arr, k):\n\thash = [0]*MAX_CHAR\n\tn = len(arr)\n\tfor i in range( n):\n\t\thash[ord(arr[i]) - ord('a')] += 1\n\tans = \"\"\n\tindex = 0\n\tfor i in range(n):\n\t\tif (hash[ord(arr[i]) - ord('a')] != k):\n\t\t\tans += arr[i]\n\treturn ans", "20": "def EnneacontahexagonNum(n):\n\treturn (94 * n * n - 92 * n) // 2;", "21": "def possibleTripletInRange(L, R):\n\tflag = False;\n\tpossibleA = 0;\n\tpossibleB = 0;\n\tpossibleC = 0;\n\tnumbersInRange = (R - L + 1);\n\tif (numbersInRange < 3):\n\t\tflag = False;\n\telif (numbersInRange > 3):\n\t\tflag = True;\n\t\tif ((L % 2) > 0):\n\t\t\tL += 1;\n\t\tpossibleA = L;\n\t\tpossibleB = L + 1;\n\t\tpossibleC = L + 2;\n\telse:\n\t\tif ((L % 2) == 0):\n\t\t\tflag = True;\n\t\t\tpossibleA = L;\n\t\t\tpossibleB = L + 1;\n\t\t\tpossibleC = L + 2;\n\t\telse:\n\t\t\tflag = False;\n\tif (flag == True):\n\t\tprint(\"(\", possibleA, \",\", possibleB, \",\", possibleC, \") is one such\", \"possible triplet between\", L, \"and\", R);\n\telse:\n\t\tprint(\"No Such Triplet exists between\", L, \"and\", R);", "22": "def largest_sum(arr, n):\n\tmaximum = -1\n\tm = dict()\n\tfor i in arr:\n\t\tm[i] = m.get(i,0) + 1\n\tfor j in list(m):\n\t\tif ((j in m) and m[j] > 1):\n\t\t\tx, y = 0, 0\n\t\t\tif 2*j in m:\n\t\t\t\tm[2*j] = m[2 * j]+ m[j]// 2\n\t\t\telse:\n\t\t\t\tm[2*j] = m[j]//2\n\t\t\tif (2 * j > maximum):\n\t\t\t\tmaximum = 2 * j\n\treturn maximum", "23": "def sieveOfEratostheneses():\n\tisPrime[1] = False\n\ti = 2\n\twhile i * i < 100005:\n\t\tif(isPrime[i]):\n\t\t\tj = 2 * i\n\t\t\twhile j < 100005:\n\t\t\t\tisPrime[j] = False\n\t\t\t\tj += i\n\t\ti += 1\n\treturn\ndef findPrime(n):\n\tnum = n + 1\n\twhile(num):\n\t\tif isPrime[num]:\n\t\t\treturn num\n\t\tnum += 1\n\treturn 0\ndef minNumber(arr):\n\tsieveOfEratostheneses()\n\ts = 0\n\tfor i in range(0, len(arr)):\n\t\ts += arr[i]\n\tif isPrime[s] == True:\n\t\treturn 0\n\tnum = findPrime(s)\n\treturn num - s", "24": "def possible(mid, a):\n\tn = len(a);\n\ttotal = (n * (n - 1)) // 2;\n\tneed = (total + 1) // 2;\n\tcount = 0;\n\tstart = 0; end = 1;\n\twhile (end < n):\n\t\tif (a[end] - a[start] <= mid):\n\t\t\tend += 1;\n\t\telse:\n\t\t\tcount += (end - start - 1);\n\t\t\tstart += 1;\n\tif (end == n and start < end and a[end - 1] - a[start] <= mid):\n\t\tt = end - start - 1;\n\t\tcount += (t * (t + 1) // 2);\n\tif (count >= need):\n\t\treturn True;\n\telse:\n\t\treturn False;\ndef findMedian(a):\n\tn = len(a);\n\tlow = 0; high = a[n - 1] - a[0];\n\twhile (low <= high):\n\t\tmid = (low + high) // 2;\n\t\tif (possible(mid, a)):\n\t\t\thigh = mid - 1;\n\t\telse :\n\t\t\tlow = mid + 1;\n\treturn high + 1;", "25": "def MinimizeleftOverSum(a, n) :\n\tv1, v2 = [], [];\n\tfor i in range(n) :\n\t\tif (a[i] % 2) :\n\t\t\tv1.append(a[i]);\n\t\telse :\n\t\t\tv2.append(a[i]);\n\tif (len(v1) > len(v2)) :\n\t\tv1.sort();\n\t\tv2.sort();\n\t\tx = len(v1) - len(v2) - 1;\n\t\tsum = 0;\n\t\ti = 0;\n\t\twhile (i < x) :\n\t\t\tsum += v1[i];\n\t\t\ti += 1\n\t\treturn sum;\n\telif (len(v2) > len(v1)) :\n\t\tv1.sort();\n\t\tv2.sort();\n\t\tx = len(v2) - len(v1) - 1;\n\t\tsum = 0;\n\t\ti = 0;\n\t\twhile (i < x) :\n\t\t\tsum += v2[i];\n\t\t\ti += 1\n\t\treturn sum;\n\telse :\n\t\treturn 0;", "26": "def MaxGCD(a, n):\n\tPrefix=[0 for i in range(n + 2)]\n\tSuffix=[0 for i in range(n + 2)]\n\tPrefix[1] = a[0]\n\tfor i in range(2,n+1):\n\t\tPrefix[i] = mt.gcd(Prefix[i - 1], a[i - 1])\n\tSuffix[n] = a[n - 1]\n\tfor i in range(n-1,0,-1):\n\t\tSuffix[i] =mt.gcd(Suffix[i + 1], a[i - 1])\n\tans = max(Suffix[2], Prefix[n - 1])\n\tfor i in range(2,n):\n\t\tans = max(ans, mt.gcd(Prefix[i - 1], Suffix[i + 1]))\n\treturn ans", "27": "def countWays(N):\n\tE = (N * (N - 1)) / 2\n\tif (N == 1):\n\t\treturn 0\n\treturn int(pow(2, E - 1))", "28": "def power(X, Y):\n\tres = 1\n\tX = X % M\n\tif (X == 0):\n\t\treturn 0\n\twhile (Y > 0):\n\t\tif (Y & 1):\n\t\t\tres = (res * X) % M\n\t\tY = Y >> 1\n\t\tX = (X * X) % M\n\treturn res\ndef findValue(n):\n\tX = 0\n\tpow_10 = 1\n\twhile(n):\n\t\tif (n & 1):\n\t\t\tX += pow_10\n\t\tpow_10 *= 10\n\t\tn //= 2\n\tX = (X * 2) % M\n\tres = power(2, X)\n\treturn res", "29": "def printNum(L, R):\n\tfor i in range(L, R + 1):\n\t\ttemp = i\n\t\tc = 10\n\t\tflag = 0\n\t\twhile (temp > 0):\n\t\t\tif (temp % 10 >= c):\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tc = temp % 10\n\t\t\ttemp //= 10\n\t\tif (flag == 0):\n\t\t\tprint(i, end = \" \")", "30": "def sub_segments (string, n):\n\tl = len (string)\n\tfor x in range (0, l, n):\n\t\tnewlist = string[x : x + n]\n\t\tarr = []\n\t\tfor y in newlist:\n\t\t\tif y not in arr:\n\t\t\t\tarr.append (y)\n\t\tprint (''.join (arr))", "31": "def cutRod(price, n):\n\tval = [0 for x in range(n+1)]\n\tval[0] = 0\n\tfor i in range(1, n+1):\n\t\tmax_val = INT_MIN\n\t\tfor j in range(i):\n\t\t\tmax_val = max(max_val, price[j] + val[i-j-1])\n\t\tval[i] = max_val\n\treturn val[n]", "32": "def find_distinct(a, n, q, queries):\n        check = [0] * MAX;\n        idx = [0] * MAX;\n        cnt = 1;\n        for i in range(n - 1, -1, -1):\n                if (check[a[i]] == 0):\n                        idx[i] = cnt;\n                        check[a[i]] = 1;\n                        cnt += 1;\n                else:\n                        idx[i] = cnt - 1;\n        for i in range(0, q):\n                m = queries[i];\n                print(idx[m], end = \" \");", "33": "def possibility(m, length, s):\n        countodd = 0\n        for i in range(0, length):\n                if m[int(s[i])] & 1:\n                        countodd += 1\n                if countodd > 1:\n                        return False\n        return True\ndef largestPalindrome(s):\n        l = len(s)\n        m = defaultdict(lambda:0)\n        for i in range(0, l):\n                m[int(s[i])] += 1\n        if possibility(m, l, s) == False:\n                print(\"Palindrome cannot be formed\")\n                return\n        largest = [None] * l\n        front = 0\n        for i in range(9, -1, -1):\n                if m[i] & 1:\n                        largest[l // 2] = chr(i + 48)\n                        m[i] -= 1\n                        while m[i] > 0:\n                                largest[front] = chr(i + 48)\n                                largest[l - front - 1] = chr(i + 48)\n                                m[i] -= 2\n                                front += 1\n                else:\n                        while m[i] > 0:\n                                largest[front] = chr(i + 48)\n                                largest[l - front - 1] = chr(i + 48)\n                                m[i] -= 2\n                                front += 1\n        for i in range(0, l):\n                print(largest[i], end = \"\")", "34": "def Wedderburn(n):\n        if (n <= 2):\n                return store[n]\n        elif (n % 2 == 0):\n                x = n // 2\n                ans = 0\n                for i in range(1, x):\n                        ans += store[i] * store[n - i]\n                ans += (store[x] * (store[x] + 1)) // 2\n                store[n] = ans\n                return ans\n        else:\n                x = (n + 1) // 2\n                ans = 0\n                for i in range(1, x):\n                        ans += store[i] * store[n - i]\n                store[n] = ans\n                return ans\ndef Wedderburn_Etherington(n):\n        store[0] = 0\n        store[1] = 1\n        store[2] = 1\n        for i in range(n):\n                print(Wedderburn(i), end = \"\")\n                if(i != n - 1):\n                        print(end = \", \")", "35": "def Icosihenagonal_num(n):\n        return (19 * n * n - 17 * n) / 2", "36": "def noOfBinaryStrings(N, k) :\n        dp = [0] * 100002;\n        for i in range(1, K) :\n                dp[i] = 1;\n        dp[k] = 2;\n        for i in range(k + 1, N + 1) :\n                dp[i] = (dp[i - 1] + dp[i - k]) % mod;\n        return dp[N];", "37": "def averageEven(n) :\n        if (n % 2 != 0) :\n                print(\"Invalid Input\")\n                return -1\n        return (n + 2) // 2", "38": "def LowerInsertionPoint(arr, n, X) :\n        if (X < arr[0]) :\n                return 0;\n        elif (X > arr[n - 1]) :\n                return n\n        lowerPnt = 0\n        i = 1\n        while (i < n and arr[i] < X) :\n                lowerPnt = i\n                i = i * 2\n        while (lowerPnt < n and arr[lowerPnt] < X) :\n                lowerPnt += 1\n        return lowerPnt", "39": "def encryptString(string, n):\n        i, cnt = 0, 0\n        encryptedStr = \"\"\n        while i < n:\n                cnt = i + 1\n                while cnt > 0:\n                        encryptedStr += string[i]\n                        cnt -= 1\n                i += 1\n        return encryptedStr", "40": "def countIntersections(n):\n        return n * (n - 1) // 2", "41": "def findElements(arr, n):\n        first = -sys.maxsize\n        second = -sys.maxsize\n        for i in range(0, n):\n                if (arr[i] > first):\n                        second = first\n                        first = arr[i]\n                elif (arr[i] > second):\n                        second = arr[i]\n        for i in range(0, n):\n                if (arr[i] < second):\n                        print(arr[i], end =\" \")", "42": "def check(s, m):\n        l = len(s);\n        c1 = 0;\n        c2 = 0;\n        for i in range(0, l - 1):\n                if (s[i] == '0'):\n                        c2 = 0;\n                        c1 = c1 + 1;\n                else :\n                        c1 = 0;\n                        c2 = c2 + 1;\n                if (c1 == m or c2 == m):\n                        return True;\n        return False;", "43": "def findbitwiseOR(a, n):\n        res = 0\n        for i in range(n):\n                curr_sub_array = a[i]\n                res = res | curr_sub_array\n                for j in range(i, n):\n                        curr_sub_array = curr_sub_array & a[j]\n                        res = res | curr_sub_array\n        print (res)", "44": "def multiplyByMersenne(N, M) :\n        x = int(math.log2(M + 1))\n        return ((N << x) - N)", "45": "def performQuery(arr, Q):\n        for i in range (0, len(Q)):\n                orr = 0\n                x = Q[i][0]\n                arr[x - 1] = Q[i][1]\n                for j in range(0,len(arr)):\n                        orr = orr | arr[j]\n                print(orr ,end= \" \")", "46": "def areaOfSquare(S):\n        area = S * S\n        return area", "47": "def longOddEvenIncSeq( arr , n ):\n        lioes = list()\n        maxLen = 0\n        for i in range(n):\n                lioes.append(1)\n        i=1\n        for i in range(n):\n                for j in range(i):\n                        if (arr[i] > arr[j] and\n                                (arr[i] + arr[j]) % 2 != 0 and lioes[i] < lioes[j] + 1):\n                                        lioes[i] = lioes[j] + 1\n        for i in range(n):\n                if maxLen < lioes[i]:\n                        maxLen = lioes[i]\n        return maxLen", "48": "def counLastDigitK(low, high, k):\n        mlow = 10 * math.ceil(low/10.0)\n        mhigh = 10 * int(high/10.0)\n        count = (mhigh - mlow)/10\n        if (high % 10 >= k):\n                count += 1\n        if (low % 10 <= k and \\\n                (low%10) > 0):\n                count += 1\n        return int(count)", "49": "def findCrossOver(arr, low, high, x) :\n        if (arr[high] <= x) : \n                        return high\n        if (arr[low] > x) : \n                        return low\n        mid = (low + high) // 2 \n        if (arr[mid] <= x and arr[mid + 1] > x) :\n                return mid\n        if(arr[mid] < x) :\n                return findCrossOver(arr, mid + 1, high, x)\n        return findCrossOver(arr, low, mid - 1, x)\ndef printKclosest(arr, x, k, n) :\n        l = findCrossOver(arr, 0, n - 1, x)\n        r = l + 1 \n        count = 0 \n        if (arr[l] == x) :\n                l -= 1\n        while (l >= 0 and r < n and count < k) :\n                if (x - arr[l] < arr[r] - x) :\n                        print(arr[l], end = \" \")\n                        l -= 1\n                else :\n                        print(arr[r], end = \" \")\n                        r += 1\n                count += 1\n        while (count < k and l >= 0) :\n                print(arr[l], end = \" \")\n                l -= 1\n                count += 1\n        while (count < k and r < n) :\n                print(arr[r], end = \" \")\n                r += 1\n                count += 1", "50": "def SieveOfEratosthenes():\n        global isPrime\n        p = 2\n        while p * p <= MAX:\n                if (isPrime[p] == True):\n                        for i in range (p * p, MAX + 1, p):\n                                isPrime[i] = False\n                p += 1\n        for p in range (2, MAX + 1):\n                if (isPrime[p]):\n                        primes.append(p)\ndef prime_search(primes, diff):\n        low = 0\n        high = len(primes) - 1\n        while (low <= high):\n                mid = (low + high) // 2\n                if (primes[mid] == diff):\n                        return primes[mid]\n                elif (primes[mid] < diff):\n                        low = mid + 1\n                else:\n                        res = primes[mid]\n                        high = mid - 1\n        return res\ndef minCost(arr, n):\n        SieveOfEratosthenes()\n        res = 0\n        for i in range (1, n):\n                if (arr[i] < arr[i - 1]):\n                        diff = arr[i - 1] - arr[i]\n                        closest_prime = prime_search(primes, diff)\n                        res += closest_prime\n                        arr[i] += closest_prime\n        return res", "51": "def check(s, n):\n\tst = []\n\tfor i in range(n):\n\t\tif (len(st) != 0 and\n\t\tst[len(st) - 1] == s[i]):\n\t\t\tst.pop();\n\t\telse:\n\t\t\tst.append(s[i]);\n\tif (len(st) == 0):\n\t\treturn True;\n\telse:\n\t\treturn False;", "52": "def isPrime(n):\n\tif n <= 1:\n\t\treturn False\n\tfor i in range(2, n):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\ndef findPrime(n):\n\tnum = n + 1\n\twhile (num):\n\t\tif isPrime(num):\n\t\t\treturn num\n\t\tnum += 1\n\treturn 0\ndef minNumber(arr):\n\ts = 0\n\tfor i in range(0, len(arr)):\n\t\ts += arr[i]\n\tif isPrime(s) :\n\t\treturn 0\n\tnum = findPrime(s)\n\treturn num - s", "53": "def Convert(radian):\n\tpi = 3.14159\n\tdegree = radian * (180/pi)\n\treturn degree", "54": "def longestRodInCuboid(length, breadth, height) :\n\ttemp = length * length + breadth * breadth + height * height\n\tresult = sqrt(temp)\n\treturn result", "55": "def least_prime_factor():\n        for i in range(2, N):\n                if (lpf[i] == 0):\n                        for j in range(i, N, i):\n                                if (lpf[j] == 0):\n                                        lpf[j] = i\ndef Mobius():\n        for i in range(1, N):\n                if (i == 1):\n                        mobius[i] = 1\n                else:\n                        if (lpf[ (i // lpf[i]) ] == lpf[i]):\n                                mobius[i] = 0\n                        else:\n                                mobius[i] = -1 * mobius[i // lpf[i]]\ndef gcd_pairs(a, n):\n        maxi = 0\n        fre = [0 for i in range(N)]\n        for i in range(n):\n                fre[a[i]] += 1\n                maxi = max(a[i], maxi)\n        least_prime_factor()\n        Mobius()\n        ans = 0\n        for i in range(1, maxi + 1):\n                if (mobius[i] == 0):\n                        continue\n                temp = 0\n                for j in range(i, maxi + 1, i):\n                        temp += fre[j]\n                ans += temp * (temp - 1) // 2 * mobius[i]\n        return ans", "56": "def isPrime(n):\n        if (n <= 1):\n                return False;\n        for i in range(2, n):\n                if (n % i == 0):\n                        return False;\n        return True;\ndef countSubsequences(arr, n):\n        totalSubsequence = (int)(pow(2, n) - 1);\n        countPrime = 0;\n        countOnes = 0;\n        for i in range(n):\n                if (arr[i] == 1):\n                        countOnes += 1;\n                elif (isPrime(arr[i])):\n                        countPrime += 1;\n        compositeSubsequence = 0;\n        onesSequence = (int)(pow(2, countOnes) - 1);\n        compositeSubsequence = (totalSubsequence - countPrime - onesSequence - onesSequence * countPrime);\n        return compositeSubsequence;"}, "Java": {"0": "public static int max(int a, int b) {\n        return a if (a > b) else b;\n}\npublic static int cutRod(int price, int n) {\n        if(n <= 0) {\n                return 0;\n        }\n        int max_val = -Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++) {\n                max_val = max(max_val, price[i] +\n                                        cutRod(price, n - i - 1));\n        }\n        return max_val;\n}", "1": "public class checkdigit {\n\t\n\tpublic static int checkdigit(int n, int k) {\n\t\t\n\t\twhile (n > 0) {\n\t\t\t\n\t\t\tint rem = n % 10;\n\t\t\t\n\t\t\tif (rem == k) {\n\t\t\t\t\n\t\t\t\treturn 1;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tn = n / 10;\n\t\t}\n\t\t\n\t\treturn 0;\n\t\t\n\t}\n\t\n\tpublic static int findNthNumber(int n, int k) {\n\t\t\n\t\tint i = k + 1;\n\t\tint count = 1;\n\t\t\n\t\twhile (count < n) {\n\t\t\t\n\t\t\tif (checkdigit(i, k) == 1 || (i % k == 0)) {\n\t\t\t\t\n\t\t\t\tcount += 1;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif (count == n) {\n\t\t\t\t\n\t\t\t\treturn i;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\ti += 1;\n\t\t}\n\t\t\n\t\treturn -1;\n\t\t\n\t}\n\n}", "2": "public static boolean isNumber(String s) {\n        for (int i = 0; i < s.length(); i++) {\n                if (!Character.isDigit(s.charAt(i))) {\n                        return false;\n                }\n        }\n        return true;\n}", "3": "public static int averageEven(int n) {\n        if (n % 2 != 0) {\n                System.out.println(\"Invalid Input\");\n                return -1;\n        }\n        int sm = 0;\n        int count = 0;\n        while (n >= 2) {\n                count = count + 1;\n                sm = sm + n;\n                n = n - 2;\n        }\n        return sm / count;\n}", "4": "public static void sortByRow(int[][] mat, int n, boolean descending) {\n        for (int i = 0; i < n; i++) {\n                if (descending == true) {\n                        Arrays.sort(mat[i], Collections.reverseOrder());\n                }\n                else {\n                        Arrays.sort(mat[i]);\n                }\n        }\n}\npublic static void transpose(int[][] mat, int n) {\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < i + 1; j++) {\n                        int temp = mat[i][j];\n                        mat[i][j] = mat[j][i];\n                        mat[j][i] = temp;\n                }\n        }\n}\npublic static void sortMatRowAndColWise(int[][] mat, int n) {\n        sortByRow(mat, n, true);\n        transpose(mat, n);\n        sortByRow(mat, n, false);\n        transpose(mat, n);\n}\npublic static void printMat(int[][] mat, int n) {\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                        System.out.print(mat[i][j] + \" \");\n                }\n                System.out.println();\n        }\n}", "5": "public static boolean isDNum(int n) {\n        if (n < 4) {\n                return false;\n        }\n        for (int k = 2; k < n; k++) {\n                int numerator = Math.pow(k, n - 2) - k;\n                int hcf = math.gcd(n, k);\n                if (hcf == 1 && (numerator % n) != 0) {\n                        return false;\n                }\n        }\n        return true;\n}", "6": "public static int minOperations(int[] a, int[] b, int n) {\n        int minA = Integer.MAX_VALUE;\n        for (int x : a) {\n                minA = Math.min(minA, x);\n        }\n        for (int x = minA; x >= 0; x--) {\n                boolean check = true;\n                int operations = 0;\n                for (int i = 0; i < n; i++) {\n                        if (x % b[i] == a[i] % b[i]) {\n                                operations += (a[i] - x) / b[i];\n                        } else {\n                                check = false;\n                                break;\n                        }\n                }\n                if (check) {\n                        return operations;\n                }\n        }\n        return -1;\n}", "7": NaN, "8": "static int countSubsequences(int arr[], int N)\n        {\n                int odd = 0;\n                for (int i = 0; i < N; i++) {\n                        if ((arr[i] & 1) % 2 == 1)\n                                odd++;\n                }\n                return (1 << odd) - 1;\n        }", "9": "static long power(int p)\n        {\n                long res = 1;\n                for (int i = 1; i <= p; ++i)\n                {\n                        res *= 2;\n                        res %= mod;\n                }\n                return res % mod;\n        }\nstatic long subset_square_sum(int A[])\n        {\n                int n = A.length;\n                long ans = 0;\n                for (int i : A)\n                {\n                        ans += (1 * i * i) % mod;\n                        ans %= mod;\n                }\n                return (1 * ans * power(n - 1)) % mod;\n        }", "10": "static boolean digitWell(int n, int m, int k)\n{\n        int cnt = 0;\n        while (n > 0)\n        {\n                if (n % 10 == m)\n                        ++cnt;\n                n /= 10;\n        }\n        return cnt == k;\n}\nstatic int findInt(int n, int m, int k)\n{\n        int i = n + 1;\n        while (true)\n        {\n                if (digitWell(i, m, k))\n                        return i;\n                i++;\n        }\n}", "11": "static int gcd(int a, int b)\n        {\n                if (a == 0 || b == 0)\n                        return 0;\n                if (a == b)\n                        return a;\n                if (a > b)\n                        return gcd(a - b, b);\n                return gcd(a, b - a);\n        }\nstatic int cpFact(int x, int y)\n        {\n                while (gcd(x, y) != 1) {\n                        x = x / gcd(x, y);\n                }\n                return x;\n        }", "12": "public class SieveOfAtkin {\n\n    public static void main(String[] args) {\n\n        int limit = 100;\n\n        if (limit > 2)\n            System.out.print(2 + \" \");\n        if (limit > 3)\n            System.out.print(3 + \" \");\n\n        boolean[] sieve = new boolean[limit];\n\n        for (int i = 0; i < limit; i++)\n            sieve[i] = false;\n\n        int x = 1;\n        while (x * x < limit) {\n            int y = 1;\n            while (y * y < limit) {\n                int n = (4 * x * x) + (y * y);\n                if (n <= limit && (n % 12 == 1 || n % 12 == 5))\n                    sieve[n] ^= true;\n\n                n = (3 * x * x) + (y * y);\n                if (n <= limit && n % 12 == 7)\n                    sieve[n] ^= true;\n\n                n = (3 * x * x) - (y * y);\n                if (x > y && n <= limit && n % 12 == 11)\n                    sieve[n] ^= true;\n\n                y += 1;\n            }\n            x += 1;\n        }\n\n        int r = 5;\n        while (r * r < limit) {\n            if (sieve[r]) {\n                for (int i = r * r; i < limit; i += r * r)\n                    sieve[i] = false;\n            }\n\n            r += 1;\n        }\n\n        for (int a = 5; a < limit; a++)\n            if (sieve[a])\n                System.out.print(a + \" \");\n    }\n}", "13": "public static int MaxSubsetlength(String arr[], int A, int B) \n    { \n        int dp[][] = new int[A + 1][B + 1]; \n        for (String str : arr) { \n            int zeros = 0, ones = 0; \n            for (char ch : str.toCharArray()) { \n                if (ch == '0') \n                    zeros++; \n                else\n                    ones++; \n            } \n            for (int i = A; i >= zeros; i--) { \n                for (int j = B; j >= ones; j--) { \n                    dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1); \n                } \n            } \n        } \n        return dp[A][B]; \n    }", "14": "public class Log2 {\n        public static void main(String[] args) {\n                if(x == 0) {\n                        return false;\n                }\n                return (Math.log10(x) /\n                                Math.log10(2));\n        }\n}\npublic class isPowerOfTwo {\n        public static void main(String[] args) {\n                return (Math.ceil(Log2(n)) ==\n                                Math.floor(Log2(n)));\n        }\n}", "15": "public static int productPairs(int[] arr, int n) {\n        int product = 1;\n        for(int i = 0; i < n; i++) {\n                for(int j = 0; j < n; j++) {\n                        product *= (arr[i] % mod * arr[j] % mod) % mod;\n                        product = product % mod;\n                }\n        }\n        return product % mod;\n}", "16": "public class Main {\n    public static int findMaxAverage(int[] arr, int n, int k) {\n        if (k > n) {\n                return -1;\n        }\n        int[] csum = new int[n];\n        csum[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n                csum[i] = csum[i-1] + arr[i];\n        }\n        int max_sum = csum[k-1];\n        int max_end = k-1;\n        for (int i = k; i < n; i++) {\n                int curr_sum = csum[i] - csum[i-k];\n                if (curr_sum > max_sum) {\n                        max_sum = curr_sum;\n                        max_end = i;\n                }\n        }\n        return max_end - k + 1;\n    }\n}", "17": "public class Main { \n   \n    // Function to count subarrays \n    // with sum divisible by k \n    static int countSubarrays(int a[], int n, int k) \n    { \n  \n        // code here \n    } \n  \n    // Driver code \n    public static void main(String[] args) \n    { \n        int a[] = { 2, 7, 6, 1, 4, 5 }, k = 3; \n        int n = a.length; \n  \n        System.out.println(countSubarrays(a, n, k)); \n    } \n}", "18": "public static void Calculate_factorial(){\n        fact[0] = 1;\n        for (int i = 1; i <= mx + 1; i++){\n                fact[i] = i * fact[i - 1];\n                fact[i] %= mod;\n        }\n}\npublic static int UniModal_per(int a, int b){\n        int res = 1;\n        while (b != 0){\n                if (b % 2 != 0){\n                        res = res * a;\n                }\n                res %= mod;\n                a = a * a;\n                a %= mod;\n                b //= 2;\n        }\n        return res;\n}\npublic static int countPermutations(int n){\n        Calculate_factorial();\n        int uni_modal = UniModal_per(2, n - 1);\n        int nonuni_modal = fact[n] - uni_modal;\n        System.out.println(int(uni_modal), \"\",\n                int(nonuni_modal));\n        return;\n}", "19": "static String removeChars(char arr[], int k)\n{\n        int []hash = new int[MAX_CHAR];\n        int n = arr.length;\n        for (int i = 0; i < n; ++i)\n                hash[arr[i] - 'a']++;\n        String ans = \"\";\n        for (int i = 0; i < n; ++i) {\n                if (hash[arr[i] - 'a'] != k) {\n                        ans += arr[i];\n                }\n        }\n        return ans;\n}", "20": "static int enneacontahexagonNum(int n)\n{\n        return (94 * n * n - 92 * n) / 2;\n}", "21": "static void possibleTripletInRange(int L, int R)\n{\n        boolean flag = false;\n        int possibleA = 0,\n                possibleB = 0,\n                possibleC = 0;\n        int numbersInRange = (R - L + 1);\n        if (numbersInRange < 3)\n        {\n                flag = false;\n        }\n        else if (numbersInRange > 3)\n        {\n                flag = true;\n                if (L % 2 > 0)\n                {\n                        L++;\n                }\n                possibleA = L;\n                possibleB = L + 1;\n                possibleC = L + 2;\n        }\n        else\n        {\n                if (!(L % 2 > 0))\n                {\n                        flag = true;\n                        possibleA = L;\n                        possibleB = L + 1;\n                        possibleC = L + 2;\n                }\n                else\n                {\n                        flag = false;\n                }\n        }\n        if (flag == true)\n        {\n                System.out.println(\"(\" + possibleA + \", \" + possibleB + \", \" + possibleC + \")\" + \" is one such possible\" + \" triplet between \" + L + \" and \" + R );\n        }\n        else {\n                System.out.println(\"No Such Triplet\" + \" exists between \" + L + \" and \" + R);\n        }\n}", "22": "static int largest_sum(int arr[], int n)\n        {\n                int maximum = -1;\n                HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n                for (int i = 0; i < n; i++) {\n                        if (m.containsKey(arr[i])){\n                        m.put(arr[i], m.get(arr[i]) + 1);\n                        }\n                        else{\n                                m.put(arr[i], 1);\n                        }\n                }\n                for(int i = 0; i < n; i++){\n                        if (m.get(arr[i]) > 1) {\n                                if (m.containsKey(2*arr[i]))\n                                {\n                                        m.put(2*arr[i],m.get(2 * arr[i])+ m.get(arr[i]) / 2);\n                                }\n                                else\n                                {\n                                        m.put(2*arr[i],m.get(arr[i]) / 2);\n                                }\n                                if (2 * arr[i] > maximum)\n                                        maximum = 2 * arr[i];\n                        }\n                        }\n                return maximum;\n        }", "23": "static void sieveOfEratostheneses()\n{\n        isPrime[1] = true;\n        for (int i = 2; i * i < MAX; i++)\n        {\n                if (!isPrime[i])\n                {\n                        for (int j = 2 * i; j < MAX; j += i)\n                                isPrime[j] = true;\n                }\n        }\n}\nstatic int findPrime(int n)\n{\n        int num = n + 1;\n        while (num > 0)\n        {\n                if (!isPrime[num])\n                        return num;\n                num = num + 1;\n        }\n        return 0;\n}\nstatic int minNumber(int arr[], int n)\n{\n        sieveOfEratostheneses();\n        int sum = 0;\n        for (int i = 0; i < n; i++)\n                sum += arr[i];\n        if (!isPrime[sum])\n                return 0;\n        int num = findPrime(sum);\n        return num - sum;\n}", "24": "static boolean possible(long mid, int[] a)\n{\n        long n = a.length;\n        long total = (n * (n - 1)) / 2;\n        long need = (total + 1) / 2;\n        long count = 0;\n        long start = 0, end = 1;\n        while (end < n)\n        {\n                if (a[(int)end] - a[(int)start] <= mid)\n                {\n                        end++;\n                }\n                else\n                {\n                        count += (end - start - 1);\n                        start++;\n                }\n        }\n        if (end == n && start < end &&\n                a[(int)end - 1] - a[(int)start] <= mid)\n        {\n                long t = end - start - 1;\n                count += (t * (t + 1) / 2);\n        }\n        if (count >= need)\n                return true;\n        else\n                return false;\n}\nstatic long findMedian(int[] a)\n{\n        long n = a.length;\n        long low = 0, high = a[(int)n - 1] - a[0];\n        while (low <= high)\n        {\n                long mid = (low + high) / 2;\n                if (possible(mid, a))\n                        high = mid - 1;\n                else\n                        low = mid + 1;\n        }\n        return high + 1;\n}", "25": "static int MinimizeleftOverSum(int a[], int n)\n{\n        Vector<Integer> v1 = new Vector<Integer>(),\n                                        v2 = new Vector<Integer>();\n        for (int i = 0; i < n; i++)\n        {\n                if (a[i] % 2 == 1)\n                        v1.add(a[i]);\n                else\n                        v2.add(a[i]);\n        }\n        if (v1.size() > v2.size())\n        {\n                Collections.sort(v1);\n                Collections.sort(v2);\n                int x = v1.size() - v2.size() - 1;\n                int sum = 0;\n                int i = 0;\n                while (i < x)\n                {\n                        sum += v1.get(i++);\n                }\n                return sum;\n        }\n        else if (v2.size() > v1.size())\n        {\n                Collections.sort(v1);\n                Collections.sort(v2);\n                int x = v2.size() - v1.size() - 1;\n                int sum = 0;\n                int i = 0;\n                while (i < x)\n                {\n                        sum += v2.get(i++);\n                }\n                return sum;\n        }\n        else\n                return 0;\n}", "26": "static int gcd(int a, int b)\n        {\n                if (b == 0)\n                        return a;\n                return gcd(b, a % b);\n        }\nstatic int MaxGCD(int a[], int n)\n        {\n                int Prefix[] = new int[n + 2];\n                int Suffix[] = new int[n + 2] ;\n                Prefix[1] = a[0];\n                for (int i = 2; i <= n; i += 1)\n                {\n                        Prefix[i] = gcd(Prefix[i - 1], a[i - 1]);\n                }\n                Suffix[n] = a[n - 1];\n                for (int i = n - 1; i >= 1; i -= 1)\n                {\n                        Suffix[i] = gcd(Suffix[i + 1], a[i - 1]);\n                }\n                int ans = Math.max(Suffix[2], Prefix[n - 1]);\n                for (int i = 2; i < n; i += 1)\n                {\n                        ans = Math.max(ans, gcd(Prefix[i - 1], Suffix[i + 1]));\n                }\n                return ans;\n        }", "27": "static int countWays(int N)\n{\n        int E = (N * (N - 1)) / 2;\n        if (N == 1)\n                return 0;\n        return (int)Math.pow(2, E - 1);\n}", "28": "static int power(int X, int Y)\n {\n        int res = 1;\n        X = X % M;\n        if (X == 0)\n        return 0;\n        while (Y > 0)\n        {\n        if ((Y & 1) != 0)\n        {\n                res = (res * X) % M;\n        }\n        Y = Y >> 1;\n        X = (X * X) % M;\n        }\n        return res;\n }\nstatic int findValue(int n)\n {\n        int X = 0;\n        int pow_10 = 1;\n        while (n != 0)\n        {\n        if ((n & 1) != 0)\n        {\n                X += pow_10;\n        }\n        pow_10 *= 10;\n        n /= 2;\n        }\n        X = (X * 2) % M;\n        int res = power(2, X);\n        return res;\n }", "29": "static void printNum(int L, int R)\n{\n        for(int i = L; i <= R; i++)\n        {\n                int temp = i;\n                int c = 10;\n                int flag = 0;\n                while (temp > 0)\n                {\n                        if (temp % 10 >= c)\n                        {\n                                flag = 1;\n                                break;\n                        }\n                        c = temp % 10;\n                        temp /= 10;\n                }\n                if (flag == 0)\n                        System.out.print(i + \" \");\n        }\n}", "30": "static void sub_segments(String str, int n)\n{\n        int l = str.length();\n        for (int x = 0; x < l; x += n)\n        {\n                String newlist = str.substring(x, x + n);\n                List<Character> arr = new ArrayList<Character>();\n                for (char y : newlist.toCharArray())\n                {\n                        if (!arr.contains(y))\n                                arr.add(y);\n                }\n                for (char y : arr)\n                        System.out.print(y);\n                System.out.println();\n        }\n}", "31": "static int cutRod(int price[],int n)\n        {\n                int val[] = new int[n+1];\n                val[0] = 0;\n                for (int i = 1; i<=n; i++)\n                {\n                        int max_val = Integer.MIN_VALUE;\n                        for (int j = 0; j < i; j++)\n                                max_val = Math.max(max_val, price[j] + val[i-j-1]);\n                        val[i] = max_val;\n                }\n                return val[n];\n        }", "32": "public static void find_distinct(int a[], int n, int q, int queries[]) {\n        int check[] = new int[MAX];\n        int idx[] = new int[MAX];\n        int cnt = 1;\n        for (int i = n - 1; i >= 0; i--) {\n                if (check[a[i]] == 0) {\n                        idx[i] = cnt;\n                        check[a[i]] = 1;\n                        cnt += 1;\n                } else {\n                        idx[i] = cnt - 1;\n                }\n        }\n        for (int i = 0; i < q; i++) {\n                int m = queries[i];\n                System.out.print(idx[m] + \" \");\n        }\n}", "33": "public static void possibility(int[] m, int length, char[] s) {\n        int countodd = 0;\n        for (int i = 0; i < length; i++) {\n                if ((m[(int)(s[i])] & 1) == 1) {\n                        countodd++;\n                }\n                if (countodd > 1) {\n                        System.out.println(\"false\");\n                }\n        }\n}\npublic static void largestPalindrome(String s) {\n        int l = s.length();\n        int[] m = new int[256];\n        for (int i = 0; i < l; i++) {\n                m[(int)(s.charAt(i))]++;\n        }\n        possibility(m, l, s.toCharArray());\n        char[] largest = new char[l];\n        int front = 0;\n        for (int i = 9; i > -1; i--) {\n                if ((m[i] & 1) == 1) {\n                        largest[l / 2] = (char)(i + 48);\n                        m[i]--;\n                        while (m[i] > 0) {\n                                largest[front] = (char)(i + 48);\n                                largest[l - front - 1] = (char)(i + 48);\n                                m[i] -= 2;\n                                front++;\n                        }\n                }\n                else {\n                        while (m[i] > 0) {\n                                largest[front] = (char)(i + 48);\n                                largest[l - front - 1] = (char)(i + 48);\n                                m[i] -= 2;\n                                front++;\n                        }\n                }\n        }\n        for (int i = 0; i < l; i++) {\n                System.out.print(largest[i]);\n        }\n}", "34": "public static int Wedderburn(int n) {\n        if (n <= 2) {\n                return store[n];\n        }\n        else if (n % 2 == 0) {\n                int x = n / 2;\n                int ans = 0;\n                for (int i = 1; i < x; i++) {\n                        ans += store[i] * store[n - i];\n                }\n                ans += (store[x] * (store[x] + 1)) / 2;\n                store[n] = ans;\n                return ans;\n        }\n        else {\n                int x = (n + 1) / 2;\n                int ans = 0;\n                for (int i = 1; i < x; i++) {\n                        ans += store[i] * store[n - i];\n                }\n                store[n] = ans;\n                return ans;\n        }\n}\npublic static int Wedderburn_Etherington(int n) {\n        store[0] = 0;\n        store[1] = 1;\n        store[2] = 1;\n        for (int i = 0; i < n; i++) {\n                System.out.print(Wedderburn(i));\n                if (i != n - 1) {\n                        System.out.print(\", \");\n                }\n        }\n}", "35": "public class Icosahedral {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(Icosihenagonal_num(i));\n        }\n    }\n}", "36": "public static int noOfBinaryStrings(int N, int k)\n{\n        int dp[] = new int[100002];\n        for(int i = 1; i < K; i++)\n        {\n                dp[i] = 1;\n        }\n        dp[k] = 2;\n        for(int i = k + 1; i < N + 1; i++)\n        {\n                dp[i] = (dp[i - 1] + dp[i - k]) % mod;\n        }\n        return dp[N];\n}", "37": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(averageEven(4));\n    }\n\n    public static int averageEven(int n) {\n        if (n % 2 != 0) {\n            System.out.println(\"Invalid Input\");\n            return -1;\n        }\n        return (n + 2) / 2;\n    }\n}", "38": "public static int LowerInsertionPoint(int[] arr, int n, int X) {\n        if (X < arr[0]) {\n                return 0;\n        } else if (X > arr[n - 1]) {\n                return n\n        }\n        int lowerPnt = 0\n        int i = 1\n        while (i < n && arr[i] < X) {\n                lowerPnt = i\n                i = i * 2\n        }\n        while (lowerPnt < n && arr[lowerPnt] < X) {\n                lowerPnt += 1\n        }\n        return lowerPnt;\n}", "39": "public class EncryptString {\n    public static void main(String[] args) {\n        String encryptString = \"\";\n        String string = \"Test\";\n        int n = 3;\n        for (int i = 0; i < n; i++) {\n            for (int cnt = i + 1; cnt > 0; cnt--) {\n                encryptString += string.charAt(i);\n            }\n        }\n        System.out.println(encryptString);\n    }\n}", "40": "public class CountIntersections {\n    public static int countIntersections(int n) {\n        return n * (n - 1) / 2;\n    }\n}", "41": "public static void findElements(int[] arr, int n) {\n        int first = -sys.maxsize;\n        int second = -sys.maxsize;\n        for (int i = 0; i < n; i++) {\n                if (arr[i] > first) {\n                        second = first;\n                        first = arr[i];\n                }\n                else if (arr[i] > second) {\n                        second = arr[i];\n                }\n        }\n        for (int i = 0; i < n; i++) {\n                if (arr[i] < second) {\n                        System.out.print(arr[i] + \" \");\n                }\n        }\n}", "42": "class Check {\n\tpublic static void main(String[] args) {\n\t\tString str1 = \"001110\";\n\t\tint m1 = 3;\n\t\tSystem.out.println(check(str1, m1));\n\n\t\tString str2 = \"10101\";\n\t\tint m2 = 4;\n\t\tSystem.out.println(check(str2, m2));\n\t}\n\n\tpublic static boolean check(String s, int m) {\n\t\tint l = s.length();\n\t\tint c1 = 0;\n\t\tint c2 = 0;\n\t\tfor (int i = 0; i < l - 1; i++) {\n\t\t\tif (s.charAt(i) == '0') {\n\t\t\t\tc2 = 0;\n\t\t\t\tc1 = c1 + 1;\n\t\t\t} else {\n\t\t\t\tc1 = 0;\n\t\t\t\tc2 = c2 + 1;\n\t\t\t}\n\t\t\tif (c1 == m || c2 == m) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}", "43": "public class TestClass { \n        public static void findbitwiseOR(int a, int n) {\n                int res = 0;\n                for (int i = 0; i < n; i++) {\n                        int curr_sub_array = a[i];\n                        res = res | curr_sub_array;\n                        for (int j = i; j < n; j++) {\n                                curr_sub_array = curr_sub_array & a[j];\n                                res = res | curr_sub_array;\n                        }\n                }\n                System.out.println(res);\n        }\n}", "44": "public class multiplyByMersenne {\n\t\n\tpublic static int multiplyByMersenne(int N, int M) {\n\t\tint x = (int) (Math.log(M + 1) / Math.log(2));\n\t\treturn ((N << x) - N);\n\t}\n\n}", "45": "public static int performQuery(int arr[], \n                                 int Q[][], int m) \n    { \n        int orr = 0; \n        for (int i = 0; i < m; i++) { \n            int x = Q[i][0]; \n            arr[x - 1] = Q[i][1]; \n            for (int j = 0; j < arr.length; j++) { \n                orr = orr | arr[j]; \n            } \n            System.out.print(orr + \" \"); \n        } \n        return orr; \n    } ", "46": "public static int areaOfSquare(int S) {\n        int area = S * S;\n        return area;\n}", "47": "public static int longOddEvenIncSeq(int arr[] , int n) {\n    int lioes[] = new int[n];\n    int maxLen = 0;\n    for (int i = 0; i < n; i++) {\n        lioes[i] = 1;\n    }\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if ((arr[i] > arr[j]) &&\n                ((arr[i] + arr[j]) % 2 != 0) && (lioes[i] < lioes[j] + 1)) {\n                lioes[i] = lioes[j] + 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (maxLen < lioes[i]) {\n            maxLen = lioes[i];\n        }\n    }\n    return maxLen;\n}", "48": "public static int countLastDigitK(int low, int high, int k) {\n        int mlow = 10 * ((int)Math.ceil(low/10.0));\n        int mhigh = 10 * ((int)(high/10.0));\n        int count = (mhigh - mlow)/10;\n        if ((high % 10 >= k)) {\n                count += 1;\n        }\n        if ((low % 10 <= k) && (low%10) > 0) {\n                count += 1;\n        }\n        return count;\n}", "49": "int findCrossOver(int arr[], int low, int high, int x)\n        {\nif (arr[high] <= x) \n                        return high;\nif (arr[low] > x) \n                        return low;\n                int mid = (low + high)/2; \n                if (arr[mid] <= x && arr[mid+1] > x)\n                        return mid;\n                if(arr[mid] < x)\n                        return findCrossOver(arr, mid+1, high, x);\n                return findCrossOver(arr, low, mid - 1, x);\n        }\nvoid printKclosest(int arr[], int x, int k, int n)\n        {\n                int l = findCrossOver(arr, 0, n-1, x);\nint r = l+1; \nint count = 0; \n                if (arr[l] == x) l--;\n                while (l >= 0 && r < n && count < k)\n                {\n                        if (x - arr[l] < arr[r] - x)\n                                System.out.print(arr[l--]+\" \");\n                        else\n                                System.out.print(arr[r++]+\" \");\n                        count++;\n                }\n                while (count < k && l >= 0)\n                {\n                        System.out.print(arr[l--]+\" \");\n                        count++;\n                }\n                while (count < k && r < n)\n                {\n                        System.out.print(arr[r++]+\" \");\n                        count++;\n                }\n        }", "50": "public static void SieveOfEratosthenes() {\n        p = 2;\n        while (p * p <= MAX) {\n                if (isPrime[p] == true) {\n                        for (int i = p * p; i <= MAX; i += p) {\n                                isPrime[i] = false;\n                        }\n                }\n                p++;\n        }\n        for (p = 2; p <= MAX; p++) {\n                if (isPrime[p]) {\n                        primes.add(p);\n                }\n        }\n}\npublic static int prime_search(ArrayList<Integer> primes, int diff) {\n        int low = 0;\n        int high = primes.size() - 1;\n        while (low <= high) {\n                int mid = (low + high) / 2;\n                if (primes.get(mid) == diff) {\n                        return primes.get(mid);\n                } else if (primes.get(mid) < diff) {\n                        low = mid + 1;\n                } else {\n                        res = primes.get(mid);\n                        high = mid - 1;\n                }\n        }\n        return res;\n}\npublic static int minCost(int[] arr, int n) {\n        SieveOfEratosthenes();\n        int res = 0;\n        for (int i = 1; i < n; i++) {\n                if (arr[i] < arr[i - 1]) {\n                        int diff = arr[i - 1] - arr[i];\n                        int closest_prime = prime_search(primes, diff);\n                        res += closest_prime;\n                        arr[i] += closest_prime;\n                }\n        }\n        return res;\n}", "51": "static boolean check(String s, int n)\n{\n        Stack<Character> st = new Stack<Character>();\n        for(int i = 0; i < n; i++)\n        {\n        if (!st.isEmpty() &&\n                        st.peek() == s.charAt(i))\n                st.pop();\n        else\n                st.add(s.charAt(i));\n        }\n        if (st.isEmpty())\n        {\n                return true;\n        }\n        else\n        {\n                return false;\n        }\n}", "52": "static boolean isPrime(int n)\n                {\n                        if (n <= 1)\n                                return false;\n                        for (int i = 2; i < n; i++)\n                                if (n % i == 0)\n                                        return false;\n                        return true;\n                }\nstatic int findPrime(int n)\n                {\n                        int num = n + 1;\n                        while (num > 0)\n                                {\n                                        if (isPrime(num))\n                                                return num;\n                                        num = num + 1;\n                                }\n                        return 0;\n                }\nstatic int minNumber(int arr[], int n)\n                {\n                        int sum = 0;\n                        for (int i = 0; i < n; i++)\n                                sum += arr[i];\n                        if (isPrime(sum))\n                                return 0;\n                        int num = findPrime(sum);\n                        return num - sum;\n                }", "53": "static double Convert(double radian){\n                double pi = 3.14159;\n                return(radian * (180/pi));\n        }", "54": "static double longestRodInCuboid(int length, int breadth, int height)\n{\n        double result;\n        int temp;\n        temp = length * length + breadth *\n                breadth + height * height;\n        result = Math.sqrt(temp);\n        return result;\n}", "55": "public class Main { \n\t\n\t// Function to find the mobius function \n\t// for the given range \n\tstatic void mobius(int N) \n\t{ \n\t\tint mob[] = new int[N + 1]; \n\n\t\tArrays.fill(mob, 1); \n\n\t\t// In mobius function, we only consider \n\t\t// the primes \n\t\tfor (int i = 2; (i * i) <= N; i++) { \n\t\t\tif (mob[i] == 1) { \n\t\t\t\tfor (int j = i; (j * i) <= N; j++) { \n\t\t\t\t\tmob[i * j] = 0; \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\n\t\t// If a number is square of a prime, \n\t\t// then mobius function is 0. \n\t\tfor (int i = 2; (i * i) <= N; i++) { \n\t\t\tif (mob[i] == 1) { \n\t\t\t\tfor (int j = (i * i); j <= N; j += (i * i)) { \n\t\t\t\t\tmob[j] = 0; \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\n\t\t// We consider only those numbers \n\t\t// which are relatively prime to \n\t\t// their corresponding index. \n\t\tmob[0] = mob[1] = 0; \n\n\t\t// Finally print all mobius function \n\t\t// values from 0 to N \n\t\tfor (int i = 0; i <= N; i++) { \n\t\t\tif (mob[i] == 1) { \n\t\t\t\tSystem.out.print(i + \" \"); \n\t\t\t} \n\t\t} \n\t} \n\n\t// Driver code \n\tpublic static void main(String args[]) \n\t{ \n\t\tint N = 10; \n\t\tmobius(N); \n\t} \n} ", "56": "public class Question {\n\t\n\tpublic static boolean isPrime(int n) {\n\t\tif (n <= 1) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i = 2; i < n; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static int countSubsequences(int[] arr, int n) {\n\t\tint totalSubsequence = (int) Math.pow(2, n) - 1;\n\t\tint countPrime = 0;\n\t\tint countOnes = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i] == 1) {\n\t\t\t\tcountOnes += 1;\n\t\t\t} else if (isPrime(arr[i])) {\n\t\t\t\tcountPrime += 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint compositeSubsequence = 0;\n\t\tint onesSequence = (int) Math.pow(2, countOnes) - 1;\n\t\tcompositeSubsequence = (totalSubsequence - countPrime - onesSequence - onesSequence * countPrime);\n\t\t\n\t\treturn compositeSubsequence;\n\t}\n\n}"}}, "Python -  C": {"Id": {"0": 9290, "1": 2114, "2": 8795, "3": 12646, "4": 1998, "5": 14021, "6": 1694, "7": 2120, "8": 2308, "9": 14022, "10": 1696, "11": 7071, "12": 7051, "13": 1535, "14": 2026, "15": 2079, "16": 12639, "17": 13575, "18": 9457, "19": 2127, "20": 14023, "21": 13140, "22": 13430, "23": 4855, "24": 2132, "25": 7068, "26": 12716, "27": 12794, "28": 2130}, "Python": {"0": "def Perimeter(s, n):\n        perimeter = 1\n        perimeter = n * s\n        return perimeter", "1": "def countSetBits(n):\n        count = 0\n        while (n):\n                count += n & 1\n                n >>= 1\n        return count", "2": "def reverse(string):\n        if len(string) == 0:\n                return\n        temp = string[0]\n        reverse(string[1:])\n        print(temp, end='')", "3": "def averageOdd(n) :\n        if (n % 2 == 0) :\n                print(\"Invalid Input\")\n                return -1\n        return (n + 1) // 2", "4": "def multiply(x,y):\n        if(y == 0):\n                return 0\n        if(y > 0 ):\n                return (x + multiply(x, y - 1))\n        if(y < 0 ):\n                return -multiply(x, -y)", "5": "def multiplyBySevenByEight(n):\n        return ((n << 3) -n) >> 3;", "6": "def isMajority(arr, n, x):\n        last_index = (n//2 + 1) if n % 2 == 0 else (n//2)\n        for i in range(last_index):\n                if arr[i] == x and arr[i + n//2] == x:\n                        return 1", "7": "def countSetBitsRec(num):\n        nibble = 0;\n        if(0 == num):\n                return num_to_bits[0];\n        nibble = num & 0xf;\n        return num_to_bits[nibble] + countSetBitsRec(num >> 4);", "8": "def printTwoOdd(arr, size):\n        xor2 = arr[0]\n        set_bit_no = 0 \n        n = size - 2\n        x, y = 0, 0\n        for i in range(1, size):\n                xor2 = xor2 ^ arr[i]\n        set_bit_no = xor2 & ~(xor2 - 1)\n        for i in range(size):\n                if(arr[i] & set_bit_no):\n                        x = x ^ arr[i]\n                else:\n                        y = y ^ arr[i]\n        print(\"The two ODD elements are\", x, \"&\", y)", "9": "def subtract(x, y):\n        while (y != 0):\n                borrow = (~x) & y\n                x = x ^ y\n                y = borrow << 1\n        return x", "10": "def isMajorityElement(arr, n, key):\n if (arr[n // 2] == key):\n                return True\n return False", "11": "def count(S, m, n ):\n        if (n == 0):\n                return 1\n        if (n < 0):\n                return 0;\n        if (m <=0 and n >= 1):\n                return 0\n        return count( S, m - 1, n ) + count( S, m, n-S[m-1] );", "12": "def cutRod(price, n):\n        val = [0 for x in range(n+1)]\n        val[0] = 0\n        for i in range(1, n+1):\n                max_val = INT_MIN\n                for j in range(i):\n                        max_val = max(max_val, price[j] + val[i-j-1])\n                val[i] = max_val\n        return val[n]", "13": "def findFirstMissing(array, start, end):\n        if (start > end):\n                return end + 1\n        if (start != array[start]):\n                return start;\n        mid = int((start + end) / 2)\n        if (array[mid] == mid):\n                return findFirstMissing(array, mid+1, end)\n        return findFirstMissing(array, start, mid)", "14": "def printPascal(n):\n        for line in range(1, n + 1):\n                C = 1; \n                for i in range(1, line + 1):\n                        print(C, end = \" \");\n                        C = int(C * (line - i) / i);\n                print(\"\");", "15": "def Add(x, y):\n        while (y != 0):\n                carry = x & y\n                x = x ^ y\n                y = carry << 1\n        return x", "16": "def averageEven(n) :\n        if (n % 2 != 0) :\n                print(\"Invalid Input\")\n                return -1\n        return (n + 2) // 2", "17": "def reversDigits(num):\n        global rev_num\n        global base_pos\n        if(num > 0):\n                reversDigits((int)(num / 10))\n                rev_num += (num % 10) * base_pos\n                base_pos *= 10\n        return rev_num", "18": "def Area(b1, b2, h):\n        return ((b1 + b2) / 2) * h", "19": "def getParity( n ):\n        parity = 0\n        while n:\n                parity = ~parity\n                n = n & (n - 1)\n        return parity", "20": "def subtract(x, y):\n        if (y == 0):\n                return x\n        return subtract(x ^ y, (~x & y) << 1)", "21": "def fact(n):\n        if (n == 0):\n                return 1\n        return n * fact(n - 1)\ndef div(x):\n        ans = 0;\n        for i in range(1, x + 1):\n                if (x % i == 0):\n                        ans += i\n        return ans\ndef sumFactDiv(n):\n        return div(fact(n))", "22": "def printDivisors (n):\n        i = 1\n        while (i * i < n):\n                if (n % i == 0):\n                        print(i, end = \" \")\n                i += 1\n        for i in range(int(sqrt(n)), 0, -1):\n                if (n % i == 0):\n                        print(n // i, end = \" \")", "23": "def insertionSort(arr):\n        for i in range(1, len(arr)):\n                key = arr[i]\n                j = i-1\n                while j >= 0 and key < arr[j] :\n                                arr[j + 1] = arr[j]\n                                j -= 1\n                arr[j + 1] = key", "24": "def isPowerOfTwo (x):\n        return (x and (not(x & (x - 1))) )", "25": "def MatrixChainOrder(p, i, j):\n        if i == j:\n                return 0\n        _min = sys.maxsize\n        for k in range(i, j):\n                count = (MatrixChainOrder(p, i, k)\n                                + MatrixChainOrder(p, k + 1, j) + p[i-1] * p[k] * p[j])\n                if count < _min:\n                        _min = count\n        return _min", "26": "def Series(n):\n        sums = 0\n        for i in range(1, n + 1):\n                sums += (i * i);\n        return sums", "27": "def Convert(radian):\n        pi = 3.14159\n        degree = radian * (180/pi)\n        return degree", "28": "def isPowerOfTwo(n):\n        if (n == 0):\n                return False\n        while (n != 1):\n                        if (n % 2 != 0):\n                                return False\n                        n = n // 2\n        return True"}, "C": {"0": "int Perimeter(int s, int n) {\n        int perimeter = 1;\n        perimeter = n * s;\n        return perimeter;\n}", "1": "int countSetBits(int n)\n{\n   int count = 0;\n   while(n)\n   {\n      count += n & 1;\n      n >>= 1;\n   }\n   return count;\n}", "2": "void reverse(char *string)\n{\n        if (strlen(string) == 0)\n                return;\n        char temp = string[0];\n        reverse(string + 1);\n        printf(\"%c\", temp);\n}", "3": "int averageOdd(int n) {\n        if (n % 2 == 0) {\n                printf(\"Invalid Input\");\n                return -1;\n        }\n        return (n + 1) / 2;\n}", "4": "int multiply(int x, int y) {\n        if (y == 0) {\n                return 0;\n        }\n        if (y > 0) {\n                return (x + multiply(x, y - 1));\n        }\n        if (y < 0) {\n                return -multiply(x, -y);\n        }\n}", "5": "int multiplyBySevenByEight(int n)\n{\n        return ((n << 3) -n) >> 3;\n}", "6": "int isMajority(int* arr, int n, int x) {\n        int last_index = (n//2 + 1) if n % 2 == 0 else (n//2);\n        for (int i = 0; i < last_index; i++) {\n                if (arr[i] == x && arr[i + n//2] == x) {\n                        return 1;\n                }\n        }\n}", "7": "int countSetBitsRec(int num) {\n        int nibble = 0;\n        if(0 == num)\n                return num_to_bits[0];\n        nibble = num & 0xf;\n        return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}", "8": "int printTwoOdd(int arr[], int size){\n        int xor2 = arr[0];\n        int set_bit_no = 0; \n        int n = size - 2;\n        int x = 0, y = 0;\n        for(int i = 1; i < size; i++){\n                xor2 = xor2 ^ arr[i];\n        }\n        set_bit_no = xor2 & ~(xor2 - 1);\n        for(int i = 0; i < size; i++){\n                if((arr[i] & set_bit_no) > 0){\n                        x = x ^ arr[i];\n                }\n                else{\n                        y = y ^ arr[i];\n                }\n        }\n        printf(\"The two ODD elements are %d & %d\", x, y);\n}", "9": "int subtract(int x, int y){\n        while (y != 0){\n                borrow = (~x) & y;\n                x = x ^ y;\n                y = borrow << 1;\n        }\n        return x;\n}", "10": "bool isMajorityElement(int arr[], int n, int key)\n{\n     if (arr[n/2] == key)\n          return true;\n     return false;\n}", "11": "int count(int S[], int m, int n )\n{\n    if (n == 0)\n        return 1;\n    if (n < 0)\n        return 0;\n    if (m <=0 && n >= 1)\n        return 0;\n    return count( S, m - 1, n ) + count( S, m, n-S[m-1] );\n}", "12": "int cutRod(int price[], int n) \n{ \nint val[n+1]; \nval[0] = 0; \nint i, j; \n\n// Build the table val[] in bottom up manner and return the last entry \n// from the table \nfor (i = 1; i<=n; i++) \n{ \nint max_val = INT_MIN; \nfor (j = 0; j < i; j++) \nmax_val = max(max_val, \nprice[j] + val[i-j-1]); \nval[i] = max_val; \n} \n\nreturn val[n]; \n}", "13": "int findFirstMissing(int array[], int start, int end) {\n        if (start > end) {\n                return end + 1;\n        }\n        if (start != array[start]) {\n                return start;\n        }\n        int mid = (start + end) / 2;\n        if (array[mid] == mid) {\n                return findFirstMissing(array, mid+1, end);\n        }\n        return findFirstMissing(array, start, mid);\n}", "14": "void printPascal(int n)\n{\n        for (int line = 1; line <= n; line++)\n        {\n                int C = 1;\n                for (int i = 1; i <= line; i++)\n                {\n                        printf(\"%d \", C);\n                        C = C * (line - i) / i;\n                }\n                printf(\"\\n\");\n        }\n}", "15": "int Add(int x, int y)\n{\n        while (y != 0)\n        {\n                carry = x & y;\n                x = x ^ y;\n                y = carry << 1;\n        }\n        return x;\n}", "16": "int averageEven(int n) {\n        if (n % 2 != 0) {\n                printf(\"Invalid Input\");\n                return -1;\n        }\n        return (n + 2) / 2;\n}", "17": "int reversDigits(int num)\n{\n        if(num > 0)\n        {\n                reversDigits((int)(num / 10));\n                rev_num += (num % 10) * base_pos;\n                base_pos *= 10;\n        }\n        return rev_num;\n}", "18": "int Area(int b1, int b2, int h)\n{\n    return ((b1 + b2) / 2) * h;\n}", "19": "int getParity(int n) {\n    int parity = 0;\n    while (n) {\n        parity = ~parity;\n        n = n & (n - 1);\n    }\n    return parity;\n}", "20": "int subtract(int x, int y)\n{\n        if (y == 0)\n                return x;\n        return subtract(x ^ y, (~x & y) << 1);\n}", "21": "int fact(int n) {\n        if (n == 0) {\n                return 1;\n        }\n        return n * fact(n - 1);\n}\nint div(int x) {\n        ans = 0;\n        for (i = 1; i <= x; i++) {\n                if (x % i == 0) {\n                        ans += i;\n                }\n        }\n        return ans;\n}\nint sumFactDiv(int n) {\n        return div(fact(n));\n}", "22": "void printDivisors (int n)\n        int i = 1;\n        while (i * i < n) {\n                if (n % i == 0) {\n                        printf(i, \" \");\n                }\n                i += 1;\n        }\n        for (int i = int(sqrt(n)), 0, -1) {\n                if (n % i == 0) {\n                        printf(n / i, \" \");\n                }\n        }\n}", "23": "void insertionSort(int arr[], int n)\n{\n   int i, key, j;\n   for (i = 1; i < n; i++)\n   {\n       key = arr[i];\n       j = i-1;\n \n       while (j >= 0 && arr[j] > key)\n       {\n           arr[j+1] = arr[j];\n           j = j-1;\n       }\n       arr[j+1] = key;\n   }\n}", "24": "bool isPowerOfTwo(unsigned int x)  \n{  \n    return x && (!(x & (x - 1)));  \n}", "25": "int MatrixChainOrder(int p[], int i, int j) \n{ \n    if (i == j) \n        return 0; \n  \n    int _min = INT_MAX; \n  \n    for (int k = i; k < j; k++) \n    { \n        int count = (MatrixChainOrder(p, i, k) \n                          + MatrixChainOrder(p, k + 1, j) \n                          + p[i - 1] * p[k] * p[j]); \n  \n        if (count < _min) \n            _min = count; \n    } \n  \n    return _min; \n}", "26": "int Series(int n) {\n        int sums = 0;\n        for (int i = 1; i <= n; i++) {\n                sums += (i * i);\n        }\n        return sums;\n}", "27": "double Convert(double radian) {\n        double pi = 3.14159;\n        double degree = radian * (180/pi);\n        return degree;\n}", "28": "bool isPowerOfTwo(int n){\n        if(n==0){\n                return false;\n        }\n        while(n!=1){\n                if(n%2!=0){\n                        return false;\n                }\n                n=n/2;\n        }\n        return true;\n}"}}}