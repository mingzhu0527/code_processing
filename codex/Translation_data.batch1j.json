{"Java-Python": {"ID": {"0": 451, "1": 455, "2": 496, "3": 617, "4": 647, "5": 649, "6": 803, "7": 815, "8": 818, "9": 821, "10": 832, "11": 833, "12": 846, "13": 861, "14": 862, "15": 883, "16": 895, "17": 918, "18": 919, "19": 920, "20": 926, "21": 927, "22": 953, "23": 955, "24": 956, "25": 958, "26": 959, "27": 965, "28": 966, "29": 1045, "30": 1064, "31": 1065, "32": 1072, "33": 1073, "34": 1074, "35": 1075, "36": 1132, "37": 1252, "38": 1253, "39": 1344, "40": 1345, "41": 1346, "42": 1366, "43": 1390, "44": 1405, "45": 1406, "46": 1428, "47": 1468, "48": 1469, "49": 1473, "50": 1478, "51": 1480, "52": 1481, "53": 1515, "54": 1516, "55": 1517, "56": 1535, "57": 1536, "58": 1537, "59": 1545, "60": 1546, "61": 1590, "62": 1591, "63": 1694, "64": 1695, "65": 1696, "66": 1730, "67": 1795, "68": 1797, "69": 1813, "70": 1822, "71": 1849, "72": 1852, "73": 1853, "74": 1869, "75": 1870, "76": 1998, "77": 2013, "78": 2024, "79": 2025, "80": 2026, "81": 2079, "82": 2080, "83": 2101, "84": 2114, "85": 2117, "86": 2118, "87": 2119, "88": 2120, "89": 2121, "90": 2127, "91": 2129, "92": 2130, "93": 2131, "94": 2132, "95": 2210, "96": 2226, "97": 2243, "98": 2258, "99": 2259, "100": 2281, "101": 2308, "102": 2310, "103": 2360, "104": 2372, "105": 2379, "106": 2382, "107": 2437, "108": 2438, "109": 2464, "110": 2501, "111": 2502, "112": 2518, "113": 2575, "114": 2578, "115": 2579, "116": 2583, "117": 2615, "118": 2616, "119": 2623, "120": 2673, "121": 2675, "122": 2696, "123": 2697, "124": 2740, "125": 2753, "126": 2773, "127": 2783, "128": 2802, "129": 2804, "130": 2809, "131": 2816, "132": 2818, "133": 2827, "134": 2831, "135": 2832, "136": 2847, "137": 2883, "138": 2892, "139": 2923, "140": 2924, "141": 2940, "142": 2950, "143": 2983, "144": 3003, "145": 3010, "146": 3053, "147": 3096, "148": 3120, "149": 3121, "150": 3128, "151": 3129, "152": 3135, "153": 3138, "154": 3142, "155": 3163, "156": 3176, "157": 3179, "158": 3183, "159": 3198, "160": 3199, "161": 3229, "162": 3234, "163": 3235, "164": 3253, "165": 3270, "166": 3311, "167": 3332, "168": 3337, "169": 3345, "170": 3346, "171": 3374, "172": 3375, "173": 3398, "174": 3417, "175": 3427, "176": 3463, "177": 3464, "178": 3468, "179": 3471, "180": 3487, "181": 3488, "182": 3495, "183": 3516, "184": 3520, "185": 3531, "186": 3540, "187": 3550, "188": 3555, "189": 3562, "190": 3564, "191": 3567, "192": 3584, "193": 3601, "194": 3605, "195": 3629, "196": 3644, "197": 3664, "198": 3678, "199": 3692, "200": 3704, "201": 3742, "202": 3743, "203": 3752, "204": 3755, "205": 3765, "206": 3773, "207": 3798, "208": 3814, "209": 3822, "210": 3825, "211": 3829, "212": 3871, "213": 3885, "214": 3932, "215": 3967, "216": 4039, "217": 4048, "218": 4052, "219": 4079, "220": 4080, "221": 4081, "222": 4099, "223": 4129, "224": 4155, "225": 4169, "226": 4179, "227": 4185, "228": 4186, "229": 4194, "230": 4197, "231": 4209, "232": 4210, "233": 4219, "234": 4220, "235": 4237, "236": 4238, "237": 4249, "238": 4250, "239": 4256, "240": 4305, "241": 4307, "242": 4310, "243": 4326, "244": 4347, "245": 4354, "246": 4357, "247": 4360, "248": 4362, "249": 4369, "250": 4371, "251": 4378, "252": 4385, "253": 4386, "254": 4392, "255": 4400}, "Java": {"0": "static int minCost(int cost[][])\n        {\n                int dist[] = new int[N];\n                for (int i=0; i<N; i++)\n                dist[i] = INF;\n                dist[0] = 0;\n                for (int i=0; i<N; i++)\n                for (int j=i+1; j<N; j++)\n                        if (dist[j] > dist[i] + cost[i][j])\n                                dist[j] = dist[i] + cost[i][j];\n                return dist[N-1];\n        }", "1": "static int numOfways(int n, int k)\n\t{\n\t\tint p = 1;\n\t\tif (k % 2 != 0)\n\t\t\tp = -1;\n\t\treturn (int)(Math.pow(n - 1, k)\n\t\t\t\t\t+ p * (n - 1)) / n;\n\t}", "2": "static int fib(int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn n;\n\t\treturn fib(n - 1) + fib(n - 2);\n\t}\nstatic int findVertices (int n)\n\t{\n\t\treturn fib(n + 2);\n\t}", "3": "static Node reverse( Node head_ref)\n{\n\tNode temp = null;\n\tNode current = head_ref;\n\twhile (current != null)\n\t{\n\t\ttemp = current.prev;\n\t\tcurrent.prev = current.next;\n\t\tcurrent.next = temp;\n\t\tcurrent = current.prev;\n\t}\n\tif (temp != null)\n\t\thead_ref = temp.prev;\n\t\treturn head_ref;\n}\nstatic Node merge(Node first, Node second)\n{\n\tif (first == null)\n\t\treturn second;\n\tif (second == null)\n\t\treturn first;\n\tif (first.data < second.data)\n\t{\n\t\tfirst.next = merge(first.next, second);\n\t\tfirst.next.prev = first;\n\t\tfirst.prev = null;\n\t\treturn first;\n\t}\n\telse\n\t{\n\t\tsecond.next = merge(first, second.next);\n\t\tsecond.next.prev = second;\n\t\tsecond.prev = null;\n\t\treturn second;\n\t}\n}\nstatic Node sort(Node head)\n{\n\tif (head == null head.next == null)\n\t\treturn head;\n\tNode current = head.next;\n\twhile (current != null)\n\t{\n\t\tif (current.data < current.prev.data)\n\t\t\tbreak;\n\t\tcurrent = current.next;\n\t}\n\tif (current == null)\n\t\treturn head;\n\tcurrent.prev.next = null;\n\tcurrent.prev = null;\n\tcurrent = reverse(current);\n\treturn merge(head, current);\n}\nstatic Node push( Node head_ref, int new_data)\n{\n\tNode new_node = new Node();\n\tnew_node.data = new_data;\n\tnew_node.prev = null;\n\tnew_node.next = (head_ref);\n\tif ((head_ref) != null)\n\t\t(head_ref).prev = new_node;\n\t(head_ref) = new_node;\n\treturn head_ref;\n}\nstatic void printList( Node head)\n{\n\tif (head == null)\n\t\tSystem.out.println(\"Doubly Linked list empty\");\n\twhile (head != null)\n\t{\n\t\tSystem.out.print(head.data + \" \");\n\t\thead = head.next;\n\t}\n}", "4": "static Node newNode(char key)\n{\n\tNode temp = new Node();\n\ttemp.data = key;\n\ttemp.next = null;\n\treturn temp;\n}\nstatic void printlist(Node head)\n{\n\tif (head == null)\n\t{\n\t\tSystem.out.println(\"Empty List\");\n\t\treturn;\n\t}\n\twhile (head != null)\n\t{\n\t\tSystem.out.print(head.data +\" \");\n\t\tif (head.next != null)\n\t\tSystem.out.print(\"-> \");\n\t\thead = head.next;\n\t}\n\tSystem.out.println();\n}\nstatic boolean isVowel(char x)\n{\n\treturn (x == 'a' x == 'e' x == 'i' x == 'o' x == 'u');\n}\nstatic Node arrange(Node head)\n{\n\tNode newHead = head;\n\tNode latestVowel;\n\tNode curr = head;\n\tif (head == null)\n\t\treturn null;\n\tif (isVowel(head.data) == true)\n\t\tlatestVowel = head;\n\telse\n\t{\n\t\twhile (curr.next != null &&\n\t\t\t!isVowel(curr.next.data))\n\t\t\tcurr = curr.next;\n\t\tif (curr.next == null)\n\t\t\treturn head;\n\t\tlatestVowel = newHead = curr.next;\n\t\tcurr.next = curr.next.next;\n\t\tlatestVowel.next = head;\n\t}\n\twhile (curr != null && curr.next != null)\n\t{\n\t\tif (isVowel(curr.next.data) == true)\n\t\t{\n\t\t\tif (curr == latestVowel)\n\t\t\t{\n\t\t\t\tlatestVowel = curr = curr.next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNode temp = latestVowel.next;\n\t\t\t\tlatestVowel.next = curr.next;\n\t\t\t\tlatestVowel = latestVowel.next;\n\t\t\t\tcurr.next = curr.next.next;\n\t\t\t\tlatestVowel.next = temp;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurr = curr.next;\n\t\t}\n\t}\n\treturn newHead;\n}", "5": "static Node newNode(int data)\n{\n\tNode temp = new Node();\n\ttemp.data = data;\n\ttemp.right = null;\n\ttemp.left = null;\n\treturn temp;\n}\nstatic Node KthLargestUsingMorrisTraversal(Node root, int k)\n{\n\tNode curr = root;\n\tNode Klargest = null;\n\tint count = 0;\n\twhile (curr != null)\n\t{\n\t\tif (curr.right == null)\n\t\t{\n\t\t\tif (++count == k)\n\t\t\t\tKlargest = curr;\n\t\t\tcurr = curr.left;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNode succ = curr.right;\n\t\t\twhile (succ.left != null && succ.left != curr)\n\t\t\t\tsucc = succ.left;\n\t\t\tif (succ.left == null)\n\t\t\t{\n\t\t\t\tsucc.left = curr;\n\t\t\t\tcurr = curr.right;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsucc.left = null;\n\t\t\t\tif (++count == k)\n\t\t\t\t\tKlargest = curr;\n\t\t\t\tcurr = curr.left;\n\t\t\t}\n\t\t}\n\t}\n\treturn Klargest;\n}", "6": "static void sortByRow(Integer mat[][], int n, boolean ascending)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (ascending)\n\t\t\t\tArrays.sort(mat[i]);\n\t\t\telse\n\t\t\t\tArrays.sort(mat[i],Collections.reverseOrder());\n\t\t}\t\n\t}\nstatic void transpose(Integer mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tint temp = mat[i][j];\n\t\t\t\tmat[i][j] = mat[j][i];\n\t\t\t\tmat[j][i] = temp;\n\t\t\t}\n\t}\nstatic void sortMatRowAndColWise(Integer mat[][], int n)\n\t{\n\t\tsortByRow(mat, n, true);\n\t\ttranspose(mat, n);\n\t\tsortByRow(mat, n, false);\n\t\ttranspose(mat, n);\n\t}\nstatic void printMat(Integer mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tSystem.out.print(mat[i][j] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "7": "static void sortByRow(int mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tArrays.sort(mat[i]);\n\t}\nstatic void transpose(int mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\tint temp=mat[i][j];\n\t\t\t\tmat[i][j]=mat[j][i];\n\t\t\t\tmat[j][i]=temp;\n\t\t\t\t}\n\t}\nstatic void sortMatRowAndColWise(int mat[][],int n)\n\t{\n\t\tsortByRow(mat, n);\n\t\ttranspose(mat, n);\n\t\tsortByRow(mat, n);\n\t\ttranspose(mat, n);\n\t}\nstatic void printMat(int mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tSystem.out.print(mat[i][j] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "8": "static void doublyEven(int n)\n\t{\n\t\tint[][] arr = new int[n][n];\n\t\tint i, j;\n\t\tfor ( i = 0; i < n; i++)\n\t\t\tfor ( j = 0; j < n; j++)\n\t\t\t\tarr[i][j] = (n*i) + j + 1;\n\t\tfor ( i = 0; i < n/4; i++)\n\t\t\tfor ( j = 0; j < n/4; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor ( i = 0; i < n/4; i++)\n\t\t\tfor ( j = 3 * (n/4); j < n; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor ( i = 3 * n/4; i < n; i++)\n\t\t\tfor ( j = 0; j < n/4; j++)\n\t\t\t\tarr[i][j] = (n*n+1) - arr[i][j];\n\t\tfor ( i = 3 * n/4; i < n; i++)\n\t\t\tfor ( j = 3 * n/4; j < n; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor ( i = n/4; i < 3 * n/4; i++)\n\t\t\tfor ( j = n/4; j < 3 * n/4; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tfor ( j = 0; j < n; j++)\n\t\t\t\tSystem.out.print(arr[i][j]+\" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "9": "static void Kroneckerproduct(int A[][], int B[][])\n\t{\n\t\tint[][] C= new int[rowa * rowb][cola * colb];\n\t\tfor (int i = 0; i < rowa; i++)\n\t\t{\n\t\t\tfor (int k = 0; k < rowb; k++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < cola; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < colb; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tC[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n\t\t\t\t\t\tSystem.out.print( C[i + l + 1][j + k + 1]+\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}", "10": "boolean isLowerTriangularMatrix(int mat[][])\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\tif (mat[i][j] != 0)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "11": "public static Boolean isUpperTriangularMatrix(int mat[][])\n\t{\n\t\tfor (int i = 1; i < N ; i++)\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tif (mat[i][j] != 0)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "12": "static long countSets(int a[][]) {\n\tlong res = 0;\n\tfor (int i = 0; i < n; i++) {\n\tint u = 0, v = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tif (a[i][j] == 1)\n\t\tu++;\n\t\telse\n\t\tv++;\n\t}\n\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\tint u = 0, v = 0;\n\tfor (int j = 0; j < n; j++) {\n\t\tif (a[j][i] == 1)\n\t\tu++;\n\t\telse\n\t\tv++;\n\t}\n\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n\t}\n\treturn res - (n * m);\n}", "13": "static void transpose(int mat[][], int tr[][], int N)\n{\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\ttr[i][j] = mat[j][i];\n}\nstatic boolean isSymmetric(int mat[][], int N)\n{\n\tint tr[][] = new int[N][MAX];\n\ttranspose(mat, tr, N);\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (mat[i][j] != tr[i][j])\n\t\t\t\treturn false;\n\treturn true;\n}", "14": "static boolean isSymmetric(int mat[][], int N)\n{\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (mat[i][j] != mat[j][i])\n\t\t\t\treturn false;\n\treturn true;\n}", "15": "static int findNormal(int mat[][], int n)\n{\n\tint sum = 0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<n; j++)\n\t\t\tsum += mat[i][j]*mat[i][j];\n\treturn (int)Math.sqrt(sum);\n}\nstatic int findTrace(int mat[][], int n)\n{\n\tint sum = 0;\n\tfor (int i=0; i<n; i++)\n\t\tsum += mat[i][i];\n\treturn sum;\n}", "16": "static int maxDet(int n)\n{\n\treturn (2 * n * n * n);\n}\nvoid resMatrix(int n)\n{\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tif (i == 0 && j == 2)\n\t\t\t\tSystem.out.print(\"0 \");\n\t\t\telse if (i == 1 && j == 0)\n\t\t\t\tSystem.out.print(\"0 \");\n\t\t\telse if (i == 2 && j == 1)\n\t\t\t\tSystem.out.print(\"0 \");\n\t\t\telse\n\t\t\t\tSystem.out.print(n +\" \");\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n}", "17": "static int countNegative(int M[][], int n, int m)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (M[i][j] < 0)\n\t\t\t\t\tcount += 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "18": "static int countNegative(int M[][], int n, int m)\n\t{\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tint j = m - 1;\n\t\twhile (j >= 0 && i < n) {\n\t\t\tif (M[i][j] < 0) {\n\t\t\t\tcount += j + 1;\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tj -= 1;\n\t\t}\n\t\treturn count;\n\t}", "19": "static int getLastNegativeIndex(int array[], int start, int end)\n\t{\n\t\tif (start == end) {\n\t\t\treturn start;\n\t\t}\n\t\tint mid = start + (end - start) / 2;\n\t\tif (array[mid] < 0) {\n\t\t\tif (mid + 1 < array.length && array[mid + 1] >= 0) {\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\treturn getLastNegativeIndex(array, mid + 1, end);\n\t\t}\n\t\telse {\n\t\t\treturn getLastNegativeIndex(array, start, mid - 1);\n\t\t}\n\t}\nstatic int countNegative(int M[][], int n, int m)\n\t{\n\t\tint count = 0;\n\t\tint nextEnd = m - 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (M[i][0] >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextEnd = getLastNegativeIndex(M[i], 0, nextEnd);\n\t\t\tcount += nextEnd + 1;\n\t\t}\n\t\treturn count;\n\t}", "20": "static int findMaxValue(int N,int mat[][])\n\t{\n\t\tint maxValue = Integer.MIN_VALUE;\n\t\tfor (int a = 0; a < N - 1; a++)\n\t\tfor (int b = 0; b < N - 1; b++)\n\t\t\tfor (int d = a + 1; d < N; d++)\n\t\t\tfor (int e = b + 1; e < N; e++)\n\t\t\t\tif (maxValue < (mat[d][e] - mat[a][b]))\n\t\t\t\t\tmaxValue = mat[d][e] - mat[a][b];\n\t\treturn maxValue;\n\t}", "21": "This one did not work even when I tried to submit 3 times", "22": "static void youngify(int mat[][], int i, int j)\n\t{\n\t\tint downVal = (i + 1 < N) ?\n\t\t\t\t\tmat[i + 1][j] : INF;\n\t\tint rightVal = (j + 1 < N) ?\n\t\t\t\t\tmat[i][j + 1] : INF;\n\t\tif (downVal == INF && rightVal == INF)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (downVal < rightVal)\n\t\t{\n\t\t\tmat[i][j] = downVal;\n\t\t\tmat[i + 1][j] = INF;\n\t\t\tyoungify(mat, i + 1, j);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmat[i][j] = rightVal;\n\t\t\tmat[i][j + 1] = INF;\n\t\t\tyoungify(mat, i, j + 1);\n\t\t}\n\t}\nstatic int extractMin(int mat[][])\n\t{\n\t\tint ret = mat[0][0];\n\t\tmat[0][0] = INF;\n\t\tyoungify(mat, 0, 0);\n\t\treturn ret;\n\t}\nstatic void printSorted(int mat[][])\n\t{\n\t\tSystem.out.println(\"Elements of matrix in sorted order n\");\n\t\tfor (int i = 0; i < N * N; i++)\n\t\t{\n\t\t\tSystem.out.print(extractMin(mat) + \" \");\n\t\t}\n\t}", "23": "static void printSumSimple(int mat[][], int k)\n\t{\n\t\tif (k > n) return;\n\t\tfor (int i = 0; i < n-k+1; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n-k+1; j++)\n\t\t\t{\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int p = i; p < k+i; p++)\n\t\t\t\t\tfor (int q = j; q < k+j; q++)\n\t\t\t\t\t\tsum += mat[p][q];\n\t\t\t\tSystem.out.print(sum+ \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "24": "static void printSumTricky(int mat[][], int k) {\n\tif (k > n)\n\treturn;\n\tint stripSum[][] = new int[n][n];\n\tfor (int j = 0; j < n; j++) {\n\tint sum = 0;\n\tfor (int i = 0; i < k; i++)\n\t\tsum += mat[i][j];\n\tstripSum[0][j] = sum;\n\tfor (int i = 1; i < n - k + 1; i++) {\n\t\tsum += (mat[i + k - 1][j] - mat[i - 1][j]);\n\t\tstripSum[i][j] = sum;\n\t}\n\t}\n\tfor (int i = 0; i < n - k + 1; i++) {\n\tint sum = 0;\n\tfor (int j = 0; j < k; j++)\n\t\tsum += stripSum[i][j];\n\tSystem.out.print(sum + \" \");\n\tfor (int j = 1; j < n - k + 1; j++) {\n\t\tsum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n\t\tSystem.out.print(sum + \" \");\n\t}\n\tSystem.out.println();\n\t}\n}", "25": "static void transpose(int A[][], int B[][])\n\t{\n\t\tint i, j;\n\t\tfor (i = 0; i < N; i++)\n\t\t\tfor (j = 0; j < M; j++)\n\t\t\t\tB[i][j] = A[j][i];\n\t}", "26": "static void transpose(int A[][])\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = i+1; j < N; j++)\n\t\t\t{\n\t\t\t\tint temp = A[i][j];\n\t\t\t\tA[i][j] = A[j][i];\n\t\t\t\tA[j][i] = temp;\n\t\t\t}\n\t}", "27": "static int pathCountRec(int mat[][], int m, int n, int k) {\n\t\tif (m < 0 n < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (m == 0 && n == 0 && (k == mat[m][n])) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn pathCountRec(mat, m - 1, n, k - mat[m][n])\n\t\t\t\t+ pathCountRec(mat, m, n - 1, k - mat[m][n]);\n\t}\nstatic int pathCount(int mat[][], int k) {\n\t\treturn pathCountRec(mat, R - 1, C - 1, k);\n\t}", "28": "static int pathCountDPRecDP(int [][]mat, int m, int n, int k)\n\t{\n\t\tif (m < 0 n < 0) return 0;\n\t\tif (m==0 && n==0) return (k == mat[m][n] ? 1 : 0);\n\t\tif (dp[m][n][k] != -1) return dp[m][n][k];\n\t\tdp[m][n][k] = pathCountDPRecDP(mat, m-1, n, k-mat[m][n]) +\n\t\t\t\t\tpathCountDPRecDP(mat, m, n-1, k-mat[m][n]);\n\t\treturn dp[m][n][k];\n\t}\nstatic int pathCountDP(int [][]mat, int k)\n\t{\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++)\n\t\t\t\tfor(int l=0;l<MAX_K;l++)\n\t\t\t\tdp[i][j][l]=-1;\n\t\treturn pathCountDPRecDP(mat, R-1, C-1, k);\n\t}", "29": "static boolean check(int A[], int N) {\n\t\tStack<Integer> S = new Stack<Integer>();\n\t\tint B_end = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!S.empty()) {\n\t\t\t\tint top = S.peek();\n\t\t\t\twhile (top == B_end + 1) {\n\t\t\t\t\tB_end = B_end + 1;\n\t\t\t\t\tS.pop();\n\t\t\t\t\tif (S.empty()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttop = S.peek();\n\t\t\t\t}\n\t\t\t\tif (S.empty()) {\n\t\t\t\t\tS.push(A[i]);\n\t\t\t\t} else {\n\t\t\t\t\ttop = S.peek();\n\t\t\t\t\tif (A[i] < top) {\n\t\t\t\t\t\tS.push(A[i]);\n} \n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tS.push(A[i]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "30": "static int countMinReversals(String expr)\n\t{\n\t\tint len = expr.length();\n\t\tif (len%2 != 0)\n\t\treturn -1;\n\t\tStack<Character> s=new Stack<>();\n\t\tfor (int i=0; i<len; i++)\n\t\t{\n\t\t\tchar c = expr.charAt(i);\n\t\t\tif (c =='}' && !s.empty())\n\t\t\t{\n\t\t\t\tif (s.peek()=='{')\n\t\t\t\t\ts.pop();\n\t\t\t\telse\n\t\t\t\t\ts.push(c);\n\t\t\t}\n\t\t\telse\n\t\t\t\ts.push(c);\n\t\t}\n\t\tint red_len = s.size();\n\t\tint n = 0;\n\t\twhile (!s.empty() && s.peek() == '{')\n\t\t{\n\t\t\ts.pop();\n\t\t\tn++;\n\t\t}\n\t\treturn (red_len/2 + n%2);\n\t}", "31": "static int countMinReversals(String expr)\n\t{\n\t\tint len = expr.length();\n\t\tint ans;\n\t\tif (len % 2 != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tint left_brace = 0, right_brace = 0;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tchar ch = expr.charAt(i);\n\t\t\tif (ch == '{') {\n\t\t\t\tleft_brace++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (left_brace == 0) {\n\t\t\t\t\tright_brace++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tleft_brace--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (int)(Math.ceil((0.0 + left_brace) / 2)\n\t\t\t\t\t+ Math.ceil((0.0 + right_brace) / 2));\n\t\treturn ans;\n\t}", "32": "static void PrintMinNumberForPattern(String arr)\n\t{\n\t\tint curr_max = 0;\n\t\tint last_entry = 0;\n\t\tint j;\n\t\tfor (int i = 0; i < arr.length(); i++)\n\t\t{\n\t\t\tint noOfNextD = 0;\n\t\t\tswitch (arr.charAt(i))\n\t\t\t{\n\t\t\t\tcase 'I':\n\t\t\t\t\tj = i + 1;\n\t\t\t\t\twhile (j < arr.length() && arr.charAt(j) == 'D')\n\t\t\t\t\t{\n\t\t\t\t\t\tnoOfNextD++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\t\t\tSystem.out.print(\" \" + ++last_entry);\n\t\t\t\t\t\tSystem.out.print(\" \" + curr_max);\n\t\t\t\t\t\tlast_entry = curr_max;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_max = curr_max + noOfNextD + 1;\n\t\t\t\t\t\tlast_entry = curr_max;\n\t\t\t\t\t\tSystem.out.print(\" \" + last_entry);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < noOfNextD; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.print(\" \" + --last_entry);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = i + 1;\n\t\t\t\t\t\twhile (j < arr.length()&&arr.charAt(j) == 'D')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnoOfNextD++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\t\t\tSystem.out.print(\" \" + curr_max + \" \" + (curr_max - 1));\n\t\t\t\t\t\tlast_entry = curr_max - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.print(\" \" + (last_entry - 1));\n\t\t\t\t\t\tlast_entry--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}", "33": "static void printLeast(String arr)\n\t{\n\t\t\tint min_avail = 1, pos_of_I = 0;\n\t\t\tArrayList<Integer> al = new ArrayList<>();\n\t\t\tif (arr.charAt(0) == 'I')\n\t\t\t{\n\t\t\t\tal.add(1);\n\t\t\t\tal.add(2);\n\t\t\t\tmin_avail = 3;\n\t\t\t\tpos_of_I = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tal.add(2);\n\t\t\t\tal.add(1);\n\t\t\t\tmin_avail = 3;\n\t\t\t\tpos_of_I = 0;\n\t\t\t}\n\t\t\tfor (int i = 1; i < arr.length(); i++)\n\t\t\t{\n\t\t\t\tif (arr.charAt(i) == 'I')\n\t\t\t\t{\n\t\t\t\t\tal.add(min_avail);\n\t\t\t\t\tmin_avail++;\n\t\t\t\t\tpos_of_I = i + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tal.add(al.get(i));\n\t\t\t\t\tfor (int j = pos_of_I; j <= i; j++)\n\t\t\t\t\t\t\tal.set(j, al.get(j) + 1);\n\t\t\t\t\tmin_avail++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < al.size(); i++)\n\t\t\t\tSystem.out.print(al.get(i) + \" \");\n\t\t\tSystem.out.println();\n\t}", "34": "static void PrintMinNumberForPattern(String seq) {\n\t\tString result = \"\";\n\t\tStack<Integer> stk = new Stack<Integer>();\n\t\tfor (int i = 0; i <= seq.length(); i++) {\n\t\t\tstk.push(i + 1);\n\t\t\tif (i == seq.length() || seq.charAt(i) == 'I') {\n\t\t\t\twhile (!stk.empty()) {\n\t\t\t\t\tresult += String.valueOf(stk.peek());\n\t\t\t\t\tresult += \" \";\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}", "35": "static String getMinNumberForPattern(String seq)\n\t{\n\t\tint n = seq.length();\n\t\tif (n >= 9)\n\t\t\treturn \"-1\";\n\t\tchar result[] = new char[n + 1];\n\t\tint count = 1;\n\t\tfor (int i = 0; i <= n; i++)\n\t\t{\n\t\t\tif (i == n || seq.charAt(i) == 'I')\n\t\t\t{\n\t\t\t\tfor (int j = i - 1; j >= -1; j--)\n\t\t\t\t{\n\t\t\t\t\tresult[j + 1] = (char) ((int) '0' + count++);\n\t\t\t\t\tif (j >= 0 && seq.charAt(j) == 'I')\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new String(result);\n\t}", "36": "public int compare(Key k1, Key k2)\n\t{\n\t\tif (k1.freq < k2.freq)\n\t\t\treturn 1;\n\t\telse if (k1.freq > k2.freq)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\nstatic void rearrangeString(String str)\n\t{\n\t\tint n = str.length();\n\t\tint[] count = new int[MAX_CHAR];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcount[str.charAt(i) - 'a']++;\n\t\tPriorityQueue<Key> pq\n\t\t\t= new PriorityQueue<>(new KeyComparator());\n\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\tint val = c - 'a';\n\t\t\tif (count[val] > 0)\n\t\t\t\tpq.add(new Key(count[val], c));\n\t\t}\n\t\tstr = \"\";\n\t\tKey prev = new Key(-1, '#');\n\t\twhile (pq.size() != 0) {\n\t\t\tKey k = pq.peek();\n\t\t\tpq.poll();\n\t\t\tstr = str + k.ch;\n\t\t\tif (prev.freq > 0)\n\t\t\t\tpq.add(prev);\n\t\t\t(k.freq)--;\n\t\t\tprev = k;\n\t\t}\n\t\tif (n != str.length())\n\t\t\tSystem.out.println(\" Not valid String \");\n\t\telse\n\t\t\tSystem.out.println(str);\n\t}", "37": "public static int subset(int ar[], int n)\n\t{\n\t\tint res = 0;\n\t\tArrays.sort(ar);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint count = 1;\n\t\t\tfor (; i < n - 1; i++) {\n\t\t\t\tif (ar[i] == ar[i + 1])\n\t\t\t\t\tcount++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres = Math.max(res, count);\n\t\t}\n\t\treturn res;\n\t}", "38": "static int subset(int arr[], int n)\n{\n        HashMap<Integer, Integer> mp = new HashMap<>();\n        for (int i = 0; i < n; i++)\n                mp.put(arr[i],mp.get(arr[i]) == null?1:mp.get(arr[i])+1);\n        int res = 0;\n        for (Map.Entry<Integer,Integer> entry : mp.entrySet())\n        res = Math.max(res, entry.getValue());\n        return res;\n}", "39": "static boolean areElementsContiguous(int arr[], int n)\n\t{\n\tArrays.sort(arr);\n\tfor (int i = 1; i < n; i++)\n\t\tif (arr[i] - arr[i-1] > 1)\n\t\t\treturn false;\n\treturn true; \n\t}", "40": "static boolean areElementsContiguous(int arr[], int n)\n\t{\n\t\tint max = Integer.MIN_VALUE;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tmax = Math.max(max, arr[i]);\n\t\t\tmin = Math.min(min, arr[i]);\n\t\t}\n\t\tint m = max - min + 1;\n\t\tif (m > n)\n\t\t\treturn false;\n\t\tboolean visited[] = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) \n\t\tvisited[arr[i] - min] = true;\n\t\tfor (int i = 0; i < m; i++)\n\t\tif (visited[i] == false)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "41": "static Boolean areElementsContiguous(int arr[], int n)\n\t{\n\t\tHashSet<Integer> us = new HashSet<Integer>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tus.add(arr[i]);\n\t\tint count = 1;\n\t\tint curr_ele = arr[0] - 1;\n\t\twhile (us.contains(curr_ele) == true) {\n\t\t\tcount++;\n\t\t\tcurr_ele--;\n\t\t}\n\t\tcurr_ele = arr[0] + 1;\n\t\twhile (us.contains(curr_ele) == true) {\n\t\t\tcount++;\n\t\t\tcurr_ele++;\n\t\t}\n\t\treturn (count == (us.size()));\n\t}", "42": "static void longest(int a[], int n, int k)\n{\n\tint[] freq = new int[7];\n\tint start = 0, end = 0, now = 0, l = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfreq[a[i]]++;\n\t\tif (freq[a[i]] == 1)\n\t\t\tnow++;\n\t\twhile (now > k)\n\t\t{\n\t\t\tfreq[a[l]]--;\n\t\t\tif (freq[a[l]] == 0)\n\t\t\t\tnow--;\n\t\t\tl++;\n\t\t}\n\t\tif (i - l + 1 >= end - start + 1)\n\t\t{\n\t\t\tend = i;\n\t\t\tstart = l;\n\t\t}\n\t}\n\tfor (int i = start; i <= end; i++)\n\t\tSystem.out.print(a[i]+\" \");\n}", "43": "static void findSmallestRange(int arr[][], int n, int k)\n\t{\n\t\tint i, minval, maxval, minrange, minel = 0, maxel = 0, flag, minind;\n\t\tfor (i = 0; i <= k; i++) {\n\t\t\tptr[i] = 0;\n\t\t}\n\t\tminrange = Integer.MAX_VALUE;\n\t\twhile (true) {\n\t\t\tminind = -1;\n\t\t\tminval = Integer.MAX_VALUE;\n\t\t\tmaxval = Integer.MIN_VALUE;\n\t\t\tflag = 0;\n\t\t\tfor (i = 0; i < k; i++) {\n\t\t\t\tif (ptr[i] == n) {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ptr[i] < n && arr[i][ptr[i]] < minval) {\nminind = i; \n\t\t\t\t\tminval = arr[i][ptr[i]];\n\t\t\t\t}\n\t\t\t\tif (ptr[i] < n && arr[i][ptr[i]] > maxval) {\n\t\t\t\t\tmaxval = arr[i][ptr[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr[minind]++;\n\t\t\tif ((maxval - minval) < minrange) {\n\t\t\t\tminel = minval;\n\t\t\t\tmaxel = maxval;\n\t\t\t\tminrange = maxel - minel;\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"The smallest range is [%d, %d]\\n\", minel, maxel);\n\t}", "44": "static int findLargestd(int []S, int n)\n{\n\tboolean found = false;\n\tArrays.sort(S);\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tif (i == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int l = k + 1; l < n; l++)\n\t\t\t\t{\n\t\t\t\t\tif (i == l)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (S[i] == S[j] + S[k] + S[l])\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\treturn S[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (found == false)\n\t\treturn Integer.MAX_VALUE;\n\treturn -1;\n}", "45": "int getI()\n\t{\n\t\treturn i;\n\t}\nint getJ()\n\t{\n\t\treturn j;\n\t}\nstatic int findFourElements(int[] arr, int n)\n\t{\n\t\tHashMap<Integer, Indexes> map = new HashMap<>();\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tmap.put(arr[i] + arr[j], new Indexes(i, j));\n\t\t\t}\n\t\t}\n\t\tint d = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tint abs_diff = Math.abs(arr[i] - arr[j]);\n\t\t\t\tif (map.containsKey(abs_diff))\n\t\t\t\t{\n\t\t\t\t\tIndexes indexes = map.get(abs_diff);\n\t\t\t\t\tif (indexes.getI() != i && indexes.getI() != j &&\n\t\t\t\t\tindexes.getJ() != i && indexes.getJ() != j)\n\t\t\t\t\t{\n\t\t\t\t\t\td = Math.max(d, Math.max(arr[i], arr[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}", "46": "void leftRotatebyOne(int arr[], int n)\n\t{\n\t\tint i, temp;\n\t\ttemp = arr[0];\n\t\tfor (i = 0; i < n - 1; i++)\n\t\t\tarr[i] = arr[i + 1];\n\t\tarr[n-1] = temp;\n\t}\nvoid leftRotate(int arr[], int d, int n)\n\t{\n\t\tfor (int i = 0; i < d; i++)\n\t\t\tleftRotatebyOne(arr, n);\n\t}\nvoid printArray(int arr[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t}", "47": "static void pushZerosToEnd(int arr[], int n)\n\t{\nint count = 0; \n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != 0)\narr[count++] = arr[i]; \n\t\twhile (count < n)\n\t\t\tarr[count++] = 0;\n\t}", "48": "static void moveZerosToEnd(int arr[], int n) {\n\tint count = 0;\n\tint temp;\n\tfor (int i = 0; i < n; i++) {\n\tif ((arr[i] != 0)) {\n\t\ttemp = arr[count];\n\t\tarr[count] = arr[i];\n\t\tarr[i] = temp;\n\t\tcount = count + 1;\n\t}\n\t}\n}\nstatic void printArray(int arr[], int n) {\n\tfor (int i = 0; i < n; i++)\n\tSystem.out.print(arr[i] + \" \");\n}", "49": "static void pushZerosToEnd(int arr[], int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != 0)\n\t\t\t\tarr[count++] = arr[i];\n\t\twhile (count < n)\n\t\t\tarr[count++] = 0;\n\t}\nstatic void modifyAndRearrangeArr(int arr[], int n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif ((arr[i] != 0) && (arr[i] == arr[i + 1]))\n\t\t\t{\n\t\t\t\tarr[i] = 2 * arr[i];\n\t\t\t\tarr[i + 1] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tpushZerosToEnd(arr, n);\n\t}\nstatic void printArray(int arr[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}", "50": "static void printArray(int arr[], int n)\n        {\n                for (int i = 0; i < n; i++)\n                        System.out.print(arr[i] + \" \");\n                System.out.println();\n        }\nstatic void RearrangePosNeg(int arr[], int n)\n        {\n                int key, j;\n                for (int i = 1; i < n; i++) {\n                        key = arr[i];\n                        if (key > 0)\n                                continue;\n                        j = i - 1;\n                        while (j >= 0 && arr[j] > 0) {\n                                arr[j + 1] = arr[j];\n                                j = j - 1;\n                        }\n                        arr[j + 1] = key;\n                }\n        }", "51": "static void printArray(int A[], int size)\n        {\n                for (int i = 0; i < size; i++)\n                        System.out.print(A[i] + \" \");\n                System.out.println(\"\");\n                ;\n        }\nstatic void reverse(int arr[], int l, int r)\n        {\n                if (l < r) {\n                        arr = swap(arr, l, r);\n                        reverse(arr, ++l, --r);\n                }\n        }\nstatic void merge(int arr[], int l, int m, int r)\n        {\nint i = l; \nint j = m + 1; \n                while (i <= m && arr[i] < 0)\n                        i++;\n                while (j <= r && arr[j] < 0)\n                        j++;\n                reverse(arr, i, m);\n                reverse(arr, m + 1, j - 1);\n                reverse(arr, i, j - 1);\n        }\nstatic void RearrangePosNeg(int arr[], int l, int r)\n        {\n                if (l < r) {\n                        int m = l + (r - l) / 2;\n                        RearrangePosNeg(arr, l, m);\n                        RearrangePosNeg(arr, m + 1, r);\n                        merge(arr, l, m, r);\n                }\n        }\nstatic int[] swap(int[] arr, int i, int j)\n        {\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n                return arr;\n        }", "52": "public static void RearrangePosNeg(int arr[])\n        {\n                int i=0;\n                int j=arr.length-1;\n                while(true)\n                {\n                        while(arr[i]<0 && i<arr.length)\n                        i++;\n                        while(arr[j]>0 && j>=0)\n                        j--;\n                        if(i<j)\n                        {\n                                int temp = arr[i];\n                                arr[i] = arr[j];\n                                arr[j] = temp;\n                        }\n                        else\n                        break;\n                }\n        }", "53": "static void findElements(int arr[], int n)\n{\n        for (int i = 0; i < n; i++)\n        {\n                int count = 0;\n                for (int j = 0; j < n; j++)\n                        if (arr[j] > arr[i])\n                                count++;\n                if (count >= 2)\n                System.out.print(arr[i] + \" \");\n        }\n}", "54": "static void findElements(int arr[], int n)\n{\n        Arrays.sort(arr);\n        for (int i = 0; i < n - 2; i++)\n        System.out.print(arr[i] + \" \");\n}", "55": "static void findElements(int arr[], int n)\n{\n        int first = Integer.MIN_VALUE;\n        int second = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++)\n        {\n                if (arr[i] > first)\n                {\n                        second = first;\n                        first = arr[i];\n                }\n                else if (arr[i] > second)\n                        second = arr[i];\n        }\n        for (int i = 0; i < n; i++)\n                if (arr[i] < second)\n                        System.out.print(arr[i] + \" \") ;\n}", "56": "int findFirstMissing(int array[], int start, int end)\n        {\n                if (start > end)\n                        return end + 1;\n                if (start != array[start])\n                        return start;\n                int mid = (start + end) / 2;\n                if (array[mid] == mid)\n                        return findFirstMissing(array, mid+1, end);\n                return findFirstMissing(array, start, mid);\n        }", "57": "int findFirstMissing(int[] arr , int start , int end, int first)\n        {\n        if (start < end)\n        {\n                int mid = (start+end)/2;\n                if (arr[mid] != mid+first)\n                return findFirstMissing(arr, start, mid , first);\n                else\n                return findFirstMissing(arr, mid+1, end , first);\n        }\n        return start+first;\n        }\nint findSmallestMissinginSortedArray( int[] arr)\n        {\n        if(arr[0] != 0)\n                return 0;\n        if(arr[arr.length-1] == arr.length - 1)\n                return arr.length;\n        int first = arr[0];\n        return findFirstMissing(arr,0, arr.length-1,first);\n        }", "58": "int FindMaxSum(int arr[], int n)\n        {\n                int incl = arr[0];\n                int excl = 0;\n                int excl_new;\n                int i;\n                for (i = 1; i < n; i++)\n                {\n                        excl_new = (incl > excl) ? incl : excl;\n                        incl = excl + arr[i];\n                        excl = excl_new;\n                }\n                return ((incl > excl) ? incl : excl);\n        }", "59": "static void buildSparseTable(int arr[], int n)\n        {\n                for (int i = 0; i < n; i++)\n                        lookup[i][0] = arr[i];\n                for (int j = 1; (1 << j) <= n; j++) {\n                        for (int i = 0; (i + (1 << j) - 1) < n; i++) {\n                                if (lookup[i][j - 1] <\n                                                        lookup[i + (1 << (j - 1))][j - 1])\n                                        lookup[i][j] = lookup[i][j - 1];\n                                else\n                                        lookup[i][j] =\n                                                        lookup[i + (1 << (j - 1))][j - 1];\n                        }\n                }\n        }\nstatic int query(int L, int R)\n        {\n                int j = (int)Math.log(R - L + 1);\n                if (lookup[L][j] <= lookup[R - (1 << j) + 1][j])\n                        return lookup[L][j];\n                else\n                        return lookup[R - (1 << j) + 1][j];\n        }", "60": "static void buildSparseTable(int arr[], int n)\n{\n        for (int i = 0; i < n; i++)\n                table[i][0] = arr[i];\n        for (int j = 1; j <= n; j++)\n                for (int i = 0; i <= n - (1 << j); i++)\n                        table[i][j] = __gcd(table[i][j - 1],\n                                                                table[i + (1 << (j - 1))][j - 1]);\n}\nstatic int query(int L, int R)\n{\n        int j = (int)Math.log(R - L + 1);\n        return __gcd(table[L][j],\n                                table[R - (1 << j) + 1][j]);\n}\nstatic int __gcd(int a, int b)\n{\n        return b == 0 ? a : __gcd(b, a % b);        \n}", "61": "static int findMaxAverage(int []arr, int n, int k)\n        {\n                if (k > n)\n                        return -1;\n                int []csum = new int[n];\n                csum[0] = arr[0];\n                for (int i = 1; i < n; i++)\n                csum[i] = csum[i - 1] + arr[i];\n                int max_sum = csum[k - 1],\n                                        max_end = k - 1;\n                for (int i = k; i < n; i++)\n                {\n                        int curr_sum = csum[i] -\n                                        csum[i - k];\n                        if (curr_sum > max_sum)\n                        {\n                                max_sum = curr_sum;\n                                max_end = i;\n                        }\n                }\n                return max_end - k + 1;\n        }", "62": "static int findMaxAverage(int arr[], int n, int k)\n        {\n                if (k > n)\n                        return -1;\n                int sum = arr[0];\n                for (int i = 1; i < k; i++)\n                        sum += arr[i];\n                int max_sum = sum, max_end = k-1;\n                for (int i = k; i < n; i++)\n                {\n                        sum = sum + arr[i] - arr[i-k];\n                        if (sum > max_sum)\n                        {\n                                max_sum = sum;\n                                max_end = i;\n                        }\n                }\n                return max_end - k + 1;\n        }", "63": "static boolean isMajority(int arr[], int n, int x)\n        {\n                int i, last_index = 0;\n                last_index = (n%2==0)? n/2: n/2+1;\n                for (i = 0; i < last_index; i++)\n                {\n                        if (arr[i] == x && arr[i+n/2] == x)\n                                return true;\n                }\n                return false;\n        }", "64": "static int _binarySearch(int arr[], int low, int high, int x)\n        {\n                if (high >= low)\n                {\n                        int mid = (low + high)/2; \n                        if ( (mid == 0 x > arr[mid-1]) && (arr[mid] == x) )\n                                return mid;\n                        else if (x > arr[mid])\n                                return _binarySearch(arr, (mid + 1), high, x);\n                        else\n                                return _binarySearch(arr, low, (mid -1), x);\n                }\n                return -1;\n        }\nstatic boolean isMajority(int arr[], int n, int x)\n        {\n                int i = _binarySearch(arr, 0, n-1, x);\n                if (i == -1)\n                        return false;\n                if (((i + n/2) <= (n -1)) && arr[i + n/2] == x)\n                        return true;\n                else\n                        return false;\n        }", "65": "static boolean isMajorityElement(int arr[], int n, int key)\n{\n        if (arr[n / 2] == key)\n                return true;\n        else\n                return false;\n}", "66": "static void sortMat(int mat[][], int n)\n        {\n                int temp[] = new int[n * n];\n                int k = 0;\n                for (int i = 0; i < n; i++)\n                        for (int j = 0; j < n; j++)\n                                temp[k++] = mat[i][j];\n                Arrays.sort(temp);\n                k = 0;\n                for (int i = 0; i < n; i++)\n                        for (int j = 0; j < n; j++)\n                                mat[i][j] = temp[k++];\n        }\nstatic void printMat(int mat[][], int n)\n        {\n                for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < n; j++)\n                                System.out.print( mat[i][j] + \" \");\n                        System.out.println();\n                }\n        }", "67": "void sort(int arr[])\n        {\n                int n = arr.length;\n                for (int i = 0; i < n-1; i++)\n                {\n                        int min_idx = i;\n                        for (int j = i+1; j < n; j++)\n                                if (arr[j] < arr[min_idx])\n                                        min_idx = j;\n                        int temp = arr[min_idx];\n                        arr[min_idx] = arr[i];\n                        arr[i] = temp;\n                }\n        }\nvoid printArray(int arr[])\n        {\n                int n = arr.length;\n                for (int i=0; i<n; ++i)\n                        System.out.print(arr[i]+\" \");\n                System.out.println();\n        }", "68": "static void bubbleSort(int arr[], int n)\n        {\n                int i, j, temp;\n                boolean swapped;\n                for (i = 0; i < n - 1; i++)\n                {\n                        swapped = false;\n                        for (j = 0; j < n - i - 1; j++)\n                        {\n                                if (arr[j] > arr[j + 1])\n                                {\n                                        temp = arr[j];\n                                        arr[j] = arr[j + 1];\n                                        arr[j + 1] = temp;\n                                        swapped = true;\n                                }\n                        }\n                        if (swapped == false)\n                                break;\n                }\n        }\nstatic void printArray(int arr[], int size)\n        {\n                int i;\n                for (i = 0; i < size; i++)\n                        System.out.print(arr[i] + \" \");\n                System.out.println();\n        }", "69": "int findCrossOver(int arr[], int low, int high, int x)\n        {\nif (arr[high] <= x) \n                        return high;\nif (arr[low] > x) \n                        return low;\n                int mid = (low + high)/2; \n                if (arr[mid] <= x && arr[mid+1] > x)\n                        return mid;\n                if(arr[mid] < x)\n                        return findCrossOver(arr, mid+1, high, x);\n                return findCrossOver(arr, low, mid - 1, x);\n        }\nvoid printKclosest(int arr[], int x, int k, int n)\n        {\n                int l = findCrossOver(arr, 0, n-1, x);\nint r = l+1; \nint count = 0; \n                if (arr[l] == x) l--;\n                while (l >= 0 && r < n && count < k)\n                {\n                        if (x - arr[l] < arr[r] - x)\n                                System.out.print(arr[l--]+\" \");\n                        else\n                                System.out.print(arr[r++]+\" \");\n                        count++;\n                }\n                while (count < k && l >= 0)\n                {\n                        System.out.print(arr[l--]+\" \");\n                        count++;\n                }\n                while (count < k && r < n)\n                {\n                        System.out.print(arr[r++]+\" \");\n                        count++;\n                }\n        }", "70": "void push(int val)\n        {\n                node newnode = new node(val);\n                newnode.next = head;\n                head = newnode;\n        }\nvoid insertionSort(node headref)\n        {\n                sorted = null;\n                node current = headref;\n                while (current != null)\n                {\n                        node next = current.next;\n                        sortedInsert(current);\n                        current = next;\n                }\n                head = sorted;\n        }\nvoid sortedInsert(node newnode)\n        {\n                if (sorted == null sorted.val >= newnode.val)\n                {\n                        newnode.next = sorted;\n                        sorted = newnode;\n                }\n                else\n                {\n                        node current = sorted;\n                        while (current.next != null && current.next.val < newnode.val)\n                        {\n                                current = current.next;\n                        }\n                        newnode.next = current.next;\n                        current.next = newnode;\n                }\n        }\nvoid printlist(node head)\n        {\n                while (head != null)\n                {\n                        System.out.print(head.val + \" \");\n                        head = head.next;\n                }\n        }", "71": "Data point is missing", "72": "static int matrixChainMemoised(int[] p, int i, int j)\n {\n        if (i == j) \n        {\n        return 0;\n        }\n        if (dp[i][j] != -1) \n        {\n        return dp[i][j];\n        }\n        dp[i][j] = Integer.MAX_VALUE;\n        for (int k = i; k < j; k++) \n        {\n        dp[i][j] = Math.min(\n                dp[i][j], matrixChainMemoised(p, i, k)\n                + matrixChainMemoised(p, k + 1, j) + p[i - 1] * p[k] * p[j]);\n        }\n        return dp[i][j];\n }\nstatic int MatrixChainOrder(int[] p, int n)\n {\n        int i = 1, j = n - 1;\n        return matrixChainMemoised(p, i, j);\n }", "73": "static int MatrixChainOrder(int p[], int n)\n        {\n                int m[][] = new int[n][n];\n                int i, j, k, L, q;\n                for (i = 1; i < n; i++)\n                        m[i][i] = 0;\n                for (L = 2; L < n; L++)\n                {\n                        for (i = 1; i < n - L + 1; i++)\n                        {\n                                j = i + L - 1;\n                                if (j == n)\n                                        continue;\n                                m[i][j] = Integer.MAX_VALUE;\n                                for (k = i; k <= j - 1; k++)\n                                {\n                                        q = m[i][k] + m[k + 1][j]\n                                                + p[i - 1] * p[k] * p[j];\n                                        if (q < m[i][j])\n                                                m[i][j] = q;\n                                }\n                        }\n                }\n                return m[1][n - 1];\n        }", "74": "static int cutRod(int price[], int n)\n        {\n                if (n <= 0)\n                        return 0;\n                int max_val = Integer.MIN_VALUE;\n                for (int i = 0; i<n; i++)\n                        max_val = Math.max(max_val,\n                                                        price[i] + cutRod(price, n-i-1));\n                return max_val;\n        }", "75": "static int cutRod(int price[],int n)\n        {\n                int val[] = new int[n+1];\n                val[0] = 0;\n                for (int i = 1; i<=n; i++)\n                {\n                        int max_val = Integer.MIN_VALUE;\n                        for (int j = 0; j < i; j++)\n                                max_val = Math.max(max_val, price[j] + val[i-j-1]);\n                        val[i] = max_val;\n                }\n                return val[n];\n        }", "76": "static int multiply(int x, int y) {\n                if (y == 0)\n                        return 0;\n                if (y > 0)\n                        return (x + multiply(x, y - 1));\n                if (y < 0)\n                        return -multiply(x, -y);\n                return -1;\n        }", "77": "void sieveOfEratosthenes(int n)\n        {\n                boolean prime[] = new boolean[n + 1];\n                for (int i = 0; i <= n; i++)\n                        prime[i] = true;\n                for (int p = 2; p * p <= n; p++)\n                {\n                        if (prime[p] == true)\n                        {\n                                for (int i = p * p; i <= n; i += p)\n                                        prime[i] = false;\n                        }\n                }\n                for (int i = 2; i <= n; i++)\n                {\n                        if (prime[i] == true)\n                                System.out.print(i + \" \");\n                }\n        }", "78": "static int binomialCoeff(int n, int k)\n        {\n                int res = 1;\n                if (k > n - k)\n                k = n - k;\n                for (int i = 0; i < k; ++i)\n                {\n                        res *= (n - i);\n                        res /= (i + 1);\n                }\n                return res;\n        }\nstatic void printPascal(int n)\n        {\n        for (int line = 0; line < n; line++)\n        {\n                for (int i = 0; i <= line; i++)\n                System.out.print(binomialCoeff\n                                                (line, i)+\" \");\n                System.out.println();\n        }\n        }", "79": "public static void printPascal(int n)\n{\nint[][] arr = new int[n][n];\nfor (int line = 0; line < n; line++)\n{\n        for (int i = 0; i <= line; i++)\n        {\n        if (line == i i == 0)\n                arr[line][i] = 1;\nelse \n                arr[line][i] = arr[line-1][i-1] + arr[line-1][i];\n        System.out.print(arr[line][i]);\n        }\n        System.out.println(\"\");\n}\n}", "80": "public static void printPascal(int n)\n{\n        for(int line = 1; line <= n; line++)\n        {\nint C=1;\n        for(int i = 1; i <= line; i++)\n        {\n                System.out.print(C+\" \");\n                C = C * (line - i) / i;\n        }\n        System.out.println();\n        }\n}", "81": "static int Add(int x, int y)\n        {\n                while (y != 0)\n                {\n                        int carry = x & y;\n                        x = x ^ y;\n                        y = carry << 1;\n                }\n                return x;\n        }", "82": "This data point is missing", "83": "static int getModulo(int n, int d)\n        {\n                return ( n & (d-1) );\n        }", "84": "static int countSetBits(int n)\n        {\n                int count = 0;\n                while (n > 0) {\n                        count += n & 1;\n                        n >>= 1;\n                }\n                return count;\n        }", "85": "public static int countSetBits(int n)\n        {\n                if (n == 0)\n                        return 0;\n                else\n                        return 1 + countSetBits(n & (n - 1));\n        }", "86": "public static void initialize()\n        {\n                BitsSetTable256[0] = 0;\n                for (int i = 0; i < 256; i++) {\n                        BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n                }\n        }\npublic static int countSetBits(int n)\n        {\n                return (BitsSetTable256[n & 0xff]\n                                + BitsSetTable256[(n >> 8) & 0xff]\n                                + BitsSetTable256[(n >> 16) & 0xff] + BitsSetTable256[n >> 24]);\n        }", "87": "This data point is missing", "88": "static int countSetBitsRec(int num)\n        {\n                int nibble = 0;\n                if (0 == num)\n                        return num_to_bits[0];\n                nibble = num & 0xf;\n                return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n        }", "89": "static int countSetBits(int N)\n {\n        int count = 0;\n        for (int i = 0; i < 4 * 8; i++)\n        {\n        if ((N & (1 << i)) != 0)\n                count++;\n        }\n        return count;\n }", "90": "static boolean getParity(int n)\n        {\n                boolean parity = false;\n                while(n != 0)\n                {\n                        parity = !parity;\n                        n = n & (n-1);\n                }\n                return parity;\n        }", "91": "static boolean isPowerOfTwo(int n)\n{\n        if(n==0)\n        return false;\nreturn (int)(Math.ceil((Math.log(n) / Math.log(2)))) ==\n        (int)(Math.floor(((Math.log(n) / Math.log(2)))));\n}", "92": "static boolean isPowerOfTwo(int n)\n        {\n                if (n == 0)\n                        return false;\n                while (n != 1)\n                {\n                        if (n % 2 != 0)\n                                return false;\n                        n = n / 2;\n                }\n                return true;\n        }", "93": "static boolean powerOf2(int n)\n{\n if (n == 1)\n        return true;\n else if (n % 2 != 0 n ==0)\n        return false;\n return powerOf2(n / 2);\n}", "94": "static boolean isPowerOfTwo (int x)\n        {\n                return x!=0 && ((x&(x-1)) == 0);\n        }", "95": "static int maxRepeating(int arr[], int n, int k)\n        {\n                for (int i = 0; i< n; i++)\n                        arr[(arr[i]%k)] += k;\n                int max = arr[0], result = 0;\n                for (int i = 1; i < n; i++)\n                {\n                        if (arr[i] > max)\n                        {\n                                max = arr[i];\n                                result = i;\n                        }\n                }\n                return result;\n        }", "96": "static int fun(int x)\n        {\n                int y = (x / 4) * 4;\n                int ans = 0;\n                for (int i = y; i <= x; i++)\n                        ans ^= i;\n                return ans;\n        }\nstatic int query(int x)\n        {\n                if (x == 0)\n                        return 0;\n                int k = (x + 1) / 2;\n                return ((x %= 2) != 0) ? 2 * fun(k) :\n                                ((fun(k - 1) * 2) ^ (k & 1));\n        }\nstatic void allQueries(int q, int l[], int r[])\n        {\n                for (int i = 0; i < q; i++)\n                        System.out.println((query(r[i]) ^\n                                                        query(l[i] - 1))) ;\n        }", "97": "static void prefixXOR(int arr[], int preXOR[], int n)\n        {\n                for (int i = 0; i < n; i++)\n                {\n                        while (arr[i] % 2 != 1)\n                                arr[i] /= 2;\n                        preXOR[i] = arr[i];\n                }\n                for (int i = 1; i < n; i++)\n                        preXOR[i] = preXOR[i - 1] ^ preXOR[i];\n        }\nstatic int query(int preXOR[], int l, int r)\n        {\n                if (l == 0)\n                        return preXOR[r];\n                else\n                        return preXOR[r] ^ preXOR[l - 1];\n        }", "98": "static int findMinSwaps(int arr[], int n)\n        {\n                int noOfZeroes[] = new int[n];\n                int i, count = 0;\n                noOfZeroes[n - 1] = 1 - arr[n - 1];\n                for (i = n - 2; i >= 0; i--)\n                {\n                        noOfZeroes[i] = noOfZeroes[i + 1];\n                        if (arr[i] == 0)\n                                noOfZeroes[i]++;\n                }\n                for (i = 0; i < n; i++)\n                {\n                        if (arr[i] == 1)\n                                count += noOfZeroes[i];\n                }\n                return count;\n        }", "99": "public static int minswaps(int arr[], int n)\n        {\n                int count = 0;\n                int num_unplaced_zeros = 0;\n                for (int index = n - 1; index >= 0; index--)\n                {\n                        if (arr[index] == 0)\n                                num_unplaced_zeros += 1;\n                        else\n                                count += num_unplaced_zeros;\n                }\n                return count;\n        }", "100": "static boolean arraySortedOrNot(int arr[], int n)\n        {\n                if (n == 0 n == 1)\n                        return true;\n                for (int i = 1; i < n; i++)\n                        if (arr[i - 1] > arr[i])\n                                return false;\n                return true;\n        }", "101": "static void printTwoOdd(int arr[], int size)\n        {\n        int xor2 = arr[0];\n        int set_bit_no; \n        int i;\n        int n = size - 2;\n        int x = 0, y = 0;\n        for(i = 1; i < size; i++)\n                xor2 = xor2 ^ arr[i];\n        set_bit_no = xor2 & ~(xor2-1);\n        for(i = 0; i < size; i++)\n        {\n                if((arr[i] & set_bit_no)>0)\n                x = x ^ arr[i];\n                else\n                y = y ^ arr[i];\n        }\n        System.out.println(\"The two ODD elements are \"+ x + \" & \" + y);\n        }", "102": "static boolean findPair(int arr[],int n)\n        {\n                int size = arr.length;\n                int i = 0, j = 1;\n                while (i < size && j < size)\n                {\n                        if (i != j && arr[j]-arr[i] == n)\n                        {\n                                System.out.print(\"Pair Found: \"+\n                                                                \"( \"+arr[i]+\", \"+ arr[j]+\" )\");\n                                return true;\n                        }\n                        else if (arr[j] - arr[i] < n)\n                                j++;\n                        else\n                                i++;\n                }\n                System.out.print(\"No such pair\");\n                return false;\n        }", "103": "public static void printMax(int arr[], int k, int n)\n        {\n                Integer[] brr = new Integer[n];\n                for (int i = 0; i < n; i++)\n                brr[i] = arr[i];\n                Arrays.sort(brr, Collections.reverseOrder());\n                for (int i = 0; i < n; ++i)\n                        if (Arrays.binarySearch(brr, arr[i],\n                                        Collections.reverseOrder()) >= 0\n                                && Arrays.binarySearch(brr, arr[i],\n                                        Collections.reverseOrder()) < k)\n                                System.out.print(arr[i]+ \" \");\n        }", "104": "static void printSmall(int arr[], int asize, int n)\n{\n        int []copy_arr = Arrays.copyOf(arr,asize);\n        Arrays.sort(copy_arr);\n        for (int i = 0; i < asize; ++i)\n        {\n                if (Arrays.binarySearch(copy_arr,0,n, arr[i])>-1)\n                        System.out.print(arr[i] + \" \");\n        }\n}", "105": "static boolean checkIsAP(int arr[], int n)\n        {\n                if (n == 1)\n                        return true;\n                Arrays.sort(arr);\n                int d = arr[1] - arr[0];\n                for (int i = 2; i < n; i++)\n                        if (arr[i] - arr[i-1] != d)\n                                return false;\n                return true;\n        }", "106": "static int countPairs(int a[], int n)\n        {\n                int mn = Integer.MAX_VALUE;\n                int mx = Integer.MIN_VALUE;\n                for (int i = 0; i < n; i++) {\n                        mn = Math.min(mn, a[i]);\n                        mx = Math.max(mx, a[i]);\n                }\n                int c1 = 0;\nint c2 = 0; \n                for (int i = 0; i < n; i++) {\n                        if (a[i] == mn)\n                                c1++;\n                        if (a[i] == mx)\n                                c2++;\n                }\n                if (mn == mx)\n                        return n * (n - 1) / 2;\n                else\n                        return c1 * c2;\n        }", "107": "static Node rearrange(Node head)\n        {\nif (head == null) \n                        return null;\n                Node prev = head, curr = head.next;\n                while (curr != null) {\n                        if (prev.data > curr.data) {\n                                int t = prev.data;\n                                prev.data = curr.data;\n                                curr.data = t;\n                        }\n                        if (curr.next != null && curr.next.data > curr.data) {\n                                int t = curr.next.data;\n                                curr.next.data = curr.data;\n                                curr.data = t;\n                        }\n                        prev = curr.next;\n                        if (curr.next == null)\n                                break;\n                        curr = curr.next.next;\n                }\n                return head;\n        }\nstatic Node push(Node head, int k)\n        {\n                Node tem = new Node();\n                tem.data = k;\n                tem.next = head;\n                head = tem;\n                return head;\n        }\nstatic void display(Node head)\n        {\n                Node curr = head;\n                while (curr != null) {\n                        System.out.printf(\"%d \", curr.data);\n                        curr = curr.next;\n                }\n        }", "108": "void printlist(Node head)\n        {\n                while (head != null) {\n                        System.out.print(head.data + \" \");\n                        if (head.next != null) {\n                                System.out.print(\"->\");\n                        }\n                        head = head.next;\n                }\n                System.out.println();\n        }\nvoid rearrange(Node head)\n        {\n                if (head != null) {\n                        left = head;\n                        reorderListUtil(left);\n                }\n        }\nvoid reorderListUtil(Node right)\n        {\n                if (right == null) {\n                        return;\n                }\n                reorderListUtil(right.next);\n                if (left == null) {\n                        return;\n                }\n                if (left != right && left.next != right) {\n                        Node temp = left.next;\n                        left.next = right;\n                        right.next = temp;\n                        left = temp;\n                }\nelse { \n                        if (left.next == right) {\nleft.next.next = null; \n                                left = null;\n                        }\n                        else {\nleft.next = null; \n                                left = null;\n                        }\n                }\n        }", "109": "int getLength(Node node)\n        {\n                int size = 0;\n                while (node != null) {\n                        node = node.next;\n                        size++;\n                }\n                return size;\n        }\nNode paddZeros(Node sNode, int diff)\n        {\n                if (sNode == null)\n                        return null;\n                Node zHead = new Node(0);\n                diff--;\n                Node temp = zHead;\n                while ((diff--) != 0) {\n                        temp.next = new Node(0);\n                        temp = temp.next;\n                }\n                temp.next = sNode;\n                return zHead;\n        }\nNode subtractLinkedListHelper(Node l1, Node l2)\n        {\n                if (l1 == null && l2 == null && borrow == false)\n                        return null;\n                Node previous\n                        = subtractLinkedListHelper(\n                                (l1 != null) ? l1.next\n                                                        : null,\n                                (l2 != null) ? l2.next : null);\n                int d1 = l1.data;\n                int d2 = l2.data;\n                int sub = 0;\n                if (borrow) {\n                        d1--;\n                        borrow = false;\n                }\n                if (d1 < d2) {\n                        borrow = true;\n                        d1 = d1 + 10;\n                }\n                sub = d1 - d2;\n                Node current = new Node(sub);\n                current.next = previous;\n                return current;\n        }\nNode subtractLinkedList(Node l1, Node l2)\n        {\n                if (l1 == null && l2 == null)\n                        return null;\n                int len1 = getLength(l1);\n                int len2 = getLength(l2);\n                Node lNode = null, sNode = null;\n                Node temp1 = l1;\n                Node temp2 = l2;\n                if (len1 != len2) {\n                        lNode = len1 > len2 ? l1 : l2;\n                        sNode = len1 > len2 ? l2 : l1;\n                        sNode = paddZeros(sNode, Math.abs(len1 - len2));\n                }\n                else {\n                        while (l1 != null && l2 != null) {\n                                if (l1.data != l2.data) {\n                                        lNode = l1.data > l2.data ? temp1 : temp2;\n                                        sNode = l1.data > l2.data ? temp2 : temp1;\n                                        break;\n                                }\n                                l1 = l1.next;\n                                l2 = l2.next;\n                        }\n                }\n                borrow = false;\n                return subtractLinkedListHelper(lNode, sNode);\n        }\nstatic void printList(Node head)\n        {\n                Node temp = head;\n                while (temp != null) {\n                        System.out.print(temp.data + \" \");\n                        temp = temp.next;\n                }\n        }", "110": "static void insertAtMid(int x)\n        {\n                if (head == null)\n                        head = new Node(x);\n                else {\n                        Node newNode = new Node(x);\n                        Node ptr = head;\n                        int len = 0;\n                        while (ptr != null) {\n                                len++;\n                                ptr = ptr.next;\n                        }\n                        int count = ((len % 2) == 0) ? (len / 2) :\n                                                                                (len + 1) / 2;\n                        ptr = head;\n                        while (count-- > 1)\n                                ptr = ptr.next;\n                        newNode.next = ptr.next;\n                        ptr.next = newNode;\n                }\n        }\nstatic void display()\n        {\n                Node temp = head;\n                while (temp != null)\n                {\n                        System.out.print(temp.data + \" \");\n                        temp = temp.next;\n                }\n        }", "111": "static void insertAtMid(int x)\n        {\n                if (head == null)\n                head = new Node(x);\n                else {\n                        Node newNode = new Node(x);\n                        Node slow = head;\n                        Node fast = head.next;\n                        while (fast != null && fast.next != null)\n                        {\n                                slow = slow.next;\n                                fast = fast.next.next;\n                        }\n                        newNode.next = slow.next;\n                        slow.next = newNode;\n                }\n        }\nstatic void display()\n        {\n                Node temp = head;\n                while (temp != null)\n                {\n                        System.out.print(temp.data + \" \");\n                        temp = temp.next;\n                }\n        }", "112": "static Node getNode(int data)\n{\n        Node newNode = new Node();\n        newNode.data = data;\n        newNode.prev = newNode.next = null;\n        return newNode;\n}\nstatic Node sortedInsert(Node head_ref, Node newNode)\n{\n        Node current;\n        if (head_ref == null)\n                head_ref = newNode;\n        else if ((head_ref).data >= newNode.data)\n        {\n                newNode.next = head_ref;\n                newNode.next.prev = newNode;\n                head_ref = newNode;\n        }\n        else\n        {\n                current = head_ref;\n                while (current.next != null && current.next.data < newNode.data)\n                        current = current.next;\n                newNode.next = current.next;\n                if (current.next != null)\n                        newNode.next.prev = newNode;\n                current.next = newNode;\n                newNode.prev = current;\n        }\n        return head_ref;\n}\nstatic Node insertionSort(Node head_ref)\n{\n        Node sorted = null;\n        Node current = head_ref;\n        while (current != null)\n        {\n                Node next = current.next;\n                current.prev = current.next = null;\n                sorted=sortedInsert(sorted, current);\n                current = next;\n        }\n        head_ref = sorted;\n        return head_ref;\n}\nstatic void printList(Node head)\n{\n        while (head != null)\n        {\n                System.out.print(head.data + \" \");\n                head = head.next;\n        }\n}\nstatic Node push(Node head_ref, int new_data)\n{\n        Node new_node = new Node();\n        new_node.data = new_data;\n        new_node.next = (head_ref);\n        new_node.prev = null;\n        if ((head_ref) != null)\n                (head_ref).prev = new_node;\n        (head_ref) = new_node;\n        return head_ref;\n}", "113": "public static void reverse(int arr[], int s, int e)\n{\n        while(s < e)\n        {\n                int tem = arr[s];\n                arr[s] = arr[e];\n                arr[e] = tem;\n                s = s + 1;\n                e = e - 1;\n        }\n}\npublic static void fun(int arr[], int k)\n{\n        int n = 4 - 1;\n        int v = n - k;\n        if (v >= 0)\n        {\n                reverse(arr, 0, v);\n                reverse(arr, v + 1, n);\n                reverse(arr, 0, n);\n        }\n}", "114": "static void build(int node, int l, int r, int a[])\n{\n        if (l == r)\n                seg[node] = a[l];\n        else\n        {\n                int mid = (l + r) / 2;\n                build(2 * node, l, mid, a);\n                build(2 * node + 1, mid + 1, r, a);\n                seg[node] = (seg[2 * node] seg[2 * node + 1]);\n        }\n}\nstatic int query(int node, int l, int r, int start, int end, int a[])\n{\n        if (l > end r < start)\n                return 0;\n        if (start <= l && r <= end)\n                return seg[node];\n        int mid = (l + r) / 2;\n        return ((query(2 * node, l, mid, start, end, a)) |\n                        (query(2 * node + 1, mid + 1, r, start, end, a)));\n}\nstatic void orsum(int a[], int n, int q, int k[])\n{\n        build(1, 0, n - 1, a);\n        for(int j = 0; j < q; j++)\n        {\n                int i = k[j] % (n / 2);\n                int sec = query(1, 0, n - 1, n / 2 - i, n - i - 1, a);\n                int first = (query(1, 0, n - 1, 0, n / 2 - 1 - i, a) |\n                                        query(1, 0, n - 1, n - i, n - 1, a));\n                int temp = sec + first;\n                System.out.print(temp + \"\\n\");\n        }\n}", "115": "static void maximumEqual(int a[], int b[], int n)\n{\n        int store[] = new int[(int) 1e5];\n        for (int i = 0; i < n; i++)\n        {\n                store[b[i]] = i + 1;\n        }\n        int ans[] = new int[(int) 1e5];\n        for (int i = 0; i < n; i++)\n        {\n                int d = Math.abs(store[a[i]] - (i + 1));\n                if (store[a[i]] < i + 1)\n                {\n                        d = n - d;\n                }\n                ans[d]++;\n        }\n        int finalans = 0;\n        for (int i = 0; i < 1e5; i++)\n                finalans = Math.max(finalans, ans[i]);\n        System.out.print(finalans + \"\\n\");\n}", "116": "static void RightRotate(int a[], int n, int k)\n{\n        k=k%n;\n        for(int i = 0; i < n; i++)\n        {\n                if(i<k)\n                {\n                        System.out.print(a[n + i - k] + \" \");\n                }\n                else\n                {\n                        System.out.print(a[i - k] + \" \");\n                }\n        }\n        System.out.println();\n}", "117": "static void restoreSortedArray(int arr[], int n)\n{\n        for (int i = 0; i < n; i++)\n        {\n                if (arr[i] > arr[i + 1])\n                {\n                        reverse(arr,0,i);\n                        reverse(arr , i + 1, n);\n                        reverse(arr,0, n);\n                }\n        }\n}\nstatic void reverse(int[] arr, int i, int j)\n{\n        int temp;\n        while(i < j)\n        {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n                i++;\n                j--;\n        }\n}\nstatic void printArray(int arr[], int size)\n{\n        for (int i = 0; i < size; i++)\n                System.out.print(arr[i] + \" \");\n}", "118": "static int findStartIndexOfArray(int arr[], int low, int high)\n        {\n                if (low > high)\n                {\n                        return -1;\n                }\n                if (low == high)\n                {\n                        return low;\n                }\n                int mid = low + (high - low) / 2;\n                if (arr[mid] > arr[mid + 1])\n                {\n                        return mid + 1;\n                }\n                if (arr[mid - 1] > arr[mid])\n                {\n                        return mid;\n                }\n                if (arr[low] > arr[mid])\n                {\n                        return findStartIndexOfArray(arr, low, mid - 1);\n                }\n                else\n                {\n                        return findStartIndexOfArray(arr, mid + 1, high);\n                }\n        }\nstatic void restoreSortedArray(int arr[], int n)\n        {\n                if (arr[0] < arr[n - 1])\n                {\n                        return;\n                }\n                int start = findStartIndexOfArray(arr, 0, n - 1);\n                Arrays.sort(arr, 0, start);\n                Arrays.sort(arr, start, n);\n                Arrays.sort(arr);\n        }\nstatic void printArray(int arr[], int size)\n        {\n                for (int i = 0; i < size; i++)\n                {\n                        System.out.print(arr[i] + \" \");\n                }\n        }", "119": "static String leftrotate(String str, int d)\n        {\n                        String ans = str.substring(d) + str.substring(0, d);\n                        return ans;\n        }\nstatic String rightrotate(String str, int d)\n        {\n                        return leftrotate(str, str.length() - d);\n        }", "120": "static Node insertNode(Node start, int value)\n{\n        if (start == null)\n        {\n                Node new_node = new Node();\n                new_node.data = value;\n                new_node.next = new_node.prev = new_node;\n                start = new_node;\n                return new_node;\n        }\n        Node last = (start).prev;\n        Node new_node = new Node();\n        new_node.data = value;\n        new_node.next = start;\n        (start).prev = new_node;\n        new_node.prev = last;\n        last.next = new_node;\n        return start;\n}\nstatic void displayList(Node start)\n{\n        Node temp = start;\n        while (temp.next != start)\n        {\n                System.out.printf(\"%d \", temp.data);\n                temp = temp.next;\n        }\n        System.out.printf(\"%d \", temp.data);\n}\nstatic int searchList(Node start, int search)\n{\n        Node temp = start;\n        int count = 0, flag = 0, value;\n        if(temp == null)\n                return -1;\n        else\n        {\n                while(temp.next != start)\n                {\n                        count++;\n                        if(temp.data == search)\n                        {\n                                flag = 1;\n                                count--;\n                                break;\n                        }\n                        temp = temp.next;\n                }\n                if(temp.data == search)\n                {\n                        count++;\n                        flag = 1;\n                }\n                if(flag == 1)\n                        System.out.println(\"\\n\"+search +\" found at location \"+ count);\n                else\n                        System.out.println(\"\\n\"+search +\" not found\");\n        }\n        return -1;\n}", "121": "static Node getNode(int data)\n{\n        Node newNode = new Node();\n        newNode.data = data;\n        return newNode;\n}\nstatic Node insertEnd(Node head, Node new_node)\n{\n        if (head == null)\n        {\n                new_node.next = new_node.prev = new_node;\n                head = new_node;\n                return head;\n        }\n        Node last = (head).prev;\n        new_node.next = head;\n        (head).prev = new_node;\n        new_node.prev = last;\n        last.next = new_node;\n        return head;\n}\nstatic Node reverse(Node head)\n{\n        if (head==null)\n                return null;\n        Node new_head = null;\n        Node last = head.prev;\n        Node curr = last, prev;\n        while (curr.prev != last)\n        {\n                prev = curr.prev;\n                new_head=insertEnd(new_head, curr);\n                curr = prev;\n        }\n        new_head=insertEnd(new_head, curr);\n        return new_head;\n}\nstatic void display(Node head)\n{\n        if (head==null)\n                return;\n        Node temp = head;\n        System.out.print( \"Forward direction: \");\n        while (temp.next != head)\n        {\n                System.out.print( temp.data + \" \");\n                temp = temp.next;\n        }\n                System.out.print( temp.data + \" \");\n        Node last = head.prev;\n        temp = last;\n        System.out.print( \"\\nBackward direction: \");\n        while (temp.prev != last)\n        {\n                System.out.print( temp.data + \" \");\n                temp = temp.prev;\n        }\n                System.out.print( temp.data + \" \");\n}", "122": "static void addEdge(int u, int v)\n        {\n                adj[u].add(v);\n                adj[v].add(u);\n        }\nstatic void dfs(int cur, int prev)\n        {\n                parent[cur] = prev;\n                depth[cur] = depth[prev] + 1;\n                for (int i = 0; i < adj[cur].size(); i++)\n                        if (adj[cur].elementAt(i) != prev)\n                                dfs(adj[cur].elementAt(i), cur);\n        }\nstatic void preprocess()\n        {\n                depth[0] = -1;\n                dfs(1, 0);\n        }\nstatic int LCANaive(int u, int v)\n        {\n                if (u == v)\n                        return u;\n                if (depth[u] > depth[v])\n                {\n                        int temp = u;\n                        u = v;\n                        v = temp;\n                }\n                v = parent[v];\n                return LCANaive(u, v);\n        }", "123": "static void addEdge(int u,int v)\n{\n        adj[u].add(v);\n        adj[v].add(u);\n}\nstatic int LCANaive(int u,int v)\n{\n        if (u == v) return u;\n        if (depth[u] > depth[v])\n        {\n                int t = u;\n                u = v;\n                v = t;\n        }        \n        v = parent[v];\n        return LCANaive(u, v);\n}\nstatic void dfs(int cur, int prev)\n{\n        depth[cur] = depth[prev] + 1;\n        parent[cur] = prev;\n        if (depth[cur] % block_sz == 0)\n                jump_parent[cur] = parent[cur];\n        else\n                jump_parent[cur] = jump_parent[prev];\n        for (int i = 0; i < adj[cur].size(); ++i)\n                if (adj[cur].get(i) != prev)\n                        dfs(adj[cur].get(i), cur);\n}\nstatic int LCASQRT(int u, int v)\n{\n        while (jump_parent[u] != jump_parent[v])\n        {\n                if (depth[u] > depth[v])\n                {\n                        int t = u;\n                        u = v;\n                        v = t;\n                }\n                v = jump_parent[v];\n        }\n        return LCANaive(u, v);\n}\nstatic void preprocess(int height)\n{\n        block_sz = (int)Math.sqrt(height);\n        depth[0] = -1;\n        dfs(1, 0);\n}", "124": "public static int find_permutations( Vector<Integer> arr)\n{\n        int cnt = 0;\n        int max_ind = -1, min_ind = 10000000;\n        int n = arr.size();\n        HashMap<Integer,\n                        Integer> index_of = new HashMap<>();\n        for(int i = 0; i < n; i++)\n        {\n                index_of.put(arr.get(i), i + 1);\n        }\n        for(int i = 1; i <= n; i++)\n        {\n                max_ind = Math.max(max_ind, index_of.get(i));\n                min_ind = Math.min(min_ind, index_of.get(i));\n                if (max_ind - min_ind + 1 == i)\n                        cnt++;\n        }\n        return cnt;\n}", "125": "This data point is missing", "126": "static int countOfNum( int n, int a, int b)\n        {\n                int cnt_of_a, cnt_of_b, cnt_of_ab, sum;\n                cnt_of_a = n / a;\n                cnt_of_b = n / b;\n                sum = cnt_of_b + cnt_of_a;\n                cnt_of_ab = n / (a * b);\n                sum = sum - cnt_of_ab;\n                return sum;\n        }\nstatic int sumOfNum( int n, int a, int b)\n        {\n                int i;\n                int sum = 0;\n                Set< Integer> ans = new HashSet<Integer>();\n                for (i = a; i <= n; i = i + a) {\n                        ans.add(i);\n                }\n                for (i = b; i <= n; i = i + b) {\n                        ans.add(i);\n                }\n                for (Integer it : ans) {\n                        sum = sum + it;\n                }\n                return sum;\n        }", "127": "static void maximumArea(int l, int b, int x, int y)\n{\n        int left, right, above, below;\n        left = x * b;\n        right = (l - x - 1) * b;\n        above = l * y;\n        below = (b - y - 1) * l;\n        System.out.print(Math.max(Math.max(left, right),\n                                Math.max(above, below)));\n}", "128": "static void precompute()\n{\n        F[1] = 2;\n        F[2] = 3;\n        F[3] = 4;\n        for (int i = 4; i < N; i++)\n                F[i] = (F[i - 1] + F[i - 2]) % MOD;\n}", "129": "static double get(double L, double R)\n{\n        double x = 1.0 / L;\n        double y = 1.0 / (R + 1.0);\n        return (x - y);\n}", "130": "public static int upper_bound(ArrayList<Integer> ar, int k)\n{\n        int s = 0;\n        int e = ar.size();\n        while (s != e)\n        {\n                int mid = s + e >> 1;\n                if (ar.get(mid) <= k)\n                {\n                        s = mid + 1;\n                }\n                else\n                {\n                        e = mid;\n                }\n        }\n        if (s == ar.size())\n        {\n                return -1;\n        }\n        return s;\n}\nstatic int consecutiveOnes(int x)\n{\n        int p = 0;\n        while (x > 0)\n        {\n                if (x % 2 == 1 && p == 1)\n                {\n                        return 1;\n                }\n                p = x % 2;\n                x /= 2;\n        }\n        return 0;\n}\nstatic void preCompute()\n{\n        for(int i = 0; i <= MAX; i++)\n        {\n                if (consecutiveOnes(i) == 0)\n                {\n                        v.add(i);\n                }\n        }\n}\nstatic int nextValid(int n)\n{\n        int it = upper_bound(v,n);\n        int val = v.get(it);\n        return val;\n}\nstatic void performQueries(int queries[], int q)\n{\n        for(int i = 0; i < q; i++)\n        {\n                System.out.println(nextValid(queries[i]));\n        }\n}", "131": "static int changeToOnes(String str)\n{\n        int i, l, ctr = 0;\n        l = str.length();\n        for (i = l - 1; i >= 0; i--)\n        {\n                if (str.charAt(i) == '1')\n                        ctr++;\n                else\n                        break;\n        }\n        return l - ctr;\n}\nstatic String removeZeroesFromFront(String str)\n{\n        String s;\n        int i = 0;\n        while (i < str.length() &&\n                        str.charAt(i) == '0')\n                i++;\n        if (i == str.length())\n                s = \"0\";\n        else\n                s = str.substring(i, str.length() - i);\n        return s;\n}", "132": "static int calgcd(int a, int b)\n        {\n                if (b == 0)\n                        return a;\n                return calgcd(b, a % b);\n        }\nstatic int getCount(int [] a, int n)\n        {\n                int gcd = 0;\n                for (int i = 0; i < n; i++)\n                        gcd = calgcd(gcd, a[i]);\n                int cnt = 0;\n                for (int i = 1; i * i <= gcd; i++)\n                {\n                        if (gcd % i == 0)\n                        {\n                                if (i * i == gcd)\n                                        cnt++;\n                                else\n                                        cnt += 2;\n                        }\n                }\n                return cnt;\n        }", "133": "static int MinDeletion(int a[], int n)\n{\n        Map<Integer,Integer> mp = new HashMap<>();\n        for (int i = 0 ; i < n; i++)\n        {\n                if(mp.containsKey(a[i]))\n                {\n                        mp.put(a[i], mp.get(a[i])+1);\n                }\n                else\n                {\n                        mp.put(a[i], 1);\n                }\n        }\n        int ans = 0;\n        for (Map.Entry<Integer,Integer> i : mp.entrySet())\n        {\n                int x = i.getKey();\n                int frequency = i.getValue();\n                if (x <= frequency)\n                {\n                        ans += (frequency - x);\n                }\n                else\n                        ans += frequency;\n        }\n        return ans;\n}", "134": "static int maxCountAB(String s[], int n)\n{\n        int A = 0, B = 0, BA = 0, ans = 0;\n        for (int i = 0; i < n; i++)\n        {\n                String S = s[i];\n                int L = S.length();\n                for (int j = 0; j < L - 1; j++)\n                {\n                        if (S.charAt(j) == 'A' &&\n                                                S.charAt(j + 1) == 'B')\n                        {\n                                ans++;\n                        }\n                }\n                if (S.charAt(0) == 'B' && S.charAt(L - 1) == 'A')\n                        BA++;\n                else if (S.charAt(0) == 'B')\n                        B++;\n                else if (S.charAt(L - 1) == 'A')\n                        A++;\n        }\n        if (BA == 0)\n                ans += Math.min(B, A);\n        else if (A + B == 0)\n                ans += BA - 1;\n        else\n                ans += BA + Math.min(B, A);\n        return ans;\n}", "135": "static int MinOperations(int n, int x, int[] arr)\n{\n        int total = 0;\n        for (int i = 0; i < n; ++i)\n        {\n                if (arr[i] > x)\n                {\n                        int difference = arr[i] - x;\n                        total = total + difference;\n                        arr[i] = x;\n                }\n        }\n        for (int i = 1; i < n; ++i)\n        {\n                int LeftNeigbouringSum = arr[i] + arr[i - 1];\n                if (LeftNeigbouringSum > x)\n                {\n                        int current_diff = LeftNeigbouringSum - x;\n                        arr[i] = Math.max(0, arr[i] - current_diff);\n                        total = total + current_diff;\n                }\n        }\n        return total;\n}", "136": "static void findNumbers(int arr[], int n)\n        {\n                int sumN = (n * (n + 1)) / 2;\n                int sumSqN = (n * (n + 1) * (2 * n + 1)) / 6;\n                int sum = 0, sumSq = 0, i;\n                for (i = 0; i < n; i++) {\n                        sum += arr[i];\n                        sumSq += Math.pow(arr[i], 2);\n                }\n                int B = (((sumSq - sumSqN) / (sum - sumN)) + sumN - sum) / 2;\n                int A = sum - sumN + B;\n                System.out.println(\"A = \" + A + \"\\nB = \" + B);\n        }", "137": "static boolean is_prefix(String temp, String str)\n        {\n                if (temp.length() < str.length())\n                        return false;\n                else {\n                        for (int i = 0; i < str.length(); i++) {\n                                if (str.charAt(i) != temp.charAt(i))\n                                        return false;\n                        }\n                        return true;\n                }\n        }\nstatic String lexicographicallyString(String[] input, int n, String str)\n        {\n                Arrays.sort(input);\n                for (int i = 0; i < n; i++) {\n                        String temp = input[i];\n                        if (is_prefix(temp, str)) {\n                                return temp;\n                        }\n                }\n                return \"-1\";\n        }", "138": "static void Rearrange(int arr[], int K, int N)\n{\n        int ans[] = new int[N + 1];\n        int f = -1;\n        for (int i = 0; i < N; i++) {\n                ans[i] = -1;\n        }\n for (int i = 0; i < arr.length; i++)\n {\n        if (arr[i] == K)\n        {\n                K = i;\n                break;\n        }\n }\n        Vector<Integer> smaller = new Vector<Integer>();\n        Vector<Integer> greater = new Vector<Integer>();\n        for (int i = 0; i < N; i++) {\n                if (arr[i] < arr[K])\n                        smaller.add(arr[i]);\n                else if (arr[i] > arr[K])\n                        greater.add(arr[i]);\n        }\n        int low = 0, high = N - 1;\n        while (low <= high) {\n                int mid = (low + high) / 2;\n                if (mid == K) {\n                        ans[mid] = arr[K];\n                        f = 1;\n                        break;\n                }\n                else if (mid < K) {\n                        if (smaller.size() == 0) {\n                                break;\n                        }\n                        ans[mid] = smaller.lastElement();\n                        smaller.remove(smaller.size()-1);\n                        low = mid + 1;\n                }\n                else {\n                        if (greater.size() == 0) {\n                                break;\n                        }\n                        ans[mid] = greater.lastElement();\n                        greater.remove(greater.size()-1);\n                        high = mid - 1;\n                }\n        }\n        if (f == -1) {\n                System.out.println(-1 );\n                return;\n        }\n        for (int i = 0; i < N; i++) {\n                if (ans[i] == -1) {\n                        if (smaller.size()>0) {\n                                ans[i] = smaller.lastElement();\n                                smaller.remove(smaller.size()-1);\n                        }\n                        else if (greater.size()>0) {\n                                ans[i] = greater.lastElement();\n                                greater.remove(greater.size()-1);\n                        }\n                }\n        }\n        for (int i = 0; i < N; i++)\n                System.out.print(ans[i] +\" \");\n        System.out.println();\n}", "139": "static void minimumK(ArrayList<Integer> arr, int M, int N)\n{\n        int good = (int)((N * 1.0) / ((M + 1) * 1.0)) + 1;\n        for(int i = 1; i <= N; i++)\n        {\n                int K = i;\n                int candies = N;\n                int taken = 0;\n                while (candies > 0)\n                {\n                        taken += Math.min(K, candies);\n                        candies -= Math.min(K, candies);\n                        for(int j = 0; j < M; j++)\n                        {\n                                int consume = (arr.get(j) * candies) / 100;\n                                candies -= consume;\n                        }\n                }\n                if (taken >= good)\n                {\n                        System.out.print(i);\n                        return;\n                }\n        }\n}", "140": "static boolean check(int K, int n, int m, ArrayList<Integer> arr, int good_share)\n{\n        int candies = n, taken = 0;\n        while (candies > 0) {\n                taken += Math.min(K, candies);\n                candies -= Math.min(K, candies);\n                for (int j = 0; j < m; j++) {\n                        int consume = (arr.get(j) * candies) / 100;\n                        candies -= consume;\n                }\n        }\n        return (taken >= good_share);\n}\nstatic void minimumK(ArrayList<Integer> arr, int N, int M)\n{\n        int good_share = (int)Math.ceil((N * 1.0)\n                                                / ((M + 1) * 1.0));\n        int lo = 1, hi = N;\n        while (lo < hi) {\n                int mid = (lo + hi) / 2;\n                if (check(mid, N, M, arr, good_share)) {\n                        hi = mid;\n                }\n                else {\n                        lo = mid + 1;\n                }\n        }\n        System.out.print(hi);\n}", "141": "static void calcTotalTime(String path)\n{\n        int time = 0;\n        int x = 0, y = 0;\n        Set<String> s = new HashSet<>();\n        for(int i = 0; i < path.length(); i++)\n        {\n                int p = x;\n                int q = y;\n                if (path.charAt(i) == 'N')\n                        y++;\n                else if (path.charAt(i) == 'S')\n                        y--;\n                else if (path.charAt(i) == 'E')\n                        x++;\n                else if (path.charAt(i) == 'W')\n                        x--;\n                String o = (p + x) + \" \" + (q + y);\n                if (!s.contains(o))\n                {\n                        time += 2;\n                        s.add(o);\n                }\n                else\n                        time += 1;\n        }\n        System.out.println(time);\n}", "142": "static void calcPsquare(int N)\n        {\n                for (int i = 1; i * i <= N; i++)\n                        psquare.add(i * i);\n        }\nstatic int countWays(int index, int target)\n        {\n                if (target == 0)\n                        return 1;\n                if (index < 0 target < 0)\n                        return 0;\n                int inc\n                        = countWays(index, target - psquare.get(index));\n                int exc = countWays(index - 1, target);\n                return inc + exc;\n        }", "143": "static int findCost(int[] A, int N)\n{\n        int totalCost = 0;\n        for(int i = 0; i < N; i++)\n        {\n                if (A[i] == 0)\n                {\n                        A[i] = 1;\n                        totalCost += i;\n                }\n        }\n        return totalCost;\n}", "144": "static int countNumbers(int L, int R, int K)\n        {\n                ArrayList<Integer> list\n                        = new ArrayList<>();\n                for (int i = L; i <= R; i++) {\n                        if (isPalindrome(i)) {\n                                list.add(i);\n                        }\n                }\n                int count = 0;\n                for (int i = 0; i < list.size(); i++) {\n                        int right_index\n                                = search(list, list.get(i) + K - 1);\n                        if (right_index != -1)\n                                count = Math.max(count, right_index - i + 1);\n                }\n                return count;\n        }\nstatic int search( ArrayList<Integer> list, int num)\n        {\n                int low = 0, high = list.size() - 1;\n                int ans = -1;\n                while (low <= high) {\n                        int mid = low + (high - low) / 2;\n                        if (list.get(mid) <= num) {\n                                ans = mid;\n                                low = mid + 1;\n                        }\n                        else\n                                high = mid - 1;\n                }\n                return ans;\n        }\nstatic boolean isPalindrome(int n)\n        {\n                int rev = 0;\n                int temp = n;\n                while (n > 0) {\n                        rev = rev * 10 + n % 10;\n                        n /= 10;\n                }\n                return rev == temp;\n        }", "145": "public static int peakIndex(int[] arr)\n        {\n                int N = arr.length;\n                if (arr.length < 3)\n                        return -1;\n                int i = 0;\n                while (i + 1 < N) {\n                        if (arr[i + 1] < arr[i] arr[i] == arr[i + 1])\n                                break;\n                        i++;\n                }\n                if (i == 0 i == N - 1)\n                        return -1;\n                int ans = i;\n                while (i < N - 1) {\n                        if (arr[i] < arr[i + 1] arr[i] == arr[i + 1])\n                                break;\n                        i++;\n                }\n                if (i == N - 1)\n                        return ans;\n                return -1;\n        }", "146": "static void hasArrayTwoPairs(int nums[], int n, int target)\n {\n        Arrays.sort(nums);\n        for (int i = 0; i < n; i++) {\n        int x = target - nums[i];\n        int low = 0, high = n - 1;\n        while (low <= high) {\n                int mid = low\n                + ((high - low) / 2);\n                if (nums[mid] > x) {\n                high = mid - 1;\n                }\n                else if (nums[mid] < x) {\n                low = mid + 1;\n                }\n                else {\n                if (mid == i) {\n                        if ((mid - 1 >= 0) && nums[mid - 1] == x) {\n                        System.out.print(nums[i] + \", \");\n                        System.out.print( nums[mid - 1]);\n                        return;\n                        }\n                        if ((mid + 1 < n) && nums[mid + 1] == x) {\n                        System.out.print( nums[i] + \", \");\n                        System.out.print( nums[mid + 1]);\n                        return;\n                        }\n                        break;\n                }\n                else {\n                        System.out.print( nums[i] + \", \");\n                        System.out.print(nums[mid]);\n                        return;\n                }\n                }\n        }\n        }\n        System.out.print(-1);\n }", "147": "static TreeNode newNode(int data)\n{\n        TreeNode Node = new TreeNode();\n        Node.data = data;\n        Node.left = null;\n        Node.right = null;\n        return (Node);\n}\nstatic pair sumofsubtree(TreeNode root)\n{\n        pair p = new pair(1, 0);\n        if (root.left != null)\n        {\n                pair ptemp\n                        = sumofsubtree(root.left);\n                p.second += ptemp.first\n                                        + ptemp.second;\n                p.first += ptemp.first;\n        }\n        if (root.right != null)\n        {\n                pair ptemp\n                        = sumofsubtree(root.right);\n                p.second += ptemp.first\n                                        + ptemp.second;\n                p.first += ptemp.first;\n        }\n        root.size = p.first;\n        return p;\n}\nstatic void distance(TreeNode root, int target, int distancesum, int n)\n{\n        if (root.data == target)\n        {\n                sum = distancesum;\n        }\n        if (root.left != null)\n        {\n                int tempsum = distancesum\n                                        - root.left.size\n                                        + (n - root.left.size);\n                distance(root.left, target, tempsum, n);\n        }\n        if (root.right != null)\n        {\n                int tempsum = distancesum\n                                        - root.right.size\n                                        + (n - root.right.size);\n                distance(root.right, target, tempsum, n);\n        }\n}", "148": "public static int delCost(String s, int[] cost)\n {\n        boolean visited[] = new boolean[s.length()];\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++)\n        {\n        if (visited[i])\n        {\n                continue;\n        }\n        int maxDel = 0;\n        int totalCost = 0;\n        visited[i] = true;\n        for (int j = i; j < s.length(); j++)\n        {\n                if (s.charAt(i) == s.charAt(j))\n                {\n                maxDel = Math.max(maxDel, cost[j]);\n                totalCost += cost[j];\n                visited[j] = true;\n                }\n        }\n        ans += totalCost - maxDel;\n        }\n        return ans;\n }", "149": "static int delCost(String s, int[] cost)\n {\n        int ans = 0;\n        HashMap<Character, Integer> forMax = new HashMap<>();\n        HashMap<Character, Integer> forTot = new HashMap<>();\n        for(int i = 0; i < s.length(); i++)\n        {\n        if(!forMax.containsKey(s.charAt(i)))\n        {\n                forMax.put(s.charAt(i), cost[i]);\n        }\n        else\n        {\n                forMax.put(s.charAt(i), Math.max(cost[i], forMax.get(s.charAt(i))));\n        }\n        if(!forTot.containsKey(s.charAt(i)))\n        {\n                forTot.put(s.charAt(i), cost[i]);\n        }\n        else\n        {\n                forTot.put(s.charAt(i), forTot.get(s.charAt(i)) + cost[i]);\n        }\n        }\n        for (Map.Entry<Character, Integer> i : forMax.entrySet())\n        {\n        ans += forTot.get(i.getKey()) - i.getValue();\n        }\n        return ans;\n }", "150": "static void findClosest(int N, int target)\n {\n        int closest = -1;\n        int diff = Integer.MAX_VALUE;\n        for (int i = 1; i <= (int)Math.sqrt(N); i++) {\n        if (N % i == 0) {\n                if (N / i == i) {\n                if (Math.abs(target - i) < diff)\n                {\n                        diff = Math.abs(target - i);\n                        closest = i;\n                }\n                }\n                else {\n                if (Math.abs(target - i) < diff)\n                {\n                        diff = Math.abs(target - i);\n                        closest = i;\n                }\n                if (Math.abs(target - N / i) < diff)\n                {\n                        diff = Math.abs(target - N / i);\n                        closest = N / i;\n                }\n                }\n        }\n        }\n        System.out.println(closest);\n }", "151": "static void computeDivisors()\n{\n        for (int i = 1; i <= MAX; i++)\n        {\n                for (int j = i; j <= MAX; j += i)\n                {\n                        divisors[j].add(i);\n                }\n        }\n}\nstatic int getClosest(int val1, int val2, int target)\n{\n        if (target - val1 >= val2 - target)\n                return val2;\n        else\n                return val1;\n}\nstatic int findClosest(Vector<Integer> array, int n, int target)\n{\n        Integer []arr = array.toArray(new Integer[array.size()]);\n        if (target <= arr[0])\n                return arr[0];\n        if (target >= arr[n - 1])\n                return arr[n - 1];\n        int i = 0, j = n, mid = 0;\n        while (i < j)\n        {\n                mid = (i + j) / 2;\n                if (arr[mid] == target)\n                        return arr[mid];\n                if (target < arr[mid])\n                {\n                        if (mid > 0 && target > arr[mid - 1])\n                                return getClosest(arr[mid - 1], arr[mid], target);\n                        j = mid;\n                }\n                else\n                {\n                        if (mid < n - 1 && target < arr[mid + 1])\n                                return getClosest(arr[mid], arr[mid + 1], target);\n                        i = mid + 1;\n                }\n        }\n        return arr[mid];\n}\nstatic void printClosest(int N, int X)\n{\n        computeDivisors();\n        int ans\n                = findClosest(divisors[N], divisors[N].size(), X);\n        System.out.print(ans);\n}", "152": "static void countTriplets(int []arr, int N)\n{\n        Vector<Integer> zero_i = new Vector<Integer>();\n        Vector<Integer> one_i = new Vector<Integer>();\n        HashMap<Integer,\n                        Integer> mp = new HashMap<Integer,\n                                                                        Integer>();\n        for(int i = 0; i < N; i++)\n        {\n                if (arr[i] == 0)\n                        zero_i.add(i + 1);\n                else if (arr[i] == 1)\n                        one_i.add(i + 1);\n                else\n                        mp.put(i + 1, 1);\n        }\n        int total = zero_i.size() *\n                                one_i.size() * mp.size();\n        for(int i = 0; i < zero_i.size(); i++)\n        {\n                for(int j = 0; j < one_i.size(); j++)\n                {\n                        int p = zero_i.get(i);\n                        int q = one_i.get(j);\n                        int r = 2 * p - q;\n                        if (mp.containsKey(r) && mp.get(r) > 0)\n                                total--;\n                        r = 2 * q - p;\n                        if (mp.containsKey(r) && mp.get(r) > 0)\n                                total--;\n                        r = (p + q) / 2;\n                        if (mp.containsKey(r) &&\n                                        mp.get(r) > 0 &&\n                                Math.abs(r - p) == Math.abs(r - q))\n                                total--;\n                }\n        }\n        System.out.print(total);\n}", "153": "static int power(int A, int N)\n{\n        int count = 0;\n        if (A == 1)\n                return 0;\n        while (N > 0)\n        {\n                count++;\n                N /= A;\n        }\n        return count;\n}\nstatic void Pairs(int N, int A, int B)\n{\n        int powerA, powerB;\n        powerA = power(A, N);\n        powerB = power(B, N);\n        int intialB = B, intialA = A;\n        A = 1;\n        for(int i = 0; i <= powerA; i++)\n        {\n                B = 1;\n                for(int j = 0; j <= powerB; j++)\n                {\n                        if (B == N - A)\n                        {\n                                System.out.println(i + \" \" + j);\n                                return;\n                        }\n                        B *= intialB;\n                }\n                A *= intialA;\n        }\n        System.out.println(\"-1\");\n        return;\n}", "154": "public static int findNonMultiples(int[] arr, int n, int k)\n{\n        Set<Integer> multiples = new HashSet<Integer>();\n        for(int i = 0; i < n; ++i)\n        {\n                if (!multiples.contains(arr[i]))\n                {\n                        for(int j = 1; j <= k / arr[i]; j++)\n                        {\n                                multiples.add(arr[i] * j);\n                        }\n                }\n        }\n        return k - multiples.size();\n}\npublic static int countValues(int[] arr, int N, int L, int R)\n{\n        return findNonMultiples(arr, N, R) -\n                findNonMultiples(arr, N, L - 1);\n}", "155": "static int maxMatch(int[] A, int[] B)\n {\n        HashMap<Integer, Integer> Aindex = new HashMap<Integer, Integer>();\n        HashMap<Integer, Integer> diff = new HashMap<Integer, Integer>();\n        for (int i = 0; i < A.length; i++)\n        {\n        Aindex.put(A[i], i);\n        }\n        for (int i = 0; i < B.length; i++)\n        {\n        if (i - Aindex.get(B[i]) < 0)\n        {\n                if (!diff.containsKey(A.length + i - Aindex.get(B[i])))\n                {\n                diff.put(A.length + i - Aindex.get(B[i]), 1);\n                } else {\n                diff.put(A.length + i - Aindex.get(B[i]), diff.get(A.length + i - Aindex.get(B[i])) + 1);\n                }\n        }\n        else {\n                if (!diff.containsKey(i - Aindex.get(B[i]))) {\n                diff.put(i - Aindex.get(B[i]), 1);\n                }\n                else\n                {\n                diff.put(i - Aindex.get(B[i]),\n                                diff.get(i - Aindex.get(B[i])) + 1);\n                }\n        }\n        }\n        int max = 0;\n        for (Map.Entry<Integer, Integer> ele : diff.entrySet())\n        {\n        if (ele.getValue() > max)\n        {\n                max = ele.getValue();\n        }\n        }\n        return max;\n }", "156": "static void checkXOR(int arr[], int N)\n{\n        if (N % 2 == 0)\n        {\n                int xro = 0;\n                for(int i = 0; i < N; i++)\n                {\n                        xro ^= arr[i];\n                }\n                if (xro != 0)\n                {\n                        System.out.println(-1);\n                        return;\n                }\n                for(int i = 0; i < N - 3; i += 2)\n                {\n                        System.out.println(i + \" \" + (i + 1) +\n                                                                \" \" + (i + 2));\n                }\n                for(int i = 0; i < N - 3; i += 2)\n                {\n                        System.out.println(i + \" \" + (i + 1) +\n                                                                \" \" + (N - 1));\n                }\n        }\n        else\n        {\n                for(int i = 0; i < N - 2; i += 2)\n                {\n                        System.out.println(i + \" \" + (i + 1) +\n                                                                \" \" + (i + 2));\n                }\n                for(int i = 0; i < N - 2; i += 2)\n                {\n                        System.out.println(i + \" \" + (i + 1) +\n                                                                \" \" + (N - 1));\n                }\n        }\n}", "157": "static int make_array_element_even(int arr[], int N)\n {\n        int res = 0;\n        int odd_cont_seg = 0;\n        for (int i = 0; i < N; i++)\n        {\n        if (arr[i] % 2 == 1)\n        {\n                odd_cont_seg++;\n        }\n        else\n        {\n                if (odd_cont_seg > 0)\n                {\n                if (odd_cont_seg % 2 == 0)\n                {\n                        res += odd_cont_seg / 2;\n                }\n                else\n                {\n                        res += (odd_cont_seg / 2) + 2;\n                }\n                odd_cont_seg = 0;\n                }\n        }\n        }\n        if (odd_cont_seg > 0)\n        {\n        if (odd_cont_seg % 2 == 0)\n        {\n                res += odd_cont_seg / 2;\n        }\n        else\n        {\n                res += odd_cont_seg / 2 + 2;\n        }\n        }\n        return res;\n }", "158": "static void minCollectingSpeed(int[] piles, int H)\n{\n        int ans = -1;\n        int low = 1, high;\n        high = Arrays.stream(piles).max().getAsInt();\n        while (low <= high)\n        {\n                int K = low + (high - low) / 2;\n                int time = 0;\n                for(int ai : piles)\n                {\n                        time += (ai + K - 1) / K;\n                }\n                if (time <= H)\n                {\n                        ans = K;\n                        high = K - 1;\n                }\n                else\n                {\n                        low = K + 1;\n                }\n        }\n        System.out.print(ans);\n}", "159": "static int cntDisPairs(int arr[], int N, int K)\n{\n        int cntPairs = 0;\n        Arrays.sort(arr);\n        int i = 0;\n        int j = N - 1;\n        while (i < j) {\n                if (arr[i] + arr[j] == K) {\n                        while (i < j && arr[i] == arr[i + 1]) {\n                                i++;\n                        }\n                        while (i < j && arr[j] == arr[j - 1]) {\n                                j--;\n                        }\n                        cntPairs += 1;\n                        i++;\n                        j--;\n                }\n                else if (arr[i] + arr[j] < K) {\n                        i++;\n                }\n                else {\n                        j--;\n                }\n        }\n        return cntPairs;\n}", "160": "static int cntDisPairs(int arr[], int N, int K)\n{\n        int cntPairs = 0;\n        HashMap<Integer,Integer> cntFre = new HashMap<Integer,Integer>();\n        for (int i = 0; i < N; i++)\n        {\n                if(cntFre.containsKey(arr[i]))\n                        cntFre.put(arr[i], cntFre.get(arr[i]) + 1);\n                else\n                        cntFre.put(arr[i], 1);\n        }\n        for (Map.Entry<Integer,Integer> it : cntFre.entrySet())\n        {\n                int i = it.getKey();\n                if (2 * i == K)\n                {\n                        if (cntFre.get(i) > 1)\n                                cntPairs += 2;\n                }\n                else\n                {\n                        if (cntFre.containsKey(K - i))\n                        {\n                                cntPairs += 1;\n                        }\n                }\n        }\n        cntPairs = cntPairs / 2;\n        return cntPairs;\n}", "161": "static Node push(Node head_ref, int new_data)\n {\n        Node new_node = new Node();\n        new_node.data = new_data;\n        new_node.prev = null;\n        new_node.next = head_ref;\n        if (head_ref != null)\n        {\n        head_ref.prev = new_node;\n        }\n        head_ref = new_node;\n        return head_ref;\n }\nstatic int search(Node head_ref, int x)\n {\n        Node temp = head_ref;\n        int pos = 0;\n        while (temp.data != x && temp.next != null)\n        {\n        pos++;\n        temp = temp.next;\n        }\n        if (temp.data != x)\n        return -1;\n        return (pos + 1);\n }", "162": "static void longestSubsequence(int N, int Q, int arr[], int Queries[][])\n{\n        for (int i = 0; i < Q; i++)\n        {\n                int x = Queries[i][0];\n                int y = Queries[i][1];\n                arr[x - 1] = y;\n                int count = 1;\n                for (int j = 1; j < N; j++)\n                {\n                        if (arr[j] != arr[j - 1])\n                        {\n                                count += 1;\n                        }\n                }\n                System.out.print(count +\" \");\n        }\n}", "163": "static void longestSubsequence(int N, int Q, int arr[], int Queries[][])\n{\n        int count = 1;\n        for(int i = 1; i < N; i++)\n        {\n                if (arr[i] != arr[i - 1])\n                {\n                        count += 1;\n                }\n        }\n        for(int i = 0; i < Q; i++)\n        {\n                int x = Queries[i][0];\n                int y = Queries[i][1];\n                if (x > 1)\n                {\n                        if (arr[x - 1] != arr[x - 2])\n                        {\n                                count -= 1;\n                        }\n                        if (arr[x - 2] != y)\n                        {\n                                count += 1;\n                        }\n                }\n                if (x < N)\n                {\n                        if (arr[x] != arr[x - 1])\n                        {\n                                count -= 1;\n                        }\n                        if (y != arr[x])\n                        {\n                                count += 1;\n                        }\n                }\n                System.out.print(count + \" \");\n                arr[x - 1] = y;\n        }\n}", "164": "static void sum(int arr[], int n)\n{\n        HashMap<Integer, Vector<Integer>> mp = new HashMap<>();\n        for(int i = 0; i < n; i++)\n        {\n                Vector<Integer> v = new Vector<>();\n                v.add(i);\n                if (mp.containsKey(arr[i]))\n                        v.addAll(mp.get(arr[i]));\n                mp.put(arr[i], v);\n        }\n        int []ans = new int[n];\n        for(int i = 0; i < n; i++)\n        {\n                int sum = 0;\n                for(int it : mp.get(arr[i]))\n                {\n                        sum += Math.abs(it - i);\n                }\n                ans[i] = sum;\n        }\n        for(int i = 0; i < n; i++)\n        {\n                System.out.print(ans[i] + \" \");\n        }\n        ", "165": "static int[] reverse(int a[])\n{\n        int i, n = a.length, t;\n        for(i = 0; i < n / 2; i++)\n        {\n                t = a[i];\n                a[i] = a[n - i - 1];\n                a[n - i - 1] = t;\n        }\n        return a;\n}\nstatic void rearrangeArray(int A[], int B[], int N, int K)\n{\n        Arrays.sort(B);\n        B = reverse(B);\n        boolean flag = true;\n        for(int i = 0; i < N; i++)\n        {\n                if (A[i] + B[i] > K)\n                {\n                        flag = false;\n                        break;\n                }\n        }\n        if (!flag)\n        {\n                System.out.print(\"-1\" + \"\\n\");\n        }\n        else\n        {\n                for(int i = 0; i < N; i++)\n                {\n                        System.out.print(B[i] + \" \");\n                }\n        }\n}", "166": "static boolean isinRange(int[][] board)\n{\n        for(int i = 0; i < N; i++)\n        {\n                for(int j = 0; j < N; j++)\n                {\n                        if (board[i][j] <= 0 board[i][j] > 9)\n                        {\n                                return false;\n                        }\n                }\n        }\n        return true;\n}\nstatic boolean isValidSudoku(int board[][])\n{\n        if (isinRange(board) == false)\n        {\n                return false;\n        }\n        boolean[] unique = new boolean[N + 1];\n        for(int i = 0; i < N; i++)\n        {\n                Arrays.fill(unique, false);\n                for(int j = 0; j < N; j++)\n                {\n                        int Z = board[i][j];\n                        if (unique[Z])\n                        {\n                                return false;\n                        }\n                        unique[Z] = true;\n                }\n        }\n        for(int i = 0; i < N; i++)\n        {\n                Arrays.fill(unique, false);\n                for(int j = 0; j < N; j++)\n                {\n                        int Z = board[j][i];\n                        if (unique[Z])\n                        {\n                                return false;\n                        }\n                        unique[Z] = true;\n                }\n        }\n        for(int i = 0; i < N - 2; i += 3)\n        {\n                for(int j = 0; j < N - 2; j += 3)\n                {\n                        Arrays.fill(unique, false);\n                        for(int k = 0; k < 3; k++)\n                        {\n                                for(int l = 0; l < 3; l++)\n                                {\n                                        int X = i + k;\n                                        int Y = j + l;\n                                        int Z = board[X][Y];\n                                        if (unique[Z])\n                                        {\n                                                return false;\n                                        }\n                                        unique[Z] = true;\n                                }\n                        }\n                }\n        }\n        return true;\n}", "167": "static void conVowUpp(char[] str)\n{\n int N = str.length;\n for (int i = 0; i < N; i++)\n {\n        if (str[i] == 'a' str[i] == 'e' str[i] == 'i' str[i] == 'o' str[i] == 'u')\n        {\n        char c = Character.toUpperCase(str[i]);\n        str[i] = c;\n        }\n }\n for(char c : str)\n        System.out.print(c);\n}", "168": "public static int zvalue(int[] nums)\n{\n        int m = max_element(nums);\n        int cnt = 0;\n        for(int i = 0; i <= m; i++)\n        {\n                cnt = 0;\n                for(int j = 0; j < nums.length; j++)\n                {\n                        if (nums[j] >= i)\n                                cnt++;\n                }\n                if (cnt == i)\n                        return i;\n        }\n        return -1;\n}\npublic static int max_element(int[] nums)\n{\n        int max = nums[0];\n        for(int i = 1; i < nums.length; i++)\n                max = Math.max(max, nums[i]);\n        return max;\n}", "169": "public static boolean palindrome(int[] a, int i, int j)\n        {\n                while(i<j)\n                {\n                        if(a[i] != a[j])\n                                return false;\n                        i++;\n                        j--;\n                }\n                return true;\n        }\nstatic int findSubArray(int []arr, int k)\n        {\n                int n= arr.length;\n                for(int i=0; i<=n-k; i++){\n                        if(palindrome(arr, i, i+k-1))\n                                return i;\n                }\n                return -1;\n        }", "170": "static boolean helper(int mid)\n{\n        int cnt = 0;\n        for(Map.Entry<Integer, Integer> i : mp.entrySet())\n        {\n                int temp = i.getValue();\n                while (temp >= mid)\n                {\n                        temp -= mid;\n                        cnt++;\n                }\n        }\n        return cnt >= N;\n}\nstatic int findMaximumDays(int arr[])\n{\n        for(int i = 0; i < P; i++)\n        {\n                if (mp.containsKey(arr[i]))\n                {\n                        mp.put(arr[i], mp.get(arr[i]) + 1);\n                }\n                else\n                {\n                        mp.put(arr[i], 1);\n                }\n        }\n        int start = 0, end = P, ans = 0;\n        while (start <= end)\n        {\n                int mid = start +\n                                ((end - start) / 2);\n                if (mid != 0 && helper(mid))\n                {\n                        ans = mid;\n                        start = mid + 1;\n                }\n                else if (mid == 0)\n                {\n                        start = mid + 1;\n                }\n                else\n                {\n                        end = mid - 1;\n                }\n        }\n        return ans;\n}", "171": "static void countSubarrays(int a[], int n, int k)\n{\n        int ans = 0;\n        ArrayList<Integer> pref = new ArrayList<>();\n        pref.add(0);\n        for(int i = 0; i < n; i++)\n                pref.add((a[i] + pref.get(i)) % k);\n        for(int i = 1; i <= n; i++)\n        {\n                for(int j = i; j <= n; j++)\n                {\n                        if ((pref.get(j) -\n                                pref.get(i - 1) + k) % k == j - i + 1)\n                        {\n                                ans++;\n                        }\n                }\n        }\n        System.out.println(ans);\n}", "172": "static void countSubarrays(int a[], int n, int k)\n{\n        HashMap<Integer, Integer> cnt = new HashMap<>();\n        long ans = 0;\n        ArrayList<Integer> pref = new ArrayList<>();\n        pref.add(0);\n        for(int i = 0; i < n; i++)\n                pref.add((a[i] + pref.get(i)) % k);\n        cnt.put(0, 1);\n        for(int i = 1; i <= n; i++)\n        {\n                int remIdx = i - k;\n                if (remIdx >= 0)\n                {\n                        if (cnt.containsKey((pref.get(remIdx) - remIdx % k + k) % k))\n                                cnt.put((pref.get(remIdx) - remIdx % k + k) % k,\n                                cnt.get((pref.get(remIdx) - remIdx % k + k) % k) - 1);\n                        else\n                                cnt.put((pref.get(remIdx) - remIdx % k + k) % k, -1);\n                }\n                if (cnt.containsKey((pref.get(i) - i % k + k) % k))\n                        ans += cnt.get((pref.get(i) - i % k + k) % k);\n                if (cnt.containsKey((pref.get(i) - i % k + k) % k))\n                        cnt.put((pref.get(i) - i % k + k) % k,\n                        cnt.get((pref.get(i) - i % k + k) % k) + 1);\n                else\n                        cnt.put((pref.get(i) - i % k + k) % k, 1);\n        }\n        System.out.println(ans);\n}", "173": "static void countRows(int[][] mat)\n        {\n                int n = mat.length;\n                int m = mat[0].length;\n                int count = 0;\n                int totalSum = 0;\n                for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < m; j++) {\n                                totalSum += mat[i][j];\n                        }\n                }\n                for (int i = 0; i < n; i++) {\n                        int currSum = 0;\n                        for (int j = 0; j < m; j++) {\n                                currSum += mat[i][j];\n                        }\n                        if (currSum > totalSum - currSum)\n                                count++;\n                }\n                System.out.println(count);\n        }", "174": "static void isCrossed(String path)\n{\n if (path.length() == 0)\n        return;\n boolean ans = false;\n HashSet<Point> set =\n                new HashSet<Point>();\n int x = 0, y = 0;\n set.add(new Point(x, y));\n for (int i = 0; i < path.length(); i++)\n {\n        if (path.charAt(i) == 'N')\n        set.add(new Point(x, y++));\n        if (path.charAt(i) == 'S')\n        set.add(new Point(x, y--));\n        if (path.charAt(i) == 'E')\n        set.add(new Point(x++, y));\n        if (path.charAt(i) == 'W')\n        set.add(new Point(x--, y));\n        if (set.contains(new Point(x, y)))\n        {\n        ans = true;\n        break;\n        }\n }\n if (ans)\n        System.out.print(\"Crossed\");\n else\n        System.out.print(\"Not Crossed\");\n}", "175": "static int maxWidth(int N, int M,ArrayList<Integer> cost, ArrayList<ArrayList<Integer> > s)\n        {\n                ArrayList<ArrayList<Integer> > adj =\n                new ArrayList<ArrayList<Integer> >();\n                for(int i = 0; i < N; i++)\n                {\n                        adj.add(new ArrayList<Integer>());\n                }\n                for(int i = 0; i < M; i++)\n                {\n                        adj.get(s.get(i).get(0)).add(s.get(i).get(1));\n                }\n                int result = 0;\n                Queue<Integer> q = new LinkedList<>();\n                q.add(0);\n                while(q.size() != 0)\n                {\n                        int count = q.size();\n                        result = Math.max(count, result);\n                        while(count-->0)\n                        {\n                                int temp = q.remove();\n                                for(int i = 0; i < adj.get(temp).size(); i++)\n                                {\n                                        q.add(adj.get(temp).get(i));\n                                }\n                        }\n                }\n                return result;\n        }", "176": "static void SieveOfEratosthenes()\n{\n        Arrays.fill(isPrime, true);\n        for(int p = 2; p * p <= MAX; p++)\n        {\n                if (isPrime[p] == true)\n                {\n                        for(int i = p * p; i <= MAX; i += p)\n                                isPrime[i] = false;\n                }\n        }\n        for(int p = 2; p <= MAX; p++)\n                if (isPrime[p])\n                        primes.add(p);\n}\nstatic int prime_search(Vector<Integer> primes, int diff)\n{\n        int low = 0;\n        int high = primes.size() - 1;\n        int res = -1;\n        while (low <= high)\n        {\n                int mid = (low + high) / 2;\n                if (primes.get(mid) == diff)\n                {\n                        return primes.get(mid);\n                }\n                else if (primes.get(mid) < diff)\n                {\n                        low = mid + 1;\n                }\n                else\n                {\n                        res = primes.get(mid);\n                        high = mid - 1;\n                }\n        }\n        return res;\n}\nstatic int minCost(int arr[], int n)\n{\n        SieveOfEratosthenes();\n        int res = 0;\n        for(int i = 1; i < n; i++)\n        {\n                if (arr[i] < arr[i - 1])\n                {\n                        int diff = arr[i - 1] - arr[i];\n                        int closest_prime = prime_search(primes, diff);\n                        res += closest_prime;\n                        arr[i] += closest_prime;\n                }\n        }\n        return res;\n}", "177": "static String[] lexico_smallest(String s1, String s2)\n{\n        Map<Character, Integer> M = new HashMap<>();\n        Set<Character> S = new TreeSet<>();\n        for(int i = 0; i <= s1.length() - 1; ++i)\n        {\n                if (!M.containsKey(s1.charAt(i)))\n                        M.put(s1.charAt(i), 1);\n                else\n                        M.replace(s1.charAt(i),\n                                M.get(s1.charAt(i)) + 1);\n                S.add(s1.charAt(i));\n        }\n        for(int i = 0; i <= s2.length() - 1; ++i)\n        {\n                if (M.containsKey(s2.charAt(i)))\n                        M.replace(s2.charAt(i),\n                                M.get(s2.charAt(i)) - 1);\n        }\n        char c = s2.charAt(0);\n        int index = 0;\n        String res = \"\";\n        Iterator<Character> it = S.iterator();\n        while (it.hasNext())\n        {\n                char x = it.next();\n                if (x != c)\n                {\n                        for(int i = 1; i <= M.get(x); ++i)\n                        {\n                                res += x;\n                        }\n                }\n                else\n                {\n                        int j = 0;\n                        index = res.length();\n                        while (s2.charAt(j) == x)\n                        {\n                                j++;\n                        }\n                        if (s2.charAt(j) < c)\n                        {\n                                res += s2;\n                                for(int i = 1; i <= M.get(x); ++i)\n                                {\n                                        res += x;\n                                }\n                        }\n                        else\n                        {\n                                for(int i = 1; i <= M.get(x); ++i)\n                                {\n                                        res += x;\n                                }\n                                index += M.get(x);\n                                res += s2;\n                        }\n                }\n        }\n        String pr[] = {res, index + \"\"};\n        return pr;\n}", "178": "static void addEdge(Vector<Integer> v[], int x, int y)\n{\n        v[x].add(y);\n        v[y].add(x);\n}\nstatic void dfs(Vector<Integer> tree[], Vector<Integer> temp, int ancestor[], int u, int parent, int k)\n{\n        temp.add(u);\n        for(int i : tree[u])\n        {\n                if (i == parent)\n                        continue;\n                dfs(tree, temp, ancestor, i, u, k);\n        }\n        temp.remove(temp.size() - 1);\n        if (temp.size() < k)\n        {\n                ancestor[u] = -1;\n        }\n        else\n        {\n                ancestor[u] = temp.get(temp.size() - k);\n        }\n}\nstatic void KthAncestor(int N, int K, int E, int edges[][])\n{\n        @SuppressWarnings(\"unchecked\")\n        Vector<Integer> []tree = new Vector[N + 1];\n        for(int i = 0; i < tree.length; i++)\n                tree[i] = new Vector<Integer>();\n        for(int i = 0; i < E; i++)\n        {\n                addEdge(tree, edges[i][0], edges[i][1]);\n        }\n        Vector<Integer> temp = new Vector<Integer>();\n        int []ancestor = new int[N + 1];\n        dfs(tree, temp, ancestor, 1, 0, K);\n        for(int i = 1; i <= N; i++)\n        {\n                System.out.print(ancestor[i] + \" \");\n        }\n}", "179": "static void build(Vector<Integer> sum,Vector<Integer> a, int l, int r, int rt)\n        {\n                if(l == r)\n                {\n                        sum.set(rt, a.get(l - 1));\n                        return;\n                }\n                int m = (l + r) >> 1;\n                build(sum, a, l, m, rt << 1);\n                build(sum, a, m + 1, r, rt << 1 1);\n        }\nstatic void pushDown(Vector<Integer> sum, Vector<Integer> add, int rt, int ln, int rn)\n        {\n                if(add.get(rt) != 0)\n                {\n                        add.set(rt << 1, add.get(rt));\n                        add.set(rt << 1 | 1, add.get(rt));\n                        sum.set(rt << 1, sum.get(rt << 1) + add.get(rt) * ln);\n                        sum.set(rt << 1 | 1, sum.get(rt << 1 1) + add.get(rt) * rn);\n                        add.set(rt, 0);\n                }\n        }\nstatic void update(Vector<Integer> sum, Vector<Integer> add,int L, int R, int C, int l, int r, int rt)\n        {\n                if(L <= l && r <= R)\n                {\n                        sum.set(rt,sum.get(rt) + C * (r - l + 1));\n                        add.set(rt,add.get(rt) + C);\n                        return;\n                }\n                int m = (l + r) >> 1;\n                pushDown(sum, add, rt, m - l + 1, r - m);\n                if(L <= m)\n                {\n                        update(sum, add, L, R, C, l, m, rt << 1);\n                }\n                if(R > m)\n                {\n                        update(sum, add, L, R, C, m + 1, r, rt << 1 1);\n                }\n        }\nstatic int query(Vector<Integer> sum,Vector<Integer> add, int L, int R, int l,int r, int rt)\n        {\n                if (L <= l && r <= R)\n                {\n                        return sum.get(rt);\n                }\n                int m = (l + r) >> 1;\n                pushDown(sum, add, rt, m - l + 1, r - m);\n                int ans = 0;\n                if(L <= m)\n                {\n                        ans += query(sum, add, L, R, l, m, rt << 1);\n                }\n                if(R > m)\n                {\n                        ans += query(sum, add, L, R, m + 1, r,rt << 1 1);\n                }\n                return ans;\n        }\nstatic void sequenceMaintenance(int n, int q, Vector<Integer> a, Vector<Integer> b,int m)\n        {\n                Collections.sort(a);\n                Vector<Integer> sum = new Vector<Integer>();\n                Vector<Integer> ad = new Vector<Integer>();\n                Vector<Integer> ans = new Vector<Integer>();\n                for(int i = 0; i < (n << 2); i++)\n                {\n                        sum.add(0);\n                        ad.add(0);\n                }\n                build(sum, a, 1, n, 1);\n                for(int i = 0; i < q; i++)\n                {\n                        int l = 1, r = n, pos = -1;\n                        while(l <= r)\n                        {\n                                m = (l + r) >> 1;\n                                if(query(sum, ad, m, m, 1, n, 1) >= b.get(i))\n                                {\n                                        r = m - 1;\n                                        pos = m;\n                                }\n                                else\n                                {\n                                        l = m + 1;\n                                }\n                        }\n                        if(pos == -1)\n                        {\n                                ans.add(0);\n                        }\n                        else\n                        {\n                                ans.add(n - pos + 1);\n                                update(sum, ad, pos, n, -m, 1, n, 1);\n                        }\n                }\n                for(int i = 0; i < ans.size(); i++)\n                {\n                        System.out.print(ans.get(i) + \" \");\n                }\n        }", "180": "static int count(String s)\n        {\n                int cnt = 0;\n                for (char c : s.toCharArray()) {\n                        cnt += c == '0' ? 1 : 0;\n                }\n                if (cnt % 3 != 0)\n                        return 0;\n                int res = 0, k = cnt / 3, sum = 0;\n                Map<Integer, Integer> map = new HashMap<>();\n                for (int i = 0; i < s.length(); i++) {\n                        sum += s.charAt(i) == '0' ? 1 : 0;\n                        if (sum == 2 * k && map.containsKey(k)\n                                && i < s.length() - 1 && i > 0) {\n                                res += map.get(k);\n                        }\n                        map.put(sum,\n                                        map.getOrDefault(sum, 0) + 1);\n                }\n                return res;\n        }", "181": "static int splitstring(String s)\n{\n        int n = s.length();\n        int zeros = 0;\n        for(int i = 0; i < n; i++)\n                if (s.charAt(i) == '0')\n                        zeros++;\n        if (zeros % 3 != 0)\n                return 0;\n        if (zeros == 0)\n                return ((n - 1) * (n - 2)) / 2;\n        int zerosInEachSubstring = zeros / 3;\n        int waysOfFirstCut = 0;\n        int waysOfSecondCut = 0;\n        int count = 0;\n        for(int i = 0; i < n; i++)\n        {\n                if (s.charAt(i) == '0')\n                        count++;\n                if (count == zerosInEachSubstring)\n                        waysOfFirstCut++;\n                else if (count == 2 * zerosInEachSubstring)\n                        waysOfSecondCut++;\n        }\n        return waysOfFirstCut * waysOfSecondCut;\n}", "182": "static boolean check(String s, int k)\n{\n int n = s.length();\n for (int i = 0; i < k; i++)\n {\n        for (int j = i; j < n; j += k)\n        {\n        if (s.charAt(i) != s.charAt(j))\n                return false;\n        }\n }\n int c = 0;\n for (int i = 0; i < k; i++)\n {\n        if (s.charAt(i) == '0')\n        c++;\n        else\n        c--;\n }\n if (c == 0)\n        return true;\n else\n        return false;\n}\n3503\nstatic void addEdge(int a, int b)\n{\n tree[a].add(b);\n tree[b].add(a);\n}\nstatic void dfs(int x)\n{\n vis[x] = true;\n subtreeSize[x] = 1;\n for (int i : tree[x])\n {\n        if (!vis[i])\n        {\n        dfs(i);\n        subtreeSize[x] += subtreeSize[i];\n        }\n }\n}\nstatic void countPairs(int a, int b)\n{\n int sub = Math.min(subtreeSize[a], subtreeSize[b]);\n System.out.print(sub * (n - sub) + \"\\n\");\n}", "183": "static int revNum(int N)\n{\n        int x = 0;\n        while (N != 0)\n        {\n                x = x * 10 + N % 10;\n                N = N / 10;\n        }\n        return x;\n}\nstatic int ctNonPalin(int arr[], int N)\n{\n        int Res = 0;\n        for(int i = 0; i < N; i++)\n        {\n                int x = revNum(arr[i]);\n                if (x == arr[i])\n                {\n                        continue;\n                }\n                else\n                {\n                        if(arr[i] % 10 == x % 10)\n                                Res += 1;\n                }\n        }\n        return Res;\n}", "184": "static boolean isSame(String str, int n)\n{\n        HashMap<Integer,\n                        Integer> mp = new HashMap<Integer,\n                                                                        Integer>();\n        for (int i = 0; i < str.length(); i++)\n        {\n                if(mp.containsKey(str.charAt(i) - 'a'))\n                {\n                        mp.put(str.charAt(i) - 'a',\n                                mp.get(str.charAt(i) - 'a') + 1);\n                }\n                else\n                {\n                        mp.put(str.charAt(i) - 'a', 1);\n                }\n        }\n        for (Map.Entry<Integer, Integer> it : mp.entrySet())\n        {\n                if ((it.getValue()) >= n)\n                {\n                        return true;\n                }\n        }\n        return false;\n}", "185": "static boolean canTransform(String str1, String str2)\n        {\n                String s1 = \"\";\n                String s2 = \"\";\n                for (char c : str1.toCharArray())\n                {\n                        if (c != 'C')\n                        {\n                                s1 += c;\n                        }\n                }\n                for (char c : str2.toCharArray())\n                {\n                        if (c != 'C')\n                        {\n                                s2 += c;\n                        }\n                }\n                if (!s1.equals(s2))\n                        return false;\n                int i = 0;\n                int j = 0;\n                int n = str1.length();\n                while (i < n && j < n)\n                {\n                        if (str1.charAt(i) == 'C')\n                        {\n                                i++;\n                        }\n                        else if (str2.charAt(j) == 'C')\n                        {\n                                j++;\n                        }\n                        else\n                        {\n                                if ((str1.charAt(i) == 'A' && i < j) ||\n                                        (str1.charAt(i) == 'B' && i > j))\n                                {\n                                        return false;\n                                }\n                                i++;\n                                j++;\n                        }\n                }\n                return true;\n        }", "186": "static double func(double a, double b, double c, double x)\n{\n        return a * x * x + b * x + c;\n}\nstatic double findRoot(double a, double b, double c, double low, double high)\n{\n        double x = -1;\n        while (Math.abs(high - low) > eps)\n        {\n                x = (low + high) / 2;\n                if (func(a, b, c, low) *\n                        func(a, b, c, x) <= 0)\n                {\n                        high = x;\n                }\n                else\n                {\n                        low = x;\n                }\n        }\n        return x;\n}\nstatic void solve(double a, double b, double c, double A, double B)\n{\n        if (func(a, b, c, A) * func(a, b, c, B) > 0)\n        {\n                System.out.println(\"No solution\");\n        }\n        else\n        {\n                System.out.format(\"%.4f\", findRoot( a, b, c, A, B));\n        }\n}", "187": "static int __gcd(int a, int b) \n{ \n        return b == 0? a:__gcd(b, a % b);        \n}\nstatic boolean hasCoprimePair(int []arr, int n)\n{\n        for (int i = 0; i < n - 1; i++)\n        {\n                for (int j = i + 1; j < n; j++)\n                {\n                        if ((__gcd(arr[i], arr[j])) == 1)\n                        {\n                                return true;\n                        }\n                }\n        }\n        return false;\n}", "188": "static int findPermutation(Set<Integer>arr, int N)\n{\n        int pos = arr.size() + 1;\n        if (pos > N)\n                return 1;\n        int res = 0;\n        for(int i = 1; i <= N; i++)\n        {\n                if (! arr.contains(i))\n                {\n                        if (i % pos == 0 pos % i == 0)\n                        {\n                                arr.add(i);\n                                res += findPermutation(arr, N);\n                                arr.remove(i);\n                        }\n                }\n        }\n        return res;\n}", "189": "static void solve(int arr[], int n, int X, int Y)\n{\n        int diff = Y - X;\n        for(int i = 0; i < n; i++)\n        {\n                if (arr[i] != 1)\n                {\n                        diff = diff % (arr[i] - 1);\n                }\n        }\n        if (diff == 0)\n                System.out.print( \"Yes\");\n        else\n                System.out.print(\"No\");\n}", "190": "static int Numberofways(int n)\n        {\n                int count = 0;\n                for (int a = 1; a < n; a++) {\n                        for (int b = 0; b < n; b++) {\n                                int c = n - (a + b);\n                                if (a + b > c && a + c > b && b + c > a) {\n                                        count++;\n                                }\n                        }\n                }\n        return count;\n}", "191": "static int maxsubStringLength(char[] S, int N)\n{\n        int arr[] = new int[N];\n        for(int i = 0; i < N; i++)\n        if (S[i] == 'a' S[i] == 'e' S[i] == 'i' S[i] == 'o' S[i] == 'u')\n                arr[i] = 1;\n        else\n                arr[i] = -1;\n        int maxLen = 0;\n        int curr_sum = 0;\n        HashMap<Integer, Integer> hash = new HashMap<>();\n        for(int i = 0; i < N; i++)\n        {\n                curr_sum += arr[i];\n                if (curr_sum == 0)\n                        maxLen = Math.max(maxLen, i + 1);\n                if (hash.containsKey(curr_sum))\n                        maxLen = Math.max(maxLen,\n                                                        i - hash.get(curr_sum));\n                else\n                        hash.put(curr_sum, i);\n        }\n        return maxLen;\n}", "192": "public static int findMaximumSum(int[] a, int n)\n        {\n                int prev_smaller[] = findPrevious(a, n);\n                int next_smaller[] = findNext(a, n);\n                int max_value = 0;\n                for (int i = 0; i < n; i++) {\n                        max_value\n                                = Math.max(max_value,\n                                                a[i] * (next_smaller[i] - prev_smaller[i] - 1));\n                }\n                return max_value;\n        }\npublic static int[] findPrevious(int[] a, int n)\n        {\n                int ps[] = new int[n];\n                ps[0] = -1;\n                Stack<Integer> stack = new Stack<>();\n                stack.push(0);\n                for (int i = 1; i < a.length; i++) {\n                        while (stack.size() > 0\n                                && a[stack.peek()] >= a[i])\n                                stack.pop();\n                        ps[i] = stack.size() > 0 ? stack.peek() : -1;\n                        stack.push(i);\n                }\n                return ps;\n        }\npublic static int[] findNext(int[] a, int n)\n        {\n                int ns[] = new int[n];\n                ns[n - 1] = n;\n                Stack<Integer> stack = new Stack<>();\n                stack.push(n - 1);\n                for (int i = n - 2; i >= 0; i--) {\n                        while (stack.size() > 0\n                                && a[stack.peek()] >= a[i])\n                                stack.pop();\n                        ns[i] = stack.size() > 0 ? stack.peek()\n                                                                        : a.length;\n                        stack.push(i);\n                }\n                return ns;\n        }", "193": "static boolean possible(long mid, int[] a)\n{\n        long n = a.length;\n        long total = (n * (n - 1)) / 2;\n        long need = (total + 1) / 2;\n        long count = 0;\n        long start = 0, end = 1;\n        while (end < n)\n        {\n                if (a[(int)end] - a[(int)start] <= mid)\n                {\n                        end++;\n                }\n                else\n                {\n                        count += (end - start - 1);\n                        start++;\n                }\n        }\n        if (end == n && start < end &&\n                a[(int)end - 1] - a[(int)start] <= mid)\n        {\n                long t = end - start - 1;\n                count += (t * (t + 1) / 2);\n        }\n        if (count >= need)\n                return true;\n        else\n                return false;\n}\nstatic long findMedian(int[] a)\n{\n        long n = a.length;\n        long low = 0, high = a[(int)n - 1] - a[0];\n        while (low <= high)\n        {\n                long mid = (low + high) / 2;\n                if (possible(mid, a))\n                        high = mid - 1;\n                else\n                        low = mid + 1;\n        }\n        return high + 1;\n}", "194": "static void FindMinimumDistance()\n{\n        Queue<pair> q = new LinkedList<>();\n        q.add(new pair(x, y));\n        mat[x][y] = 0;\n        while (!q.isEmpty())\n        {\n                x = q.peek().first;\n                y = q.peek().second;\n                q.remove();\n                for(int i = 0; i < 8; i++)\n                {\n                        int a = x + dx[i];\n                        int b = y + dy[i];\n                        if (a < 0 a >= r b >= c b < 0)\n                                continue;\n                        if (mat[a][b] == 0)\n                        {\n                                mat[a][b] = mat[x][y] + 1;\n                                q.add(new pair(a, b));\n                        }\n                }\n        }\n}", "195": "static void addEdge(int u, int v)\n{\n        adj[u].add(v);\n        adj[v].add(u);\n}\nstatic void dfs1(int cur, int par)\n{\n        for(int u : adj[cur])\n        {\n                if (u != par)\n                {\n                        dfs1(u, cur);\n                        height[cur] = Math.max(height[cur], height[u]);\n                }\n        }\n        height[cur] += 1;\n}\nstatic void dfs2(int cur, int par)\n{\n        int max1 = 0;\n        int max2 = 0;\n        for(int u : adj[cur])\n        {\n                if (u != par)\n                {\n                        if (height[u] >= max1)\n                        {\n                                max2 = max1;\n                                max1 = height[u];\n                        }\n                        else if (height[u] > max2)\n                        {\n                                max2 = height[u];\n                        }\n                }\n        }\n        int sum = 0;\n        for(int u : adj[cur])\n        {\n                if (u != par)\n                {\n                        sum = ((max1 == height[u]) ? max2 : max1);\n                        if (max1 == height[u])\n                                dist[u] = 1 + Math.max(1 + max2, dist[cur]);\n                        else\n                                dist[u] = 1 + Math.max(1 + max1, dist[cur]);\n                        dfs2(u, cur);\n                }\n        }\n}", "196": "static void countPairs(int N, int[] arr)\n        {\n                int count = 0;\n                for (int i = 0; i < N; i++) {\n                        if (i == arr[arr[i] - 1] - 1) {\n                                count++;\n                        }\n                }\n                System.out.println(count / 2);\n        }", "197": "public static int minOperations(String S, int K)\n{\n        int ans = 0;\n        for(int i = 0; i < K; i++)\n        {\n                int zero = 0, one = 0;\n                for(int j = i; j < S.length(); j += K)\n                {\n                        if (S.charAt(j) == '0')\n                                zero++;\n                        else\n                                one++;\n                }\n                ans += Math.min(zero, one);\n        }\n        return ans;\n}", "198": "static void UniversalSubset(List<String> A, List<String> B)\n{\n        int n1 = A.size();\n        int n2 = B.size();\n        List<String> res = new ArrayList<>();\n        int[][] A_fre = new int[n1][26];\n        for(int i = 0; i < n1; i++)\n        {\n                for(int j = 0; j < 26; j++)\n                        A_fre[i][j] = 0;\n        }\n        for(int i = 0; i < n1; i++)\n        {\n                for(int j = 0; j < A.get(i).length(); j++)\n                {\n                        A_fre[i][A.get(i).charAt(j) - 'a']++;\n                }\n        }\n        int[] B_fre = new int[26];\n        for(int i = 0; i < n2; i++)\n        {\n                int[] arr = new int[26] ;\n                for(int j = 0; j < B.get(i).length(); j++)\n                {\n                        arr[B.get(i).charAt(j) - 'a']++;\n                        B_fre[B.get(i).charAt(j) - 'a'] = Math.max(\n                        B_fre[B.get(i).charAt(j) - 'a'],\n                        arr[B.get(i).charAt(j) - 'a']);\n                }\n        }\n        for(int i = 0; i < n1; i++)\n        {\n                int flag = 0;\n                for(int j = 0; j < 26; j++)\n                {\n                        if (A_fre[i][j] < B_fre[j])\n                        {\n                                flag = 1;\n                                break;\n                        }\n                }\n                if (flag == 0)\n                        res.add(A.get(i));\n        }\n        if (res.size() != 0)\n        {\n                for(int i = 0; i < res.size(); i++)\n                {\n                        for(int j = 0;\n                                        j < res.get(i).length(); j++)\n                        System.out.print(res.get(i).charAt(j));\n                }\n                System.out.print(\" \");\n        }\n        else\n        System.out.print(\"-1\");\n}", "199": "public static void\n        findPair(int a[], int n)\n        {\n                int min_dist = Integer.MAX_VALUE;\n                int index_a = -1, index_b = -1;\n                for (int i = 0; i < n; i++) {\n                        for (int j = i + 1; j < n; j++) {\n                                if (j - i < min_dist) {\n                                        if (a[i] % a[j] == 0 a[j] % a[i] == 0) {\n                                                min_dist = j - i;\n                                                index_a = i;\n                                                index_b = j;\n                                        }\n                                }\n                        }\n                }\n                if (index_a == -1) {\n                        System.out.println(\"-1\");\n                }\n                else {\n                        System.out.print(\n                                \"(\" + a[index_a] + \", \" + a[index_b] + \")\");\n                }\n        }", "200": "static void printNum(int L, int R)\n{\n        for(int i = L; i <= R; i++)\n        {\n                int temp = i;\n                int c = 10;\n                int flag = 0;\n                while (temp > 0)\n                {\n                        if (temp % 10 >= c)\n                        {\n                                flag = 1;\n                                break;\n                        }\n                        c = temp % 10;\n                        temp /= 10;\n                }\n                if (flag == 0)\n                        System.out.print(i + \" \");\n        }\n}", "201": "static int findMissing(int arr[], int left, int right, int diff)\n{\n        if (right <= left)\n                return 0;\n        int mid = left + (right - left) / 2;\n        if (arr[mid + 1] - arr[mid] != diff)\n                return (arr[mid] + diff);\n        if (mid > 0 && arr[mid] - arr[mid - 1] != diff)\n                return (arr[mid - 1] + diff);\n        if (arr[mid] == arr[0] + mid * diff)\n                return findMissing(arr, mid + 1, right, diff);\n        return findMissing(arr, left, mid - 1, diff);\n}\nstatic int missingElement(int arr[], int n)\n{\n        Arrays.sort(arr);\n        int diff = (arr[n - 1] - arr[0]) / n;\n        return findMissing(arr, 0, n - 1, diff);\n}", "202": "static int missingElement(int arr[], int n)\n{\n        int max_ele = arr[0];\n        int min_ele = arr[0];\n        int x = 0;\n        int d;\n        for(int i = 0; i < n; i++)\n        {\n        if (arr[i] > max_ele)\n                max_ele = arr[i];\n        if (arr[i] < min_ele)\n                min_ele = arr[i];\n        }\n        d = (max_ele - min_ele) / n;\n        for(int i = 0; i < n; i++)\n        {\n        x = x ^ arr[i];\n        }\n        for(int i = 0; i <= n; i++)\n        {\n        x = x ^ (min_ele + (i * d));\n        }\n        return x;\n}", "203": "static int power(int x, int y)\n{\n        int temp;\n        if (y == 0)\n                return 1;\n        temp = power(x, y / 2);\n        if (y % 2 == 0)\n                return temp * temp;\n        else\n                return x * temp * temp;\n}\nstatic int nthRootSearch(int low, int high, int N, int K)\n{\n        if (low <= high)\n        {\n                int mid = (low + high) / 2;\n                if ((power(mid, K) <= N) &&\n                        (power(mid + 1, K) > N))\n                {\n                        return mid;\n                }\n                else if (power(mid, K) < N)\n                {\n                        return nthRootSearch(mid + 1, high, N, K);\n                }\n                else\n                {\n                        return nthRootSearch(low, mid - 1, N, K);\n                }\n        }\n        return low;\n}", "204": "static int get_subset_count(int arr[], int K, int N)\n{\n        Arrays.sort(arr);\n        int left, right;\n        left = 0;\n        right = N - 1;\n        int ans = 0;\n        while (left <= right)\n        {\n                if (arr[left] + arr[right] < K)\n                {\n                        ans += 1 << (right - left);\n                        left++;\n                }\n                else\n                {\n                        right--;\n                }\n        }\n        return ans;\n}", "205": "static int minMaxDiff(int arr[], int n, int k)\n{\n        int max_adj_dif = Integer.MIN_VALUE;\n        for(int i = 0; i < n - 1; i++)\n                max_adj_dif = Math.max(max_adj_dif,\n                                        Math.abs(arr[i] - arr[i + 1]));\n        if (max_adj_dif == 0)\n                return 0;\n        int best = 1;\n        int worst = max_adj_dif;\n        int mid, required;\n        while (best < worst)\n        {\n                mid = (best + worst) / 2;\n                required = 0;\n                for(int i = 0; i < n - 1; i++)\n                {\n                        required += (Math.abs(arr[i] - arr[i + 1]) - 1) / mid;\n                }\n                if (required > k)\n                        best = mid + 1;\n                else\n                        worst = mid;\n        }\n        return worst;\n}", "206": "static void checkMin(int arr[], int len)\n{\n        int smallest = Integer.MAX_VALUE;\n        int secondSmallest = Integer.MAX_VALUE;\n        for(int i = 0; i < len; i++)\n        {\n        if (arr[i] < smallest)\n        {\n                secondSmallest = smallest;\n                smallest = arr[i];\n        }\n        else if (arr[i] < secondSmallest)\n        {\n                secondSmallest = arr[i];\n        }\n        }\n        if (2 * smallest <= secondSmallest)\n                System.out.print(\"Yes\");\n        else\n                System.out.print(\"No\");\n}", "207": "static void createHash(HashSet<Integer> hash, int maxElement)\n{\n        int prev = 0, curr = 1;\n        hash.add(prev);\n        hash.add(curr);\n        while (curr <= maxElement) {\n                int temp = curr + prev;\n                hash.add(temp);\n                prev = curr;\n                curr = temp;\n        }\n}\nstatic void fibonacci(int arr[], int n)\n{\n        int max_val= Arrays.stream(arr).max().getAsInt();\n        HashSet<Integer> hash = new HashSet<Integer>();\n        createHash(hash, max_val);\n        int minimum = Integer.MAX_VALUE;\n        int maximum = Integer.MIN_VALUE;\n        for (int i = 0; i < n; i++) {\n                if (hash.contains(arr[i])) {\n                        minimum = Math.min(minimum, arr[i]);\n                        maximum = Math.max(maximum, arr[i]);\n                }\n        }\n        System.out.print(minimum+ \", \" + maximum +\"\\n\");\n}", "208": "static boolean isValidLen(String s, int len, int k)\n        {\n                int n = s.length();\n                Map<Character,\n                        Integer> mp = new HashMap<Character,\n                                                                        Integer>();\n                int right = 0;\n                while (right < len)\n                {\n                        if (mp.containsKey(s.charAt(right)))\n                        {\n                                mp.put(s.charAt(right),\n                                mp.get(s.charAt(right)) + 1);\n                        }\n                        else\n                        {\n                                mp.put(s.charAt(right), 1);\n                        }\n                        right++;\n                }\n                if (mp.size() <= k)\n                        return true;\n                while (right < n)\n                {\n                        if (mp.containsKey(s.charAt(right)))\n                        {\n                                mp.put(s.charAt(right),\n                                mp.get(s.charAt(right)) + 1);\n                        }\n                        else\n                        {\n                                mp.put(s.charAt(right), 1);\n                        }\n                        if (mp.containsKey(s.charAt(right - len)))\n                        {\n                                mp.put(s.charAt(right - len),\n                                mp.get(s.charAt(right - len)) - 1);\n                        }\n                        if (mp.get(s.charAt(right - len)) == 0)\n                                mp.remove(s.charAt(right - len));\n                        if (mp.size() <= k)\n                                return true;\n                        right++;\n                }\n                return mp.size() <= k;\n        }\nstatic int maxLenSubStr(String s, int k)\n        {\n                Set<Character> uni = new HashSet<Character>();\n                for (Character x : s.toCharArray())\n                        uni.add(x);\n                if (uni.size() < k)\n                        return -1;\n                int n = s.length();\n                int lo = -1, hi = n + 1;\n                while (hi - lo > 1)\n                {\n                        int mid = lo + hi >> 1;\n                        if (isValidLen(s, mid, k))\n                                lo = mid;\n                        else\n                                hi = mid;\n                }\n                return lo;\n        }", "209": "static boolean isSquarePossible(int arr[], int n, int l)\n        {\n                int cnt = 0;\n                for (int i = 0; i < n; i++)\n                {\n                        if (arr[i] >= l)\n                                cnt++;\n                        if (cnt >= l)\n                                return true;\n                }\n                return false;\n        }\nstatic int maxArea(int arr[], int n)\n        {\n                int l = 0, r = n;\n                int len = 0;\n                while (l <= r)\n                {\n                        int m = l + ((r - l) / 2);\n                        if (isSquarePossible(arr, n, m))\n                        {\n                                len = m;\n                                l = m + 1;\n                        }\n                        else\n                                r = m - 1;\n                }\n                return (len * len);\n        }", "210": "static boolean kOverlap(ArrayList<Pair> pairs, int k)\n{\n        ArrayList<Pair> vec = new ArrayList<>();\n        for(int i = 0; i < pairs.size(); i++)\n        {\n                vec.add(new Pair(pairs.get(i).first, -1));\n                vec.add(new Pair(pairs.get(i).second, +1));\n        }\n        Collections.sort(vec, new Comparator<Pair>()\n        {\n                public int compare(Pair a, Pair b)\n                {\n                        if (a.first != b.first)\n                                return a.first - b.first;\n                        return (a.second - b.second); } });\n        Stack<Pair> st = new Stack<>();\n        for(int i = 0; i < vec.size(); i++)\n        {\n                Pair cur = vec.get(i);\n                if (cur.second == -1)\n                {\n                        st.push(cur);\n                }\n                else\n                {\n                        st.pop();\n                }\n                if (st.size() >= k)\n                {\n                        return true;\n                }\n        }\n        return false;\n}\npublic int compare(Pair a, Pair b)\n                {\n                        if (a.first != b.first)\n                                return a.first - b.first;\n                        return (a.second - b.second); }", "211": "static void insertNames(String arr[], int n)\n{\n        HashSet<String> set = new HashSet<String>();\n        for (int i = 0; i < n; i++)\n        {\n                if (!set.contains(arr[i]))\n                {\n                        System.out.print(\"No\\n\");\n                        set.add(arr[i]);\n                }\n                else\n                {\n                        System.out.print(\"Yes\\n\");\n                }\n        }\n}", "212": "static int countLessThan(int arr[], int n, int key)\n        {\n                int l = 0, r = n - 1;\n                int index = -1;\n                while (l <= r)\n                {\n                        int m = (l + r) / 2;\n                        if (arr[m] < key)\n                        {\n                                l = m + 1;\n                                index = m;\n                        }\n                        else\n                        {\n                                r = m - 1;\n                        }\n                }\n                return (index + 1);\n        }\nstatic int countGreaterThan(int arr[], int n, int key)\n        {\n                int l = 0, r = n - 1;\n                int index = -1;\n                while (l <= r)\n                {\n                        int m = (l + r) / 2;\n                        if (arr[m] <= key)\n                        {\n                                l = m + 1;\n                        }\n                        else\n                        {\n                                r = m - 1;\n                                index = m;\n                        }\n                }\n                if (index == -1)\n                        return 0;\n                return (n - index);\n        }\nstatic int countTriplets(int n, int a[], int b[], int c[])\n        {\n                Arrays.sort(a) ;\n                Arrays.sort(b);\n                Arrays.sort(c);\n                int count = 0;\n                for (int i = 0; i < n; ++i)\n                {\n                        int current = b[i];\n                        int low = countLessThan(a, n, current);\n                        int high = countGreaterThan(c, n, current);\n                        count += (low * high);\n                }\n                return count;\n        }", "213": "static void Printksubstring(String str, int n, int k)\n        {\n                int total = (n * (n + 1)) / 2;\n                if (k > total)\n                {\n                        System.out.printf(\"-1\\n\");\n                        return;\n                }\n                int substring[] = new int[n + 1];\n                substring[0] = 0;\n                int temp = n;\n                for (int i = 1; i <= n; i++)\n                {\n                        substring[i] = substring[i - 1] + temp;\n                        temp--;\n                }\n                int l = 1;\n                int h = n;\n                int start = 0;\n                while (l <= h)\n                {\n                        int m = (l + h) / 2;\n                        if (substring[m] > k)\n                        {\n                                start = m;\n                                h = m - 1;\n                        }\n                        else if (substring[m] < k)\n                        {\n                                l = m + 1;\n                        }\n                        else\n                        {\n                                start = m;\n                                break;\n                        }\n                }\n                int end = n - (substring[start] - k);\n                for (int i = start - 1; i < end; i++)\n                {\n                        System.out.print(str.charAt(i));\n                }\n        }", "214": "static int LowerInsertionPoint(int arr[], int n, int X)\n        {\n        if (X < arr[0])\n                return 0;\n        else if (X > arr[n - 1])\n                return n;\n        int lowerPnt = 0;\n        int i = 1;\n        while (i < n && arr[i] < X) {\n                lowerPnt = i;\n                i = i * 2;\n        }\n        while (lowerPnt < n && arr[lowerPnt] < X)\n                lowerPnt++;\n        return lowerPnt;\n        }", "215": "static int LongestFibSubseq(int A[], int n) {\n                TreeSet<Integer> S = new TreeSet<>();\n                for (int t : A) {\n                        S.add(t);\n                }\n                int maxLen = 0, x, y;\n                for (int i = 0; i < n; ++i) {\n                        for (int j = i + 1; j < n; ++j) {\n                                x = A[j];\n                                y = A[i] + A[j];\n                                int length = 3;\n                                while (S.contains(y) && (y != S.last())) {\n                                        int z = x + y;\n                                        x = y;\n                                        y = z;\n                                        maxLen = Math.max(maxLen, ++length);\n                                }\n                        }\n                }\n                return maxLen >= 3 ? maxLen : 0;\n        }", "216": "static int getCount(int M, int N)\n{\n        int count = 0;\n        if (M == 1)\n                return N;\n        if (N == 1)\n                return M;\n        if (N > M) {\n                for (int i = 1; i <= M; i++) {\n                        int numerator = N * i - N + M - i;\n                        int denominator = M - 1;\n                        if (numerator % denominator == 0) {\n                                int j = numerator / denominator;\n                                if (j >= 1 && j <= N)\n                                        count++;\n                        }\n                }\n        }\n        else {\n                for (int j = 1; j <= N; j++) {\n                        int numerator = M * j - M + N - j;\n                        int denominator = N - 1;\n                        if (numerator % denominator == 0) {\n                                int i = numerator / denominator;\n                                if (i >= 1 && i <= M)\n                                        count++;\n                        }\n                }\n        }\n        return count;\n}", "217": "static boolean swapElement(int[] arr1, int[] arr2, int n)\n{\n        int wrongIdx = 0;\n        for (int i = 1; i < n; i++)\n        {\n                if (arr1[i] < arr1[i - 1])\n                {\n                        wrongIdx = i;\n                }\n        }\n        int maximum = Integer.MIN_VALUE;\n        int maxIdx = -1;\n        boolean res = false;\n        for (int i = 0; i < n; i++)\n        {\n                if (arr2[i] > maximum && arr2[i] >= arr1[wrongIdx - 1])\n                {\n                        if (wrongIdx + 1 <= n - 1 && arr2[i] <= arr1[wrongIdx + 1])\n                        {\n                                maximum = arr2[i];\n                                maxIdx = i;\n                                res = true;\n                        }\n                }\n        }\n        if (res)\n        {\n                swap(arr1, wrongIdx, arr2, maxIdx);\n        }\n        return res;\n}\nstatic void swap(int[] a, int wrongIdx, int[] b, int maxIdx)\n{\n        int c = a[wrongIdx];\n        a[wrongIdx] = b[maxIdx];\n        b[maxIdx] = c;\n}\nstatic void getSortedArray(int arr1[], int arr2[], int n)\n{\n        if (swapElement(arr1, arr2, n))\n        {\n                for (int i = 0; i < n; i++)\n                {\n                        System.out.print(arr1[i] + \" \");\n                }\n        }\n        else\n        {\n                System.out.println(\"Not Possible\");\n        }\n}", "218": "static int costToBalance(String s)\n        {\n                if (s.length() == 0)\n                        System.out.println(0);\n                int ans = 0;\n                int o = 0, c = 0;\n                for (int i = 0; i < s.length(); i++)\n                {\n                        if (s.charAt(i) == '(')\n                                o++;\n                        if (s.charAt(i) == ')')\n                                c++;\n                }\n                if (o != c)\n                        return -1;\n                int []a = new int[s.length()];\n                if (s.charAt(0) == '(')\n                        a[0] = 1;\n                else\n                        a[0] = -1;\n                if (a[0] < 0)\n                        ans += Math.abs(a[0]);\n                for (int i = 1; i < s.length(); i++)\n                {\n                        if (s.charAt(i) == '(')\n                                a[i] = a[i - 1] + 1;\n                        else\n                                a[i] = a[i - 1] - 1;\n                        if (a[i] < 0)\n                                ans += Math.abs(a[i]);\n                }\n                return ans;\n        }", "219": "public static int middleOfThree(int a, int b, int c)\n        {\n                if ((a < b && b < c) || (c < b && b < a))\n                        return b;\n                else if ((b < a && a < c) || (c < a && a < b))\n                return a;\n                else\n                return c;\n        }", "220": "public static int middleOfThree(int a, int b, int c)\n        {\n                if (a > b)\n                {\n                        if (b > c)\n                                return b;\n                        else if (a > c)\n                                return c;\n                        else\n                                return a;\n                }\n                else\n                {\n                        if (a > c)\n                                return a;\n                        else if (b > c)\n                                return c;\n                        else\n                                return b;\n                }\n        }", "221": "public static int middleOfThree(int a, int b, int c)\n        {\n                int x = a - b;\nint y = b - c; \nint z = a - c; \n                if (x * y > 0)\n                        return b;\n                else if (x * z > 0)\n                        return c;\n                else\n                        return a;\n        }", "222": "public static void missing4(int[] arr)\n        {\n                int[] helper = new int[4];\n                for (int i = 0; i < arr.length; i++) {\n                        int temp = Math.abs(arr[i]);\n                        if (temp <= arr.length)\n                                arr[temp - 1] *= (-1);\n                        else if (temp > arr.length) {\n                                if (temp % arr.length != 0)\n                                        helper[temp % arr.length - 1] = -1;\n                                else\n                                        helper[(temp % arr.length) + arr.length - 1] = -1;\n                        }\n                }\n                for (int i = 0; i < arr.length; i++)\n                        if (arr[i] > 0)\n                                System.out.print(i + 1 + \" \");        \n                for (int i = 0; i < helper.length; i++)\n                        if (helper[i] >= 0)\n                                System.out.print(arr.length + i + 1 + \" \");                \n                return;\n        }", "223": "static void lexiMiddleSmallest(int K, int N)\n        {\n                if (K % 2 == 0) {\n                        System.out.print(K / 2 + \" \");\n                        for (int i = 0; i < N - 1; ++i) {\n                                System.out.print(K + \" \");\n                        }\n                        System.out.println();\n                        return;\n                }\n                ArrayList<Integer> a = new ArrayList<Integer>();\n                for (int i = 0; i < N / 2; ++i) {\n                        if (a.get(a.size() - 1) == 1) {\n                                a.remove(a.size() - 1);\n                        }\n                        else {\n                                int t = a.get(a.size() - 1) - 1;\n                                a.set(a.get(a.size() - 1), t);\n                                while (a.size() < N) {\n                                        a.add(K);\n                                }\n                        }\n                }\n                for (int i : a) {\n                        System.out.print(i + \" \");\n                }\n                System.out.println();\n        }", "224": "static int[][] transpose(int[][] mat, int row, int col)\n{\n        int[][] tr = new int[col][row];\n        for(int i = 0; i < row; i++)\n        {\n                for(int j = 0; j < col; j++)\n                {\n                        tr[j][i] = mat[i][j];\n                }\n        }\n        return tr;\n}\nstatic void RowWiseSort(int[][] B)\n{\n        for(int i = 0; i < (int)B.length; i++)\n        {\n                Arrays.sort(B[i]);\n        }\n}\nstatic void sortCol(int[][] mat, int N, int M)\n{\n        int[][] B = transpose(mat, N, M);\n        RowWiseSort(B);\n        mat = transpose(B, M, N);\n        for(int i = 0; i < N; i++)\n        {\n                for(int j = 0; j < M; j++)\n                {\n                        System.out.print(mat[i][j] + \" \");\n                }\n                System.out.println();\n        }\n}", "225": "static void largestArea(int N, int M, int[] H, int[] V)\n        {\n                Set<Integer> s1 = new HashSet<>();\n                Set<Integer> s2 = new HashSet<>();\n                for (int i = 1; i <= N + 1; i++)\n                        s1.add(i);\n                for (int i = 1; i <= M + 1; i++)\n                        s2.add(i);\n                for (int i = 0; i < H.length; i++) {\n                        s1.remove(H[i]);\n                }\n                for (int i = 0; i < V.length; i++) {\n                        s2.remove(V[i]);\n                }\n                int[] list1 = new int[s1.size()];\n                int[] list2 = new int[s2.size()];\n                int i = 0;\n                Iterator it1 = s1.iterator();\n                while (it1.hasNext()) {\n                        list1[i++] = (int)it1.next();\n                }\n                i = 0;\n                Iterator it2 = s2.iterator();\n                while (it2.hasNext()) {\n                        list2[i++] = (int)it2.next();\n                }\n                Arrays.sort(list1);\n                Arrays.sort(list2);\n                int maxH = 0, p1 = 0, maxV = 0, p2 = 0;\n                for (int j = 0; j < list1.length; j++) {\n                        maxH = Math.max(maxH, list1[j] - p1);\n                        p1 = list1[j];\n                }\n                for (int j = 0; j < list2.length; j++) {\n                        maxV = Math.max(maxV, list2[j] - p2);\n                        p2 = list2[j];\n                }\n                System.out.println(maxV * maxH);\n        }", "226": "static void findLastElement(int arr[], int N)\n {\n        Arrays.sort(arr);\n        int i = 0;\n        for (i = 1; i < N; i++) {\n        if (arr[i] - arr[i - 1] != 0 && arr[i] - arr[i - 1] != 2)\n        {\n                System.out.println(\"-1\");\n                return;\n        }\n        }\n        System.out.println( arr[N - 1]);\n }", "227": "static boolean checkifSorted(int A[], int B[], int N)\n        {\n                boolean flag = false;\n                for (int i = 0; i < N - 1; i++) {\n                        if (A[i] > A[i + 1]) {\n                                flag = true;\n                                break;\n                        }\n                }\n                if (!flag) {\n                        return true;\n                }\n                int count = 0;\n                for (int i = 0; i < N; i++) {\n                        if (B[i] == 0) {\n                                count++;\n                                break;\n                        }\n                }\n                for (int i = 0; i < N; i++) {\n                        if (B[i] == 1) {\n                                count++;\n                                break;\n                        }\n                }\n                if (count == 2) {\n                        return true;\n                }\n                return false;\n        }", "228": "static void maxDivisions(Integer arr[], int N, int X)\n{\n        Arrays.sort(arr,Collections.reverseOrder());\n        int maxSub = 0;\n        int size = 0;\n        for (int i = 0; i < N; i++)\n        {\n                size++;\n                if (arr[i] * size >= X)\n                {\n                        maxSub++;\n                        size = 0;\n                }\n        }\n        System.out.print(maxSub +\"\\n\");\n}", "229": "public static void maxPossibleSum(int[] arr, int N)\n        {\n                Arrays.sort(arr);\n                int sum = 0;\n                int j = N - 3;\n                while (j >= 0) {\n                        sum += arr[j];\n                        j -= 3;\n                }\n                System.out.println(sum);\n        }", "230": "static int minSteps(StringBuilder A, StringBuilder B, int M, int N)\n {\n        if (A.charAt(0) > B.charAt(0))\n        return 0;\n        if (B.charAt(0) > A.charAt(0))\n        {\n        return 1;\n        }\n        if (M <= N && A.charAt(0) == B.charAt(0)\n                && count(A, A.charAt(0)) == M\n                && count(B, B.charAt(0)) == N)\n        return -1;\n        for (int i = 1; i < N; i++)\n        {\n        if (B.charAt(i) > B.charAt(0))\n                return 1;\n        }\n        for (int i = 1; i < M; i++)\n        {\n        if (A.charAt(i) < A.charAt(0))\n                return 1;\n        }\n        for (int i = 1; i < M; i++)\n        {\n        if (A.charAt(i) > A.charAt(0))\n        {\n                swap(A, i, B, 0);\n                swap(A, 0, B, 0);\n                return 2;\n        }\n        }\n        for (int i = 1; i < N; i++)\n        {\n        if (B.charAt(i) < B.charAt(0))\n        {\n                swap(A, 0, B, i);\n                swap(A, 0, B, 0);\n                return 2;\n        }\n        }\n        return 0;\n }\nstatic int count(StringBuilder a, char c)\n {\n        int count = 0;\n        for(int i = 0; i < a.length(); i++)\n        if(a.charAt(i) == c)\n                count++; \n        return count; \n }\nstatic void swap(StringBuilder s1, int index1, StringBuilder s2, int index2)\n {\n        char c = s1.charAt(index1);\n        s1.setCharAt(index1,s2.charAt(index2));\n        s2.setCharAt(index2,c);\n }", "231": "static int CountMaximum(int arr[], int n, int k)\n        {\n                Arrays.sort(arr);\n                int sum = 0, count = 0;\n                for (int i = 0; i < n; i++) {\n                        sum += arr[i];\n                        if (sum > k)\n                                break;\n                        count++;\n                }\n                return count;\n        }", "232": "static int CountMaximum(int arr[], int n, int k)\n        {\n                Arrays.sort(arr);\n                int sum = 0, count = 0;\n                for (int i = 0; i < n; i++) {\n                        sum += arr[i];\n                        if (sum > k)\n                                break;\n                        count++;\n                }\n                return count;\n        }", "233": "static void insertionSort(int arr[], int n)\n{\n        int i, key, j;\n        for (i = 1; i < n; i++)\n        {\n                key = arr[i];\n                j = i - 1;\n                while (j >= 0 && arr[j] > key)\n                {\n                        arr[j + 1] = arr[j];\n                        j = j - 1;\n                }\n                arr[j + 1] = key;\n        }\n}\nstatic void printArray(int arr[], int n)\n{\n        int i;\n        for (i = 0; i < n; i++) {\n                System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n}", "234": "static void selectionSort(int arr[], int n)\n{\n        int i, j, min_idx;\n        for (i = 0; i < n - 1; i++)\n        {\n                min_idx = i;\n                for (j = i + 1; j < n; j++)\n                        if (arr[j] < arr[min_idx])\n                                min_idx = j;\n                int temp = arr[min_idx];\n                arr[min_idx]= arr[i];\n                arr[i] = temp;\n        }\n}\nstatic void printArray(int arr[], int size)\n{\n        int i;\n        for (i = 0; i < size; i++) {\n                System.out.print(arr[i]+ \" \");\n        }\n        System.out.println();\n}", "235": "static void getPairs(int arr[], int N, int K)\n{\n        int count = 0;\n        for (int i = 0; i < N; i++)\n        {\n                for (int j = i + 1; j < N; j++)\n                {\n                        if (arr[i] > K * arr[i + 1])\n                                count++;\n                }\n        }\n        System.out.print(count);\n}", "236": "static int merge(int arr[], int temp[], int l, int m, int r, int K)\n        {\n                int i = l;\n                int j = m + 1;\n                int cnt = 0;\n                for (i = l; i <= m; i++)\n                {\n                        boolean found = false;\n                        while (j <= r)\n                        {\n                                if (arr[i] >= K * arr[j])\n                                {\n                                        found = true;\n                                }\n                                else\n                                        break;\n                                j++;\n                        }\n                        if (found == true)\n                        {\n                                cnt += j - (m + 1);\n                                j--;\n                        }\n                }\n                int k = l;\n                i = l;\n                j = m + 1;\n                while (i <= m && j <= r)\n                {\n                        if (arr[i] <= arr[j])\n                                temp[k++] = arr[i++];\n                        else\n                                temp[k++] = arr[j++];\n                }\n                while (i <= m)\n                        temp[k++] = arr[i++];\n                while (j <= r)\n                        temp[k++] = arr[j++];\n                for (i = l; i <= r; i++)\n                        arr[i] = temp[i];\n                return cnt;\n        }\nstatic int mergeSortUtil(int arr[], int temp[], int l, int r, int K)\n        {\n                int cnt = 0;\n                if (l < r)\n                {\n                        int m = (l + r) / 2;\n                        cnt += mergeSortUtil(arr, temp, l, m, K);\n                        cnt += mergeSortUtil(arr, temp, m + 1, r, K);\n                        cnt += merge(arr, temp, l, m, r, K);\n                } \n                return cnt;\n        }\nstatic void mergeSort(int arr[], int N, int K)\n        {\n                int temp[] = new int[N];\n                System.out.print(mergeSortUtil(arr, temp, 0, N - 1, K));\n        }", "237": "static void minRemovals(int []A, int N)\n        {\n                Arrays.sort(A);\n                int mx = A[N - 1];\n                int sum = 1;\n                for (int i = 0; i < N; i++)\n                {\n                        sum += A[i];\n                }\n                if (sum - mx >= mx) {\n                        System.out.println(0);\n                }\n                else {\n                        System.out.println(2 * mx - sum);\n                }\n        }", "238": "static void rearrangeArray(int a[], int n)\n{\n        Arrays.sort(a);\n        for(int i = 0; i < n - 1; i++)\n        {\n                if (a[i] == i + 1)\n                {\n                        int temp = a[i];\n                        a[i] = a[i + 1];\n                        a[i + 1] = temp;\n                }\n        }\n        if (a[n - 1] == n)\n        {\n                int temp = a[n - 1];\n                a[n - 1] = a[n - 2];\n                a[n - 2] = temp;\n        }\n        for(int i = 0; i < n; i++)\n        {\n                System.out.print(a[i] + \" \");\n        }\n}", "239": "static boolean checkStr1CanConStr2(String str1, String str2)\n{\n        int N = str1.length();\n        int M = str2.length();\n        HashSet<Integer> st1 = new HashSet<>();\n        HashSet<Integer> st2 = new HashSet<>();\n        int hash1[] = new int[256];\n        for (int i = 0; i < N; i++)\n        {\n                hash1[str1.charAt(i)]++;\n        }\n        for (int i = 0; i < N; i++)\n        {\n                st1.add((int)str1.charAt(i));\n        }\n        for (int i = 0; i < M; i++)\n        {\n                st2.add((int)str2.charAt(i));\n        }\n        if (!st1.equals(st2))\n        {\n                return false;\n        }\n        int hash2[] = new int[256];\n        for (int i = 0; i < M; i++)\n        {\n                hash2[str2.charAt(i)]++;\n        }\n        Arrays.sort(hash1);\n        Arrays.sort(hash2);\n        for (int i = 0; i < 256; i++)\n        {\n                if (hash1[i] != hash2[i])\n                {\n                        return false;\n                }\n        }\n        return true;\n}", "240": "static int minOperations(int arr1[], int arr2[], int i, int j)\n{\n        if (arr1.equals(arr2))\n                return 0;\n        if (i >= arr1.length j >= arr2.length)\n                return 0;\n        if (arr1[i] < arr2[j])\n                return 1 + minOperations(arr1, arr2, i + 1, j + 1);\n        return Math.max(minOperations(arr1, arr2, i, j + 1),\n                                        minOperations(arr1, arr2, i + 1, j));\n}\nstatic void minOperationsUtil(int[] arr)\n{\n        int brr[] = new int[arr.length];\n        for(int i = 0; i < arr.length; i++)\n                brr[i] = arr[i];\n        Arrays.sort(brr);\n        if (arr.equals(brr))\n                System.out.print(\"0\");\n        else\n                System.out.println(minOperations(arr, brr, 0, 0));\n}", "241": "public static int minOperations(int[] arr, int n)\n        {\n                Pair[] num = new Pair[n];\n                for (int i = 0; i < n; i++) {\n                        num[i] = new Pair(arr[i], i);\n                }\n                Arrays.sort(num, (Pair a, Pair b) -> a.val - b.val);\n                int res = 1;\n                int streak = 1;\n                int prev = num[0].idx;\n                for (int i = 1; i < n; i++) {\n                        if (prev < num[i].idx) {\n                                res++;\n                                streak = Math.max(res, streak);\n                        }\n                        else\n                                res = 1;\n                        prev = num[i].idx;\n                }\n                return n - streak;\n        }", "242": "static void canTransform(String s, String t)\n{\n int n = s.length();\n Vector<Integer> occur[] = new Vector[26];\n for (int i = 0; i < occur.length; i++)\n        occur[i] = new Vector<Integer>();\n for (int x = 0; x < n; x++)\n {\n        char ch = (char)(s.charAt(x) - 'a');\n        occur[ch].add(x);\n }\n int []idx = new int[26];\n boolean poss = true;\n for (int x = 0; x < n; x++)\n {\n        char ch = (char)(t.charAt(x) - 'a');\n        if (idx[ch] >= occur[ch].size())\n        {\n        poss = false;\n        break;\n        }\n        for (int small = 0; small < ch; small++)\n        {\n        if (idx[small] < occur[small].size() &&\n                occur[small].get(idx[small]) <\n                occur[ch].get(idx[ch]))\n        {\n                poss = false;\n                break;\n        }\n        }\n        idx[ch]++;\n }\n if (poss)\n {\n        System.out.print(\"Yes\" + \"\\n\");\n }\n else\n {\n        System.out.print(\"No\" + \"\\n\");\n }\n}", "243": "static int getMaxSum(int i, int j, int k, int arr1[], int arr2[], int arr3[])\n{\n        int cnt = 0;\n        if (i >= n1)\n                cnt++;\n        if (j >= n2)\n                cnt++;\n        if (k >= n3)\n                cnt++;\n        if (cnt >= 2)\n                return 0;\n        if (dp[i][j][k] != -1)\n                return dp[i][j][k];\n        int ans = 0;\n        if (i < n1 && j < n2)\n                ans = Math.max(ans,\n                                        getMaxSum(i + 1, j + 1, k, arr1, arr2, arr3) + arr1[i] * arr2[j]);\n        if (i < n1 && k < n3)\n                ans = Math.max(ans,\n                                        getMaxSum(i + 1, j, k + 1, arr1, arr2, arr3) + arr1[i] * arr3[k]);\n        if (j < n2 && k < n3)\n                ans = Math.max(ans,\n                                        getMaxSum(i, j + 1, k + 1, arr1, arr2, arr3) + arr2[j] * arr3[k]);\n        dp[i][j][k] = ans;\n        return dp[i][j][k];\n}\nstatic void reverse(int[] tmp)\n{\n        int i, k, t;\n        int n = tmp.length;\n                for(i = 0; i < n/ 2; i++)\n                {\n                        t = tmp[i];\n                        tmp[i] = tmp[n - i - 1];\n                        tmp[n - i - 1] = t;\n                }\n}\nstatic int maxProductSum(int arr1[], int arr2[], int arr3[])\n{\n        for(int i = 0; i < dp.length; i++)\n                for(int j = 0; j < dp[0].length; j++)\n                        for(int k = 0; k < dp[j][0].length; k++)\n                                dp[i][j][k] = -1;\n        Arrays.sort(arr1);\n        reverse(arr1);\n        Arrays.sort(arr2);\n        reverse(arr2);\n        Arrays.sort(arr3);\n        reverse(arr3);\n        return getMaxSum(0, 0, 0, arr1, arr2, arr3);\n}", "244": "static void findTriplet(int arr[], int N)\n{\n        Arrays.sort(arr);\n        int flag = 0, i;\n        for(i = N - 1; i - 2 >= 0; i--)\n        {\n                if (arr[i - 2] + arr[i - 1] > arr[i])\n                {\n                        flag = 1;\n                        break;\n                }\n        }\n        if (flag != 0)\n        {\n                System.out.println(arr[i - 2] + \" \" + arr[i - 1] + \" \" + arr[i] );\n        }\n        else\n        {\n                System.out.println(-1);\n        }\n}", "245": "static int inversionCount(String s)\n{\n        int[] freq = new int[26];\n        int inv = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n                int temp = 0;\n                for(int j = 0;\n                                j < (int)(s.charAt(i) - 'a'); j++)\n                temp += freq[j];\n                inv += (i - temp);\n                freq[s.charAt(i) - 'a']++;\n        }\n        return inv;\n}\nstatic boolean haveRepeated(String S1, String S2)\n{\n        int[] freq = new int[26];\n        for(char i : S1.toCharArray())\n        {\n                if (freq[i - 'a'] > 0)\n                        return true;\n                freq[i - 'a']++;\n        }\n        for(int i = 0; i < 26; i++)\n                freq[i] = 0;\n        for(char i : S2.toCharArray())\n        {\n                if (freq[i - 'a'] > 0)\n                        return true;\n                freq[i - 'a']++;\n        }\n        return false;\n}\nstatic void checkToMakeEqual(String S1, String S2)\n{\n        int[] freq = new int[26];\n        for(int i = 0; i < S1.length(); i++)\n        {\n                freq[S1.charAt(i) - 'a']++;\n        }\n        boolean flag = false;\n        for(int i = 0; i < S2.length(); i++)\n        {\n                if (freq[S2.charAt(i) - 'a'] == 0)\n                {\n                        flag = true;\n                        break;\n                }\n                freq[S2.charAt(i) - 'a']--;\n        }\n        if (flag == true)\n        {\n                System.out.println(\"No\");\n                return;\n        }\n        int invCount1 = inversionCount(S1);\n        int invCount2 = inversionCount(S2);\n        if (invCount1 == invCount2 ||\n        (invCount1 & 1) == (invCount2 & 1) ||\n                haveRepeated(S1, S2))\n        {\n                System.out.println(\"Yes\");\n        }\n        else\n        System.out.println(\"No\");\n}", "246": "static int numberofpairs(int []arr, int N)\n{\n        int answer = 0;\n        Arrays.sort(arr);\n        int minDiff = 10000000;\n        for (int i = 0; i < N - 1; i++)\n                minDiff = Math.min(minDiff, arr[i + 1] - arr[i]);\n        for (int i = 0; i < N - 1; i++)\n        {\n                if (arr[i + 1] - arr[i] == minDiff)\n                        answer++;\n        }\n        return answer;\n}", "247": "static void sortArr(int a[], int n)\n{\n        int i, k;\n        k = (int)(Math.log(n) / Math.log(2));\n        k = (int) Math.pow(2, k);\n        while (k > 0)\n        {\n                for(i = 0; i + k < n; i++)\n                        if (a[i] > a[i + k])\n                        {\n                                int tmp = a[i];\n                                a[i] = a[i + k];\n                                a[i + k] = tmp;\n                        }\n                k = k / 2;\n        }\n        for(i = 0; i < n; i++)\n        {\n                System.out.print(a[i] + \" \");\n        }\n}", "248": "static void maximumSum(int arr[], int n, int k)\n{\n        int elt = n / k;\n        int sum = 0;\n        Arrays.sort(arr);\n        int count = 0;\n        int i = n - 1;\n        while (count < k)\n        {\n                sum += arr[i];\n                i--;\n                count++;\n        }\n        count = 0;\n        i = 0;\n        while (count < k)\n        {\n                sum += arr[i];\n                i += elt - 1;\n                count++;\n        }\n        System.out.println(sum);\n}", "249": "static int findMinSum(int []arr, int K, int L, int size)\n{\n        if (K * L > size)\n                return -1;\n        int minsum = 0;\n        Arrays.sort(arr);\n        for(int i = 0; i < K; i++)\n                minsum += arr[i];\n        return minsum;\n}", "250": "static void find_max_length( int []arr, int index, int sum, int k)\n{\n        sum = sum + arr[index];\n        store.add(arr[index]);\n        if (sum == k)\n        {\n                if (max_length < store.size())\n                {\n                        max_length = store.size();\n                        ans = store;\n                }\n        }\n        for (int i = index + 1; i < arr.length; i++)\n        {\n                if (sum + arr[i] <= k)\n                {\n                        find_max_length(arr, i, sum, k);\n                        store.remove(store.size() - 1);\n                }\n                else\n                        return;\n        }\n        return;\n}\nstatic int longestSubsequence(int []arr, int n, int k)\n{\n        Arrays.sort(arr);\n        for (int i = 0; i < n; i++)\n        {\n                if (max_length >= n - i)\n                        break;\n                store.clear();\n                find_max_length(arr, i, 0, k);\n        }\n        return max_length;\n}", "251": "static int findKthSmallest(int[] arr, int n, int k)\n        {\n                int max = 0;\n                for (int i = 0; i < n; i++)\n                {\n                        if (arr[i] > max)\n                                max = arr[i];\n                }\n                int[] counter = new int[max + 1];\n                int smallest = 0;\n                for (int i = 0; i < n; i++)\n                {\n                        counter[arr[i]]++;\n                }\n                for (int num = 1; num <= max; num++)\n                {\n                        if (counter[num] > 0)\n                        {\n                                smallest += counter[num];\n                        }\n                        if (smallest >= k)\n                        {\n                                return num;\n                        }\n                }\n                return -1;\n        }", "252": "static void lexNumbers(int n)\n{\n        Vector<String> s = new Vector<String>();\n        for (int i = 1; i <= n; i++)\n        {\n                s.add(String.valueOf(i));\n        }\n        Collections.sort(s);\n        Vector<Integer> ans = new Vector<Integer>();\n        for (int i = 0; i < n; i++)\n                ans.add(Integer.valueOf(s.get(i)));\n        for (int i = 0; i < n; i++)\n                System.out.print(ans.get(i) + \" \");\n}", "253": "public static void lexNumbers(int n)\n        {\n                List<Integer> sol = new ArrayList<>();\n                dfs(1, n, sol);\n                System.out.println(sol);\n        }\npublic static void dfs(int temp, int n, List<Integer> sol)\n        {\n                if (temp > n)\n                        return;\n                sol.add(temp);\n                dfs(temp * 10, n, sol);\n                if (temp % 10 != 9)\n                        dfs(temp + 1, n, sol);\n        }", "254": "static void func(int a[][])\n{\n        int i, j, k;\n        for(i = 0; i < N; i++)\n        {\n        if (i % 2 == 0)\n        {\n                for(j = 0; j < N; j++)\n                {\n                        for(k = j + 1; k < N; ++k)\n                        {\n                                if (a[i][j] > a[i][k])\n                                {\n                                        int temp = a[i][j];\n                                        a[i][j] = a[i][k];\n                                        a[i][k] = temp;\n                                }\n                        }\n                }\n        }\n        else\n        {\n                for(j = 0; j < N; j++)\n                {\n                        for(k = j + 1; k < N; ++k)\n                        {\n                                if (a[i][j] < a[i][k])\n                                {\n                                        int temp = a[i][j];\n                                        a[i][j] = a[i][k];\n                                        a[i][k] = temp;\n                                }\n                        }\n                }\n        }\n        }\n        for(i = 0; i < N; i++)\n        {\n        for(j = 0; j < N; j++)\n        {\n                System.out.print(a[i][j] + \" \");\n        }\n        System.out.print(\"\\n\");\n        }\n}", "255": "static int partition(int arr[], int l, int h)\n{\n        int pivot = arr[l];\n        int i = l + 1;\n        int j = h;\n        while (i <= j)\n        {\n                while (i <= h && arr[i] < pivot)\n                {\n                        i++;\n                }\n                while (j > l && arr[j] > pivot)\n                {\n                        j--;\n                }\n                if (i < j)\n                {\n                        int temp = arr[i];\n                        arr[i] = arr[j];\n                        arr[j] = temp;\n                        i++;\n                        j--;\n                }\n                else\n                        i++;\n        }\n        arr[l] = arr[j];\n        arr[j] = pivot;\n        return j;\n}\nstatic void sortArray(int arr[], int l, int h)\n{\n        if (l >= h)\n                return;\n        int pivot = partition(arr, l, h);\n        sortArray(arr, l, pivot - 1);\n        sortArray(arr, pivot + 1, h);\n}\nstatic int findMaxIntervals(int start[], int end[], int n, int R)\n{\n        int ans = 0;\n        int prev = 0;\n        int currActive = 0;\n        int i = 0;\n        int j = 0;\n        if (start[0] > 0)\n                ans++;\n        while (i < n && j < n)\n        {\n                if (start[i] < end[j])\n                {\n                        i++;\n                        currActive++;\n                }\n                else if (start[i] > end[j])\n                {\n                        j++;\n                        currActive--;\n                }\n                else\n                {\n                        i++;\n                        j++;\n                }\n                if (currActive == 0)\n                {\n                        ans++;\n                }\n        }\n        if (end[n - 1] < R)\n                ans++;\n        return ans;\n}"}, "Python": {"0": "def minCost(cost):\n    dist = [INF] * N\n    dist[0] = 0\n    for i in range(N):\n        for j in range(i, N):\n            if dist[j] > dist[i] + cost[i][j]:\n                dist[j] = dist[i] + cost[i][j]\n    return dist[N-1]", "1": "def numOfways(n, k):\n    p = 1\n    if k % 2 != 0:\n        p = -1\n    return (int((math.pow(n - 1, k))\n                + p * (n - 1)) / n)", "2": "def fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\ndef findVertices(n):\n    return fib(n + 2)", "3": "def reverse(head_ref): \n    temp = None\n    current = head_ref \n    while(current is not None): \n        temp = current.prev\n        current.prev = current.next\n        current.next = temp \n        current = current.prev \n    if(temp is not None): \n        head_ref = temp.prev \n    return head_ref \n\ndef merge(first, second): \n    if first is None: \n        return second \n    if second is None: \n        return first \n    if first.data < second.data: \n        first.next = merge(first.next, second) \n        first.next.prev = first \n        first.prev = None\n        return first \n    else: \n        second.next = merge(first, second.next) \n        second.next.prev = second \n        second.prev = None\n        return second \n\ndef sort(head): \n    if head is None or head.next is None: \n        return head \n    current = head.next\n    while(current is not None): \n        if current.data < current.prev.data: \n            break \n        current = current.next\n    if current is None: \n        return head \n    current.prev.next = None\n    current.prev = None\n    current = reverse(current)\n    return merge(head, current)\n\ndef push(head_ref, new_data): \n    new_node = Node() \n    new_node.data = new_data \n    new_node.prev = None\n    new_node.next = (head_ref) \n    if((head_ref) is not None): \n        (head_ref).prev = new_node \n    (head_ref) = new_node \n    return head_ref \n\ndef printList(head): \n    if(head is None): \n        print(\"Doubly Linked list empty\") \n    while(head is not None): \n        print(head.data, end = ' ') \n        head = head.next", "4": "class Node:\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\n        \ndef newNode(key):\n    temp = Node(key)\n    temp.next = None\n    return temp\n\ndef printlist(head):\n    if head == None:\n        print(\"Empty List\")\n        return\n    while head != None:\n        print(head.data, end = \" \")\n        if head.next != None:\n            print(\"-> \", end = \"\")\n        head = head.next\n    print()\n\ndef isVowel(x):\n    return (x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u')\n\ndef arrange(head):\n    newHead = head\n    latestVowel = None\n    curr = head\n    if head == None:\n        return None\n    if isVowel(head.data) == True:\n        latestVowel = head\n    else:\n        while curr.next != None and not isVowel(curr.next.data):\n            curr = curr.next\n        if curr.next == None:\n            return head\n        latestVowel = newHead = curr.next\n        curr.next = curr.next.next\n        latestVowel.next = head\n    while curr != None and curr.next != None:\n        if isVowel(curr.next.data) == True:\n            if curr == latestVowel:\n                latestVowel = curr = curr.next\n            else:\n                temp = latestVowel.next\n                latestVowel.next = curr.next\n                latestVowel = latestVowel.next\n                curr.next = curr.next.next\n                latestVowel.next = temp\n        else:\n            curr = curr.next\n    return newHead", "5": "def newNode(data):\n    temp = Node()\n    temp.data = data\n    temp.right = None\n    temp.left = None\n    return temp\ndef KthLargestUsingMorrisTraversal(root, k):\n    curr = root\n    Klargest = None\n    count = 0\n    while curr != None:\n        if curr.right == None:\n            if ++count == k:\n                Klargest = curr\n            curr = curr.left\n        else:\n            succ = curr.right\n            while succ.left != None and succ.left != curr:\n                succ = succ.left\n            if succ.left == None:\n                succ.left = curr\n                curr = curr.right\n            else:\n                succ.left = None\n                if ++count == k:\n                    Klargest = curr\n                curr = curr.left\n    return Klargest", "6": "def sortByRow(mat, n, ascending):\n\tfor i in range(0,n):\n\t\tif ascending:\n\t\t\tmat[i].sort()\n\t\telse:\n\t\t\tmat[i].sort(reverse=True)\ndef transpose(mat, n):\n\tfor i in range (0,n):\n\t\tfor j in range (i+1,n):\n\t\t\ttemp = mat[i][j]\n\t\t\tmat[i][j] = mat[j][i]\n\t\t\tmat[j][i] = temp\ndef sortMatRowAndColWise(mat, n):\n\tsortByRow(mat, n, True)\n\ttranspose(mat, n)\n\tsortByRow(mat, n, False)\n\ttranspose(mat, n)\ndef printMat(mat, n):\n\tfor i in range (0,n):\n\t\tfor j in range (0,n):\n\t\t\tprint(mat[i][j], end=\" \")\n\t\tprint()", "7": "def sortByRow(mat, n):\n\tfor i in range(n):\n\t\tmat[i].sort()\ndef transpose(mat, n):\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\ttemp = mat[i][j]\n\t\t\tmat[i][j] = mat[j][i]\n\t\t\tmat[j][i] = temp\ndef sortMatRowAndColWise(mat, n):\n\tsortByRow(mat, n)\n\ttranspose(mat, n)\n\tsortByRow(mat, n)\n\ttranspose(mat, n)\ndef printMat(mat, n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tprint(mat[i][j] + \" \", end=\"\")\n\t\tprint()", "8": "def doublyEven(n):\n\tarr = [[0 for i in range(n)] for j in range(n)]\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tarr[i][j] = (n*i) + j + 1\n\tfor i in range(n/4):\n\t\tfor j in range(n/4):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j]\n\tfor i in range(n/4):\n\t\tfor j in range(3 * (n/4), n):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j]\n\tfor i in range(3 * n/4, n):\n\t\tfor j in range(n/4):\n\t\t\tarr[i][j] = (n*n+1) - arr[i][j]\n\tfor i in range(3 * n/4, n):\n\t\tfor j in range(3 * n/4, n):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j]\n\tfor i in range(n/4, 3 * n/4):\n\t\tfor j in range(n/4, 3 * n/4):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j]\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tprint(arr[i][j], end = \" \")\n\t\tprint()", "9": "def Kroneckerproduct(A, B):\n        rowa = len(A)\n        rowb = len(B)\n        cola = len(A[0])\n        colb = len(B[0])\n        C = [[0 for x in range(rowa * rowb)] for y in range(cola * colb)]\n        for i in range(rowa):\n            for k in range(rowb):\n                for j in range(cola):\n                    for l in range(colb):\n                        C[i + l][j + k] = A[i][j] * B[k][l]\n        return C", "10": "def isLowerTriangularMatrix(mat):\n        for i in range(N):\n                for j in range(i + 1, N):\n                        if (mat[i][j] != 0):\n                                return False\n        return True", "11": "def isUpperTriangularMatrix(mat):\n\tfor i in range(1, N):\n\t\tfor j in range(0, i):\n\t\t\tif (mat[i][j] != 0):\n\t\t\t\treturn false\n\treturn true", "12": "def countSets(array):\n\tres = 0\n\tfor i in range(n):\n\t\tu = 0\n\t\tv = 0\n\t\tfor j in range(m):\n\t\t\tif (array[i][j] == 1):\n\t\t\t\tu += 1\n\t\t\telse:\n\t\t\t\tv += 1\n\t\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1\n\tfor i in range(m):\n\t\tu = 0\n\t\tv = 0\n\t\tfor j in range(n):\n\t\t\tif (array[j][i] == 1):\n\t\t\t\tu += 1\n\t\t\telse:\n\t\t\t\tv += 1\n\t\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1\n\treturn res - (n * m)", "13": "def transpose(mat, N):\n\ttr = []\n\tfor i in range(0,N):\n\t\tfor j in range(0,N):\n\t\t\ttr[i][j] = mat[j][i]\n\t\t\t\ndef isSymmetric(mat, N):\n\ttr = transpose(mat, N)\n\tfor i in range(0,N):\n\t\tfor j in range(0,N):\n\t\t\tif (mat[i][j] != tr[i][j]):\n\t\t\t\treturn false\n\treturn true", "14": "def isSymmetric(mat, N):\n\tfor i in range(0, N):\n\t\tfor j in range(0, N):\n\t\t\tif (mat[i][j] != mat[j][i]):\n\t\t\t\treturn false\n\treturn true", "15": "def findNormal(mat, n):\n    sum = 0\n    for i in range(n):\n        for j in range(n):\n            sum += mat[i][j]*mat[i][j]\n    return int(sqrt(sum))\ndef findTrace(mat, n):\n    sum = 0\n    for i in range(n):\n        sum += mat[i][i]\n    return sum", "16": "def maxDet(n):\n\treturn (2 * n * n * n)\n\ndef resMatrix(n):\n\tfor i in range(3):\n\t\tfor j in range(3):\n\t\t\tif i == 0 and j == 2:\n\t\t\t\tprint(\"0 \", end=\"\")\n\t\t\telif i == 1 and j == 0:\n\t\t\t\tprint(\"0 \", end=\"\")\n\t\t\telif i == 2 and j == 1:\n\t\t\t\tprint(\"0 \", end=\"\")\n\t\t\telse:\n\t\t\t\tprint(n +\" \", end=\"\")\n\t\tprint(\"\")", "17": "def countNegative(M, n, m):\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if M[i][j] < 0:\n                count += 1\n            else:\n                break\n    return count", "18": "def countNegative(M, n, m):\n    count = 0\n    i = 0\n    j = m - 1\n    while j >= 0 and i < n:\n        if M[i][j] < 0:\n            count += j + 1\n            i += 1\n        else:\n            j -= 1\n    return count", "19": "def getLastNegativeIndex(array, start, end):\n\tif (start == end):\n\t\treturn start\n\tmid = start + (end - start) / 2\n\tif (array[mid] < 0):\n\t\tif (mid + 1 < array.length and array[mid + 1] >= 0):\n\t\t\treturn mid\n\t\treturn getLastNegativeIndex(array, mid + 1, end)\n\telse:\n\t\treturn getLastNegativeIndex(array, start, mid - 1)\ndef countNegative(M, n, m):\n\tcount = 0\n\tnextEnd = m - 1\n\tfor i in range(n):\n\t\tif (M[i][0] >= 0):\n\t\t\tbreak\n\t\tnextEnd = getLastNegativeIndex(M[i], 0, nextEnd)\n\t\tcount += nextEnd + 1\n\treturn count", "20": "def findMaxValue(N, mat):\n    maxValue = -99999999\n    for a in range(0, N-1):\n        for b in range(0, N-1):\n            for d in range(a+1, N):\n                for e in range(b+1, N):\n                    if maxValue < (mat[d][e] - mat[a][b]):\n                        maxValue = mat[d][e] - mat[a][b]\n    return maxValue", "21": NaN, "22": "def youngify(mat, i, j):\n\tdownVal = (i + 1 < N) ? mat[i + 1][j] : INF\n\trightVal = (j + 1 < N) ? mat[i][j + 1] : INF\n\tif downVal == INF and rightVal == INF:\n\t\treturn\n\tif downVal < rightVal:\n\t\tmat[i][j] = downVal\n\t\tmat[i + 1][j] = INF\n\t\tyoungify(mat, i + 1, j)\n\telse:\n\t\tmat[i][j] = rightVal\n\t\tmat[i][j + 1] = INF\n\t\tyoungify(mat, i, j + 1)\n\ndef extractMin(mat):\n\tret = mat[0][0]\n\tmat[0][0] = INF\n\tyoungify(mat, 0, 0)\n\treturn ret\n\ndef printSorted(mat):\n\tprint(\"Elements of matrix in sorted order n\")\n\tfor i in range(0, N * N):\n\t\tprint(extractMin(mat) + \" \")", "23": "def printSumSimple(mat, k):\n\tif k > n:\n\t\treturn\n\tfor i in range(0, n-k+1):\n\t\tfor j in range(0, n-k+1):\n\t\t\tsum = 0\n\t\t\tfor p in range(i, k+i):\n\t\t\t\tfor q in range(j, k+j):\n\t\t\t\t\tsum += mat[p][q]\n\t\t\tprint(sum, \" \", end=\"\")\n\t\tprint()", "24": "def printSumTricky(mat, k):\n\tif k > len(mat):\n\t\treturn\n\tstripSum = [[0] * len(mat) for i in range(len(mat))]\n\tfor j in range(len(mat)):\n\t\tsum = 0\n\t\tfor i in range(k):\n\t\t\tsum += mat[i][j]\n\t\tstripSum[0][j] = sum\n\t\tfor i in range(1, len(mat) - k + 1):\n\t\t\tsum += mat[i + k - 1][j] - mat[i - 1][j]\n\t\t\tstripSum[i][j] = sum\n\tfor i in range(len(mat) - k + 1):\n\t\tsum = 0\n\t\tfor j in range(k):\n\t\t\tsum += stripSum[i][j]\n\t\tprint(sum + \" \", end=\"\")\n\t\tfor j in range(1, len(mat) - k + 1):\n\t\t\tsum += stripSum[i][j + k - 1] - stripSum[i][j - 1]\n\t\t\tprint(sum + \" \", end=\"\")\n\t\tprint()", "25": "def transpose(A, B):\n\tfor i in range(N):\n\t\tfor j in range(M):\n\t\t\tB[i][j] = A[j][i]", "26": "def transpose(A):\n  for i in range(0, len(A)):\n    for j in range(i+1, len(A[0])):\n      temp = A[i][j]\n      A[i][j] = A[j][i]\n      A[j][i] = temp", "27": "def pathCountRec(mat, m, n, k):\n\tif m < 0 or n < 0:\n\t\treturn 0\n\tif m == 0 and n == 0 and (k == mat[m][n]):\n\t\treturn 1\n\treturn pathCountRec(mat, m - 1, n, k - mat[m][n]) + pathCountRec(mat, m, n - 1, k - mat[m][n])\n\ndef pathCount(mat, k):\n\treturn pathCountRec(mat, len(mat) - 1, len(mat[0]) - 1, k)", "28": "def pathCountDPRecDP(mat, m, n, k):\n\tif (m < 0 n < 0):\n\t\treturn 0\n\tif (m==0 && n==0):\n\t\treturn (k == mat[m][n] ? 1 : 0)\n\tif (dp[m][n][k] != -1):\n\t\treturn dp[m][n][k]\n\tdp[m][n][k] = pathCountDPRecDP(mat, m-1, n, k-mat[m][n]) +\n\t\t\t\tpathCountDPRecDP(mat, m, n-1, k-mat[m][n]);\n\treturn dp[m][n][k]\n\ndef pathCountDP(mat, k):\n\tfor i in range(R):\n\t\tfor j in range(C):\n\t\t\tfor l in range(MAX_K):\n\t\t\t\tdp[i][j][l]=-1\n\treturn pathCountDPRecDP(mat, R-1, C-1, k)", "29": "def check(A, N):\n    S = []\n    B_end = 0\n    for i in range(N):\n        if len(S) != 0:\n            top = S[len(S) - 1]\n            while top == B_end + 1:\n                B_end = B_end + 1\n                S.pop()\n                if len(S) == 0:\n                    break\n                top = S[len(S) - 1]\n            if len(S) == 0:\n                S.append(A[i])\n            else:\n                top = S[len(S) - 1]\n                if A[i] < top:\n                    S.append(A[i])\n                else:\n                    return False\n        else:\n            S.append(A[i])\n    return True", "30": "def countMinReversals(expr):\n\tlen = expr.length();\n\tif len%2 != 0:\n\t\treturn -1;\n\ts = [];\n\tfor i in range(0, len):\n\t\tc = expr.charAt(i);\n\t\tif c =='}' and !s.empty():\n\t\t\tif s.peek()=='{':\n\t\t\t\ts.pop();\n\t\t\telse:\n\t\t\t\ts.push(c);\n\t\telse:\n\t\t\ts.push(c);\n\tred_len = s.size();\n\tn = 0;\n\twhile !s.empty() and s.peek() == '{':\n\t\ts.pop();\n\t\tn++;\n\treturn (red_len/2 + n%2);", "31": "def countMinReversals(expr):\n\tlen = expr.length()\n\tif len % 2 != 0:\n\t\treturn -1\n\tleft_brace = 0\n\tright_brace = 0\n\tfor i in range(0, len):\n\t\tch = expr.charAt(i)\n\t\tif ch == '{':\n\t\t\tleft_brace++\n\t\telse:\n\t\t\tif left_brace == 0:\n\t\t\t\tright_brace++\n\t\t\telse:\n\t\t\t\tleft_brace--\n\tans = (int)(Math.ceil((0.0 + left_brace) / 2)\n\t\t\t\t+ Math.ceil((0.0 + right_brace) / 2))\n\treturn ans", "32": "def PrintMinNumberForPattern(arr):\n\tcurr_max = 0\n\tlast_entry = 0\n\tj = 0\n\tfor i in range(0, len(arr)):\n\t\tnoOfNextD = 0\n\t\tif arr.charAt(i) == 'I':\n\t\t\tj = i + 1\n\t\t\twhile (j < arr.length() && arr.charAt(j) == 'D'):\n\t\t\t\tnoOfNextD++\n\t\t\t\tj++\n\t\t\tif (i == 0):\n\t\t\t\tcurr_max = noOfNextD + 2\n\t\t\t\tSystem.out.print(\" \" + (++last_entry))\n\t\t\t\tSystem.out.print(\" \" + curr_max)\n\t\t\t\tlast_entry = curr_max\n\t\t\telse:\n\t\t\t\tcurr_max = curr_max + noOfNextD + 1\n\t\t\t\tlast_entry = curr_max\n\t\t\t\tSystem.out.print(\" \" + last_entry)\n\t\t\tfor k in range(0, noOfNextD):\n\t\t\t\tSystem.out.print(\" \" + (--last_entry))\n\t\t\t\ti++\n\t\t\t\tbreak\n\t\t\tif arr.charAt(i) == 'D':\n\t\t\t\tif (i == 0):\n\t\t\t\t\tj = i + 1\n\t\t\t\t\twhile (j < arr.length() && arr.charAt(j) == 'D'):\n\t\t\t\t\t\tnoOfNextD++\n\t\t\t\t\t\tj++\n\t\t\t\t\t\tcurr_max = noOfNextD + 2\n\t\t\t\t\t\tSystem.out.print(\" \" + curr_max + \" \" + (curr_max - 1))\n\t\t\t\t\t\tlast_entry = curr_max - 1\n\t\t\t\telse:\n\t\t\t\t\tSystem.out.print(\" \" + (last_entry - 1))\n\t\t\t\t\tlast_entry--\n\t\t\t\t\tbreak\n\t\t\t\tSystem.out.println()", "33": "def printLeast(arr):\n    min_avail = 1\n    pos_of_I = 0\n    al = []\n    if arr[0] == 'I':\n        al.append(1)\n        al.append(2)\n        min_avail = 3\n        pos_of_I = 1\n    else:\n        al.append(2)\n        al.append(1)\n        min_avail = 3\n        pos_of_I = 0\n    for i in range(1, len(arr)):\n        if arr[i] == 'I':\n            al.append(min_avail)\n            min_avail += 1\n            pos_of_I = i + 1\n        else:\n            al.append(al[i])\n            for j in range(pos_of_I, i+1):\n                al[j] += 1\n            min_avail += 1\n    for i in range(0, len(al)):\n        print(al[i], end=' ')\n    print()", "34": "def PrintMinNumberForPattern(seq): \n\t\n\tresult = \"\"\n\tstk = []\n\t\n\tfor i in range(len(seq)+1): \n\t\tstk.append(i+1)\n\t\t\n\t\tif i == len(seq) or seq[i] == 'I': \n\t\t\t\n\t\t\twhile len(stk) != 0: \n\t\t\t\tresult += str(stk[-1])\n\t\t\t\tresult += \" \"\n\t\t\t\tstk.pop()\n\t\t\t\t\n\tprint(result)", "35": "def getMinNumberForPattern(seq):\n  n = len(seq)\n  if n >= 9:\n    return \"-1\"\n  result = [''] * (n + 1)\n  count = 1\n  for i in range(0, n + 1):\n    if i == n or seq[i] == 'I':\n      for j in range(i - 1, -2, -1):\n        result[j + 1] = str(count)\n        count += 1\n        if j >= 0 and seq[j] == 'I':\n          break\n  return ''.join(result)", "36": "def compare(k1, k2):\n\tif (k1.freq < k2.freq):\n\t\treturn 1\n\telif (k1.freq > k2.freq):\n\t\treturn -1\n\treturn 0\n\ndef rearrangeString(str):\n\tn = len(str)\n\tcount = [0] * MAX_CHAR\n\tfor i in range(0, n):\n\t\tcount[ord(str[i]) - ord('a')]++\n\tpq = PriorityQueue(new KeyComparator())\n\tfor c in range(ord('a'), ord('z')):\n\t\tval = c - ord('a')\n\t\tif (count[val] > 0):\n\t\t\tpq.add(new Key(count[val], chr(c)))\n\tstr = \"\"\n\tprev = Key(-1, '#')\n\twhile (pq.size() != 0):\n\t\tk = pq.peek()\n\t\tpq.poll()\n\t\tstr = str + k.ch\n\t\tif (prev.freq >", "37": "def subset(ar, n):\n    res = 0\n    ar.sort()\n    for i in range(0, n):\n        count = 1\n        for j in range(i, n-1):\n            if ar[j] == ar[j+1]:\n                count++\n            else:\n                break\n        res = max(res, count)\n    return res", "38": "def subset(arr, n):\n    mp = dict()\n    for i in range(0, n):\n        if not arr[i] in mp:\n            mp[arr[i]] = 1\n        else:\n            mp[arr[i]] += 1\n    res = 0\n    for entry in mp:\n        res = max(res, mp[entry])\n    return res", "39": "def areElementsContiguous(arr, n):\n\tarr.sort()\n\tfor i in range(1, n):\n\t\tif arr[i] - arr[i-1] > 1:\n\t\t\treturn False\n\treturn True", "40": "def areElementsContiguous(arr, n):\n\tmax = Integer.MIN_VALUE\n\tmin = Integer.MAX_VALUE\n\tfor i in range(0, n):\n\t\tmax = Math.max(max, arr[i])\n\t\tmin = Math.min(min, arr[i])\n\tm = max - min + 1\n\tif (m > n):\n\t\treturn false\n\tvisited = [False] * n\n\tfor i in range(0, n):\n\t\tvisited[arr[i] - min] = True\n\tfor i in range(0, m):\n\t\tif (visited[i] == False):\n\t\t\treturn False\n\treturn True", "41": "def areElementsContiguous(arr, n):\n\tus = set(arr)\n\tcount = 1\n\tcurr_ele = arr[0] - 1\n\twhile curr_ele in us:\n\t\tcount++\n\t\tcurr_ele--\n\tcurr_ele = arr[0] + 1\n\twhile curr_ele in us:\n\t\tcount++\n\t\tcurr_ele++\n\treturn count == len(us)", "42": "def longest(a, n, k): \n    freq = [0]*7 \n    start = 0\n    end = 0\n    now = 0\n    l = 0\n    for i in range(n): \n        freq[a[i]]+=1\n        if (freq[a[i]] == 1): \n            now+=1\n        while (now > k): \n            freq[a[l]]-=1\n            if (freq[a[l]] == 0): \n                now-=1\n            l+=1\n        if (i - l + 1 >= end - start +1): \n            end = i \n            start = l \n    for i in range(start, end + 1): \n        print(a[i], end = \" \")", "43": "def findSmallestRange(arr, n, k):\n    i, minval, maxval, minrange, minel, maxel, flag, minind = 0, None, None, None, 0, 0, 0, 0\n    ptr = [0] * k\n    minrange = 2147483647\n    while True:\n        minind = -1\n        minval = 2147483647\n        maxval = -2147483648\n        flag = 0\n        for i in range(0, k):\n            if ptr[i] == n:\n                flag = 1\n                break\n            if ptr[i] < n and arr[i][ptr[i]] < minval:\n                minind = i\n                minval = arr[i][ptr[i]]\n            if ptr[i] < n and arr[i][ptr[i]] > maxval:\n                maxval = arr[i][ptr[i]]\n        if flag == 1:\n            break\n        ptr[minind] += 1\n        if (maxval - minval) < minrange:\n            minel = minval", "44": "def findLargest(S, n):\n    found = False\n    S.sort()\n    for i in range(n-1, -1, -1):\n        for j in range(0, n):\n            if i == j:\n                continue\n            for k in range(j+1, n):\n                if i == k:\n                    continue\n                for l in range(k+1, n):\n                    if i == l:\n                        continue\n                    if S[i] == S[j] + S[k] + S[l]:\n                        found = True\n                        return S[i]\n    if found == False:\n        return Integer.MAX_VALUE\n    return -1", "45": "def getI():\n    return i\n    \ndef getJ():\n    return j\n    \ndef findFourElements(arr, n):\n    map = {}\n    for i in range(0, n-1):\n        for j in range(i+1, n):\n            map[arr[i] + arr[j]] = Indexes(i, j)\n            \n    d = min_value\n    for i in range(0, n-1):\n        for j in range(i+1, n):\n            abs_diff = math.abs(arr[i] - arr[j])\n            if abs_diff in map:\n                indexes = map.get(abs_diff)\n                if indexes.getI() != i and indexes.getI() != j and indexes.getJ() != i and indexes.getJ() != j:\n                    d = max(d, max(arr[i], arr[j]))\n                    \n    return d", "46": "def leftRotatebyOne(arr, n): \n    temp = arr[0] \n    for i in range(n - 1): \n        arr[i] = arr[i + 1] \n    arr[n-1] = temp \n          \ndef leftRotate(arr, d, n): \n    for i in range(d): \n        leftRotatebyOne(arr, n) \n          \ndef printArray(arr, n): \n    for i in range(n): \n        print(arr[i] , end=\" \")", "47": "def pushZerosToEnd(arr, n): \n    count = 0\n    for i in range(n): \n        if arr[i] != 0: \n            arr[count] = arr[i] \n            count+=1\n              \n    while count < n: \n        arr[count] = 0\n        count += 1", "48": "def moveZerosToEnd(arr, n):\n\tcount = 0\n\ttemp\n\tfor i in range(0, n):\n\tif (arr[i] != 0):\n\t\ttemp = arr[count]\n\t\tarr[count] = arr[i]\n\t\tarr[i] = temp\n\t\tcount = count + 1\n\tprintArray(arr, n)", "49": "def pushZerosToEnd(arr, n):\n    count = 0\n    for i in range(n):\n        if arr[i] != 0:\n            arr[count] = arr[i]\n            count += 1\n    while count < n:\n        arr[count] = 0\n        count += 1\ndef modifyAndRearrangeArr(arr, n):\n    if n == 1:\n        return\n    for i in range(n - 1):\n        if arr[i] != 0 and arr[i] == arr[i + 1]:\n            arr[i] = 2 * arr[i]\n            arr[i + 1] = 0\n            i += 1\n    pushZerosToEnd(arr, n)\ndef printArray(arr, n):\n    for i in range(n):\n        print(arr[i], \" \", end = \"\")\n    print()", "50": "def print_array(arr, n):\n        for i in range(n):\n                print(arr[i], end=\" \")\n        print()\ndef rearrange_pos_neg(arr, n):\n        key, j\n        for i in range(1, n):\n                key = arr[i]\n                if key > 0:\n                        continue\n                j = i - 1\n                while j >= 0 and arr[j] > 0:\n                        arr[j + 1] = arr[j]\n                        j = j - 1\n                arr[j + 1] = key", "51": "def print_array(A, size):\n        for i in range(0, size):\n                print(A[i], end = \" \")\n        print(\"\")\n\ndef reverse(arr, l, r):\n        if l < r:\n                arr = swap(arr, l, r)\n                reverse(arr, l + 1, r - 1)\n\ndef merge(arr, l, m, r):\n        i = l\n        j = m + 1\n        while (i <= m and arr[i] < 0):\n                i += 1\n        while (j <= r and arr[j] < 0):\n                j += 1\n        reverse(arr, i, m)\n        reverse(arr, m + 1, j - 1)\n        reverse(arr, i, j - 1)\n\ndef rearrange_pos_neg(arr, l, r):\n        if l < r:\n                m = l + (r - l) // 2\n                rearrange_pos_neg(arr, l, m)\n                rearrange_pos_neg(arr, m + 1, r)\n                merge(arr, l, m, r)\n\ndef swap(arr, i, j):\n        temp = arr[i]\n        arr[i] = arr[j]\n        arr[j] = temp\n        return arr", "52": "def RearrangePosNeg(arr):\n        i=0\n        j=arr.length-1\n        while(true):\n                while(arr[i]<0 and i<arr.length):\n                        i+=1\n                while(arr[j]>0 and j>=0):\n                        j-=1\n                if(i<j):\n                        temp = arr[i]\n                        arr[i] = arr[j]\n                        arr[j] = temp\n                else:\n                        break", "53": "def findElements(arr, n):\n    for i in range(0, n):\n        count = 0\n        for j in range(0, n):\n            if arr[j] > arr[i]:\n                count += 1\n        if count >= 2:\n            print(arr[i] + \" \")", "54": "def findElements(arr, n):\n        arr.sort()\n        for i in range(0, n - 2):\n                print(arr[i] + \" \")", "55": "def findElements(arr, n):\n \n        first = -99999999999\n        second = 99999999999\n        for i in range(0, n):\n                if arr[i] > first:\n                        second = first\n                        first = arr[i]\n                else if (arr[i] > second):\n                        second = arr[i]\n        for i in range(0, n):\n                if arr[i] < second:\n                        print(str(arr[i]) + \" \"),", "56": "def findFirstMissing(array, start, end):\n        if (start > end):\n                return end + 1;\n        if (start != array[start]):\n                return start;\n        mid = (start + end) / 2;\n        if (array[mid] == mid):\n                return findFirstMissing(array, mid+1, end);\n        return findFirstMissing(array, start, mid);", "57": "def findFirstMissing(arr, start, end, first):\n        if (start < end):\n                mid = (start+end)/2\n                if (arr[mid] != mid+first):\n                        return findFirstMissing(arr, start, mid , first)\n                else:\n                        return findFirstMissing(arr, mid+1, end , first)\n        return start+first\ndef findSmallestMissinginSortedArray( arr):\n        if(arr[0] != 0):\n                return 0\n        if(arr[len(arr)-1] == len(arr) - 1):\n                return len(arr)\n        first = arr[0]\n        return findFirstMissing(arr,0, len(arr)-1,first)", "58": "def FindMaxSum(arr, n):\n        incl = arr[0]\n        excl = 0\n        excl_new\n        for i in range(1, n):\n                excl_new = (incl > excl) ? incl : excl\n                incl = excl + arr[i]\n                excl = excl_new\n        return ((incl > excl) ? incl : excl)", "59": "def buildSparseTable(arr, n):\n        for i in range(n):\n                lookup[i][0] = arr[i]\n        for j in range(1,int(math.log(n, 2))+1):\n                for i in range(0,n-(1<<j)+1):\n                        if lookup[i][j-1] < lookup[i+(1<<(j-1))][j-1]:\n                                lookup[i][j] = lookup[i][j-1]\n                        else:\n                                lookup[i][j] = lookup[i+(1<<(j-1))][j-1]\n\ndef query(L,R):\n        j = int(math.log(R-L+1))\n        if lookup[L][j] <= lookup[R-(1<<j)+1][j]:\n                return lookup[L][j]\n        else:\n                return lookup[R-(1<<j)+1][j]", "60": "def buildSparseTable(arr, n):\n        for i in range(n):\n                table[i][0] = arr[i]\n        for j in range(1, n+1):\n                for i in range(n - (1 << j)):\n                        table[i][j] = __gcd(table[i][j - 1],\n                                                                table[i + (1 << (j - 1))][j - 1])\ndef query(L, R):\n        j = int(math.log(R - L + 1))\n        return __gcd(table[L][j],\n                                table[R - (1 << j) + 1][j])\ndef __gcd(a, b):\n        return b == 0 ? a : __gcd(b, a % b)", "61": "def findMaxAverage(arr, n, k):\n        if k > n:\n                return -1\n        csum = [0] * n\n        csum[0] = arr[0]\n        for i in range(1, n):\n                csum[i] = csum[i - 1] + arr[i]\n        max_sum = csum[k - 1]\n        max_end = k - 1\n        for i in range(k, n):\n                curr_sum = csum[i] - csum[i - k]\n                if curr_sum > max_sum:\n                        max_sum = curr_sum\n                        max_end = i\n        return max_end - k + 1", "62": "def findMaxAverage(arr, n, k):\n        if (k > n):\n                return -1;\n        sum = arr[0];\n        for (int i = 1; i < k; i++):\n                sum += arr[i];\n        max_sum = sum;\n        max_end = k-1;\n        for (int i = k; i < n; i++):\n                sum = sum + arr[i] - arr[i-k];\n                if (sum > max_sum):\n                        max_sum = sum;\n                        max_end = i;\n        return max_end - k + 1;", "63": "def isMajority(arr, n, x):\n        last_index = 0\n        last_index = (n%2==0)? n/2: n/2+1\n        for i in range(0,last_index):\n                if arr[i] == x and arr[i+n/2] == x:\n                        return true\n        return false", "64": "def binarySearch(arr, low, high, x):\n    if high >= low:\n        mid = (low + high)/2\n        if ( (mid == 0) and (x > arr[mid-1]) and (arr[mid] == x) ):\n            return mid\n        elif (x > arr[mid]):\n            return binarySearch(arr, (mid + 1), high, x)\n        else:\n            return binarySearch(arr, low, (mid -1), x)\n    return -1\ndef isMajority(arr, n, x):\n    i = binarySearch(arr, 0, n-1, x)\n    if i == -1:\n        return false\n    if (((i + n/2) <= (n -1)) and arr[i + n/2] == x):\n        return true\n    else:\n        return false", "65": "def isMajorityElement(arr, n, key):\n        if (arr[n / 2] == key):\n                return true;\n        else:\n                return false;", "66": "def sortMat(mat,n):\n        temp = [n*n]\n        k = 0\n        for i in range(0,n):\n                for j in range(0,n):\n                        temp[k] = mat[i][j]\n                        k = k + 1\n        temp.sort()\n        k = 0\n        for i in range(0,n):\n                for j in range(0,n):\n                        mat[i][j] = temp[k]\n                        k = k + 1\ndef printMat(mat,n):\n        for i in range(0,n):\n                for j in range(0,n):\n                        System.out.print(mat[i][j] + \" \")\n                System.out.println()", "67": "def sort(arr):\n        n = len(arr)\n        for i in range(0, n-1):\n                min_idx = i\n                for j in range(i+1, n):\n                        if arr[j] < arr[min_idx]:\n                                min_idx = j\n                temp = arr[min_idx]\n                arr[min_idx] = arr[i]\n                arr[i] = temp\ndef printArray(arr):\n        n = len(arr)\n        for i in range(0, n):\n                print(arr[i], end=\" \")\n        print()", "68": "def bubbleSort(arr, n):\n        for i in range (0, n-1):\n                swapped = false\n                for j in range (0, n-i-1):\n                        if (arr[j] > arr[j+1]):\n                                temp = arr[j]\n                                arr[j] = arr[j+1]\n                                arr[j+1] = temp\n                                swapped = True\n                if (swapped == false):\n                        break\n\ndef printArray(arr, size):\n        for i in range (0, size):\n                print(arr[i], end=\" \")\n        print()", "69": "def findCrossOver(arr, low, high, x):\n        if (arr[high] <= x):\n                return high;\n        if (arr[low] > x):\n                return low;\n        mid = (low + high)/2;\n        if (arr[mid] <= x and arr[mid+1] > x):\n                return mid;\n        if(arr[mid] < x):\n                return findCrossOver(arr, mid+1, high, x);\n        return findCrossOver(arr, low, mid - 1, x);\n\ndef printKclosest(arr, x, k, n):\n        l = findCrossOver(arr, 0, n-1, x);\n        r = l+1;\n        count = 0;\n        if (arr[l] == x):\n                l -= 1;\n        while (l >= 0 and r < n and count < k):\n                if (x - arr[l] < arr[r] - x):\n                        print(arr[l--] + \" \");\n                else:\n                        print(arr[r++] + \" \");\n                count += 1;\n        while (count < k and l >= 0):\n                print(arr[l--] + \" \");\n        while (count < k and r < n):\n                print(arr[r++] + \" \");", "70": "def push(val):\n        newnode = node(val)\n        newnode.next = head\n        head = newnode\ndef insertionSort(headref):\n        sorted = None\n        current = headref\n        while current != None:\n                next = current.next\n                sortedInsert(current)\n                current = next\n        head = sorted\ndef sortedInsert(newnode):\n        if sorted == None or sorted.val >= newnode.val:\n                newnode.next = sorted\n                sorted = newnode\n        else:\n                current = sorted\n                while current.next != None and current.next.val < newnode.val:\n                        current = current.next\n                newnode.next = current.next\n                current.next = newnode\ndef printlist(head):\n        while head != None:\n                print(head.val + \" \")\n                head = head.next", "71": NaN, "72": "def matrixChainMemoised(p, i, j, dp):\n        if (i == j):\n        return 0\n        if (dp[i][j] != -1):\n        return dp[i][j]\n        dp[i][j] = float(\"inf\")\n        for k in range(i, j):\n        dp[i][j] = min(dp[i][j], matrixChainMemoised(p, i, k, dp)\n                + matrixChainMemoised(p, k + 1, j, dp) + p[i - 1] * p[k] * p[j])\n        return dp[i][j]\ndef MatrixChainOrder(p, n):\n        dp = [[-1 for j in range(n)] for i in range(n)]\n        i = 1\n        j = n - 1\n        return matrixChainMemoised(p, i, j, dp)", "73": "def MatrixChainOrder(p, n):\n        m = [[0 for x in range(n)] for x in range(n)]\n        for i in range(1, n):\n                m[i][i] = 0\n        for L in range(2, n):\n                for i in range(1, n - L + 1):\n                        j = i + L - 1\n                        if j == n:\n                                continue\n                        m[i][j] = float(\"inf\")\n                        for k in range(i, j - 1):\n                                q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]\n                                if q < m[i][j]:\n                                        m[i][j] = q\n        return m[1][n - 1]", "74": "def cutRod(price, n):\n        if n <= 0:\n                return 0\n        max_val = Integer.MIN_VALUE\n        for i in range(n):\n                max_val = Math.max(max_val, price[i] + cutRod(price, n-i-1))\n        return max_val", "75": "def cutRod(price, n):\n        val = [0]*(n+1)\n        for i in range(1, n+1):\n                max_val = -10000000\n                for j in range(0, i):\n                        max_val = max(max_val, price[j] + val[i-j-1])\n                val[i] = max_val\n        return val[n]", "76": "def multiply(x, y):\n        if y == 0:\n                return 0\n        if y > 0:\n                return (x + multiply(x, y - 1))\n        if y < 0:\n                return -multiply(x, -y)\n        return -1", "77": "def sieveOfEratosthenes(n):\n        prime = [True for i in range(n + 1)]\n        p = 2\n        while p * p <= n:\n                if prime[p] == True:\n                        for i in range(p * p, n + 1, p):\n                                prime[i] = False\n                p += 1\n        for i in range(2, n):\n                if prime[i] == True:\n                        print(i, end = ' ')", "78": "def binomial_coeff(n, k): \n    res = 1\n    if (k > n - k): \n        k = n - k \n    for i in range(0 , k): \n        res = res * (n - i) \n        res = res / (i + 1) \n    return res \n  \ndef printPascal(n): \n    for line in range(0, n): \n        for i in range(0, line + 1): \n            print(int(binomial_coeff(line, i)), \" \",  \n                                              end = \"\") \n        print(\"\")", "79": "def printPascal(n): \n    for line in range (0, n): \n        for i in range (0, line + 1): \n            if (line == i or i == 0): \n                arr[line][i] = 1\n            else: \n                arr[line][i] = arr[line - 1][i - 1] +\n                               arr[line - 1][i] \n            print(arr[line][i], end = \" \") \n              \n        print(\"\")", "80": "def printPascal(n):\n    for line in range(1,n+1):\n        C=1\n        for i in range(1,line+1):\n            print(C,end=' ')\n            C=int(C*(line-i)/i)\n        print()", "81": "def Add(x, y):\n        while y != 0:\n                carry = x & y\n                x = x ^ y\n                y = carry << 1\n        return x", "82": NaN, "83": "def getModulo(n, d):\n        return ( n & (d-1) );", "84": "def count_set_bits(n):\n        count = 0\n        while n > 0:\n                count += n & 1\n                n >>= 1\n        return count", "85": "def countSetBits(n): \n       \n        if (n == 0): \n                return 0\n        else: \n                return 1 + countSetBits(n & (n - 1))", "86": "def initialize():\n        BitsSetTable256[0] = 0\n\n        for i in range(0, 256):\n                BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2]\n\n\ndef countSetBits(n):\n        return (BitsSetTable256[n & 0xff]\n                        + BitsSetTable256[(n >> 8) & 0xff]\n                        + BitsSetTable256[(n >> 16) & 0xff] + BitsSetTable256[n >> 24])", "87": NaN, "88": "def countSetBitsRec(num):\n        nibble = 0\n        if (0 == num):\n                return num_to_bits[0]\n        nibble = num & 0xf\n        return num_to_bits[nibble] + countSetBitsRec(num >> 4)", "89": "def countSetBits(N): \n    count = 0\n    for i in range (0, 4 * 8): \n        if ((N & (1 << i)) != 0): \n            count = count + 1\n    return count", "90": "def getParity(n):\n        parity = False\n        while(n != 0):\n                parity = not parity\n                n = n & (n-1)\n        return parity", "91": "def isPowerOfTwo(n): \n    if(n == 0): \n        return False\n    return (int)(math.ceil((math.log(n) / math.log(2)))) == (int)(math.floor(((math.log(n) / math.log(2)))))", "92": "def isPowerOfTwo(n):\n        if n == 0:\n                return False\n        while n != 1:\n                if n % 2 != 0:\n                        return False\n                n = n / 2\n        return True", "93": "def powerOf2(n):\n    if n == 1:\n        return True\n    elif n % 2 != 0 and n == 0:\n        return False\n    return powerOf2(n / 2)", "94": "def isPowerOfTwo (x):\n        return x!=0 and ((x&(x-1)) == 0);", "95": "def maxRepeating(arr, n, k): \n       \n        for i in range(0, n): \n                arr[(arr[i]%k)] += k \n        max = arr[0] \n        result = 0\n        for i in range(1, n): \n                if (arr[i] > max): \n                        max = arr[i] \n                        result = i \n        return result", "96": "def fun(x):\n        y = (x / 4) * 4\n        ans = 0\n        for i in range(y, x+1):\n                ans ^= i\n        return ans\ndef query(x):\n        if x == 0:\n                return 0\n        k = (x + 1) / 2\n        if x % 2 != 0:\n                return 2 * fun(k)\n        else:\n                return ((fun(k - 1) * 2) ^ (k & 1))\ndef allQueries(q, l, r):\n        for i in range(q):\n                print(query(r[i]) ^ query(l[i] - 1))", "97": "def prefixXOR(arr, preXOR, n):\n        for i in range(0, n):\n                while (arr[i] % 2 != 1):\n                        arr[i] /= 2\n                preXOR[i] = arr[i]\n        for i in range(1, n):\n                preXOR[i] = preXOR[i - 1] ^ preXOR[i]\ndef query(preXOR, l, r):\n        if (l == 0):\n                return preXOR[r]\n        else:\n                return preXOR[r] ^ preXOR[l - 1]", "98": "def findMinSwaps(arr, n):\n        noOfZeroes = []\n        count = 0\n        noOfZeroes[n - 1] = 1 - arr[n - 1]\n        for i in n - 2, n - 1:\n                noOfZeroes[i] = noOfZeroes[i + 1]\n                if arr[i] == 0:\n                        noOfZeroes[i]++\n        for i in 0, n:\n                if arr[i] == 1:\n                        count += noOfZeroes[i]\n        return count", "99": "def minswaps(arr, n):\n        count = 0\n        num_unplaced_zeros = 0\n        for index in range(n - 1, -1, -1):\n                if arr[index] == 0:\n                        num_unplaced_zeros += 1\n                else:\n                        count += num_unplaced_zeros\n        return count", "100": "def arraySortedOrNot(arr, n):\n        if (n == 0 or n == 1):\n                return True\n        for i in range(1,n):\n                if arr[i-1] > arr[i]:\n                        return False\n        return True", "101": "def printTwoOdd(arr, size):\n        xor2 = arr[0]\n        set_bit_no\n        i\n        n = size - 2\n        x = 0\n        y = 0\n        for i in range(1, size):\n                xor2 = xor2 ^ arr[i]\n        set_bit_no = xor2 & ~(xor2-1)\n        for i in range(0, size):\n                if((arr[i] & set_bit_no)>0):\n                        x = x ^ arr[i]\n                else:\n                        y = y ^ arr[i]\n        print(\"The two ODD elements are \"+ x + \" & \" + y)", "102": "def findPair(arr, n):\n        size = len(arr)\n        i = 0\n        j = 1\n        while i < size and j < size:\n                if i != j and arr[j]-arr[i] == n:\n                        print(\"Pair Found: \"+\n                                                \"( \"+arr[i]+\", \"+ arr[j]+\" )\")\n                        return True\n                elif arr[j] - arr[i] < n:\n                        j += 1\n                else:\n                        i += 1\n        print(\"No such pair\")\n        return False", "103": "def printMax(arr, k, n): \n    brr = [] \n    for i in range(0,n): \n        brr.append(arr[i]) \n    brr.sort(reverse = True) \n    for i in range(0,n): \n        if (brr.index(arr[i])>=0 and brr.index(arr[i])<k): \n            print(arr[i],end=\" \")", "104": "def printSmall(arr, asize, n):\n        copy_arr = arr.copy()\n        copy_arr.sort()\n        for i in range(asize):\n                if copy_arr.binarySearch(0,n,arr[i])>-1:\n                        print(arr[i] + \" \")", "105": "def checkIsAP(arr, n):\n        if (n == 1):\n                return true\n        arr.sort()\n        d = arr[1] - arr[0]\n        for i in range(2, n):\n                if (arr[i] - arr[i-1] != d):\n                        return false\n        return true", "106": "def countPairs(a, n):\n        mn = min(a)\n        mx = max(a)\n        c1 = 0\n        c2 = 0\n        for i in range(n):\n                if (a[i] == mn):\n                        c1++\n                if (a[i] == mx):\n                        c2++\n        if (mn == mx):\n                return n * (n - 1) / 2\n        else:\n                return c1 * c2", "107": "def rearrange(head):\n        if (head == None): \n                        return None;\n                prev = head\n                curr = head.next\n                while (curr != None):\n                        if (prev.data > curr.data):\n                                temp = prev.data\n                                prev.data = curr.data\n                                curr.data = temp\n                        if (curr.next != None && curr.next.data > curr.data):\n                                temp = curr.next.data\n                                curr.next.data = curr.data\n                                curr.data = temp\n                        prev = curr.next\n                        if (curr.next == None):\n                                break\n                        curr = curr.next.next\n                return head\ndef push(head, k):\n                temp = Node()\n                temp.data = k\n                temp.next = head\n                head = temp\n                return head\ndef display(head):\n                curr = head\n                while (curr != None):\n                        System.out.printf(\"%d \", curr.data)\n                        curr = curr.next", "108": "def printList(head):\n        while head != None:\n                print(head.data, end=\" \")\n                if head.next != None:\n                        print(\"->\", end=\" \")\n                head = head.next\n        print()\ndef rearrange(head):\n        if head != None:\n                left = head\n                reorderListUtil(left)\ndef reorderListUtil(right):\n        if right == None:\n                return\n        reorderListUtil(right.next)\n        if left == None:\n                return\n        if left != right and left.next != right:\n                temp = left.next\n                left.next = right\n                right.next = temp\n                left = temp\n        else:\n                if left.next == right:\n                        left.next.next = None\n                        left = None\n                else:\n                        left.next = None\n                        left = None", "109": "def get_length(node):\n        size = 0\n        while node != None:\n                node = node.next\n                size += 1\n        return size\ndef padd_zeros(s_node, diff):\n        if s_node == None:\n                return None\n        z_head = Node(0)\n        diff -= 1\n        temp = z_head\n        while ((diff-=) != 0):\n                temp.next = Node(0)\n                temp = temp.next\n        temp.next = s_node\n        return z_head\ndef subtract_linked_list_helper(l1, l2):\n        if l1 == None and l2 == None and borrow == False:\n                return None\n        previous = subtract_linked_list_helper(\n                                (l1 != None) ? l1.next\n                                                        : None,\n                                (l2 != None) ? l2.next : None)\n        d1 = l1.data\n        d2 = l2.data\n        sub = 0\n        if borrow:\n                d1 -= 1\n                borrow = False\n        if d1 < d2:\n                borrow = True\n                d1 = d1 + 10\n        sub = d1 - d2\n        current = Node(sub)\n        current.next = previous\n        return current\ndef subtract_linked_list(l1, l2):\n        if l1 == None and l2 == None:\n                return None\n        len1 = get_length(l1)\n        len2 = get_length(l2)\n        l_node = None\n        s_node = None\n        temp1 = l1\n        temp2 = l2\n        if len1 != len2:\n                l_node = len1 > len2 ? l1 : l2\n                s_node = len1 > len2 ? l2 : l1\n                s_node = padd_zeros(s_node, abs(len1 - len2))\n        else:\n                while l1 != None and l2 != None:\n                        if l1.data != l2.data:\n                                l_node = l1.data > l2.data ? temp1 : temp2\n                                s_node = l1.data > l2.data ? temp2 : temp1\n                                break\n                        l1 = l1.next\n                        l2 = l2.next\n        borrow = False\n        return subtract_linked_list_helper(l_node, s_node)\ndef print_list(head):\n        temp = head\n        while temp != None:\n                print(temp.data + \" \")\n                temp = temp.next", "110": "def insertAtMid(x):\n        if (head == null):\n                head = new Node(x)\n        else:\n                newNode = new Node(x)\n                ptr = head\n                len = 0\n                while (ptr != null):\n                        len++\n                        ptr = ptr.next\n                count = ((len % 2) == 0) ? (len / 2) :\n                                                                (len + 1) / 2\n                ptr = head\n                while (count-- > 1):\n                        ptr = ptr.next\n                newNode.next = ptr.next\n                ptr.next = newNode\n\ndef display():\n        temp = head\n        while (temp != null):\n                print(temp.data + \" \")\n                temp = temp.next", "111": "def insertAtMid(x):\n        if head == null:\n                head = new Node(x);\n        else:\n                newNode = new Node(x);\n                slow = head;\n                fast = head.next;\n                while fast != null and fast.next != null:\n                        slow = slow.next;\n                        fast = fast.next.next;\n                newNode.next = slow.next;\n                slow.next = newNode;\ndef display():\n        temp = head;\n        while temp != null:\n                System.out.print(temp.data + \" \");\n                temp = temp.next;", "112": "class Node:\n    def __init__(self, data=None, prev=None, next=None):\n        self.data = data\n        self.prev = prev\n        self.next = next\n\ndef getNode(data):\n        newNode = Node(data)\n        return newNode\n\ndef sortedInsert(head_ref, newNode):\n        current = head_ref\n        if head_ref == None:\n                head_ref = newNode\n        elif head_ref.data >= newNode.data:\n                newNode.next = head_ref\n                newNode.next.prev = newNode\n                head_ref = newNode\n        else:\n                current = head_ref\n                while current.next != None and current.next.data < newNode.data:\n                        current = current.next\n                newNode.next = current.next\n                if current.next != None:\n                        newNode.next.prev = newNode\n                current.next = newNode\n                newNode.prev = current\n        return head_ref\n\n\ndef insertionSort(head_ref):\n        sorted = None\n        current = head_ref\n        while current != None:\n                next = current.next\n                current.prev = current.next = None\n                sorted=sortedInsert(sorted, current)\n                current = next\n        head_ref = sorted\n        return head_ref\n\n\ndef printList(head):\n        while head != None:\n                print(head.data)\n                head = head.next\n\n\ndef push(head_ref, new_data):\n        new_node = Node(new_data)\n        new_node.next = head_ref\n        new_node.prev = None\n        if head_ref != None:\n                head_ref.prev = new_node\n        head_ref = new_node\n        return head_ref", "113": "def reverse(arr, s, e):\n        while(s < e):\n                tem = arr[s]\n                arr[s] = arr[e]\n                arr[e] = tem\n                s = s + 1\n                e = e - 1\n\ndef fun(arr, k):\n        n = 4 - 1\n        v = n - k\n        if (v >= 0):\n                reverse(arr, 0, v)\n                reverse(arr, v + 1, n)\n                reverse(arr, 0, n)", "114": "def build(node, l, r, a):\n        if (l == r):\n                seg[node] = a[l]\n        else:\n                mid = (l + r) // 2;\n                build(2 * node, l, mid, a);\n                build(2 * node + 1, mid + 1, r, a);\n                seg[node] = (seg[2 * node] seg[2 * node + 1]);\n\ndef query(node, l, r, start, end, a):\n        if (l > end r < start):\n                return 0\n        if (start <= l && r <= end):\n                return seg[node]\n        mid = (l + r) // 2;\n        return ((query(2 * node, l, mid, start, end, a)) |\n                        (query(2 * node + 1, mid + 1, r, start, end, a)));\n\ndef orsum(a, n, q, k):\n        build(1, 0, n - 1, a);\n        for j in range(0, q):\n                i = k[j] % (n / 2);\n                sec = query(1, 0, n - 1, n // 2 - i, n - i - 1, a);\n                first = (query(1, 0, n - 1, 0, n // 2 - 1 - i, a) |\n                                        query(1, 0, n - 1, n - i, n - 1, a));\n                temp = sec + first;\n                print(temp)", "115": "def maximumEqual(a, b, n):\n        store = [0] * (10**5)\n        for i in range(n):\n                store[b[i]] = i + 1\n        ans = [0] * (10**5)\n        for i in range(n):\n                d = abs(store[a[i]] - (i + 1))\n                if store[a[i]] < i + 1:\n                        d = n - d\n                ans[d] += 1\n        finalans = 0\n        for i in range(10**5):\n                finalans = max(finalans, ans[i])\n        print(finalans)", "116": "def RightRotate(a, n, k): \n    k = k % n \n    for i in range(0, n): \n        if(i < k): \n            print(a[n - k + i], end = \" \") \n        else: \n            print(a[i - k], end = \" \") \n    print()", "117": "def restoreSortedArray(arr, n):\n        for i in range(0, n):\n                if arr[i] > arr[i + 1]:\n                        reverse(arr,0,i)\n                        reverse(arr , i + 1, n)\n                        reverse(arr,0, n)\n\ndef reverse(arr, i, j):\n        temp = 0\n        while(i < j):\n                temp = arr[i]\n                arr[i] = arr[j]\n                arr[j] = temp\n                i = i + 1\n                j = j - 1\n\ndef printArray(arr, size):\n        for i in range(0, size):\n                print(arr[i] + \" \")", "118": "def findStartIndexOfArray(arr, low, high):\n        if (low > high):\n                return -1\n        if (low == high):\n                return low\n        mid = low + (high - low) / 2\n        if (arr[mid] > arr[mid + 1]):\n                return mid + 1\n        if (arr[mid - 1] > arr[mid]):\n                return mid\n        if (arr[low] > arr[mid]):\n                return findStartIndexOfArray(arr, low, mid - 1)\n        else:\n                return findStartIndexOfArray(arr, mid + 1, high)\ndef restoreSortedArray(arr, n):\n        if (arr[0] < arr[n - 1]):\n                return\n        start = findStartIndexOfArray(arr, 0, n - 1)\n        Arrays.sort(arr, 0, start)\n        Arrays.sort(arr, start, n)\n        Arrays.sort(arr)\ndef printArray(arr, size):\n        for i in range(0, size):\n                print arr[i] + \" \"", "119": "def leftrotate(str, d):\n    ans = str[d:] + str[:d]\n    return ans\ndef rightrotate(str, d):\n    return leftrotate(str, len(str) - d)", "120": "def insertNode(start, value):\n        if (start == null):\n                new_node = Node()\n                new_node.data = value\n                new_node.next = new_node.prev = new_node\n                start = new_node\n                return new_node\n        last = (start).prev\n        new_node = Node()\n        new_node.data = value\n        new_node.next = start\n        (start).prev = new_node\n        new_node.prev = last\n        last.next = new_node\n        return start\ndef displayList(start):\n        temp = start\n        while (temp.next != start):\n                print(temp.data, end = \" \")\n                temp = temp.next\n        print(temp.data, end = \" \")\ndef searchList(start, search):\n        temp = start\n        count = 0\n        flag = 0\n        value\n        if(temp == null):\n                return -1\n        else:\n                while(temp.next != start):\n                        count = count + 1\n                        if(temp.data == search):\n                                flag = 1\n                                count = count - 1\n                                break\n                        temp = temp.next\n                if(temp.data == search):\n                        count = count + 1\n                        flag = 1\n                if(flag == 1):\n                        print(\"\\n\"+search +\" found at location \"+ count)\n                else:\n                        print(\"\\n\"+search +\" not found\")\n        return -1", "121": "class Node:\n    def __init__(self, data=0, next=None, prev=None):\n        self.data = data\n        self.next = next\n        self.prev = prev\n\ndef getNode(data):\n        newNode = Node(data)\n        return newNode\n\ndef insertEnd(head, new_node):\n        if (head == None):\n                new_node.next = new_node.prev = new_node\n                head = new_node\n                return head\n        Node last = (head).prev\n        new_node.next = head\n        (head).prev = new_node\n        new_node.prev = last\n        last.next = new_node\n        return head\n\ndef reverse(head):\n        if (head==None):\n                return None\n        Node new_head = None\n        Node last = head.prev\n        Node curr = last\n        prev = curr.prev\n        while (curr.prev != last):\n                new_head = insertEnd(new_head, curr)\n                curr = prev\n                prev = curr.prev\n        new_head = insertEnd(new_head, curr)\n        return new_head\n\ndef display(head):\n        if (head==None):\n                return\n        Node temp = head\n        print( \"Forward direction: \", end=\"\")\n        while (temp.next != head):\n                print( temp.data, \" \", end=\"\")\n                temp = temp.next\n        print( temp.data, \" \", end=\"\")\n        Node last = head.prev\n        temp = last\n        print( \"\\nBackward direction: \", end=\"\")\n        while (temp.prev != last):\n                print( temp.data, \" \", end=\"\")\n                temp = temp.prev\n        print( temp.data, \" \", end=\"\")", "122": "def addEdge(u, v):\n        adj[u].append(v)\n        adj[v].append(u)\ndef dfs(cur, prev):\n        parent[cur] = prev\n        depth[cur] = depth[prev] + 1\n        for i in range(0, len(adj[cur])):\n                if (adj[cur][i] != prev):\n                        dfs(adj[cur][i], cur)\ndef preprocess():\n        depth[0] = -1\n        dfs(1, 0)\ndef LCANaive(u, v):\n        if (u == v):\n                return u\n        if (depth[u] > depth[v]):\n                temp = u\n                u = v\n                v = temp\n        v = parent[v]\n        return LCANaive(u, v)", "123": "def addEdge(u,v):\n        adj[u].add(v)\n        adj[v].add(u)\ndef LCANaive(u,v):\n        if (u == v): return u\n        if (depth[u] > depth[v]):\n                t = u\n                u = v\n                v = t\n        v = parent[v]\n        return LCANaive(u, v)\ndef dfs(cur, prev):\n        depth[cur] = depth[prev] + 1\n        parent[cur] = prev\n        if (depth[cur] % block_sz == 0):\n                jump_parent[cur] = parent[cur]\n        else:\n                jump_parent[cur] = jump_parent[prev]\n        for i in range (0, len(adj[cur])):\n                if (adj[cur][i] != prev):\n                        dfs(adj[cur][i], cur)\ndef LCASQRT(u, v):\n        while (jump_parent[u] != jump_parent[v]):\n                if (depth[u] > depth[v]):\n                        t = u\n                        u = v\n                        v = t\n                v = jump_parent[v]\n        return LCANaive(u, v)\ndef preprocess(height):\n        block_sz = (int)(math.sqrt(height))\n        depth[0] = -1\n        dfs(1, 0)", "124": "def find_permutations(arr):\n  cnt = 0\n  max_ind = -1\n  min_ind = 10000000\n  n = len(arr)\n  index_of = {}\n  for i in range(0, n):\n    index_of[arr[i]] = i + 1\n  for i in range(1, n+1):\n    max_ind = max(max_ind, index_of.get(i))\n    min_ind = min(min_ind, index_of.get(i))\n    if (max_ind - min_ind + 1 == i):\n      cnt = cnt + 1\n  return cnt", "125": NaN, "126": "def countOfNum(n, a, b):\n        cnt_of_a = n // a\n        cnt_of_b = n // b\n        sum = cnt_of_b + cnt_of_a\n        cnt_of_ab = n // (a * b)\n        sum = sum - cnt_of_ab\n        return sum\ndef sumOfNum( n, a, b):\n        i\n        sum = 0\n        ans = set()\n        for i in range(a, n+1, a):\n                ans.add(i)\n        for i in range(b, n+1, b):\n                ans.add(i)\n        for it in ans:\n                sum = sum + it\n        return sum", "127": "def maximumArea(l, b, x, y):\n        left, right, above, below;\n        left = x * b;\n        right = (l - x - 1) * b;\n        above = l * y;\n        below = (b - y - 1) * l;\n        print(Math.max(Math.max(left, right),\n                                Math.max(above, below)));", "128": "def precompute():\n        F[1] = 2\n        F[2] = 3\n        F[3] = 4\n        for i in range(4, N):\n                F[i] = (F[i - 1] + F[i - 2]) % MOD", "129": "def get(L,R):\n        x = 1.0 / L\n        y = 1.0 / (R + 1.0)\n        return (x - y)", "130": "def upper_bound(ar, k):\n        s = 0\n        e = ar.size()\n        while (s != e):\n                mid = s + e >> 1\n                if (ar[mid] <= k):\n                        s = mid + 1\n                else:\n                        e = mid\n        if (s == ar.size()):\n                return -1\n        return s\ndef consecutiveOnes(x):\n        p = 0\n        while (x > 0):\n                if (x % 2 == 1 and p == 1):\n                        return 1\n                p = x % 2\n                x /= 2\n        return 0\ndef preCompute():\n        for i in range(0, MAX):\n                if (consecutiveOnes(i) == 0):\n                        v.add(i)\ndef nextValid(n):\n        it = upper_bound(v,n)\n        val = v[it]\n        return val\ndef performQueries(queries, q):\n        for i in range(0, q):\n                print(nextValid(queries[i]))", "131": "def changeToOnes(str):\n        i = l = ctr = 0\n        l = len(str)\n        for i in range (l - 1, -1, -1):\n                if (str[i] == '1'):\n                        ctr = ctr + 1\n                else:\n                        break\n        return l - ctr\n\ndef removeZeroesFromFront(str):\n        s = i = 0\n        while (i < len(str) and str[i] == '0'):\n                i = i + 1\n        if (i == len(str)):\n                s = \"0\"\n        else:\n                s = str[i:len(str) - i]\n        return s", "132": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef getCount(a, n):\n    gcd = 0\n    for i in range(n):\n        gcd = gcd(gcd, a[i])\n\n    cnt = 0\n    for i in range(1, gcd):\n        if gcd % i == 0:\n            if i * i == gcd:\n                cnt += 1\n            else:\n                cnt += 2\n    return cnt", "133": "def MinDeletion(a, n):\n        mp = {}\n        for i in range(0, n):\n                if(a[i] in mp):\n                        mp[a[i]] = mp.get(a[i])+1\n                else:\n                        mp[a[i]] = 1\n        ans = 0\n        for x, frequency in mp.items():\n                if (x <= frequency):\n                        ans += (frequency - x)\n                else:\n                        ans += frequency\n        return ans", "134": "def maxCountAB(s, n): \n        A = 0\n        B = 0\n        BA = 0\n        ans = 0\n        for i in range(n): \n                S = s[i] \n                L = len(S) \n                for j in range(L - 1): \n                        if S[j] == 'A' and S[j + 1] == 'B': \n                                ans = ans + 1\n                if S[0] == 'B' and S[L - 1] == 'A': \n                        BA = BA + 1\n                elif S[0] == 'B': \n                        B = B + 1\n                elif S[L - 1] == 'A': \n                        A = A + 1\n        if BA == 0: \n                ans += min(B, A) \n        elif A + B == 0: \n                ans += BA - 1\n        else: \n                ans += BA + min(B, A) \n        return ans", "135": "def MinOperations(n, x, arr):\n        total = 0\n        for i in range(0, n):\n                if arr[i] > x:\n                        difference = arr[i] - x\n                        total = total + difference\n                        arr[i] = x\n        for i in range(1, n):\n                LeftNeigbouringSum = arr[i] + arr[i - 1]\n                if LeftNeigbouringSum > x:\n                        current_diff = LeftNeigbouringSum - x\n                        arr[i] = max(0, arr[i] - current_diff)\n                        total = total + current_diff\n        return total", "136": "def findNumbers(arr, n): \n        sumN = (n * (n + 1)) / 2\n        sumSqN = (n * (n + 1) * (2 * n + 1)) / 6\n        sum = 0\n        sumSq = 0\n        i = 0\n        while i < n: \n                sum += arr[i]\n                sumSq += math.pow(arr[i], 2)\n                i += 1\n        B = (((sumSq - sumSqN) / (sum - sumN)) + sumN - sum) / 2\n        A = sum - sumN + B\n        print \"A = \" + A + \"\\nB = \" + B", "137": "def is_prefix(temp, str):\n        if len(temp) < len(str):\n                return False\n        else:\n                for i in range(0, len(str)):\n                        if str[i] != temp[i]:\n                                return False\n                return True\ndef lexicographicallyString(input, n, str):\n        input.sort()\n        for i in range(0, n):\n                temp = input[i]\n                if is_prefix(temp, str):\n                        return temp\n        return \"-1\"", "138": "def Rearrange(arr, K, N):\n        ans = []\n        f = -1\n        for i in range(N):\n                ans.append(-1)\n for i in range(len(arr)):\n        if (arr[i] == K):\n                K = i\n                break\n smaller = []\n        greater = []\n        for i in range(N):\n                if (arr[i] < arr[K]):\n                        smaller.append(arr[i])\n                elif (arr[i] > arr[K]):\n                        greater.append(arr[i])\n        low = 0\n        high = N - 1\n        while (low <= high):\n                mid = (low + high) // 2\n                if (mid == K):\n                        ans[mid] = arr[K]\n                        f = 1\n                        break\n                elif (mid < K):\n                        if (len(smaller) == 0):\n                                break\n                        ans[mid] = smaller[len(smaller)-1]\n                        smaller.pop()\n                        low = mid + 1\n                else:\n                        if (len(greater) == 0):\n                                break\n                        ans[mid] = greater[len(greater)-1]\n                        greater.pop()\n                        high = mid - 1\n        if (f == -1):\n                print(-1)\n                return\n        for i in range(N):\n                if (ans[i] == -1):\n                        if (len(smaller)>0):\n                                ans[i] = smaller[len(smaller)-1]\n                                smaller.pop()\n                        elif (len(greater)>0):\n                                ans[i] = greater[len(greater)-1]\n                                greater.pop()\n        for i in range(N):\n                print(ans[i], end = \" \")\n        print()", "139": "def minimumK(arr, M, N):\n        good = int((N * 1.0) / ((M + 1) * 1.0)) + 1\n        for i in range(1, N+1):\n                K = i\n                candies = N\n                taken = 0\n                while candies > 0:\n                        taken += min(K, candies)\n                        candies -= min(K, candies)\n                        for j in range(M):\n                                consume = int((arr[j] * candies) / 100)\n                                candies -= consume\n                if taken >= good:\n                        print(i)\n                        return", "140": "def check(K, n, m, arr, good_share):\n        candies = n\n        taken = 0\n        while (candies > 0):\n                taken += min(K, candies)\n                candies -= min(K, candies)\n                for j in range(m):\n                        consume = int((arr[j] * candies) / 100)\n                        candies -= consume\n        return (taken >= good_share)\n\ndef minimumK(arr, N, M):\n        good_share = int(ceil((N * 1.0) / ((M + 1) * 1.0)))\n        lo = 1\n        hi = N\n        while (lo < hi):\n                mid = int((lo + hi) / 2)\n                if check(mid, N, M, arr, good_share):\n                        hi = mid\n                else:\n                        lo = mid + 1\n        print(hi)", "141": "def calcTotalTime(path):\n        time = 0\n        x = 0\n        y = 0\n        s = set()\n        for i in range(len(path)):\n                p = x\n                q = y\n                if path[i] == 'N':\n                        y += 1\n                elif path[i] == 'S':\n                        y -= 1\n                elif path[i] == 'E':\n                        x += 1\n                elif path[i] == 'W':\n                        x -= 1\n                o = (p + x) + \" \" + (q + y)\n                if o not in s:\n                        time += 2\n                        s.add(o)\n                else:\n                        time += 1\n        print(time)", "142": "def calcPsquare(N):\n        for i  in range(1, N):\n                psquare.add(i*i)\n\ndef countWays(index, target):\n        if target == 0:\n                return 1\n        if index < 0 target < 0:\n                return 0\n        inc = countWays(index, target - psquare.get(index))\n        exc = countWays(index - 1, target)\n        return inc + exc", "143": "def findCost(A, N):\n        totalCost = 0\n        for i in range(0, N):\n                if (A[i] == 0):\n                        A[i] = 1\n                        totalCost += i\n        return totalCost", "144": "def countNumbers(L, R, K): \n       \n        list = [] \n          \n        for i in range(L, R + 1): \n            if isPalindrome(i): \n                list.append(i) \n       \n        count = 0\n        for i in range(len(list)): \n            right_index = search(list, list[i] + K - 1) \n              \n            if (right_index != -1): \n                count = max(count, right_index - i + 1) \n       \n        return count \ndef search( list, num): \n       \n        low = 0\n        high = len(list) - 1\n        ans = -1\n        while (low <= high): \n            mid = low + (high - low) // 2\n            if (list[mid] <= num): \n                ans = mid \n                low = mid + 1\n                  \n            else: \n                high = mid - 1\n       \n        return ans \ndef isPalindrome(n): \n       \n        rev = 0\n        temp = n \n        while (n > 0): \n            rev = rev * 10 + n % 10\n            n = n // 10\n       \n        return rev == temp", "145": "def peakIndex(arr):\n        N = len(arr)\n        if len(arr) < 3:\n                return -1\n        i = 0\n        while i + 1 < N:\n                if arr[i + 1] < arr[i] arr[i] == arr[i + 1]:\n                        break\n                i++\n        if i == 0 i == N - 1:\n                return -1\n        ans = i\n        while i < N - 1:\n                if arr[i] < arr[i + 1] arr[i] == arr[i + 1]:\n                        break\n                i++\n        if i == N - 1:\n                return ans\n        return -1", "146": "def hasArrayTwoPairs(nums, n, target):\n        nums.sort()\n        for i in range(0, n):\n                x = target - nums[i]\n                low = 0\n                high = n - 1\n                while (low <= high):\n                        mid = low + ((high - low) // 2)\n                        if (nums[mid] > x):\n                                high = mid - 1\n                        elif (nums[mid] < x):\n                                low = mid + 1\n                        else:\n                                if (mid == i):\n                                        if ((mid - 1 >= 0) and nums[mid - 1] == x):\n                                                print(nums[i] + \", \", end=\"\")\n                                                print(nums[mid - 1])\n                                                return\n                                        if ((mid + 1 < n) and nums[mid + 1] == x):\n                                                print(nums[i] + \", \", end=\"\")\n                                                print(nums[mid + 1])\n                                                return\n                                        break\n                                else:\n                                        print(nums[i] + \", \", end=\"\")\n                                        print(nums[mid])\n                                        return\n        print(-1)", "147": "class TreeNode:\n    def __init__(self, data=0, left=None, right=None, size=0):\n        self.data = data\n        self.left = left\n        self.right = right\n        self.size = size\n\nclass pair:\n    def __init__(self, first=0, second=0):\n        self.first = first\n        self.second = second\n\ndef newNode(data):\n        Node = TreeNode()\n        Node.data = data\n        Node.left = None\n        Node.right = None\n        return (Node)\n\ndef sumofsubtree(root):\n        p = pair(1, 0)\n        if root.left != null:\n                ptemp = sumofsubtree(root.left)\n                p.second += ptemp.first + ptemp.second\n                p.first += ptemp.first\n        if root.right != null:\n                ptemp = sumofsubtree(root.right)\n                p.second += ptemp.first + ptemp.second\n                p.first += ptemp.first\n        root.size = p.first\n        return p\n\ndef distance(root, target, distancesum, n):\n        if root.data == target:\n                sum = distancesum\n        if root.left != null:\n                tempsum = distancesum - root.left.size + (n - root.left.size)\n                distance(root.left, target, tempsum, n)\n        if root.right != null:\n                tempsum = distancesum - root.right.size + (n - root.right.size)\n                distance(root.right, target, tempsum, n)", "148": "def delCost(s, cost):\n        visited = [False] * len(s)\n        ans = 0\n        for i in range(len(s)):\n                if visited[i]:\n                        continue\n                maxDel = 0\n                totalCost = 0\n                visited[i] = True\n                for j in range(i, len(s)):\n                        if s[i] == s[j]:\n                                maxDel = max(maxDel, cost[j])\n                                totalCost += cost[j]\n                                visited[j] = True\n                ans += totalCost - maxDel\n        return ans", "149": "def delCost(s, cost):\n        ans = 0\n        forMax = {}\n        forTot = {}\n        for i in range(len(s)):\n                if s.charAt(i) not in forMax:\n                        forMax[s.charAt(i)] = cost[i]\n                else:\n                        forMax[s.charAt(i)] = max(cost[i], forMax.get(s.charAt(i)))\n                if s.charAt(i) not in forTot:\n                        forTot[s.charAt(i)] = cost[i]\n                else:\n                        forTot[s.charAt(i)] = forTot.get(s.charAt(i)) + cost[i]\n        for i in forMax.items():\n                ans += forTot.get(i.getKey()) - i.getValue()\n        return ans", "150": "def findClosest(N, target):\n     closest = -1\n     diff = Integer.MAX_VALUE\n     for i in 1:\n          if N % i == 0:\n               if N / i == i:\n                    if abs(target - i) < diff\n                         diff = abs(target - i)\n                         closest = i\n               else:\n                    if abs(target - i) < diff\n                         diff = abs(target - i)\n                         closest = i\n                    if abs(target - N / i) < diff\n                         diff = abs(target - N / i)\n                         closest = N / i\n     print(closest)", "151": "def computeDivisors():\n        for i in range(1, MAX+1):\n                for j in range(i, MAX+1, i):\n                        divisors[j].add(i)\n\ndef getClosest(val1, val2, target):\n        if target - val1 >= val2 - target:\n                return val2\n        else:\n                return val1\n\ndef findClosest(array, n, target):\n        if target <= array[0]:\n                return array[0]\n        if target >= array[n - 1]:\n                return array[n - 1]\n        i = 0\n        j = n\n        mid = 0\n        while i < j:\n                mid = (i + j) // 2\n                if array[mid] == target:\n                        return array[mid]\n                if target < array[mid]:\n                        if mid > 0 and target > array[mid - 1]:\n                                return getClosest(array[mid - 1], array[mid], target)\n                        j = mid\n                else:\n                        if mid < n - 1 and target < array[mid + 1]:\n                                return getClosest(array[mid], array[mid + 1], target)\n                        i = mid + 1\n        return array[mid]\n\ndef printClosest(N, X):\n        computeDivisors()\n        ans\n                = findClosest(divisors[N], divisors[N].size(), X)\n        print(ans)", "152": "def countTriplets(arr, N):\n        zero_i = []\n        one_i = []\n        mp = {}\n        for i in range(0, N):\n                if (arr[i] == 0):\n                        zero_i.append(i + 1)\n                elif (arr[i] == 1):\n                        one_i.append(i + 1)\n                else:\n                        mp[i + 1] = 1\n        total = len(zero_i) * len(one_i) * len(mp)\n        for i in range(0, len(zero_i)):\n                for j in range(0, len(one_i)):\n                        p = zero_i[i]\n                        q = one_i[j]\n                        r = 2 * p - q\n                        if (r in mp and mp[r] > 0):\n                                total -= 1\n                        r = 2 * q - p\n                        if (r in mp and mp[r] > 0):\n                                total -= 1\n                        r = (p + q) / 2\n                        if (r in mp and mp[r] > 0 and abs(r - p) == abs(r - q)):\n                                total -= 1\n        print(total)", "153": "def power(A, N):\n        count = 0\n        if (A == 1):\n                return 0\n        while (N > 0):\n                count += 1\n                N /= A\n        return count\ndef Pairs(N, A, B):\n        powerA, powerB = power(A, N), power(B, N)\n        intialB, intialA = B, A\n        A = 1\n        for i in range(0, powerA + 1):\n                B = 1\n                for j in range(0, powerB + 1):\n                        if (B == N - A):\n                                print(i + \" \" + j)\n                                return\n                        B *= intialB\n                A *= intialA\n        print(\"-1\")\n        return", "154": "def findNonMultiples(arr, n, k):\n        multiples = set()\n        for i in range(0, n):\n                if (arr[i] not in multiples):\n                        for j in range(1, k // arr[i] + 1):\n                                multiples.add(arr[i] * j)\n        return k - len(multiples)\ndef countValues(arr, N, L, R):\n        return findNonMultiples(arr, N, R) -\n                findNonMultiples(arr, N, L - 1)", "155": "def maxMatch(A, B):\n    Aindex = {}\n    diff = {}\n    for i in range(len(A)):\n        Aindex[A[i]] = i\n    for i in range(len(B)):\n        if i - Aindex[B[i]] < 0:\n            if A.length + i - Aindex[B[i]] not in diff:\n                diff[A.length + i - Aindex[B[i]]] = 1\n            else:\n                diff[A.length + i - Aindex[B[i]]] += 1\n        else:\n            if i - Aindex[B[i]] not in diff:\n                diff[i - Aindex[B[i]]] = 1\n            else:\n                diff[i - Aindex[B[i]]] += 1\n    max = 0\n    for ele in diff:\n        if diff[ele] > max:\n            max = diff[ele]\n    return max", "156": "def checkXOR(arr, N):\n        if N % 2 == 0:\n                xro = 0\n                for i in range(0, N):\n                        xro = xro ^ arr[i]\n                if xro != 0:\n                        print(-1)\n                        return\n                for i in range(0, N - 3, 2):\n                        print(i + \" \" + (i + 1) + \" \" + (i + 2))\n                for i in range(0, N - 3, 2):\n                        print(i + \" \" + (i + 1) + \" \" + (N - 1))\n        else:\n                for i in range(0, N - 2, 2):\n                        print(i + \" \" + (i + 1) + \" \" + (i + 2))\n                for i in range(0, N - 2, 2):\n                        print(i + \" \" + (i + 1) + \" \" + (N - 1))", "157": " def make_array_element_even(arr, N): \n        res = 0\n        odd_cont_seg = 0\n        for i in range (0, N): \n                if (arr[i] % 2 == 1): \n                        odd_cont_seg += 1\n                else: \n                        if (odd_cont_seg > 0): \n                                if (odd_cont_seg % 2 == 0): \n                                        res += odd_cont_seg // 2\n                                else: \n                                        res += odd_cont_seg // 2 + 2\n                                odd_cont_seg = 0\n        if (odd_cont_seg > 0): \n                if (odd_cont_seg % 2 == 0): \n                        res += odd_cont_seg // 2\n                else: \n                        res += odd_cont_seg // 2 + 2\n        return res", "158": "def minCollectingSpeed(piles, H):\n        ans = -1\n        low = 1\n        high;\n        high = Arrays.stream(piles).max().getAsInt()\n        while low <= high:\n                K = low + (high - low) / 2\n                time = 0\n                for ai in piles:\n                        time += (ai + K - 1) / K\n                if time <= H:\n                        ans = K\n                        high = K - 1\n                else:\n                        low = K + 1\n        print(ans)", "159": "def cntDisPairs(arr, N, K):\n        cntPairs = 0\n        arr.sort()\n        i = 0\n        j = N - 1\n        while i < j:\n                if arr[i] + arr[j] == K:\n                        while i < j and arr[i] == arr[i + 1]:\n                                i++\n                        while i < j and arr[j] == arr[j - 1]:\n                                j--\n                        cntPairs += 1\n                        i++\n                        j--\n                elif arr[i] + arr[j] < K:\n                        i++\n                else:\n                        j--\n        return cntPairs", "160": "def cntDisPairs(arr, N, K):\n        cntPairs = 0\n        cntFre = {}\n        for i in range(0, N):\n                if arr[i] in cntFre:\n                        cntFre[arr[i]] += 1\n                else:\n                        cntFre[arr[i]] = 1\n        for key, value in cntFre.items():\n                if 2 * key == K:\n                        if value > 1:\n                                cntPairs += 2\n                else:\n                        if K - key in cntFre:\n                                cntPairs += 1\n        cntPairs = cntPairs / 2\n        return cntPairs", "161": "class Node:\n    def __init__(self, data=None, prev=None, next=None):\n        self.data = data\n        self.prev = prev\n        self.next = next\n\n    def __str__(self):\n        return repr(self)\n\n\ndef push(head_ref, new_data):\n    new_node = Node(new_data)\n    new_node.prev = None\n    new_node.next = head_ref\n    if head_ref is not None:\n        head_ref.prev = new_node\n    head_ref = new_node\n    return head_ref\n\n\ndef search(head_ref, x):\n    temp = head_ref\n    pos = 0\n    while temp.data != x and temp.next is not None:\n        pos += 1\n        temp = temp.next\n    if temp.data != x:\n        return -1\n    return (pos + 1)", "162": "def longestSubsequence(N, Q, arr, Queries):\n        for i in range(Q):\n                x = Queries[i][0]\n                y = Queries[i][1]\n                arr[x - 1] = y\n                count = 1\n                for j in range(1, N):\n                        if arr[j] != arr[j - 1]:\n                                count += 1\n                print(count +\" \")", "163": "def longestSubsequence(N, Q, arr, Queries):\n        count = 1\n        for i in range(1, N):\n                if (arr[i] != arr[i - 1]):\n                        count += 1\n        for i in range(0, Q):\n                x = Queries[i][0]\n                y = Queries[i][1]\n                if (x > 1):\n                        if (arr[x - 1] != arr[x - 2]):\n                                count -= 1\n                        if (arr[x - 2] != y):\n                                count += 1\n                if (x < N):\n                        if (arr[x] != arr[x - 1]):\n                                count -= 1\n                        if (y != arr[x]):\n                                count += 1\n                print(count + \" \")\n                arr[x - 1] = y", "164": "def sum(arr, n):\n        mp = {}\n        for i in range(0, n):\n                v = []\n                v.append(i)\n                if arr[i] in mp:\n                        v.extend(mp[arr[i]])\n                mp[arr[i]] = v\n        ans = [0] * n\n        for i in range(0, n):\n                sum = 0\n                for it in mp[arr[i]]:\n                        sum += math.fabs(it - i)\n                ans[i] = sum\n        for i in range(0, n):\n                print(ans[i], \" \", end=\"\")", "165": "def reverse(a):\n        n = len(a)\n        for i in range(0, n // 2):\n                t = a[i]\n                a[i] = a[n - i - 1]\n                a[n - i - 1] = t\n        return a\n\n\ndef rearrangeArray(A, B, N, K):\n        B.sort()\n        B = reverse(B)\n        flag = True\n        for i in range(0, N):\n                if (A[i] + B[i] > K):\n                        flag = False\n                        break\n        if (!flag):\n                print(\"-1\" + \"\\n\")\n        else:\n                for i in range(0, N):\n                        print(B[i] + \" \")", "166": "def isinRange(board):\n        for i in range(N):\n                for j in range(N):\n                        if board[i][j] <= 0 or board[i][j] > 9:\n                                return false\n        return true\n\ndef isValidSudoku(board):\n        if isinRange(board) == false:\n                return false\n        unique = [false for i in range(N + 1)]\n        for i in range(N):\n                for j in range(N):\n                        Z = board[i][j]\n                        if unique[Z]:\n                                return false\n                        unique[Z] = true\n        for i in range(N):\n                for j in range(N):\n                        Z = board[j][i]\n                        if unique[Z]:\n                                return false\n                        unique[Z] = true\n        for i in range(0, N - 2, 3):\n                for j in range(0, N - 2, 3):\n                        for k in range(3):\n                                for l in range(3):\n                                        X = i + k\n                                        Y = j + l\n                                        Z = board[X][Y]\n                                        if unique[Z]:\n                                                return false\n                                        unique[Z] = true\n        return true", "167": "def conVowUpp(str):\n    N = len(str)\n    for i in range(N):\n        if str[i] == 'a' str[i] == 'e' str[i] == 'i' str[i] == 'o' str[i] == 'u':\n            c = Character.toUpperCase(str[i])\n            str[i] = c\n    for c in str:\n        print(c)", "168": "def zvalue(nums):\n        m = max_element(nums)\n        cnt = 0\n        for i in range(0, m+1):\n                cnt = 0\n                for j in range(0, len(nums)):\n                        if nums[j] >= i:\n                                cnt+=1\n                if cnt == i:\n                        return i\n        return -1\ndef max_element(nums):\n        max = nums[0]\n        for i in range(1, len(nums)):\n                max = max(max, nums[i])\n        return max", "169": "def palindrome(a, i, j):\n        while(i<j):\n                if(a[i] != a[j]):\n                        return false\n                i=i+1\n                j=j-1\n        return true\n\n\ndef findSubArray(arr, k):\n        n= len(arr)\n        for i in range(n-k):\n                if(palindrome(arr, i, i+k-1)):\n                        return i\n        return -1", "170": "def helper(mid):\n        cnt = 0\n        for i in mp.items():\n                temp = i.getValue()\n                while (temp >= mid):\n                        temp -= mid\n                        cnt++\n        return cnt >= N\ndef findMaximumDays(arr):\n        for i in range(P):\n                if (mp.containsKey(arr[i])):\n                        mp.put(arr[i], mp.get(arr[i]) + 1)\n                else:\n                        mp.put(arr[i], 1)\n        start = 0\n        end = P\n        ans = 0\n        while (start <= end):\n                mid = start +\n                                ((end - start) / 2)\n                if (mid != 0 and helper(mid)):\n                        ans = mid\n                        start = mid + 1\n                elif (mid == 0):\n                        start = mid + 1\n                else:\n                        end = mid - 1\n        return ans", "171": "def countSubarrays(a, n, k): \n    ans = 0\n    pref = [0]\n    for i in range(0, n): \n        pref.append((a[i] + pref[i]) % k)\n    for i in range(1, n + 1): \n        for j in range(i, n + 1): \n            if ((pref[j] - pref[i - 1] + k) % k == j - i + 1): \n                ans += 1\n    return ans \n\na = [2, 3, 6, 7] \nn = len(a) \nk = 7\nprint(countSubarrays(a, n, k))", "172": "def countSubarrays(a, n, k): \n        cnt = {}\n        ans = 0\n        pref = [0]\n        for i in range(0, n): \n                pref.append((a[i] + pref[i]) % k)\n        cnt[0] = 1\n        for i in range(1, n + 1): \n                remIdx = i - k\n                if (remIdx >= 0): \n                        if ((pref[remIdx] - remIdx % k + k) % k in cnt): \n                                cnt[(pref[remIdx] - remIdx % k + k) % k] -= 1\n                        else: \n                                cnt[(pref[remIdx] - remIdx % k + k) % k] = -1\n                if ((pref[i] - i % k + k) % k in cnt): \n                        ans += cnt[(pref[i] - i % k + k) % k]\n                if ((pref[i] - i % k + k) % k in cnt): \n                        cnt[(pref[i] - i % k + k) % k] += 1\n                else: \n                        cnt[(pref[i] - i % k + k) % k] = 1\n        print(ans)", "173": "def countRows(mat):\n        n = len(mat)\n        m = len(mat[0])\n        count = 0\n        totalSum = 0\n        for i in range(n):\n                for j in range(m):\n                        totalSum += mat[i][j]\n        for i in range(n):\n                currSum = 0\n                for j in range(m):\n                        currSum += mat[i][j]\n                if currSum > totalSum - currSum:\n                        count++\n        print(count)", "174": "def isCrossed(path):\n    if len(path) == 0:\n        return\n    ans = False\n    set = set()\n    x = 0\n    y = 0\n    set.add(Point(x, y))\n    for i in range(0, len(path)):\n        if path[i] == 'N':\n            set.add(Point(x, y + 1))\n            y += 1\n        if path[i] == 'S':\n            set.add(Point(x, y - 1))\n            y -= 1\n        if path[i] == 'E':\n            set.add(Point(x + 1, y))\n            x += 1\n        if path[i] == 'W':\n            set.add(Point(x - 1, y))\n            x -= 1\n        if Point(x, y) in set:\n            ans = True\n            break\n    if ans:\n        print(\"Crossed\")\n    else:\n        print(\"Not Crossed\")", "175": "def maxWidth(N, M, cost, s):\n        adj = []\n        for i in range(N):\n                adj.append([])\n\n        for i in range(M):\n                adj[s[i][0]].append(s[i][1])\n\n        result = 0\n\n        q = []\n        q.append(0)\n        while (len(q) != 0):\n                count = len(q)\n                result = max(count, result)\n                while (count > 0):\n                        temp = q.pop()\n                        for i in range(len(adj[temp])):\n                                q.append(adj[temp][i])\n                        count -= 1\n        return result", "176": "def SieveOfEratosthenes():\n    isPrime = {}\n    for p in range(2, MAX):\n        isPrime[p] = True\n    for p in range(2, MAX):\n        if isPrime[p]:\n            for i in range(p * p, MAX):\n                isPrime[i] = False\n    for p in range(2, MAX):\n        if isPrime[p]:\n            primes.add(p)\n\n\ndef prime_search(primes, diff):\n    low = 0\n    high = len(primes) - 1\n    res = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if primes[mid] == diff:\n            return primes[mid]\n        elif primes[mid] < diff:\n            low = mid + 1\n        else:\n            res = primes[mid]\n            high = mid - 1\n    return res\n\n\ndef minCost(arr, n):\n    SieveOfEratosthenes()\n    res = 0\n    for i in range(1, n):\n        if arr[i] < arr[i - 1]:\n            diff = arr[i - 1] - arr[i]\n            closest_prime = prime_search(primes, diff)\n            res += closest_prime\n            arr[i] += closest_prime\n    return res", "177": "def lexico_smallest(s1, s2):\n    M = {}\n    S = set()\n    for i in range(0, len(s1)):\n        if s1[i] not in M:\n            M[s1[i]] = 1\n        else:\n            M[s1[i]] += 1\n        S.add(s1[i])\n    for i in range(0, len(s2)):\n        if s2[i] in M:\n            M[s2[i]] -= 1\n    c = s2[0]\n    index = 0\n    res = \"\"\n    it = sorted(S)\n    while it:\n        x = it.pop(0)\n        if x != c:\n            for i in range(0, M[x]):\n                res += x\n        else:\n            j = 0\n            index = len(res)\n            while s2[j] == x:\n                j += 1\n            if s2[j] < c:\n                res += s2\n                for i in range(0, M[x]):\n                    res += x\n            else:\n                for i in range(0, M[x]):\n                    res += x\n                index += M[x]\n                res += s2\n    pr = [res, str(index)]\n    return pr", "178": "def addEdge(v, x, y):\n        v[x].append(y)\n        v[y].append(x)\ndef dfs(tree, temp, ancestor, u, parent, k):\n        temp.append(u)\n        for i in tree[u]:\n                if (i == parent):\n                        continue\n                dfs(tree, temp, ancestor, i, u, k)\n        temp.remove(temp.size() - 1)\n        if (temp.size() < k):\n                ancestor[u] = -1\n        else:\n                ancestor[u] = temp.get(temp.size() - k)\ndef KthAncestor(N, K, E, edges):\n        tree = [[] for i in range(N + 1)]\n        for i in range(E):\n                addEdge(tree, edges[i][0], edges[i][1])\n        temp = []\n        ancestor = [0 for i in range(N + 1)]\n        dfs(tree, temp, ancestor, 1, 0, K)\n        for i in range(1, N + 1):\n                print(ancestor[i], end = \" \")", "179": "def build(sum,a,l,r,rt):\n        if l==r:\n                sum[rt]=a[l-1]\n                return\n        m=(l+r)//2\n        build(sum,a,l,m,rt*2)\n        build(sum,a,m+1,r,rt*2+1)\n\ndef pushDown(sum,add,rt,ln,rn):\n        if add[rt]!=0:\n                add[rt*2]=add[rt]\n                add[rt*2+1]=add[rt]\n                sum[rt*2]=sum[rt*2]+add[rt]*ln\n                sum[rt*2+1]=sum[rt*2+1]+add[rt]*rn\n                add[rt]=0\n\ndef update(sum,add,L,R,C,l,r,rt):\n        if L<=l and r<=R:\n                sum[rt]=sum[rt]+C*(r-l+1)\n                add[rt]=add[rt]+C\n                return \n        m=(l+r)//2\n        pushDown(sum,add,rt,m-l+1,r-m)\n        if L<=m:\n                update(sum,add,L,R,C,l,m,rt*2)\n        if R>m:\n                update(sum,add,L,R,C,m+1,r,rt*2+1)\n\ndef query(sum,add,L,R,l,r,rt):\n        if L<=l and r<=R:\n                return sum[rt]\n        m=(l+r)//2\n        pushDown(sum,add,rt,m-l+1,r-m)\n        ans=0\n        if L<=m:\n                ans+=query(sum,add,L,R,l,m,rt*2)\n        if R>m:\n                ans+=query(sum,add,L,R,m+1,r,rt*2+1)\n        return ans\n\ndef sequenceMaintenance(n,q,a,b,m):\n        a.sort()\n        sum=[0]*(n*4)\n        ad=[0]*(n*4)\n        ans=[]\n        build(sum,a,1,n,1)\n        for i in range(q):\n                l=1\n                r=n\n                pos=-1\n                while l<=r:\n                        m=(l+r)//2\n                        if query(sum,ad,m,m,1,n,1)>=b[i]:\n                                r=m-1\n                                pos=m\n                        else:\n                                l=m+1\n                if pos==-1:\n                        ans.append(0)\n                else:\n                        ans.append(n-pos+1)\n                        update(sum,ad,pos,n,-m,1,n,1)\n        for i in ans:\n                print(i,end=' ')", "180": "def count(s):\n        cnt = 0\n        for c in s:\n                cnt += c == '0' ? 1 : 0\n        if cnt % 3 != 0:\n                return 0\n        res = 0\n        k = cnt / 3\n        sum = 0\n        map = dict()\n        for i in range(s.length):\n                sum += s[i] == '0' ? 1 : 0\n                if sum == 2 * k and map.containsKey(k)\n                        and i < s.length - 1 and i > 0:\n                        res += map.get(k)\n                map.put(sum,\n                                map.getOrDefault(sum, 0) + 1)\n        return res", "181": "def splitstring(s):\n        n = len(s)\n        zeros = 0\n        for i in range(0, n):\n                if (s[i] == '0'):\n                        zeros += 1\n        if (zeros % 3 != 0):\n                return 0\n        if (zeros == 0):\n                return ((n - 1) * (n - 2)) / 2\n        zerosInEachSubstring = zeros / 3\n        waysOfFirstCut = 0\n        waysOfSecondCut = 0\n        count = 0\n        for i in range(0, n):\n                if (s[i] == '0'):\n                        count += 1\n                if (count == zerosInEachSubstring):\n                        waysOfFirstCut += 1\n                elif (count == 2 * zerosInEachSubstring):\n                        waysOfSecondCut += 1\n        return waysOfFirstCut * waysOfSecondCut", "182": "def check(s, k):\n  n = len(s)\n  for i in range(k):\n    for j in range(i, n, k):\n      if (s[i] != s[j]):\n        return false\n  c = 0\n  for i in range(k):\n    if (s[i] == '0'):\n      c += 1\n    else:\n      c -= 1\n  if (c == 0):\n    return true\n  else:\n    return false\n\ndef addEdge(a, b):\n  tree[a].append(b)\n  tree[b].append(a)\n\ndef dfs(x):\n  vis[x] = true\n  subtreeSize[x] = 1\n  for i in tree[x]:\n    if (not vis[i]):\n      dfs(i)\n      subtreeSize[x] += subtreeSize[i]\n\ndef countPairs(a, b):\n  sub = min(subtreeSize[a], subtreeSize[b])\n  print(sub * (n - sub) + \"\\n\")", "183": "def revNum(N):\n        x = 0\n        while (N != 0):\n                x = x * 10 + N % 10\n                N = N / 10\n        return x\ndef ctNonPalin(arr, N):\n        Res = 0\n        for i in range (0, N):\n                x = revNum(arr[i])\n                if (x == arr[i]):\n                        continue\n                else:\n                        if(arr[i] % 10 == x % 10):\n                                Res += 1\n        return Res", "184": "def isSame(str, n):\n    mp = {}\n    for i in range(len(str)):\n        if (str[i] - 'a' in mp):\n            mp[str[i] - 'a'] += 1\n        else:\n            mp[str[i] - 'a'] = 1\n    for it in mp:\n        if (mp[it] >= n):\n            return True\n    return False", "185": "def canTransform(str1, str2):\n        s1 = \"\"\n        s2 = \"\"\n        for c in str1:\n                if c != 'C':\n                        s1 += c\n        for c in str2:\n                if c != 'C':\n                        s2 += c\n        if s1 != s2:\n                return False\n        i = 0\n        j = 0\n        n = len(str1)\n        while i < n and j < n:\n                if str1[i] == 'C':\n                        i += 1\n                elif str2[j] == 'C':\n                        j += 1\n                else:\n                        if (str1[i] == 'A' and i < j) or (str1[i] == 'B' and i > j):\n                                return False\n                        i += 1\n                        j += 1\n        return True", "186": "def func(a, b, c, x):\n        return a * x * x + b * x + c\ndef findRoot(a, b, c, low, high):\n        x = -1\n        while (abs(high - low) > eps):\n                x = (low + high) / 2\n                if (func(a, b, c, low) *\n                        func(a, b, c, x) <= 0):\n                        high = x\n                else:\n                        low = x\n        return x\ndef solve(a, b, c, A, B):\n        if (func(a, b, c, A) * func(a, b, c, B) > 0):\n                print(\"No solution\");\n        else:\n                print(\"%.4f\" % findRoot( a, b, c, A, B))", "187": "def __gcd(a, b):\n        return b == 0? a:__gcd(b, a % b)\n\ndef hasCoprimePair(arr, n):\n        for i in range(0, n - 1):\n                for j in range(i + 1, n):\n                        if ((__gcd(arr[i], arr[j])) == 1):\n                                return true\n        return false", "188": "def findPermutation(arr, N):\n  pos = arr.size() + 1\n  if (pos > N):\n    return 1\n  res = 0\n  for i in range(1, N+1):\n    if (i not in arr):\n      if (i % pos == 0 or pos % i == 0):\n        arr.add(i)\n        res += findPermutation(arr, N)\n        arr.remove(i)\n  return res", "189": "def solve(arr, n, X, Y):\n        diff = Y - X\n        for i in range (0, n):\n                if (arr[i] != 1):\n                        diff = diff % (arr[i] - 1)\n        if (diff == 0):\n                print( \"Yes\")\n        else:\n                print(\"No\")", "190": "def Numberofways(n):\n        count = 0\n        for a in range(1, n):\n                for b in range(0, n):\n                        c = n - (a + b)\n                        if a + b > c and a + c > b and b + c > a:\n                                count = count + 1\n        return count", "191": "def maxsubStringLength(S, N):\n    arr = [0] * N\n\n    for i in range(0, N):\n        if S[i] == 'a' or S[i] == 'e' or S[i] == 'i' or S[i] == 'o' or S[i] == 'u':\n            arr[i] = 1\n        else:\n            arr[i] = -1\n\n    maxLen = 0\n    curr_sum = 0\n    hash = {}\n\n    for i in range(0, N):\n        curr_sum += arr[i]\n\n        if curr_sum == 0:\n            maxLen = max(maxLen, i + 1)\n\n        if curr_sum in hash:\n            maxLen = max(maxLen, i - hash.get(curr_sum))\n        else:\n            hash[curr_sum] = i\n\n    return maxLen", "192": "def findMaximumSum(a, n):\n        prev_smaller = findPrevious(a, n)\n        next_smaller = findNext(a, n)\n        max_value = 0\n        for i in range(0, n):\n                max_value = max(max_value, a[i] * (next_smaller[i] - prev_smaller[i] - 1))\n        return max_value\ndef findPrevious(a, n):\n        ps = [0] * n\n        ps[0] = -1\n        stack = []\n        stack.append(0)\n        for i in range(1, len(a)):\n                while (len(stack) > 0 and a[stack[-1]] >= a[i]):\n                        stack.pop()\n                if (len(stack) > 0):\n                        ps[i] = stack[-1]\n                else:\n                        ps[i] = -1\n                stack.append(i)\n        return ps\ndef findNext(a, n):\n        ns = [0] * n\n        ns[n - 1] = n\n        stack = []\n        stack.append(n - 1)\n        for i in range(n - 2, -1, -1):\n                while (len(stack) > 0 and a[stack[-1]] >= a[i]):\n                        stack.pop()\n                if (len(stack) > 0):\n                        ns[i] = stack[-1]\n                else:\n                        ns[i] = a.length\n                stack.append(i)\n        return ns", "193": "def possible(mid, a):\n        n = len(a)\n        total = (n * (n - 1)) / 2\n        need = (total + 1) / 2\n        count = 0\n        start = 0\n        end = 1\n        while end < n:\n                if a[end] - a[start] <= mid:\n                        end += 1\n                else:\n                        count += (end - start - 1)\n                        start += 1\n        if end == n and start < end and a[end - 1] - a[start] <= mid:\n                t = end - start - 1\n                count += (t * (t + 1) / 2)\n        if count >= need:\n                return True\n        else:\n                return False\n\ndef findMedian(a):\n        n = len(a)\n        low = 0\n        high = a[n - 1] - a[0]\n        while low <= high:\n                mid = (low + high) // 2\n                if possible(mid, a):\n                        high = mid - 1\n                else:\n                        low = mid + 1\n        return high + 1", "194": "def FindMinimumDistance():\n    q = []\n    q.append((x, y))\n    mat[x][y] = 0\n    while len(q) != 0:\n        x = q[0][0]\n        y = q[0][1]\n        q.remove(q[0])\n        for i in range(0, 8):\n            a = x + dx[i]\n            b = y + dy[i]\n            if (a < 0) or (a >= r) or (b >= c) or (b < 0):\n                continue\n            if (mat[a][b] == 0):\n                mat[a][b] = mat[x][y] + 1\n                q.append((a, b))", "195": "def addEdge(u, v):\n        adj[u].append(v)\n        adj[v].append(u)\n\ndef dfs1(cur, par):\n        for u in adj[cur]:\n                if (u != par):\n                        dfs1(u, cur)\n                        height[cur] = max(height[cur], height[u])\n        height[cur] += 1\n\ndef dfs2(cur, par):\n        max1 = 0\n        max2 = 0\n        for u in adj[cur]:\n                if (u != par):\n                        if (height[u] >= max1):\n                                max2 = max1\n                                max1 = height[u]\n                        else if (height[u] > max2):\n                                max2 = height[u]\n        sum = 0\n        for u in adj[cur]:\n                if (u != par):\n                        sum = ((max1 == height[u]) ? max2 : max1)\n                        if (max1 == height[u]):\n                                dist[u] = 1 + max(1 + max2, dist[cur])\n                        else:\n                                dist[u] = 1 + max(1 + max1, dist[cur])\n                        dfs2(u, cur)", "196": "def countPairs(N, arr):\n        count = 0\n        for i in range(N):\n                if i == arr[arr[i] - 1] - 1:\n                        count += 1\n        print(count / 2)", "197": "def minOperations(S, K):\n        ans = 0\n        for i in range(K):\n                zero = 0\n                one = 0\n                for j in range(i, len(S), K):\n                        if S[j] == '0':\n                                zero += 1\n                        else:\n                                one += 1\n                ans += min(zero, one)\n        return ans", "198": "def UniversalSubset(A, B):\n        n1 = len(A)\n        n2 = len(B)\n        res = []\n        A_fre = [[0 for i in range(26)] for j in range(n1)] \n        for i in range(n1):\n                for j in range(26):\n                        A_fre[i][j] = 0\n        for i in range(n1):\n                for j in range(len(A[i])):\n                        A_fre[i][ord(A[i][j]) - ord('a')] += 1\n        B_fre = [0 for i in range(26)]\n        for i in range(n2):\n                arr = [0 for j in range(26)] \n                for j in range(len(B[i])):\n                        arr[ord(B[i][j]) - ord('a')] += 1\n                        B_fre[ord(B[i][j]) - ord('a')] = max(\n                        B_fre[ord(B[i][j]) - ord('a')],\n                        arr[ord(B[i][j]) - ord('a')])\n        for i in range(n1):\n                flag = 0\n                for j in range(26):\n                        if (A_fre[i][j] < B_fre[j]):\n                                flag = 1\n                                break\n                if (flag == 0):\n                        res.append(A[i])\n        if (res != []):\n                for i in range(len(res)):\n                        for j in range(len(res[i])):\n                                print(res[i][j], end=\"\")\n                print(\" \", end=\"\")\n        else:\n                print(\"-1\", end=\"\")", "199": "def findPair(a, n):\n        min_dist = Integer.MAX_VALUE\n        index_a = -1\n        index_b = -1\n        for i in range(0, n):\n                for j in range(i + 1, n):\n                        if j - i < min_dist:\n                                if a[i] % a[j] == 0 and a[j] % a[i] == 0:\n                                        min_dist = j - i\n                                        index_a = i\n                                        index_b = j\n        if index_a == -1:\n                print(\"-1\")\n        else:\n                print(\n                        \"(\" + a[index_a] + \", \" + a[index_b] + \")\")", "200": "def printNum(L, R):\n    for i in range(L, R):\n        temp = i\n        c = 10\n        flag = 0\n        while temp > 0:\n            if temp % 10 >= c:\n                flag = 1\n                break\n            c = temp % 10\n            temp /= 10\n        if flag == 0:\n            print(i, end=\" \")", "201": "def findMissing(arr, left, right, diff):\n        if (right <= left):\n                return 0;\n        mid = left + (right - left) / 2;\n        if (arr[mid + 1] - arr[mid] != diff):\n                return (arr[mid] + diff);\n        if (mid > 0 && arr[mid] - arr[mid - 1] != diff):\n                return (arr[mid - 1] + diff);\n        if (arr[mid] == arr[0] + mid * diff):\n                return findMissing(arr, mid + 1, right, diff);\n        return findMissing(arr, left, mid - 1, diff);\n    \ndef missingElement(arr, n):\n        arr.sort();\n        diff = (arr[n - 1] - arr[0]) / n;\n        return findMissing(arr, 0, n - 1, diff);", "202": "def missingElement(arr, n):\n        max_ele = arr[0]\n        min_ele = arr[0]\n        x = 0\n        d\n        for i in range(0, n):\n        if (arr[i] > max_ele):\n                max_ele = arr[i]\n        if (arr[i] < min_ele):\n                min_ele = arr[i]\n        d = (max_ele - min_ele) / n\n        for i in range(0, n):\n        x = x ^ arr[i]\n        for i in range(0, n):\n        x = x ^ (min_ele + (i * d))\n        return x", "203": "def power(x, y):\n        temp\n        if (y == 0):\n                return 1\n        temp = power(x, y / 2)\n        if (y % 2 == 0):\n                return temp * temp\n        else:\n                return x * temp * temp\ndef nthRootSearch(low, high, N, K):\n        if (low <= high):\n                mid = (low + high) / 2\n                if ((power(mid, K) <= N) &&\n                        (power(mid + 1, K) > N)):\n                        return mid\n                else if (power(mid, K) < N):\n                        return nthRootSearch(mid + 1, high, N, K)\n                else:\n                        return nthRootSearch(low, mid - 1, N, K)\n        return low", "204": "def get_subset_count(arr, K, N):\n        arr.sort()\n        left = 0\n        right = N - 1\n        ans = 0\n        while (left <= right):\n                if (arr[left] + arr[right] < K):\n                        ans += 1 << (right - left)\n                        left += 1\n                else:\n                        right -= 1\n        return ans", "205": "def minMaxDiff(arr, n, k):\n        max_adj_dif = min(arr)\n        for i in range(0, n - 1):\n                max_adj_dif = max(max_adj_dif,\n                                        abs(arr[i] - arr[i + 1]))\n        if (max_adj_dif == 0):\n                return 0\n        best = 1\n        worst = max_adj_dif\n        mid, required = 0, 0\n        while (best < worst):\n                mid = (best + worst) // 2\n                required = 0\n                for i in range(0, n - 1):\n                        required += (abs(arr[i] - arr[i + 1]) - 1) // mid\n                if (required > k):\n                        best = mid + 1\n                else:\n                        worst = mid\n        return worst", "206": "def checkMin(arr, len):\n        smallest = max(arr)\n        secondSmallest = max(arr)\n        for i in range(0, len):\n        if (arr[i] < smallest):\n                secondSmallest = smallest\n                smallest = arr[i]\n        else if (arr[i] < secondSmallest):\n                secondSmallest = arr[i]\n        if (2 * smallest <= secondSmallest):\n                print(\"Yes\")\n        else:\n                print(\"No\")", "207": "def createHash(hash, maxElement):\n        prev = 0\n        curr = 1\n        hash.add(prev)\n        hash.add(curr)\n        while (curr <= maxElement):\n                temp = curr + prev\n                hash.add(temp)\n                prev = curr\n                curr = temp\ndef fibonacci(arr, n):\n        max_val= max(arr)\n        hash = set()\n        createHash(hash, max_val)\n        minimum = 2147483647\n        maximum = -2147483648\n        for i in range(0, n):\n                if (arr[i] in hash):\n                        minimum = min(minimum, arr[i])\n                        maximum = max(maximum, arr[i])\n        print(minimum, \", \" ,maximum, \"\\n\")", "208": "def isValidLen(s, len, k):\n        n = len(s)\n        mp = {}\n        right = 0\n        while right < len:\n                if s[right] in mp:\n                        mp[s[right]] = mp[s[right]] + 1\n                else:\n                        mp[s[right]] = 1\n                right = right + 1\n        if len(mp) <= k:\n                return True\n        while right < n:\n                if s[right] in mp:\n                        mp[s[right]] = mp[s[right]] + 1\n                else:\n                        mp[s[right]] = 1\n                if s[right - len] in mp:\n                        mp[s[right - len]] = mp[s[right - len]] - 1\n                if mp[s[right - len]] == 0:\n                        mp.pop(s[right - len])\n                if len(mp) <= k:\n                        return True\n                right = right + 1\n        return len(mp) <= k\ndef maxLenSubStr(s, k):\n        uni = set(s)\n        if len(uni) < k:\n                return -1\n        n = len(s)\n        lo = -1\n        hi = n + 1\n        while hi - lo > 1:\n                mid = lo + hi >> 1\n                if isValidLen(s, mid, k):\n                        lo = mid\n                else:\n                        hi = mid\n        return lo", "209": "def isSquarePossible(arr, n, l):\n        cnt = 0\n        for i in range(0, n):\n                if (arr[i] >= l):\n                        cnt++\n                if (cnt >= l):\n                        return true\n        return false\ndef maxArea(arr, n):\n        l = 0\n        r = n\n        len = 0\n        while (l <= r):\n                m = l + ((r - l) // 2)\n                if (isSquarePossible(arr, n, m)):\n                        len = m\n                        l = m + 1\n                else:\n                        r = m - 1\n        return (len * len)", "210": "def kOverlap(pairs, k):\n        vec = []\n        for i in range(0, len(pairs)):\n                vec.append(Pair(pairs[i].first, -1))\n                vec.append(Pair(pairs[i].second, +1))\n\n        #sort the vector\n        vec.sort(key=lambda x: (x.first, x.second))\n\n        st = []\n        for i in range(0, len(vec)):\n                cur = vec[i]\n                if cur.second == -1:\n                        st.append(cur)\n                else:\n                        st.pop()\n                if len(st) >= k:\n                        return true\n        return false", "211": "def insertNames(arr, n):\n        set = set()\n        for i in range(n):\n                if arr[i] not in set:\n                        print(\"No\")\n                        set.add(arr[i])\n                else:\n                        print(\"Yes\")", "212": "def countLessThan(arr, n, key): \n        l = 0\n        r = n - 1\n        index = -1\n        while (l <= r): \n                m = (l + r) // 2\n                if (arr[m] < key): \n                        l = m + 1\n                        index = m \n                else: \n                        r = m - 1\n        return (index + 1) \ndef countGreaterThan(arr, n, key): \n        l = 0\n        r = n - 1\n        index = -1\n        while (l <= r): \n                m = (l + r) // 2\n                if (arr[m] <= key): \n                        l = m + 1\n                else: \n                        r = m - 1\n                        index = m \n        if (index == -1): \n                return 0\n        return (n - index) \ndef countTriplets(n, a, b, c): \n        a.sort()\n        b.sort()\n        c.sort()\n        count = 0\n        for i in range(n): \n                current = b[i]\n                low = countLessThan(a, n, current)\n                high = countGreaterThan(c, n, current)\n                count += (low * high)\n        return count", "213": "def Printksubstring(str, n, k):\n        total = (n * (n + 1)) / 2\n        if k > total:\n                print('-1')\n                return\n        substring = []\n        substring[0] = 0\n        temp = n\n        for i in range(1, n+1):\n                substring[i] = substring[i - 1] + temp\n                temp -= 1\n        l = 1\n        h = n\n        start = 0\n        while l <= h:\n                m = (l + h) // 2\n                if substring[m] > k:\n                        start = m\n                        h = m - 1\n                elif substring[m] < k:\n                        l = m + 1\n                else:\n                        start = m\n                        break\n        end = n - (substring[start] - k)\n        for i in range(start-1, end):\n                print(str[i], end = \"\")", "214": "def LowerInsertionPoint(arr, n, X):\n        if (X < arr[0]):\n                return 0;\n        elif (X > arr[n - 1]):\n                return n;\n        lowerPnt = 0;\n        i = 1;\n        while (i < n and arr[i] < X):\n                lowerPnt = i;\n                i = i * 2;\n        while (lowerPnt < n and arr[lowerPnt] < X):\n                lowerPnt++;\n        return lowerPnt;", "215": "def LongestFibSubseq(A, n):\n    S = set(A)\n    maxLen = 0\n    x, y\n    for i in range(n):\n        for j in range(i+1, n):\n            x = A[j]\n            y = A[i] + A[j]\n            length = 3\n            while y in S and (y != max(S)):\n                z = x + y\n                x = y\n                y = z\n                maxLen = max(maxLen, length+1)\n    return maxLen if maxLen >= 3 else 0", "216": "def getCount(M, N):\n        count = 0\n        if M == 1:\n                return N\n        if N == 1:\n                return M\n        if N > M:\n                for i in range(1, M+1):\n                        numerator = N * i - N + M - i\n                        denominator = M - 1\n                        if numerator % denominator == 0:\n                                j = numerator // denominator\n                                if j >= 1 and j <= N:\n                                        count+=1\n        else:\n                for j in range(1, N+1):\n                        numerator = M * j - M + N - j\n                        denominator = N - 1\n                        if numerator % denominator == 0:\n                                i = numerator // denominator\n                                if i >= 1 and i <= M:\n                                        count+=1\n        return count", "217": "def swapElement(arr1, arr2, n):\n        wrongIdx = 0\n        for i in range(1, n):\n                if arr1[i] < arr1[i - 1]:\n                        wrongIdx = i\n        maximum = -99999999\n        maxIdx = -1\n        res = False\n        for i in range(0, n):\n                if arr2[i] > maximum and arr2[i] >= arr1[wrongIdx - 1]:\n                        if wrongIdx + 1 <= n - 1 and arr2[i] <= arr1[wrongIdx + 1]:\n                                maximum = arr2[i]\n                                maxIdx = i\n                                res = True\n        if res:\n                swap(arr1, wrongIdx, arr2, maxIdx)\n        return res\ndef swap(a, wrongIdx, b, maxIdx):\n        c = a[wrongIdx]\n        a[wrongIdx] = b[maxIdx]\n        b[maxIdx] = c\ndef getSortedArray(arr1, arr2, n):\n        if swapElement(arr1, arr2, n):\n                for i in range(0, n):\n                        print(arr1[i], end = \" \")\n        else:\n                print(\"Not Possible\")\narr1 = [2, 4, 5, 1, 3]\narr2 = [5, 2, 1, 4, 3]\ngetSortedArray(arr1, arr2, 5)", "218": "def costToBalance(s):\n        if (len(s) == 0):\n                print(0);\n        ans = 0;\n        o = 0\n        c = 0;\n        for i in range(0, len(s)):\n                if (s[i] == '('):\n                        o+= 1;\n                if (s[i] == ')'):\n                        c+= 1;\n        if (o != c):\n                return -1;\n        a = [None] * len(s);\n        if (s[0] == '('):\n                a[0] = 1;\n        else:\n                a[0] = -1;\n        if (a[0] < 0):\n                ans += abs(a[0]);\n        for i in range(1, len(s)):\n                if (s[i] == '('):\n                        a[i] = a[i - 1] + 1;\n                else:\n                        a[i] = a[i - 1] - 1;\n                if (a[i] < 0):\n                        ans += abs(a[i]);\n        return ans;", "219": "def middleOfThree(a, b, c):\n    if ((a < b and b < c) or (c < b and b < a)):\n        return b\n    elif ((b < a and a < c) or (c < a and a < b)):\n        return a\n    else: \n        return c", "220": "def middleOfThree(a, b, c):\n        if (a > b):\n                if (b > c):\n                        return b\n                else if (a > c):\n                        return c\n                else:\n                        return a\n        else:\n                if (a > c):\n                        return a\n                else if (b > c):\n                        return c\n                else:\n                        return b", "221": "def middleOfThree(a, b, c):\n        x = a - b\n        y = b - c\n        z = a - c\n        if (x * y > 0):\n                return b\n        elif (x * z > 0):\n                return c\n        else:\n                return a", "222": "def missing4(arr):\n        helper = [0]*4\n        for i in range(0, len(arr)):\n                temp = abs(arr[i])\n                if(temp <= len(arr)):\n                        arr[temp - 1] *= -1\n                else:\n                        if(temp%len(arr) != 0):\n                                helper[temp%len(arr)-1] = -1\n                        else:\n                                helper[(temp%len(arr)) + len(arr) - 1] = -1\n        for i in range(0, len(arr)):\n                if(arr[i] > 0):\n                        print(i+1, end = ' ')\n        for i in range(0, len(helper)):\n                if(helper[i] >= 0):\n                        print(len(arr)+i+1, end = ' ')\n        return", "223": "def lexiMiddleSmallest(K, N):\n        if K % 2 == 0:\n                print(K / 2 + \" \"),\n                for i in range(0, N - 1):\n                        print(K + \" \"),\n                print()\n                return\n        a = []\n        for i in range(0, N / 2):\n                if a[len(a) - 1] == 1:\n                        a.remove(len(a) - 1)\n                else:\n                        t = a[len(a) - 1] - 1\n                        a[len(a) - 1] = t\n                        while len(a) < N:\n                                a.add(K)\n        for i in a:\n                print(i + \" \"),\n        print()", "224": "def transpose(mat, row, col):\n        tr = [[0 for i in range(row)] for j in range(col)]\n        for i in range(row):\n                for j in range(col):\n                        tr[j][i] = mat[i][j]\n        return tr\n\ndef RowWiseSort(B):\n        for i in range(len(B)):\n                B[i].sort()\n\ndef sortCol(mat, N, M):\n        B = transpose(mat, N, M)\n        RowWiseSort(B)\n        mat = transpose(B, M, N)\n        for i in range(N):\n                for j in range(M):\n                        print(mat[i][j], end = ' ')\n                print()", "225": "def largestArea(N, M, H, V):\n        s1 = set()\n        s2 = set()\n        for i in range(1, N+2):\n                s1.add(i)\n        for i in range(1, M+2):\n                s2.add(i)\n        for i in range(0, len(H)):\n                s1.remove(H[i])\n        for i in range(0, len(V)):\n                s2.remove(V[i])\n        list1 = []\n        list2 = []\n        i = 0\n        for it1 in s1:\n                list1[i] = int(it1)\n                i+=1\n        i = 0\n        for it2 in s2:\n                list2[i] = int(it2)\n                i+=1\n        list1.sort()\n        list2.sort()\n        maxH = 0\n        p1 = 0\n        maxV = 0\n        p2 = 0\n        for j in range(0, len(list1)):\n                maxH = max(maxH, list1[j] - p1)\n                p1 = list1[j]\n        for j in range(0, len(list2)):\n                maxV = max(maxV, list2[j] - p2)\n                p2 = list2[j]\n        print(maxV * maxH)", "226": "def findLastElement(arr, N): \n    arr.sort() \n    i = 0\n    while i < N: \n        if ((arr[i] - arr[i - 1]) != 0 and (arr[i] - arr[i - 1]) != 2): \n            print(\"-1\") \n            return\n        i += 1\n    print(arr[N - 1])", "227": "def checkifSorted(A, B, N):\n        flag = False\n        for i in range(0, N - 1):\n                if(A[i] > A[i + 1]):\n                        flag = True\n                        break\n        if(not flag):\n                return True\n        count = 0\n        for i in range(0, N):\n                if(B[i] == 0):\n                        count = count + 1\n                        break\n        for i in range(0, N):\n                if(B[i] == 1):\n                        count = count + 1\n                        break\n        if(count == 2):\n                return True\n        return False", "228": "def maxDivisions(arr, N, X): \n  \n    # Sorting the array in \n    # descending order \n    arr.sort(reverse = True) \n  \n    # Variable to store the maximum \n    # number of subarrays \n    maxSub = 0\n  \n    # Variable to store the size of \n    # each subarray \n    size = 0\n  \n    # Iterating through the array \n    for i in range(0, N): \n        size += 1\n  \n        # Checking if the sum of elements \n        # in the subarray is less than X \n        if (arr[i] * size >= X): \n  \n            # Increasing the maximum \n            # number of subarrays \n            maxSub += 1\n  \n            # Initializing size to 0 \n            size = 0\n  \n    print(maxSub)", "229": "def maxPossibleSum(arr, N):\n        arr.sort()\n        sum = 0\n        j = N - 3\n        while j >= 0:\n                sum += arr[j]\n                j -= 3\n        print(sum)", "230": "def minSteps(A, B, M, N):\n        if (A[0] > B[0]):\n                return 0;\n        if (B[0] > A[0]):\n                return 1;\n        if (M <= N and A[0] == B[0] and count(A, A[0]) == M and count(B, B[0]) == N):\n                return -1;\n        for i in range(1, N):\n                if (B[i] > B[0]):\n                        return 1;\n        for i in range(1, M):\n                if (A[i] < A[0]):\n                        return 1;\n        for i in range(1, M):\n                if (A[i] > A[0]):\n                        swap(A, i, B, 0);\n                        swap(A, 0, B, 0);\n                        return 2;\n        for i in range(1, N):\n                if (B[i] < B[0]):\n                        swap(A, 0, B, i);\n                        swap(A, 0, B, 0);\n                        return 2;\n        return 0;\ndef count(a, c):\n        count = 0;\n        for i in range(0, len(a)):\n                if (a[i] == c):\n                        count += 1;\n        return count;\ndef swap(s1, index1, s2, index2):\n        c = s1[index1];\n        s1[index1] = s2[index2];\n        s2[index2] = c;", "231": "def CountMaximum(arr, n, k):\n        arr.sort()\n        sum = 0\n        count = 0\n        for i in range(0, n):\n                sum += arr[i]\n                if sum > k:\n                        break\n                count++\n        return count", "232": "def CountMaximum(arr, n, k):\n\tarr.sort()\n\tsum = 0\n\tcount = 0\n\tfor i in range(n):\n\t\tsum += arr[i]\n\t\tif sum > k:\n\t\t\tbreak\n\t\tcount++\n\treturn count", "233": "def insertionSort(arr, n):\n        for i in range(1, n):\n                key = arr[i]\n                j = i - 1\n                while j >= 0 and arr[j] > key:\n                        arr[j + 1] = arr[j]\n                        j = j - 1\n                arr[j + 1] = key\ndef printArray(arr, n):\n        for i in range(0, n):\n                print(arr[i] + \" \")\n        print()", "234": "def selectionSort(arr, n):\n        for i in range(0, n - 1):\n                min_idx = i\n                for j in range(i + 1, n):\n                        if arr[j] < arr[min_idx]:\n                                min_idx = j\n                temp = arr[min_idx]\n                arr[min_idx]= arr[i]\n                arr[i] = temp\ndef printArray(arr, size):\n        for i in range(0, size):\n                print(arr[i]+ \" \")\n        print()", "235": "def getPairs(arr, N, K):\n        count = 0\n        for i in range(N):\n                for j in range(i + 1, N):\n                        if arr[i] > K * arr[j]:\n                                count = count + 1\n        print(count)", "236": "def merge(arr, temp, l, m, r, K):\n        i = l\n        j = m + 1\n        cnt = 0\n        for i in range (l, m):\n                found = false\n                while j <= r:\n                        if arr[i] >= K * arr[j]:\n                                found = true\n                        else:\n                                break\n                        j += 1\n                if found == true:\n                        cnt += j - (m + 1)\n                        j -= 1\n        k = l\n        i = l\n        j = m + 1\n        while i <= m and j <= r:\n                if arr[i] <= arr[i]:\n                        temp[k] = arr[i]\n                        k += 1\n                else:\n                        temp[k] = arr[j]\n                        k += 1\n                i += 1\n                j += 1\n        while i <= m:\n                temp[k] = arr[i]\n                k += 1\n                i += 1\n        while j <= r:\n                temp[k] = arr[j]\n                k += 1\n                j += 1\n        for i in range (l, r):\n                arr[i] = temp[i]\n        return cnt\ndef mergeSortUtil(arr, temp, l, r, K):\n        cnt = 0\n        if l < r:\n                m = (l + r) / 2\n                cnt += mergeSortUtil(arr, temp, l, m, K)\n                cnt += mergeSortUtil(arr, temp, m + 1, r, K)\n                cnt += merge(arr, temp, l, m, r, K)\n        return cnt\ndef mergeSort(arr, N, K):\n        temp = [0] * N\n        System.out.print(mergeSortUtil(arr, temp, 0, N - 1, K))", "237": "def minRemovals(A, N):\n        A.sort()\n        mx = A[N - 1]\n        sum = 1\n        for i in range(0, N):\n                sum += A[i]\n        if sum - mx >= mx:\n                print(0)\n        else:\n                print(2 * mx - sum)", "238": "def rearrange_array(a, n):\n        a.sort()\n        for i in range(0, n - 1):\n                if (a[i] == i + 1):\n                        temp = a[i]\n                        a[i] = a[i + 1]\n                        a[i + 1] = temp\n        if (a[n - 1] == n):\n                temp = a[n - 1]\n                a[n - 1] = a[n - 2]\n                a[n - 2] = temp\n        for i in range(0, n):\n                print(a[i] + \" \")", "239": "def checkStr1CanConStr2(str1, str2):\n        N = len(str1)\n        M = len(str2)\n        st1 = set()\n        st2 = set()\n        hash1 = [0]*256\n        for i in range(N):\n                hash1[ord(str1[i])] += 1\n        for i in range(N):\n                st1.add(ord(str1[i]))\n        for i in range(M):\n                st2.add(ord(str2[i]))\n        if st1 != st2:\n                return False\n        hash2 = [0]*256\n        for i in range(M):\n                hash2[ord(str2[i])] += 1\n        hash1.sort()\n        hash2.sort()\n        for i in range(256):\n                if hash1[i] != hash2[i]:\n                        return False\n        return True", "240": "def minOperations(arr1, arr2, i, j):\n        if arr1 == arr2:\n                return 0\n        if i >= len(arr1) or j >= len(arr2):\n                return 0\n        if arr1[i] < arr2[j]:\n                return 1 + minOperations(arr1, arr2, i + 1, j + 1)\n        return max(minOperations(arr1, arr2, i, j + 1), minOperations(arr1, arr2, i + 1, j))\ndef minOperationsUtil(arr):\n        brr = arr.copy()\n        brr.sort()\n        if arr == brr:\n                print(\"0\")\n        else:\n                print(minOperations(arr, brr, 0, 0))", "241": "def minOperations(arr, n):\n    num = []\n    for i in range(n):\n        num.append((arr[i], i))\n    num.sort(key = lambda x: x[0])\n    res = 1\n    streak = 1\n    prev = num[0][1]\n    for i in range(1, n):\n        if prev < num[i][1]:\n            res += 1\n            streak = max(res, streak)\n        else:\n            res = 1\n        prev = num[i][1]\n    return n - streak", "242": "def can_transform(s, t):\n    n = len(s)\n    occur = [[] for _ in range(26)]\n    for x in range(n):\n        ch = ord(s[x]) - ord('a')\n        occur[ch].append(x)\n    idx = [0] * 26\n    poss = True\n    for x in range(n):\n        ch = ord(t[x]) - ord('a')\n        if idx[ch] >= len(occur[ch]):\n            poss = False\n            break\n        for small in range(ch):\n            if idx[small] < len(occur[small]) and \\\n                    occur[small][idx[small]] < \\\n                    occur[ch][idx[ch]]:\n                poss = False\n                break\n        idx[ch] += 1\n    if poss:\n        print(\"Yes\")\n    else:\n        print(\"No\")", "243": "def getMaxSum(i, j, k, arr1, arr2, arr3):\n        cnt = 0\n        if (i >= n1):\n                cnt++\n        if (j >= n2):\n                cnt++\n        if (k >= n3):\n                cnt++\n        if (cnt >= 2):\n                return 0\n        if (dp[i][j][k] != -1):\n                return dp[i][j][k]\n        ans = 0\n        if (i < n1 && j < n2):\n                ans = max(ans, getMaxSum(i + 1, j + 1, k, arr1, arr2, arr3) + arr1[i] * arr2[j])\n        if (i < n1 && k < n3):\n                ans = max(ans, getMaxSum(i + 1, j, k + 1, arr1, arr2, arr3) + arr1[i] * arr3[k])\n        if (j < n2 && k < n3):\n                ans = max(ans, getMaxSum(i, j + 1, k + 1, arr1, arr2, arr3) + arr2[j] * arr3[k])\n        dp[i][j][k] = ans\n        return dp[i][j][k]\n\ndef reverse(tmp):\n        for i in range(0, len(tmp) // 2):\n                t = tmp[i]\n                tmp[i] = tmp[len(tmp) - i - 1]\n                tmp[len(tmp) - i - 1] = t\n\ndef maxProductSum(arr1, arr2, arr3):\n        for i in range(0, len(dp)):\n                for j in range(0, len(dp[0])):\n                        for k in range(0, len(dp[j])):\n                                dp[i][j][k] = -1\n        arr1.sort()\n        reverse(arr1)\n        arr2.sort()\n        reverse(arr2)\n        arr3.sort()\n        reverse(arr3)\n        return getMaxSum(0, 0, 0, arr1, arr2, arr3)", "244": "def findTriplet(arr, N):\n        arr.sort()\n        flag = 0\n        for i in range(N - 1, 2, -1):\n                if (arr[i - 2] + arr[i - 1] > arr[i]):\n                        flag = 1\n                        break\n        if (flag != 0):\n                print(arr[i - 2] + \" \" + arr[i - 1] + \" \" + arr[i] )\n        else:\n                print(-1)", "245": "def inversionCount(s):\n        freq = [0] * 26\n        inv = 0\n        for i in range(s.length()):\n                temp = 0\n                for j in range(s.charAt(i) - 'a'):\n                        temp += freq[j]\n                inv += (i - temp)\n                freq[s.charAt(i) - 'a']++\n        return inv\ndef haveRepeated(S1, S2):\n        freq = [0] * 26\n        for i in S1.toCharArray():\n                if (freq[i - 'a'] > 0):\n                        return true\n                freq[i - 'a']++\n        for i in range(26):\n                freq[i] = 0\n        for i in S2.toCharArray():\n                if (freq[i - 'a'] > 0):\n                        return true\n                freq[i - 'a']++\n        return false\ndef checkToMakeEqual(S1, S2):\n        freq = [0] * 26\n        for i in range(S1.length()):\n                freq[S1.charAt(i) - 'a']++\n        flag = false\n        for i in range(S2.length()):\n                if (freq[S2.charAt(i) - 'a'] == 0):\n                        flag = true\n                        break\n                freq[S2.charAt(i) - 'a']--\n        if (flag == true):\n                print(\"No\")\n                return\n        invCount1 = inversionCount(S1)\n        invCount2 = inversionCount(S2)\n        if (invCount1 == invCount2 or\n        (invCount1 & 1) == (invCount2 & 1) or\n                haveRepeated(S1, S2)):\n                print(\"Yes\")\n        else:\n        print(\"No\")", "246": "def numberofpairs(arr, N):\n        answer = 0\n        arr.sort()\n        minDiff = 10000000\n        for i in range(0, N - 1):\n                minDiff = min(minDiff, arr[i + 1] - arr[i])\n        for i in range(0, N - 1):\n                if arr[i + 1] - arr[i] == minDiff:\n                        answer++\n        return answer", "247": "def sortArr(a, n): \n        k = (int)(math.log(n) / math.log(2)) \n        k = (int) math.pow(2, k) \n        while (k > 0): \n                for i in range(0, n): \n                        if (a[i] > a[i + k]): \n                                tmp = a[i] \n                                a[i] = a[i + k] \n                                a[i + k] = tmp \n                k = k // 2\n        for i in range(0, n): \n                print(a[i], end = \" \")", "248": "def maximumSum(arr, n, k): \n        elt = n // k \n        sum = 0\n        arr.sort()\n        count = 0\n        i = n - 1\n        while (count < k): \n                sum += arr[i] \n                i -= 1\n                count += 1\n        count = 0\n        i = 0\n        while (count < k): \n                sum += arr[i] \n                i += elt - 1\n                count += 1\n        print(sum)", "249": "def findMinSum(arr, K, L, size):\n        if (K * L > size):\n                return -1\n        minsum = 0\n        arr.sort()\n        for i in range(0, K):\n                minsum += arr[i]\n        return minsum", "250": "def find_max_length(arr, index, sum, k):\n        sum = sum + arr[index]\n        store.add(arr[index])\n        if (sum == k):\n                if (max_length < store.size()):\n                        max_length = store.size()\n                        ans = store\n        for i in range(index + 1, len(arr)):\n                if (sum + arr[i] <= k):\n                        find_max_length(arr, i, sum, k)\n                        store.remove(store.size() - 1)\n                else:\n                        return\n        return\ndef longestSubsequence(arr, n, k):\n        arr.sort()\n        for i in range(0, n):\n                if (max_length >= n - i):\n                        break\n                store.clear()\n                find_max_length(arr, i, 0, k)\n        return max_length", "251": "def findKthSmallest(arr, n, k):\n        max = 0\n        for i in range(0, n):\n                if arr[i] > max:\n                        max = arr[i]\n        counter = [0] * (max + 1)\n        smallest = 0\n        for i in range(0, n):\n                counter[arr[i]] = counter[arr[i]] + 1\n        for num in range(1, max + 1):\n                if counter[num] > 0:\n                        smallest += counter[num]\n                if smallest >= k:\n                        return num\n        return -1", "252": "def lexNumbers(n):\n        s = []\n        for i in range(1, n+1):\n                s.append(str(i))\n        s.sort()\n        ans = []\n        for i in range(0, n):\n                ans.append(int(s[i]))\n        for i in range(0, n):\n                print(ans[i], end=\" \")", "253": "def lexNumbers(n):\n        sol = []\n        dfs(1, n, sol)\n        print(sol)\ndef dfs(temp, n, sol):\n        if temp > n:\n                return\n        sol.append(temp)\n        dfs(temp * 10, n, sol)\n        if temp % 10 != 9:\n                dfs(temp + 1, n, sol)", "254": "def func(a):\n        N = len(a)\n        for i in range(N):\n        \n                if i % 2 == 0:\n                        for j in range(N):\n                                for k in range(j+1, N):\n                                        if a[i][j] > a[i][k]:\n                                                temp = a[i][j]\n                                                a[i][j] = a[i][k]\n                                                a[i][k] = temp\n                else:\n                        for j in range(N):\n                                for k in range(j+1, N):\n                                        if a[i][j] < a[i][k]:\n                                                temp = a[i][j]\n                                                a[i][j] = a[i][k]\n                                                a[i][k] = temp\n        for i in range(N):\n                for j in range(N):\n                        print(a[i][j], end=\" \")\n                print()", "255": "def partition(arr, l, h):\n        pivot = arr[l]\n        i = l + 1\n        j = h\n        while (i <= j):\n                while (i <= h and arr[i] < pivot):\n                        i+=1\n                while (j > l and arr[j] > pivot):\n                        j-=1\n                if (i < j):\n                        temp = arr[i]\n                        arr[i] = arr[j]\n                        arr[j] = temp\n                        i+=1\n                        j-=1\n                else:\n                        i+=1\n        arr[l] = arr[j]\n        arr[j] = pivot\n        return j\n\ndef sortArray(arr, l, h):\n        if (l >= h):\n                return\n        pivot = partition(arr, l, h)\n        sortArray(arr, l, pivot - 1)\n        sortArray(arr, pivot + 1, h)\n\ndef findMaxIntervals(start, end, n, R):\n        ans = 0\n        prev = 0\n        currActive = 0\n        i = 0\n        j = 0\n        if (start[0] > 0):\n                ans+=1\n        while (i < n and j < n):\n                if (start[i] < end[j]):\n                        i+=1\n                        currActive+=1\n                elif (start[i] > end[j]):\n                        j+=1\n                        currActive-=1\n                else:\n                        i+=1\n                        j+=1\n                if (currActive == 0):\n                        ans+=1\n        if (end[n - 1] < R):\n                ans+=1\n        return ans"}}, "Python-Java": {"ID": {"0": 451, "1": 455, "2": 496, "3": 617, "4": 647, "5": 694, "6": 803, "7": 815, "8": 818, "9": 821, "10": 832, "11": 833, "12": 846, "13": 861, "14": 862, "15": 883, "16": 895, "17": 918, "18": 919, "19": 920, "20": 926, "21": 927, "22": 953, "23": 955, "24": 956, "25": 958, "26": 959, "27": 965, "28": 966, "29": 1064, "30": 1072, "31": 1073, "32": 1074, "33": 1075, "34": 1252, "35": 1253, "36": 1344, "37": 1345, "38": 1346, "39": 1366, "40": 1390, "41": 1405, "42": 1406, "43": 1428, "44": 1468, "45": 1469, "46": 1473, "47": 1474, "48": 1478}, "Python": {"0": "def minCost(cost):\n        dist=[0 for i in range(N)]\n        for i in range(N):\n                dist[i] = INF\n        dist[0] = 0\n        for i in range(N):\n                for j in range(i+1,N):\n                        if (dist[j] > dist[i] + cost[i][j]):\n                                dist[j] = dist[i] + cost[i][j]\n        return dist[N-1]", "1": "def numOfways(n,k):\n        p = 1\n        if (k % 2):\n                p = -1\n        return (pow(n - 1, k) +\n                                p * (n - 1)) / n", "2": "def fib(n):\n        if n <= 1:\n                return n\n        return fib(n - 1) + fib(n - 2)\ndef findVertices(n):\n        return fib(n + 2)", "3": "def reverse( head_ref):\n\ttemp = None\n\tcurrent = head_ref\n\twhile (current != None):\n\t\ttemp = current.prev\n\t\tcurrent.prev = current.next\n\t\tcurrent.next = temp\n\t\tcurrent = current.prev\n\tif (temp != None):\n\t\thead_ref = temp.prev\n\t\treturn head_ref\ndef merge( first, second):\n\tif (first == None):\n\t\treturn second\n\tif (second == None):\n\t\treturn first\n\tif (first.data < second.data):\n\t\tfirst.next = merge(first.next, second)\n\t\tfirst.next.prev = first\n\t\tfirst.prev = None\n\t\treturn first\n\telse:\n\t\tsecond.next = merge(first, second.next)\n\t\tsecond.next.prev = second\n\t\tsecond.prev = None\n\t\treturn second\ndef sort( head):\n\tif (head == None or head.next == None):\n\t\treturn head\n\tcurrent = head.next\n\twhile (current != None) :\n\t\tif (current.data < current.prev.data):\n\t\t\tbreak\n\t\tcurrent = current.next\n\tif (current == None):\n\t\treturn head\n\tcurrent.prev.next = None\n\tcurrent.prev = None\n\tcurrent = reverse(current)\n\treturn merge(head, current)\ndef push( head_ref, new_data):\n\tnew_node =Node()\n\tnew_node.data = new_data\n\tnew_node.prev = None\n\tnew_node.next = (head_ref)\n\tif ((head_ref) != None):\n\t\t(head_ref).prev = new_node\n\t(head_ref) = new_node\n\treturn head_ref\ndef printList( head):\n\tif (head == None):\n\t\tprint(\"Doubly Linked list empty\")\n\twhile (head != None):\n\t\tprint(head.data, end= \" \")\n\t\thead = head.next\ndef __init__(self, next = None, prev = None, data = None):\n\t\tself.next = next\n\t\tself.prev = prev\n\t\tself.data = data", "4": "def printlist(head):\n        if (not head):\n                print(\"Empty List\")\n                return\n        while (head != None):\n                print(head.data, end = \" \")\n                if (head.next):\n                        print(end = \"-> \")\n                head = head.next\n        print()\ndef isVowel(x):\n        return (x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U')\ndef arrange(head):\n        newHead = head\n        latestVowel = None\n        curr = head\n        if (head == None):\n                return None\n        if (isVowel(head.data)):\n                latestVowel = head\n        else:\n                while (curr.next != None and\n                        not isVowel(curr.next.data)):\n                        curr = curr.next\n                if (curr.next == None):\n                        return head\n                latestVowel = newHead = curr.next\n                curr.next = curr.next.next\n                latestVowel.next = head\n        while (curr != None and curr.next != None):\n                if (isVowel(curr.next.data)):\n                        if (curr == latestVowel):\n                                latestVowel = curr = curr.next\n                        else:\n                                temp = latestVowel.next\n                                latestVowel.next = curr.next\n                                latestVowel = latestVowel.next\n                                curr.next = curr.next.next\n                                latestVowel.next = temp\n                else:\n                        curr = curr.next\n        return newHead\ndef __init__(self, x):\n                self.data = x\n                self.next = None", "5": "def KthLargestUsingMorrisTraversal(root, k):\n\tcurr = root\n\tKlargest = None\n\tcount = 0\n\twhile (curr != None):\n\t\tif (curr.right == None):\n\t\t\tcount += 1\n\t\t\tif (count == k):\n\t\t\t\tKlargest = curr\n\t\t\tcurr = curr.left\n\t\telse:\n\t\t\tsucc = curr.right\n\t\t\twhile (succ.left != None and succ.left != curr):\n\t\t\t\tsucc = succ.left\n\t\t\tif (succ.left == None):\n\t\t\t\tsucc.left = curr\n\t\t\t\tcurr = curr.right\n\t\t\telse:\n\t\t\t\tsucc.left = None\n\t\t\t\tcount += 1\n\t\t\t\tif (count == k):\n\t\t\t\t\tKlargest = curr\n\t\t\t\tcurr = curr.left\n\treturn Klargest\ndef __init__(self, data):\n\t\tself.data = data\n\t\tself.right = self.left = None", "6": "def sortByRow(mat, n, ascending):\n        for i in range(n):\n                if (ascending): \n                        mat[i].sort()\n                else:\n                        mat[i].sort(reverse=True)\ndef transpose(mat, n):\n        for i in range(n):\n                for j in range(i + 1, n):\n                        temp = mat[i][j]\n                        mat[i][j] = mat[j][i]\n                        mat[j][i] = temp\ndef sortMatRowAndColWise(mat, n):\n        sortByRow(mat, n, True)\n        transpose(mat, n)\n        sortByRow(mat, n, False)\n        transpose(mat, n)\ndef printMat(mat, n):\n        for i in range(n):\n                for j in range(n):\n                        print(mat[i][j] , \" \", end=\"\")\n                print()", "7": "def sortByRow(mat, n):\n\tfor i in range (n):\n\t\tfor j in range(n-1):\n\t\t\tif mat[i][j] > mat[i][j + 1]:\n\t\t\t\ttemp = mat[i][j]\n\t\t\t\tmat[i][j] = mat[i][j + 1]\n\t\t\t\tmat[i][j + 1] = temp\ndef transpose(mat, n):\n\tfor i in range (n):\n\t\tfor j in range(i + 1, n):\n\t\t\tt = mat[i][j]\n\t\t\tmat[i][j] = mat[j][i]\n\t\t\tmat[j][i] = t\ndef sortMatRowAndColWise(mat, n):\n\tsortByRow(mat, n)\n\ttranspose(mat, n)\n\tsortByRow(mat, n)\n\ttranspose(mat, n)\ndef printMat(mat, n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tprint(str(mat[i][j] ), end = \" \")\n\t\tprint();", "8": "def DoublyEven(n):\n        arr = [[(n*y)+x+1 for x in range(n)]for y in range(n)]\n        for i in range(0,n/4):\n                for j in range(0,n/4):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(0,n/4):\n                for j in range(3 * (n/4),n):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(3 * (n/4),n):\n                for j in range(0,n/4):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(3 * (n/4),n):\n                for j in range(3 * (n/4),n):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(n/4,3 * (n/4)):\n                for j in range(n/4,3 * (n/4)):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(n):\n                for j in range(n):\n                        print '%2d ' %(arr[i][j]),\n                print", "9": "def Kroneckerproduct( A , B ):\n        C = [[0 for j in range(cola * colb)] for i in range(rowa * rowb)]\n        for i in range(0, rowa):\n                for k in range(0, rowb):\n                        for j in range(0, cola):\n                                for l in range(0, colb):\n                                        C[i + l + 1][j + k + 1] = A[i][j] * B[k][l]\n                                        print (C[i + l + 1][j + k + 1],end=' ')\n                        print (\"\\n\")", "10": "def islowertriangular(M):\n\tfor i in range(0, len(M)):\n\t\tfor j in range(i + 1, len(M)):\n\t\t\tif(M[i][j] != 0):\n\t\t\t\t\treturn False\n\treturn True", "11": "def isuppertriangular(M):\n\tfor i in range(1, len(M)):\n\t\tfor j in range(0, i):\n\t\t\tif(M[i][j] != 0):\n\t\t\t\t\treturn False\n\treturn True", "12": "def countSets(a):\n\tres = 0\n\tfor i in range(n):\n\t\tu = 0\n\t\tv = 0\n\t\tfor j in range(m):\n\t\t\tif a[i][j]:\n\t\t\t\tu += 1\n\t\t\telse:\n\t\t\t\tv += 1\n\t\tres += pow(2, u) - 1 + pow(2, v) - 1\n\tfor i in range(m):\n\t\tu = 0\n\t\tv = 0\n\t\tfor j in range(n):\n\t\t\tif a[j][i]:\n\t\t\t\tu += 1\n\t\t\telse:\n\t\t\t\tv += 1\n\t\tres += pow(2, u) - 1 + pow(2, v) - 1\n\treturn res - (n*m)", "13": "def transpose(mat, tr, N):\n        for i in range(N):\n                for j in range(N):\n                        tr[i][j] = mat[j][i]\ndef isSymmetric(mat, N):\n        tr = [ [0 for j in range(len(mat[0])) ] for i in range(len(mat)) ]\n        transpose(mat, tr, N)\n        for i in range(N):\n                for j in range(N):\n                        if (mat[i][j] != tr[i][j]):\n                                return False\n        return True", "14": "def isSymmetric(mat, N):\n\tfor i in range(N):\n\t\tfor j in range(N):\n\t\t\tif (mat[i][j] != mat[j][i]):\n\t\t\t\treturn False\n\treturn True", "15": "def findNormal(mat, n):\n\tsum = 0;\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tsum += mat[i][j] * mat[i][j];\n\treturn math.floor(math.sqrt(sum));\ndef findTrace(mat, n):\n\tsum = 0;\n\tfor i in range(n):\n\t\tsum += mat[i][i];\n\treturn sum;", "16": "def maxDet(n):\n\treturn 2 * n * n * n\ndef resMatrix(n):\n\tfor i in range(3):\n\t\tfor j in range(3):\n\t\t\tif i == 0 and j == 2:\n\t\t\t\tprint(\"0\", end = \" \")\n\t\t\telif i == 1 and j == 0:\n\t\t\t\tprint(\"0\", end = \" \")\n\t\t\telif i == 2 and j == 1:\n\t\t\t\tprint(\"0\", end = \" \")\n\t\t\telse:\n\t\t\t\tprint(n, end = \" \")\n\t\tprint(\"\\n\")", "17": "def countNegative(M, n, m):\n\tcount = 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif M[i][j] < 0:\n\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tbreak\n\treturn count", "18": "def countNegative(M, n, m):\n\tcount = 0 \n\ti = 0\n\tj = m - 1 \n\twhile j >= 0 and i < n:\n\t\tif M[i][j] < 0:\n\t\t\tcount += (j + 1)\n\t\t\ti += 1\n\t\telse:\n\t\t\tj -= 1\n\treturn count", "19": "def getLastNegativeIndex(array, start, end, n):\n\tif (start == end):\n\t\treturn start\n\tmid = start + (end - start) // 2\n\tif (array[mid] < 0):\n\t\tif (mid + 1 < n and array[mid + 1] >= 0):\n\t\t\treturn mid\n\t\treturn getLastNegativeIndex(array, mid + 1, end, n)\n\telse:\n\t\treturn getLastNegativeIndex(array, start, mid - 1, n)\ndef countNegative(M, n, m):\n\tcount = 0\n\tnextEnd = m - 1\n\tfor i in range(n):\n\t\tif (M[i][0] >= 0):\n\t\t\tbreak\n\t\tnextEnd = getLastNegativeIndex(M[i], 0, nextEnd, 4)\n\t\tcount += nextEnd + 1\n\treturn count", "20": "def findMaxValue(mat):\n\tmaxValue = 0\n\tfor a in range(N - 1):\n\t\tfor b in range(N - 1):\n\t\t\tfor d in range(a + 1, N):\n\t\t\t\tfor e in range(b + 1, N):\n\t\t\t\t\tif maxValue < int (mat[d][e] - mat[a][b]):\n\t\t\t\t\t\tmaxValue = int(mat[d][e] - mat[a][b]);\n\treturn maxValue;", "21": "def findMaxValue(mat):\n        maxValue = -sys.maxsize -1\n        maxArr = [[0 for x in range(N)] for y in range(N)]\n        maxArr[N - 1][N - 1] = mat[N - 1][N - 1]\n        maxv = mat[N - 1][N - 1];\n        for j in range (N - 2, -1, -1):\n                if (mat[N - 1][j] > maxv):\n                        maxv = mat[N - 1][j]\n                maxArr[N - 1][j] = maxv\n        maxv = mat[N - 1][N - 1];\n        for i in range (N - 2, -1, -1):\n                if (mat[i][N - 1] > maxv):\n                        maxv = mat[i][N - 1]\n                maxArr[i][N - 1] = maxv\n        for i in range (N - 2, -1, -1):\n                for j in range (N - 2, -1, -1):\n                        if (maxArr[i + 1][j + 1] - mat[i][j] > maxValue):\n                                maxValue = (maxArr[i + 1][j + 1] - mat[i][j])\n                        maxArr[i][j] = max(mat[i][j],\n                                                max(maxArr[i][j + 1], maxArr[i + 1][j]))\n        return maxValue", "22": "def youngify(mat, i, j):\n        downVal = mat[i + 1][j] if (i + 1 < N) else INF\n        rightVal = mat[i][j + 1] if (j + 1 < N) else INF\n        if (downVal == INF and rightVal == INF):\n                return\n        if (downVal < rightVal):\n                mat[i][j] = downVal\n                mat[i + 1][j] = INF\n                youngify(mat, i + 1, j)\n        else:\n                mat[i][j] = rightVal\n                mat[i][j + 1] = INF\n                youngify(mat, i, j + 1)\ndef extractMin(mat):\n        ret = mat[0][0]\n        mat[0][0] = INF\n        youngify(mat, 0, 0)\n        return ret\ndef printSorted(mat):\n        print(\"Elements of matrix in sorted order n\")\n        i = 0\n        while i < N * N:\n                print(extractMin(mat), end = \" \")\n                i += 1", "23": "def printSumSimple(mat, k):\n\tif (k > n):\n\t\treturn\n\tfor i in range(n - k + 1):\n\t\tfor j in range(n - k + 1):\n\t\t\tsum = 0\n\t\t\tfor p in range(i, k + i):\n\t\t\t\tfor q in range(j, k + j):\n\t\t\t\t\tsum += mat[p][q]\n\t\t\tprint(sum, end = \" \")\n\t\tprint()", "24": "def printSumTricky(mat, k):\n        global n\n        if k > n:\n                return\n        stripSum = [[None] * n for i in range(n)]\n        for j in range(n):\n                Sum = 0\n                for i in range(k):\n                        Sum += mat[i][j]\n                stripSum[0][j] = Sum\n                for i in range(1, n - k + 1):\n                        Sum += (mat[i + k - 1][j] - mat[i - 1][j])\n                        stripSum[i][j] = Sum\n        for i in range(n - k + 1):\n                Sum = 0\n                for j in range(k):\n                        Sum += stripSum[i][j]\n                print(Sum, end = \" \")\n                for j in range(1, n - k + 1):\n                        Sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1])\n                        print(Sum, end = \" \")\n                print()", "25": "def transpose(A, B):\n\tfor i in range(N):\n\t\tfor j in range(M):\n\t\t\tB[i][j] = A[j][i]", "26": "def transpose(A):\n\tfor i in range(N):\n\t\tfor j in range(i+1, N):\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]", "27": "def pathCountRec(mat, m, n, k):\n\tif m < 0 or n < 0:\n\t\treturn 0\n\telif m == 0 and n == 0:\n\t\treturn k == mat[m][n]\n\treturn (pathCountRec(mat, m-1, n, k-mat[m][n])\n\t\t+ pathCountRec(mat, m, n-1, k-mat[m][n]))\ndef pathCount(mat, k):\n\treturn pathCountRec(mat, R-1, C-1, k)", "28": "def pathCountDPRecDP(mat, m, n, k):\n\tif m < 0 or n < 0:\n\t\treturn 0\n\telif m == 0 and n == 0:\n\t\treturn k == mat[m][n]\n\tif (dp[m][n][k] != -1):\n\t\treturn dp[m][n][k]\n\tdp[m][n][k] = (pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) +\n\t\t\t\tpathCountDPRecDP(mat, m, n - 1, k - mat[m][n]))\n\treturn dp[m][n][k]\ndef pathCountDP(mat, k):\n\treturn pathCountDPRecDP(mat, R - 1, C - 1, k)", "29": "def countMinReversals(expr):\n\tlenn = len(expr)\n\tif (lenn % 2) :\n\t\treturn -1\n\ts = []\n\tfor i in range(lenn):\n\t\tif (expr[i] =='' and len(s)):\n\t\t\tif (s[0] == '') :\n\t\t\t\ts.pop(0)\n\t\t\telse:\n\t\t\t\ts.insert(0, expr[i])\n\t\telse:\n\t\t\ts.insert(0, expr[i])\n\tred_len = len(s)\n\tn = 0\n\twhile (len(s)and s[0] == '') :\n\t\t\ts.pop(0)\n\t\t\tn += 1\n\treturn (red_len // 2 + n % 2)", "30": "def PrintMinNumberForPattern(arr):\n\tcurr_max = 0\n\tlast_entry = 0\n\ti = 0\n\twhile i < len(arr):\n\t\tnoOfNextD = 0\n\t\tif arr[i] == \"I\":\n\t\t\tj = i + 1\n\t\t\twhile j < len(arr) and arr[j] == \"D\":\n\t\t\t\tnoOfNextD += 1\n\t\t\t\tj += 1\n\t\t\tif i == 0:\n\t\t\t\tcurr_max = noOfNextD + 2\n\t\t\t\tlast_entry += 1\n\t\t\t\tprint(\"\", last_entry, end = \"\")\n\t\t\t\tprint(\"\", curr_max, end = \"\")\n\t\t\t\tlast_entry = curr_max\n\t\t\telse:\n\t\t\t\tcurr_max += noOfNextD + 1\n\t\t\t\tlast_entry = curr_max\n\t\t\t\tprint(\"\", last_entry, end = \"\")\n\t\t\tfor k in range(noOfNextD):\n\t\t\t\tlast_entry -= 1\n\t\t\t\tprint(\"\", last_entry, end = \"\")\n\t\t\t\ti += 1\n\t\telif arr[i] == \"D\":\n\t\t\tif i == 0:\n\t\t\t\tj = i + 1\n\t\t\t\twhile j < len(arr) and arr[j] == \"D\":\n\t\t\t\t\tnoOfNextD += 1\n\t\t\t\t\tj += 1\n\t\t\t\tcurr_max = noOfNextD + 2\n\t\t\t\tprint(\"\", curr_max, curr_max - 1, end = \"\")\n\t\t\t\tlast_entry = curr_max - 1\n\t\t\telse:\n\t\t\t\tprint(\"\", last_entry - 1, end = \"\")\n\t\t\t\tlast_entry -= 1\n\t\ti += 1\n\tprint()", "31": "def printLeast(arr):\n\tmin_avail = 1\n\tpos_of_I = 0\n\tv = []\n\tif (arr[0] == 'I'):\n\t\tv.append(1)\n\t\tv.append(2)\n\t\tmin_avail = 3\n\t\tpos_of_I = 1\n\telse:\n\t\tv.append(2)\n\t\tv.append(1)\n\t\tmin_avail = 3\n\t\tpos_of_I = 0\n\tfor i in range(1, len(arr)):\n\t\tif (arr[i] == 'I'):\n\t\t\tv.append(min_avail)\n\t\t\tmin_avail += 1\n\t\t\tpos_of_I = i + 1\n\t\telse:\n\t\t\tv.append(v[i])\n\t\t\tfor j in range(pos_of_I, i + 1):\n\t\t\t\tv[j] += 1\n\t\t\tmin_avail += 1\n\tprint(*v, sep = ' ')", "32": "def PrintMinNumberForPattern(Strr):\n\tres = ''\n\tstack = []\n\tfor i in range(len(Strr) + 1):\n\t\tstack.append(i + 1)\n\t\tif (i == len(Strr) or Strr[i] == 'I'):\n\t\t\twhile len(stack) > 0:\n\t\t\t\tres += str(stack.pop())\n\t\t\t\tres += ' '\n\tprint(res)", "33": "def getMinNumberForPattern(seq):\n\tn = len(seq)\n\tif (n >= 9):\n\t\treturn \"-1\"\n\tresult = [None] * (n + 1)\n\tcount = 1\n\tfor i in range(n + 1):\n\t\tif (i == n or seq[i] == 'I'):\n\t\t\tfor j in range(i - 1, -2, -1):\n\t\t\t\tresult[j + 1] = int('0' + str(count))\n\t\t\t\tcount += 1\n\t\t\t\tif(j >= 0 and seq[j] == 'I'):\n\t\t\t\t\tbreak\n\treturn result", "34": "def subset(ar, n):\n\tres = 0\n\tar.sort()\n\tfor i in range(0, n) :\n\t\tcount = 1\n\t\tfor i in range(n - 1):\n\t\t\tif ar[i] == ar[i + 1]:\n\t\t\t\tcount+=1\n\t\t\telse:\n\t\t\t\tbreak\n\t\tres = max(res, count)\n\treturn res", "35": "def subset(arr, n):\n\tmp = {i:0 for i in range(10)}\n\tfor i in range(n):\n\t\tmp[arr[i]] += 1\n\tres = 0\n\tfor key, value in mp.items():\n\t\tres = max(res, value)\n\treturn res", "36": "def areElementsContiguous(arr, n):\n\tarr.sort()\n\tfor i in range(1,n):\n\t\tif (arr[i] - arr[i-1] > 1) :\n\t\t\treturn 0\n\treturn 1", "37": "def areElementsContiguous(arr, n):\n\tmax1 = max(arr)\n\tmin1 = min(arr)\n\tm = max1 - min1 + 1\n\tif (m > n):\n\t\treturn False\n\tvisited = [0] * m\n\tfor i in range(0,n) :\n\t\tvisited[arr[i] - min1] = True\n\tfor i in range(0, m):\n\t\tif (visited[i] == False):\n\t\t\treturn False\n\treturn True", "38": "def areElementsContiguous(arr):\n\tus = set()\n\tfor i in arr: us.add(i)\n\tcount = 1\n\tcurr_ele = arr[0] - 1\n\twhile curr_ele in us:\n\t\tcount += 1\n\t\tcurr_ele -= 1\n\tcurr_ele = arr[0] + 1\n\twhile curr_ele in us:\n\t\tcount += 1\n\t\tcurr_ele += 1\n\treturn (count == len(us))", "39": "def longest(a, n, k):\n\tfreq = collections.defaultdict(int)\n\tstart = 0\n\tend = 0\n\tnow = 0\n\tl = 0\n\tfor i in range(n):\n\t\tfreq[a[i]] += 1\n\t\tif (freq[a[i]] == 1):\n\t\t\tnow += 1\n\t\twhile (now > k) :\n\t\t\tfreq[a[l]] -= 1\n\t\t\tif (freq[a[l]] == 0):\n\t\t\t\tnow -= 1\n\t\t\tl += 1\n\t\tif (i - l + 1 >= end - start + 1):\n\t\t\tend = i\n\t\t\tstart = l\n\tfor i in range(start, end + 1):\n\t\tprint(a[i], end = \" \")", "40": "def findSmallestRange(arr, n, k):\n\ti, minval, maxval, minrange, minel, maxel, flag, minind = 0, 0, 0, 0, 0, 0, 0, 0\n\tfor i in range(k + 1):\n\t\tptr[i] = 0\n\tminrange = 10**9\n\twhile(1): \n\t\tminind = -1\n\t\tminval = 10**9\n\t\tmaxval = -10**9\n\t\tflag = 0\n\t\tfor i in range(k):\n\t\t\tif(ptr[i] == n):\n\t\t\t\tflag = 1 \n\t\t\t\tbreak\n\t\t\tif(ptr[i] < n and arr[i][ptr[i]] < minval):\n\t\t\t\tminind = i \n\t\t\t\tminval = arr[i][ptr[i]]\n\t\t\tif(ptr[i] < n and arr[i][ptr[i]] > maxval):\n\t\t\t\tmaxval = arr[i][ptr[i]]\n\t\tif(flag):\n\t\t\tbreak\n\t\tptr[minind] += 1\n\t\tif((maxval-minval) < minrange):\n\t\t\tminel = minval\n\t\t\tmaxel = maxval\n\t\t\tminrange = maxel - minel\n\tprint(\"The smallest range is [\", minel, maxel, \"]\")", "41": "def findLargestd(S, n) :\n\tfound = False\n\tS.sort()\n\tfor i in range(n-1, -1, -1) :\n\t\tfor j in range(0, n) :\n\t\t\tif (i == j) :\n\t\t\t\tcontinue\n\t\t\tfor k in range(j + 1, n) :\n\t\t\t\tif (i == k) :\n\t\t\t\t\tcontinue\n\t\t\t\tfor l in range(k+1, n) :\n\t\t\t\t\tif (i == l) :\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tif (S[i] == S[j] + S[k] + S[l]) :\n\t\t\t\t\t\tfound = True\n\t\t\t\t\t\treturn S[i]\t\t\t\t\n\tif (found == False) :\n\t\treturn -1", "42": "def findFourElements(arr, n):\n\tmp = dict()\n\tfor i in range(n - 1):\n\t\tfor j in range(i + 1, n):\n\t\t\tmp[arr[i] + arr[j]] =(i, j)\n\td = -10**9\n\tfor i in range(n - 1):\n\t\tfor j in range(i + 1, n):\n\t\t\tabs_diff = abs(arr[i] - arr[j])\n\t\t\tif abs_diff in mp.keys():\n\t\t\t\tp = mp[abs_diff]\n\t\t\t\tif (p[0] != i and p[0] != j and p[1] != i and p[1] != j):\n\t\t\t\t\td = max(d, max(arr[i], arr[j]))\n\treturn d", "43": "def leftRotatebyOne(arr, n):\n\ttemp = arr[0]\n\tfor i in range(n-1):\n\t\tarr[i] = arr[i + 1]\n\tarr[n-1] = temp\ndef leftRotate(arr, d, n):\n\tfor i in range(d):\n\t\tleftRotatebyOne(arr, n)\ndef printArray(arr, size):\n\tfor i in range(size):\n\t\tprint (\"% d\"% arr[i], end =\" \")", "44": "def pushZerosToEnd(arr, n):\n        count = 0 \n        for i in range(n):\n                if arr[i] != 0:\n                        arr[count] = arr[i]\n                        count+=1\n        while count < n:\n                arr[count] = 0\n                count += 1", "45": "def moveZerosToEnd (arr, n):\n\tcount = 0;\n\tfor i in range(0, n):\n\t\tif (arr[i] != 0):\n\t\t\tarr[count], arr[i] = arr[i], arr[count]\n\t\t\tcount+=1\ndef printArray(arr, n):\n\tfor i in range(0, n):\n\t\tprint(arr[i],end=\" \")", "46": "def pushZerosToEnd(arr, n):\n\tcount = 0\n\tfor i in range(0, n):\n\t\tif arr[i] != 0:\n\t\t\tarr[count] = arr[i]\n\t\t\tcount+=1\n\twhile (count < n):\n\t\tarr[count] = 0\n\t\tcount+=1\ndef modifyAndRearrangeArr(ar, n):\n\tif n == 1:\n\t\treturn\n\tfor i in range(0, n - 1):\n\t\tif (arr[i] != 0) and (arr[i] == arr[i + 1]):\n\t\t\tarr[i] = 2 * arr[i]\n\t\t\tarr[i + 1] = 0\n\t\t\ti+=1\n\tpushZerosToEnd(arr, n)\ndef printArray(arr, n):\n\tfor i in range(0, n):\n\t\tprint(arr[i],end=\" \")", "47": "def shiftAllZeroToLeft(arr, n):\n\tlastSeenNonZero = 0\n\tfor index in range(0, n):\n\t\tif (array[index] != 0):\n\t\t\tarray[index], array[lastSeenNonZero] = array[lastSeenNonZero], array[index]\n\t\t\tlastSeenNonZero+=1", "48": "def printArray(arr, n):\n\tfor i in range(n):\n\t\tprint(arr[i], end = \" \")\n\tprint()\ndef RearrangePosNeg(arr, n):\n\tfor i in range(1, n):\n\t\tkey = arr[i]\n\t\tif (key > 0):\n\t\t\tcontinue\n\t\tj = i - 1\n\t\twhile (j >= 0 and arr[j] > 0):\n\t\t\tarr[j + 1] = arr[j]\n\t\t\tj = j - 1\n\t\tarr[j + 1] = key"}, "Java": {"0": "public int minCost(int[][] cost) {\n        int N = cost[0].length;\n        int[] tdist = new int[N];\n        for (int i = 0; i < N; i++) {\n                tdist[i] = Integer.MAX_VALUE;\n        }\n        tdist[0] = 0;\n        for (int i = 0; i < N; i++) {\n                for (int j = i + 1; j < N; j++) {\n                        if (tdist[j] > tdist[i] + cost[i][j]) {\n                                tdist[j] = tdist[i] + cost[i][j];\n                        }\n                }\n        }\n        return tdist[N - 1];\n}", "1": "public static double numOfways(int n, int k) {\n        double p = 1;\n        if ((k % 2) == 1) {\n                p = -1;\n        }\n        return (Math.pow(n - 1, k) +\n                                p * (n - 1)) / n;\n}", "2": "public class Assignment2 {\n\t\n\tpublic static void fib(int n) {\n\t\tif (n <= 1) {\n\t\t\treturn n;\n\t\t}\n\t\treturn fib(n - 1) + fib(n - 2);\n\t}\n\t\n\tpublic static void findVertices(int n) {\n\t\treturn fib(n + 2) - 1;\n\t}\n\n}", "3": "class Node:\n\tdef __init__(self, next = None, prev = None, data = None):\n\t\tself.next = next\n\t\tself.prev = prev\n\t\tself.data = data\n\nhead = None\nhead = push(head, 2);\nhead = push(head, 4);\nhead = push(head, 8);\nhead = push(head, 10);\nprint(\"Linked list before sorting: \")\nprintList(head)\nhead = sort(head)\nprint(\"Linked list after sorting: \")\nprintList(head)", "4": "public class LinkedList {\n        public Node head;\n        public LinkedList() {\n                this.head = null;\n        }\n        public class Node {\n                public char data;\n                public Node next;\n                public Node(char x) {\n                        this.data = x;\n                        this.next = null;\n                }\n        }\n        public void printlist(Node head) {\n                if (not head) {\n                        System.out.println(\"Empty List\");\n                        return;\n                }\n                while (head != null) {\n                        System.out.print(head.data + \" \");\n                        if (head.next) {\n                                System.out.print(end = \"-> \");\n                        }\n                        head = head.next;\n                }\n                System.out.println();\n        }\n        public boolean isVowel(char x) {\n                return (x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u' || x == 'A' || x == 'E' || x == 'I' || x == 'O' || x == 'U');\n        }\n        public Node arrange(Node head) {\n                Node newHead = head;\n                Node latestVowel = null;\n                Node curr = head;\n                if (head == null) {\n                        return null;\n                }\n                if (isVowel(head.data)) {\n                        latestVowel = head;\n                } else {\n                        while (curr.next != null &&\n                                !isVowel(curr.next.data)) {\n                                curr = curr.next;\n                        }\n                        if (curr.next == null) {\n                                return head;\n                        }\n                        latestVowel = newHead = curr.next;\n                        curr.next = curr.next.next;\n                        latestVowel.next = head;\n                }\n                while (curr != null && curr.next != null) {\n                        if (isVowel(curr.next.data)) {\n                                if (curr == latestVowel) {\n                                        latestVowel = curr = curr.next;\n                                } else {\n                                        Node temp = latestVowel.next;\n                                        latestVowel.next = curr.next;\n                                        latestVowel = latestVowel.next;\n                                        curr.next = curr.next.next;\n                                        latestVowel.next = temp;\n                                }\n                        } else {\n                                curr = curr.next;\n                        }\n                }\n                return newHead;\n        }\n}", "5": "class TreeNode {\n        int data;\n        TreeNode right;\n        TreeNode left;\n\n        public TreeNode(int data) {\n                this.data = data;\n                this.right = this.left = null;\n        }\n}\n\npublic static TreeNode KthLargestUsingMorrisTraversal(TreeNode root, int k) {\n        TreeNode curr = root;\n        TreeNode Klargest = null;\n        int count = 0;\n        while (curr != null) {\n                if (curr.right == null) {\n                        count += 1;\n                        if (count == k) {\n                                Klargest = curr;\n                        }\n                        curr = curr.left;\n                } else {\n                        TreeNode succ = curr.right;\n                        while (succ.left != null && succ.left != curr) {\n                                succ = succ.left;\n                        }\n                        if (succ.left == null) {\n                                succ.left = curr;\n                                curr = curr.right;\n                        } else {\n                                succ.left = null;\n                                count += 1;\n                                if (count == k) {\n                                        Klargest = curr;\n                                }\n                                curr = curr.left;\n                        }\n                }\n        }\n        return Klargest;\n}", "6": "public class GFG { \n    \n    static void sortByRow(int mat[][], int n, \n                                boolean ascending) \n    { \n        for (int i = 0; i < n; i++) { \n            if (ascending) \n                Arrays.sort(mat[i]); \n            else\n                Arrays.sort(mat[i], Collections.reverseOrder()); \n        } \n    } \n    static void transpose(int mat[][], int n) \n    { \n        for (int i = 0; i < n; i++) { \n            for (int j = i + 1; j < n; j++) { \n                int temp = mat[i][j]; \n                mat[i][j] = mat[j][i]; \n                mat[j][i] = temp; \n            } \n        } \n    } \n    static void sortMatRowAndColWise(int mat[][], int n) \n    { \n        sortByRow(mat, n, true); \n        transpose(mat, n); \n        sortByRow(mat, n, false); \n        transpose(mat, n); \n    } \n    static void printMat(int mat[][], int n) \n    { \n        for (int i = 0; i < n; i++) { \n            for (int j = 0; j < n; j++) { \n                System.out.print(mat[i][j] + \" \"); \n            } \n            System.out.println(); \n        } \n    } \n    public static void main(String[] args) \n    { \n        int mat[][] = { { 9, 6, 5, 2 }, \n                        { 8, 7, 2, 1 }, \n                        { 5, 4, 0, 2 }, \n                        { 1, 3, 4, 5 } }; \n        int n = mat.length; \n        sortMatRowAndColWise(mat, n); \n        printMat(mat, n); \n    } \n}", "7": "sortMatRowAndColWise(mat, n)\nprintMat(mat, n)\n\npublic class Main {\n    public static void sortByRow(int[][] mat, int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - 1; j++) {\n                if (mat[i][j] > mat[i][j + 1]) {\n                    int temp = mat[i][j];\n                    mat[i][j] = mat[i][j + 1];\n                    mat[i][j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    public static void transpose(int[][] mat, int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int t = mat[i][j];\n                mat[i][j] = mat[j][i];\n                mat[j][i] = t;\n            }\n        }\n    }\n\n    public static void sortMatRowAndColWise(int[][] mat, int n) {\n        sortByRow(mat, n);\n        transpose(mat, n);\n        sortByRow(mat, n);\n        transpose(mat, n);\n    }\n\n    public static void printMat(int[][] mat, int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                System.out.print(mat[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = 3;\n        int[][] mat = {{6, 4, 3}, {5, 8, 1}, {7, 2, 9}};\n        sortMatRowAndColWise(mat, n);\n        printMat(mat, n);\n    }\n}", "8": "public class DoublyEven {\n        public static void main(String[] args) {\n                int n = 8;\n                int[][] arr = new int[n][n];\n                for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < n; j++) {\n                                arr[i][j] = (n * y) + x + 1;\n                        }\n                }\n                for (int i = 0; i < n / 4; i++) {\n                        for (int j = 0; j < n / 4; j++) {\n                                arr[i][j] = (n * n + 1) - arr[i][j];\n                        }\n                }\n                for (int i = 0; i < n / 4; i++) {\n                        for (int j = 3 * (n / 4); j < n; j++) {\n                                arr[i][j] = (n * n + 1) - arr[i][j];\n                        }\n                }\n                for (int i = 3 * (n / 4); i < n; i++) {\n                        for (int j = 0; j < n / 4; j++) {\n                                arr[i][j] = (n * n + 1) - arr[i][j];\n                        }\n                }\n                for (int i = 3 * (n / 4); i < n; i++) {\n                        for (int j = 3 * (n / 4); j < n; j++) {\n                                arr[i][j] = (n * n + 1) - arr[i][j];\n                        }\n                }\n                for (int i = n / 4; i < 3 * (n / 4); i++) {\n                        for (int j = n / 4; j < 3 * (n / 4); j++) {\n                                arr[i][j] = (n * n + 1) - arr[i][j];\n                        }\n                }\n                for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < n; j++) {\n                                System.out.print(arr[i][j] + \" \");\n                        }\n                        System.out.println();\n                }\n        }\n}", "9": "public class Kroneckerproduct {\n\tpublic static void main(String[] args) {\n\t\tint A[][] = {{1,2,3},{4,5,6}};\n\t\tint B[][] = {{7,8},{9,10},{11,12}};\n\t\tint rowa = A.length;\n\t\tint rowb = B.length;\n\t\tint cola = A[0].length;\n\t\tint colb = B[0].length;\n\t\tint C[][] = new int[rowa*rowb][cola*colb];\n\t\tfor(int i=0;i<rowa;i++) {\n\t\t\tfor(int k=0;k<rowb;k++) {\n\t\t\t\tfor(int j=0;j<cola;j++) {\n\t\t\t\t\tfor(int l=0;l<colb;l++) {\n\t\t\t\t\t\tC[i+l+1][j+k+1] = A[i][j] * B[k][l];\n\t\t\t\t\t\tSystem.out.print(C[i+l+1][j+k+1] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "10": "public boolean islowertriangular(int[][] M) {\n\t\tfor(int i = 0; i < M.length; i++) {\n\t\t\tfor(int j = i + 1; j < M[0].length; j++) {\n\t\t\t\tif(M[i][j] != 0) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n}", "11": "public static boolean isUpperTriangular(int[][] M) {\n\tfor (int i = 1; i < M.length; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (M[i][j] != 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "12": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ta[i][j] = in.nextInt();\n\t\t\t}\n\t\t}\n\t\tint res = countSets(a);\n\t\tSystem.out.println(res);\n\t\tin.close();\n\t}\n\t\n\tpublic static int countSets(int[][] a) {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint u = 0;\n\t\t\tint v = 0;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (a[i][j] == 1) {\n\t\t\t\t\tu += 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = 0;\n\t\t\tint v = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (a[j][i] == 1) {\n\t\t\t\t\tu += 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n\t\t}\n\t\treturn res - (n*m);\n\t}\n}", "13": "public static void transpose(int[][] mat, int[][] tr, int N) {\n        for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                        tr[i][j] = mat[j][i];\n                }\n        }\n}\npublic static boolean isSymmetric(int[][] mat, int N) {\n        int[][] tr = new int[mat.length][mat[0].length];\n        transpose(mat, tr, N);\n        for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                        if (mat[i][j] != tr[i][j]) {\n                                return false;\n                        }\n                }\n        }\n        return true;\n}", "14": "public boolean isSymmetric(int[][] mat, int N) {\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (mat[i][j] != mat[j][i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "15": "public static int findNormal(int[][] mat, int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tsum += mat[i][j] * mat[i][j]; \n\treturn (int)Math.floor(Math.sqrt(sum)); \n} \npublic static int findTrace(int[][] mat, int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tsum += mat[i][i]; \n\treturn sum; \n}", "16": "public class MaxDet {\n\tpublic static void maxDet(int n) {\n\t\treturn 2 * n * n * n;\n\t}\n\tpublic static void resMatrix(int n) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tif (i == 0 && j == 2) {\n\t\t\t\t\tSystem.out.print(\"0\" + \" \");\n\t\t\t\t}\n\t\t\t\telse if (i == 1 && j == 0) {\n\t\t\t\t\tSystem.out.print(\"0\" + \" \");\n\t\t\t\t}\n\t\t\t\telse if (i == 2 && j == 1) {\n\t\t\t\t\tSystem.out.print(\"0\" + \" \");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.print(n + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}", "17": "public static int countNegative(int[][] M, int n, int m){\n\tint count = 0;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif(M[i][j] < 0){\n\t\t\t\tcount ++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "18": "public static int countNegative(int[][] M, int n, int m) {\n\tint count = 0;\n\tint i = 0;\n\tint j = m - 1;\n\twhile (j >= 0 && i < n) {\n\t\tif (M[i][j] < 0) {\n\t\t\tcount += (j + 1);\n\t\t\ti += 1;\n\t\t} else {\n\t\t\tj -= 1;\n\t\t}\n\t}\n\treturn count;\n}", "19": "public static int getLastNegativeIndex(int[] array, int start, int end, int n) {\n\tif (start == end) {\n\t\treturn start;\n\t}\n\tint mid = start + (end - start) / 2;\n\tif (array[mid] < 0) {\n\t\tif (mid + 1 < n && array[mid + 1] >= 0) {\n\t\t\treturn mid;\n\t\t}\n\t\treturn getLastNegativeIndex(array, mid + 1, end, n);\n\t} else {\n\t\treturn getLastNegativeIndex(array, start, mid - 1, n);\n\t}\n}\npublic static int countNegative(int[][] M, int n, int m) {\n\tint count = 0;\n\tint nextEnd = m - 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (M[i][0] >= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tnextEnd = getLastNegativeIndex(M[i], 0, nextEnd, 4);\n\t\tcount += nextEnd + 1;\n\t}\n\treturn count;\n}", "20": "public static int findMaxValue(int mat[][]) {\n    int maxValue = 0;\n    for (int a = 0; a < N - 1; a++) {\n        for (int b = 0; b < N - 1; b++) {\n            for (int d = a + 1; d < N; d++) {\n                for (int e = b + 1; e < N; e++) {\n                    if (maxValue < mat[d][e] - mat[a][b]) {\n                        maxValue = mat[d][e] - mat[a][b];\n                    }\n                }\n            }\n        }\n    }\n    return maxValue;\n}", "21": "public static int findMaxValue(int[][] mat) {\n        int maxValue = -Integer.MAX_VALUE;\n        int maxArr[][] = new int[N][N];\n        maxArr[N - 1][N - 1] = mat[N - 1][N - 1];\n        int maxv = mat[N - 1][N - 1];\n        for (int j = N - 2; j >= 0; j--) {\n                if (mat[N - 1][j] > maxv) {\n                        maxv = mat[N - 1][j];\n                }\n                maxArr[N - 1][j] = maxv;\n        }\n        maxv = mat[N - 1][N - 1];\n        for (int i = N - 2; i >= 0; i--) {\n                if (mat[i][N - 1] > maxv) {\n                        maxv = mat[i][N - 1];\n                }\n                maxArr[i][N - 1] = maxv;\n        }\n        for (int i = N - 2; i >= 0; i--) {\n                for (int j = N - 2; j >= 0; j--) {\n                        if (maxArr[i + 1][j + 1] - mat[i][j] > maxValue) {\n                                maxValue = (maxArr[i + 1][j + 1] - mat[i][j]);\n                        }\n                        maxArr[i][j] = Math.max(mat[i][j],\n                                                Math.max(maxArr[i][j + 1], maxArr[i + 1][j]));\n                }\n        }\n        return maxValue;\n}", "22": "mat = [[10, 20, 30, 40],\n                [15, 25, 35, 45],\n                [27, 29, 37, 48],\n                [32, 33, 39, 50]]\nN = 4\nprintSorted(mat)", "23": "public static void printSumSimple(int[][] mat, int k) {\n\tif (k > n)\n\t\treturn;\n\tfor (int i = 0; i < n - k + 1; i++) {\n\t\tfor (int j = 0; i < n - k + 1; j++) {\n\t\t\tint sum = 0;\n\t\t\tfor (p = i; p < k + i; p++) {\n\t\t\t\tfor (q = j; q < k + j; q++) {\n\t\t\t\t\tsum += mat[p][q];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(sum + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "24": "def printSumTricky(mat, k):\n        n = mat.length;\n        if (k > n):\n                return;\n        stripSum = new int[n][n];\n        for (int j = 0; j < n; j++) {\n                int Sum = 0;\n                for (int i = 0; i < k; i++) {\n                        Sum += mat[i][j];\n                }\n                stripSum[0][j] = Sum;\n                for (int i = 1; i < (n - k + 1); i++) {\n                        Sum += (mat[i + k - 1][j] - mat[i - 1][j]);\n                        stripSum[i][j] = Sum;\n                }\n        }\n        for (int i = 0; i < (n - k + 1); i++) {\n                int Sum = 0;\n                for (int j = 0; j < k; j++) {\n                        Sum += stripSum[i][j];\n                }\n                System.out.print(Sum + \" \");\n                for (int j = 1; j < (n - k + 1); j++) {\n                        Sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n                        System.out.print(Sum + \" \");\n                }\n                System.out.println();\n        }\n}", "25": "int[][] transpose(int[][] A, int[][] B) {\n        for(int i = 0; i < N; i++) {\n                for(int j = 0; j < M; j++) {\n                        B[i][j] = A[j][i];\n                }\n        }\n}", "26": "public static void transpose(int[][] A) {\n        int N = A.length;\n        for (int i = 0; i < N; i++) {\n                for (int j = i+1; j < N; j++) {\n                        int temp = A[i][j];\n                        A[i][j] = A[j][i];\n                        A[j][i] = temp;\n                }\n        }\n}", "27": "public static int pathCountRec(int[][] mat, int m, int n, int k) {\n        if (m < 0 || n < 0)\n                return 0;\n        else if (m == 0 && n == 0)\n                return k == mat[m][n] ? 1 : 0;\n        return pathCountRec(mat, m-1, n, k-mat[m][n])\n                + pathCountRec(mat, m, n-1, k-mat[m][n]);\n}\npublic static int pathCount(int[][] mat, int k) {\n        return pathCountRec(mat, mat.length-1, mat[0].length-1, k);\n}", "28": "public class Main {\n        \n        public static int R = 4;\n        public static int C = 4;\n        public static int[][][] dp = new int[R][C][12];\n\n        public static void main(String[] args) {\n                for (int[][] arr : dp) {\n                        for (int[] row : arr) {\n                                Arrays.fill(row, -1);\n                        }\n                }\n                int[][] mat = { { 1, 1, 1, 1 },\n                                                { 1, 1, 0, 1 },\n                                                { 1, 1, 0, 1 },\n                                                { 1, 1, 1, 1 } };\n                System.out.println(pathCountDP(mat, 11));\n        }\n}", "29": "public static int countMinReversals(String expr) {\n\tint lenn = expr.length();\n\tif (lenn % 2) {\n\t\treturn -1;\n\t}\n\tStack<String> s = new Stack<String>();\n\tfor (int i = 0; i < lenn; i++) {\n\t\tif (expr.charAt(i) =='' && !s.isEmpty()) {\n\t\t\tif (s.peek() == '') {\n\t\t\t\ts.pop();\n\t\t\t} else {\n\t\t\t\ts.push(expr.charAt(i));\n\t\t\t}\n\t\t} else {\n\t\t\ts.push(expr.charAt(i));\n\t\t}\n\t}\n\tint red_len = s.size();\n\tint n = 0;\n\twhile (!s.isEmpty() && s.peek() == '') {\n\t\ts.pop();\n\t\tn += 1;\n\t}\n\treturn (red_len / 2 + n % 2);\n}", "30": "public static void PrintMinNumberForPattern(String[] arr) {\n\t\tint curr_max = 0;\n\t\tint last_entry = 0;\n\t\tint i = 0;\n\t\twhile (i < arr.length) {\n\t\t\tint noOfNextD = 0;\n\t\t\tif (arr[i].equals(\"I\")) {\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile (j < arr.length && arr[j].equals(\"D\")) {\n\t\t\t\t\tnoOfNextD += 1;\n\t\t\t\t\tj += 1;\n\t\t\t\t}\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\t\tlast_entry += 1;\n\t\t\t\t\tSystem.out.print(\"\" + last_entry);\n\t\t\t\t\tSystem.out.print(\"\" + curr_max);\n\t\t\t\t\tlast_entry = curr_max;\n\t\t\t\t} else {\n\t\t\t\t\tcurr_max += noOfNextD + 1;\n\t\t\t\t\tlast_entry = curr_max;\n\t\t\t\t\tSystem.out.print(\"\" + last_entry);\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < noOfNextD; k++) {\n\t\t\t\t\tlast_entry -= 1;\n\t\t\t\t\tSystem.out.print(\"\" + last_entry);\n\t\t\t\t\ti += 1;\n\t\t\t\t}\n\t\t\t} else if (arr[i].equals(\"D\")) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tint j = i + 1;\n\t\t\t\t\twhile (j < arr.length && arr[j].equals(\"D\")) {\n\t\t\t\t\t\tnoOfNextD += 1;\n\t\t\t\t\t\tj += 1;\n\t\t\t\t\t}\n\t\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\t\tSystem.out.print(\"\" + curr_max + (curr_max - 1));\n\t\t\t\t\tlast_entry = curr_max - 1;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(\"\" + (last_entry - 1));\n\t\t\t\t\tlast_entry -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += 1;\n\t\t}\n\t\tSystem.out.println();\n\t}", "31": "public void printLeast(char[] arr) {\n\tint min_avail = 1;\n\tint pos_of_I = 0;\n\tList<Integer> v = new ArrayList<Integer>();\n\tif (arr[0] == 'I') {\n\t\tv.add(1);\n\t\tv.add(2);\n\t\tmin_avail = 3;\n\t\tpos_of_I = 1;\n\t} else {\n\t\tv.add(2);\n\t\tv.add(1);\n\t\tmin_avail = 3;\n\t\tpos_of_I = 0;\n\t}\n\tfor (int i = 1; i < arr.length; i++) {\n\t\tif (arr[i] == 'I') {\n\t\t\tv.add(min_avail);\n\t\t\tmin_avail += 1;\n\t\t\tpos_of_I = i + 1;\n\t\t} else {\n\t\t\tv.add(v[i]);\n\t\t\tfor (int j = pos_of_I; j < i + 1; j++) {\n\t\t\t\tv[j] += 1;\n\t\t\t}\n\t\t\tmin_avail += 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tSystem.out.print(v.get(i) + \" \");\n\t}\n}", "32": "public static void PrintMinNumberForPattern(String str) {\n\tString res = \"\";\n\tStack<Integer> stack = new Stack<>();\n\tfor (int i = 0; i <= str.length(); i++) {\n\t\tstack.push(i + 1);\n\t\tif (i == str.length() || str.charAt(i) == 'I') {\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tres += stack.pop();\n\t\t\t\tres += \" \";\n\t\t\t}\n\t\t}\n\t}\n\tSystem.out.println(res);\n}", "33": "public static int[] getMinNumberForPattern(String seq) {\n\tint n = seq.length();\n\tif (n >= 9) {\n\t\treturn new int[1];\n\t}\n\tint[] result = new int[n + 1];\n\tint count = 1;\n\tfor (int i = 0; i < n + 1; i++) {\n\t\tif (i == n || seq.charAt(i) == 'I') {\n\t\t\tfor (int j = i - 1; j >= -2; j--) {\n\t\t\t\tresult[j + 1] = count;\n\t\t\t\tcount++;\n\t\t\t\tif (j >= 0 && seq.charAt(j) == 'I') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "34": "public static int subset(int[] ar, int n) {\n\tint res = 0;\n\tArrays.sort(ar);\n\tfor (int i = 0; i < n; i++) {\n\t\tint count = 1;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif (ar[i] == ar[i + 1]) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = Math.max(res, count);\n\t}\n\treturn res;\n}", "35": "public static int subset(int[] arr, int n) {\n\tMap<Integer,Integer> mp = new HashMap<>();\n\tfor (int i = 0; i < n; i++) {\n\t\tmp.put(arr[i], mp.getOrDefault(arr[i], 0) + 1);\n\t}\n\tint res = 0;\n\tfor (int key : mp.keySet()) {\n\t\tres = Math.max(res, mp.get(key));\n\t}\n\treturn res;\n}", "36": "public static boolean areElementsContiguous(int arr[], int n) \n    { \n        Arrays.sort(arr); \n  \n        for (int i = 1; i < n; i++) \n            if (arr[i] - arr[i - 1] > 1) \n                return false; \n  \n        return true; \n    }", "37": "public static boolean areElementsContiguous(int[] arr, int n) {\n\tint max1 = Arrays.stream(arr).max().getAsInt();\n\tint min1 = Arrays.stream(arr).min().getAsInt();\n\tint m = max1 - min1 + 1;\n\tif (m > n) {\n\t\treturn false;\n\t}\n\tboolean[] visited = new boolean[m];\n\tfor (int i = 0; i < n; i++) {\n\t\tvisited[arr[i] - min1] = true;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (visited[i] == false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "38": "public class Test {\n        public static void main(String[] args) {\n                int[] arr = {1, 2, 3, 4, 5};\n                Set<Integer> us = new HashSet<>();\n                for (int i : arr) us.add(i);\n                int count = 1;\n                int curr_ele = arr[0] - 1;\n                while (us.contains(curr_ele)) {\n                        count += 1;\n                        curr_ele -= 1;\n                }\n                curr_ele = arr[0] + 1;\n                while (us.contains(curr_ele)) {\n                        count += 1;\n                        curr_ele += 1;\n                }\n                System.out.println(count == us.size());\n        }\n}", "39": "public class Longest {\n\tpublic static void longest(int[] a, int n, int k) {\n        Map<Integer, Integer> freq = new HashMap<>();\n        int start = 0;\n        int end = 0;\n        int now = 0;\n        int l = 0;\n        for(int i = 0; i < n; i++) {\n            freq.put(a[i], freq.getOrDefault(a[i], 0) + 1);\n            if(freq.get(a[i]) == 1) {\n                now += 1;\n            }\n            while(now > k) {\n                freq.put(a[l], freq.get(a[l]) - 1);\n                if(freq.get(a[l]) == 0) {\n                    now -= 1;\n                }\n                l++;\n            }\n            if(i - l + 1 >= end - start + 1) {\n                end = i;\n                start = l;\n            }\n        }\n        for(int i = start; i <= end; i++) {\n            System.out.print(a[i] + \" \");\n        }\n\t}\n}", "40": "public static void findSmallestRange(int arr[][], int n, int k) \n    { \n        int i, minval, maxval, minrange, minel, maxel, flag, minind; \n        int ptr[] = new int[k]; \n          \n        for(i = 0; i <= k; i++) \n            ptr[i] = 0; \n        minrange = 999999; \n        while(true) \n        { \n            minind = -1; \n            minval = 999999; \n            maxval = -999999; \n            flag = 0; \n            for(i = 0; i < k; i++) \n            { \n                if(ptr[i] == n) \n                { \n                    flag = 1; \n                    break; \n                } \n                if(ptr[i] < n && arr[i][ptr[i]] < minval) \n                { \n                    minind=i; \n                    minval=arr[i][ptr[i]]; \n                } \n                if(ptr[i] < n && arr[i][ptr[i]] > maxval) \n                { \n                    maxval = arr[i][ptr[i]]; \n                } \n            } \n            if(flag == 1) \n                break; \n            ptr[minind]++; \n            if((maxval-minval)<minrange) \n            { \n                minel = minval; \n                maxel = maxval; \n                minrange = maxel-minel; \n            } \n        } \n          \n        System.out.println(\"The smallest range is[\" + minel + \" \" + maxel + \"]\"); \n    }", "41": "public int findLargestd(int[] S, int n) {\n\tboolean found = false;\n\tArrays.sort(S);\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\tif (i == k) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int l = k + 1; l < n; l++) {\n\t\t\t\t\tif (i == l) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (S[i] == S[j] + S[k] + S[l]) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\treturn S[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (found == false) {\n\t\treturn -1;\n\t}\n}", "42": "public class Main\n{\n\tpublic static void main(String[] args) {\n\t\tint []arr = {2, 4, 7, 1, 5, 3};\n\t\tSystem.out.println(findFourElements(arr, arr.length));\n\t}\n\tpublic static int findFourElements(int []arr, int n) {\n\t\tHashMap<Integer, Integer[]> mp = new HashMap<>();\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tmp.put(arr[i] + arr[j], new Integer[] {i, j});\n\t\t\t}\n\t\t}\n\t\tint d = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint abs_diff = Math.abs(arr[i] - arr[j]);\n\t\t\t\tif (mp.containsKey(abs_diff)) {\n\t\t\t\t\tInteger []p = mp.get(abs_diff);\n\t\t\t\t\tif (!(p[0] == i && p[1] == j) && !(p[0] == j && p[1] == i)) {\n\t\t\t\t\t\td = Math.max(d, Math.max(arr[i], arr[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n}", "43": "public static void leftRotatebyOne(int arr[], int n) {\n\tint temp = arr[0], i;\n\tfor(i = 0; i < n-1; i++) {\n\t\tarr[i] = arr[i+1];\n\t}\n\tarr[n-1] = temp;\n}\n\npublic static void leftRotate(int arr[], int d, int n) {\n\tint i;\n\tfor(i = 0; i < d; i++) {\n\t\tleftRotatebyOne(arr, n);\n\t}\n}\n\npublic static void printArray(int arr[], int n) {\n\tfor(int i = 0; i < n; i++) {\n\t\tSystem.out.print(arr[i] + \" \");\n\t}\n}", "44": "public static void pushZerosToEnd(int[] arr, int n) {\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n                if (arr[i] != 0) {\n                        arr[count] = arr[i];\n                        count++;\n                }\n        }\n        while (count < n) {\n                arr[count] = 0;\n                count++;\n        }\n\n}", "45": "public class Geeks {\n\n\tpublic static void moveZerosToEnd(int arr[], int n) {\n\t\tint count = 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i] != 0) {\n\t\t\t\tarr[count] = arr[i];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\twhile (count < n)\n\t\t\tarr[count++] = 0;\n\t}\n\n\tpublic static void printArray(int arr[], int n) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tint arr[] = { 1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9 };\n\t\tint n = arr.length;\n\t\tmoveZerosToEnd(arr, n);\n\t\tprintArray(arr, n);\n\t}\n}", "46": "public void pushZerosToEnd(int[] arr, int n) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i] != 0) {\n\t\t\t\tarr[count] = arr[i];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\twhile (count < n) {\n\t\t\tarr[count] = 0;\n\t\t\tcount++;\n\t\t}\n\t}\n\tpublic void modifyAndRearrangeArr(int[] ar, int n) {\n\t\tif (n == 1) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif ((arr[i] != 0) && (arr[i] == arr[i + 1])) {\n\t\t\t\tarr[i] = 2 * arr[i];\n\t\t\t\tarr[i + 1] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tpushZerosToEnd(arr, n);\n\t}\n\tpublic void printArray(int[] arr, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t}", "47": "public void shiftAllZeroToLeft(int[] arr, int n) {\n\tint lastSeenNonZero = 0;\n\tfor(int index = 0; index < n; index++) {\n\t\tif(array[index] != 0) {\n\t\t\tarray[index] = array[lastSeenNonZero];\n\t\t\tarray[lastSeenNonZero] = 0;\n\t\t\tlastSeenNonZero++;\n\t\t}\n\t}\n}", "48": "public class Main {\n\n    public static void printArray(int arr[], int n) {\n        for (int i = 0; i < n; ++i) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void RearrangePosNeg(int arr[], int n) {\n        for (int i = 1; i < n; ++i) {\n            int key = arr[i];\n            if (key > 0) {\n                continue;\n            }\n            int j = i - 1;\n            while (j >= 0 && arr[j] > 0) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n\n    public static void main(String[] args) {\n        int arr[] = { 12, 11, -13, -5, 6, 7, 5, -3, -6 };\n        int n = arr.length;\n\n        System.out.print(\"Given array is \\n\");\n        printArray(arr, n);\n\n        RearrangePosNeg(arr, n);\n\n        System.out.print(\"Rearranged array is \\n\");\n        printArray(arr, n);\n    }\n}"}}, "C++ - Python": {"ID": {"0": 451, "1": 455, "2": 496, "3": 617, "4": 647, "5": 694, "6": 803, "7": 815, "8": 818, "9": 821, "10": 832, "11": 833, "12": 846, "13": 861, "14": 862, "15": 883, "16": 895, "17": 918, "18": 919, "19": 920, "20": 926, "21": 927, "22": 953, "23": 955, "24": 956, "25": 958, "26": 959, "27": 965, "28": 966, "29": 1045, "30": 1064, "31": 1065, "32": 1072, "33": 1073, "34": 1074, "35": 1075, "36": 1132, "37": 1252, "38": 1253, "39": 1344, "40": 1345, "41": 1346, "42": 1366, "43": 1390, "44": 1405, "45": 1406, "46": 1428, "47": 1468, "48": 1469, "49": 1473, "50": 1480, "51": 1481, "52": 1515, "53": 1516, "54": 1517, "55": 1535, "56": 1536, "57": 1537, "58": 1545, "59": 1546, "60": 1590, "61": 1591, "62": 1694, "63": 1695, "64": 1696, "65": 1730, "66": 1795, "67": 1797, "68": 1813, "69": 1847, "70": 1849, "71": 1852, "72": 1853, "73": 1869, "74": 1870, "75": 1871, "76": 1998, "77": 2013, "78": 2024, "79": 2025, "80": 2026, "81": 2079, "82": 2101, "83": 2114, "84": 2117, "85": 2118, "86": 2119, "87": 2120, "88": 2121, "89": 2127, "90": 2129, "91": 2130, "92": 2131, "93": 2132, "94": 2210, "95": 2226, "96": 2243, "97": 2258, "98": 2259, "99": 2281, "100": 2308, "101": 2309, "102": 2310, "103": 2360, "104": 2372, "105": 2379, "106": 2380, "107": 2382, "108": 2437, "109": 2464, "110": 2501, "111": 2502, "112": 2518, "113": 2575, "114": 2578, "115": 2579, "116": 2583, "117": 2615, "118": 2616, "119": 2623, "120": 2673, "121": 2675, "122": 2696, "123": 2697, "124": 2740, "125": 2753, "126": 2773, "127": 2783, "128": 2802, "129": 2804, "130": 2809, "131": 2816, "132": 2818, "133": 2827, "134": 2831, "135": 2832, "136": 2847, "137": 2883, "138": 2892, "139": 2923, "140": 2924, "141": 2940, "142": 2950, "143": 2983, "144": 3003, "145": 3010, "146": 3053, "147": 3096, "148": 3120, "149": 3121, "150": 3128, "151": 3129, "152": 3135, "153": 3176, "154": 3179, "155": 3183, "156": 3198, "157": 3199, "158": 3229, "159": 3234, "160": 3235, "161": 3253, "162": 3270, "163": 3311, "164": 3332, "165": 3337, "166": 3345, "167": 3346, "168": 3374, "169": 3376, "170": 3398, "171": 3417, "172": 3427, "173": 3463, "174": 3464, "175": 3468, "176": 3471, "177": 3487, "178": 3488, "179": 3495, "180": 3503, "181": 3516, "182": 3520, "183": 3531, "184": 3540, "185": 3550, "186": 3555, "187": 3562, "188": 3564, "189": 3567, "190": 3584, "191": 3601, "192": 3605, "193": 3629, "194": 3644, "195": 3664, "196": 3678, "197": 3692, "198": 3704, "199": 3742, "200": 3743, "201": 3752, "202": 3755, "203": 3765, "204": 3773, "205": 3798, "206": 3814, "207": 3822, "208": 3825, "209": 3829, "210": 3871, "211": 3885, "212": 3932, "213": 3967, "214": 4039, "215": 4048, "216": 4052, "217": 4079, "218": 4080, "219": 4081, "220": 4099, "221": 4129, "222": 4155, "223": 4169, "224": 4179, "225": 4185, "226": 4186, "227": 4194, "228": 4197, "229": 4209, "230": 4210, "231": 4219, "232": 4220, "233": 4237, "234": 4238, "235": 4249, "236": 4250, "237": 4256, "238": 4305, "239": 4307, "240": 4310, "241": 4326, "242": 4347, "243": 4354, "244": 4357, "245": 4360, "246": 4362, "247": 4369, "248": 4371, "249": 4378, "250": 4385, "251": 4386, "252": 4392, "253": 4400}, "C++": {"0": "static int minCost(int cost[][])\n\t{\n\t\tint dist[] = new int[N];\n\t\tfor (int i=0; i<N; i++)\n\t\tdist[i] = INF;\n\t\tdist[0] = 0;\n\t\tfor (int i=0; i<N; i++)\n\t\tfor (int j=i+1; j<N; j++)\n\t\t\tif (dist[j] > dist[i] + cost[i][j])\n\t\t\t\tdist[j] = dist[i] + cost[i][j];\n\t\treturn dist[N-1];\n\t}", "1": "static int numOfways(int n, int k)\n\t{\n\t\tint p = 1;\n\t\tif (k % 2 != 0)\n\t\t\tp = -1;\n\t\treturn (int)(Math.pow(n - 1, k)\n\t\t\t\t\t+ p * (n - 1)) / n;\n\t}", "2": "static int fib(int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn n;\n\t\treturn fib(n - 1) + fib(n - 2);\n\t}\nstatic int findVertices (int n)\n\t{\n\t\treturn fib(n + 2);\n\t}", "3": "static Node reverse( Node head_ref)\n{\n\tNode temp = null;\n\tNode current = head_ref;\n\twhile (current != null)\n\t{\n\t\ttemp = current.prev;\n\t\tcurrent.prev = current.next;\n\t\tcurrent.next = temp;\n\t\tcurrent = current.prev;\n\t}\n\tif (temp != null)\n\t\thead_ref = temp.prev;\n\t\treturn head_ref;\n}\nstatic Node merge(Node first, Node second)\n{\n\tif (first == null)\n\t\treturn second;\n\tif (second == null)\n\t\treturn first;\n\tif (first.data < second.data)\n\t{\n\t\tfirst.next = merge(first.next, second);\n\t\tfirst.next.prev = first;\n\t\tfirst.prev = null;\n\t\treturn first;\n\t}\n\telse\n\t{\n\t\tsecond.next = merge(first, second.next);\n\t\tsecond.next.prev = second;\n\t\tsecond.prev = null;\n\t\treturn second;\n\t}\n}\nstatic Node sort(Node head)\n{\n\tif (head == null head.next == null)\n\t\treturn head;\n\tNode current = head.next;\n\twhile (current != null)\n\t{\n\t\tif (current.data < current.prev.data)\n\t\t\tbreak;\n\t\tcurrent = current.next;\n\t}\n\tif (current == null)\n\t\treturn head;\n\tcurrent.prev.next = null;\n\tcurrent.prev = null;\n\tcurrent = reverse(current);\n\treturn merge(head, current);\n}\nstatic Node push( Node head_ref, int new_data)\n{\n\tNode new_node = new Node();\n\tnew_node.data = new_data;\n\tnew_node.prev = null;\n\tnew_node.next = (head_ref);\n\tif ((head_ref) != null)\n\t\t(head_ref).prev = new_node;\n\t(head_ref) = new_node;\n\treturn head_ref;\n}\nstatic void printList( Node head)\n{\n\tif (head == null)\n\t\tSystem.out.println(\"Doubly Linked list empty\");\n\twhile (head != null)\n\t{\n\t\tSystem.out.print(head.data + \" \");\n\t\thead = head.next;\n\t}\n}", "4": "static Node newNode(char key)\n{\n\tNode temp = new Node();\n\ttemp.data = key;\n\ttemp.next = null;\n\treturn temp;\n}\nstatic void printlist(Node head)\n{\n\tif (head == null)\n\t{\n\t\tSystem.out.println(\"Empty List\");\n\t\treturn;\n\t}\n\twhile (head != null)\n\t{\n\t\tSystem.out.print(head.data +\" \");\n\t\tif (head.next != null)\n\t\tSystem.out.print(\"-> \");\n\t\thead = head.next;\n\t}\n\tSystem.out.println();\n}\nstatic boolean isVowel(char x)\n{\n\treturn (x == 'a' x == 'e' x == 'i' x == 'o' x == 'u');\n}\nstatic Node arrange(Node head)\n{\n\tNode newHead = head;\n\tNode latestVowel;\n\tNode curr = head;\n\tif (head == null)\n\t\treturn null;\n\tif (isVowel(head.data) == true)\n\t\tlatestVowel = head;\n\telse\n\t{\n\t\twhile (curr.next != null &&\n\t\t\t!isVowel(curr.next.data))\n\t\t\tcurr = curr.next;\n\t\tif (curr.next == null)\n\t\t\treturn head;\n\t\tlatestVowel = newHead = curr.next;\n\t\tcurr.next = curr.next.next;\n\t\tlatestVowel.next = head;\n\t}\n\twhile (curr != null && curr.next != null)\n\t{\n\t\tif (isVowel(curr.next.data) == true)\n\t\t{\n\t\t\tif (curr == latestVowel)\n\t\t\t{\n\t\t\t\tlatestVowel = curr = curr.next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNode temp = latestVowel.next;\n\t\t\t\tlatestVowel.next = curr.next;\n\t\t\t\tlatestVowel = latestVowel.next;\n\t\t\t\tcurr.next = curr.next.next;\n\t\t\t\tlatestVowel.next = temp;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurr = curr.next;\n\t\t}\n\t}\n\treturn newHead;\n}", "5": "static Node newNode(int data)\n{\n\tNode temp = new Node();\n\ttemp.data = data;\n\ttemp.right = null;\n\ttemp.left = null;\n\treturn temp;\n}\nstatic Node KthLargestUsingMorrisTraversal(Node root, int k)\n{\n\tNode curr = root;\n\tNode Klargest = null;\n\tint count = 0;\n\twhile (curr != null)\n\t{\n\t\tif (curr.right == null)\n\t\t{\n\t\t\tif (++count == k)\n\t\t\t\tKlargest = curr;\n\t\t\tcurr = curr.left;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNode succ = curr.right;\n\t\t\twhile (succ.left != null && succ.left != curr)\n\t\t\t\tsucc = succ.left;\n\t\t\tif (succ.left == null)\n\t\t\t{\n\t\t\t\tsucc.left = curr;\n\t\t\t\tcurr = curr.right;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsucc.left = null;\n\t\t\t\tif (++count == k)\n\t\t\t\t\tKlargest = curr;\n\t\t\t\tcurr = curr.left;\n\t\t\t}\n\t\t}\n\t}\n\treturn Klargest;\n}", "6": "static void sortByRow(Integer mat[][], int n, boolean ascending)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (ascending)\n\t\t\t\tArrays.sort(mat[i]);\n\t\t\telse\n\t\t\t\tArrays.sort(mat[i],Collections.reverseOrder());\n\t\t}\t\n\t}\nstatic void transpose(Integer mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tint temp = mat[i][j];\n\t\t\t\tmat[i][j] = mat[j][i];\n\t\t\t\tmat[j][i] = temp;\n\t\t\t}\n\t}\nstatic void sortMatRowAndColWise(Integer mat[][], int n)\n\t{\n\t\tsortByRow(mat, n, true);\n\t\ttranspose(mat, n);\n\t\tsortByRow(mat, n, false);\n\t\ttranspose(mat, n);\n\t}\nstatic void printMat(Integer mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tSystem.out.print(mat[i][j] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "7": "static void sortByRow(int mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tArrays.sort(mat[i]);\n\t}\nstatic void transpose(int mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\tint temp=mat[i][j];\n\t\t\t\tmat[i][j]=mat[j][i];\n\t\t\t\tmat[j][i]=temp;\n\t\t\t\t}\n\t}\nstatic void sortMatRowAndColWise(int mat[][],int n)\n\t{\n\t\tsortByRow(mat, n);\n\t\ttranspose(mat, n);\n\t\tsortByRow(mat, n);\n\t\ttranspose(mat, n);\n\t}\nstatic void printMat(int mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tSystem.out.print(mat[i][j] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "8": "static void doublyEven(int n)\n\t{\n\t\tint[][] arr = new int[n][n];\n\t\tint i, j;\n\t\tfor ( i = 0; i < n; i++)\n\t\t\tfor ( j = 0; j < n; j++)\n\t\t\t\tarr[i][j] = (n*i) + j + 1;\n\t\tfor ( i = 0; i < n/4; i++)\n\t\t\tfor ( j = 0; j < n/4; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor ( i = 0; i < n/4; i++)\n\t\t\tfor ( j = 3 * (n/4); j < n; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor ( i = 3 * n/4; i < n; i++)\n\t\t\tfor ( j = 0; j < n/4; j++)\n\t\t\t\tarr[i][j] = (n*n+1) - arr[i][j];\n\t\tfor ( i = 3 * n/4; i < n; i++)\n\t\t\tfor ( j = 3 * n/4; j < n; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor ( i = n/4; i < 3 * n/4; i++)\n\t\t\tfor ( j = n/4; j < 3 * n/4; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tfor ( j = 0; j < n; j++)\n\t\t\t\tSystem.out.print(arr[i][j]+\" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "9": "static void Kroneckerproduct(int A[][], int B[][])\n\t{\n\t\tint[][] C= new int[rowa * rowb][cola * colb];\n\t\tfor (int i = 0; i < rowa; i++)\n\t\t{\n\t\t\tfor (int k = 0; k < rowb; k++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < cola; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < colb; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tC[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n\t\t\t\t\t\tSystem.out.print( C[i + l + 1][j + k + 1]+\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}", "10": "boolean isLowerTriangularMatrix(int mat[][])\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\tif (mat[i][j] != 0)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "11": "public static Boolean isUpperTriangularMatrix(int mat[][])\n\t{\n\t\tfor (int i = 1; i < N ; i++)\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tif (mat[i][j] != 0)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "12": "static long countSets(int a[][]) {\n\tlong res = 0;\n\tfor (int i = 0; i < n; i++) {\n\tint u = 0, v = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tif (a[i][j] == 1)\n\t\tu++;\n\t\telse\n\t\tv++;\n\t}\n\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\tint u = 0, v = 0;\n\tfor (int j = 0; j < n; j++) {\n\t\tif (a[j][i] == 1)\n\t\tu++;\n\t\telse\n\t\tv++;\n\t}\n\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n\t}\n\treturn res - (n * m);\n}", "13": "static void transpose(int mat[][], int tr[][], int N)\n{\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\ttr[i][j] = mat[j][i];\n}\nstatic boolean isSymmetric(int mat[][], int N)\n{\n\tint tr[][] = new int[N][MAX];\n\ttranspose(mat, tr, N);\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (mat[i][j] != tr[i][j])\n\t\t\t\treturn false;\n\treturn true;\n}", "14": "static boolean isSymmetric(int mat[][], int N)\n{\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (mat[i][j] != mat[j][i])\n\t\t\t\treturn false;\n\treturn true;\n}", "15": "static int findNormal(int mat[][], int n)\n{\n        int sum = 0;\n        for (int i=0; i<n; i++)\n                for (int j=0; j<n; j++)\n                        sum += mat[i][j]*mat[i][j];\n        return (int)Math.sqrt(sum);\n}\nstatic int findTrace(int mat[][], int n)\n{\n        int sum = 0;\n        for (int i=0; i<n; i++)\n                sum += mat[i][i];\n        return sum;\n}", "16": "static int maxDet(int n)\n{\n        return (2 * n * n * n);\n}\nvoid resMatrix(int n)\n{\n        for (int i = 0; i < 3; i++)\n        {\n                for (int j = 0; j < 3; j++)\n                {\n                        if (i == 0 && j == 2)\n                                System.out.print(\"0 \");\n                        else if (i == 1 && j == 0)\n                                System.out.print(\"0 \");\n                        else if (i == 2 && j == 1)\n                                System.out.print(\"0 \");\n                        else\n                                System.out.print(n +\" \");\n                }\n                System.out.println(\"\");\n        }\n}\n", "17": "static int countNegative(int M[][], int n, int m)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (M[i][j] < 0)\n\t\t\t\t\tcount += 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "18": "static int countNegative(int M[][], int n, int m)\n\t{\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tint j = m - 1;\n\t\twhile (j >= 0 && i < n) {\n\t\t\tif (M[i][j] < 0) {\n\t\t\t\tcount += j + 1;\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tj -= 1;\n\t\t}\n\t\treturn count;\n\t}", "19": "static int getLastNegativeIndex(int array[], int start, int end)\n\t{\n\t\tif (start == end) {\n\t\t\treturn start;\n\t\t}\n\t\tint mid = start + (end - start) / 2;\n\t\tif (array[mid] < 0) {\n\t\t\tif (mid + 1 < array.length && array[mid + 1] >= 0) {\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\treturn getLastNegativeIndex(array, mid + 1, end);\n\t\t}\n\t\telse {\n\t\t\treturn getLastNegativeIndex(array, start, mid - 1);\n\t\t}\n\t}\nstatic int countNegative(int M[][], int n, int m)\n\t{\n\t\tint count = 0;\n\t\tint nextEnd = m - 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (M[i][0] >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextEnd = getLastNegativeIndex(M[i], 0, nextEnd);\n\t\t\tcount += nextEnd + 1;\n\t\t}\n\t\treturn count;\n\t}", "20": "static int findMaxValue(int N,int mat[][])\n\t{\n\t\tint maxValue = Integer.MIN_VALUE;\n\t\tfor (int a = 0; a < N - 1; a++)\n\t\tfor (int b = 0; b < N - 1; b++)\n\t\t\tfor (int d = a + 1; d < N; d++)\n\t\t\tfor (int e = b + 1; e < N; e++)\n\t\t\t\tif (maxValue < (mat[d][e] - mat[a][b]))\n\t\t\t\t\tmaxValue = mat[d][e] - mat[a][b];\n\t\treturn maxValue;\n\t}", "21": "static int findMaxValue(int N,int mat[][])\n\t{\n\t\tint maxValue = Integer.MIN_VALUE;\n\t\tint maxArr[][] = new int[N][N];\n\t\tmaxArr[N-1][N-1] = mat[N-1][N-1];\nint maxv = mat[N-1][N-1]; \n\t\tfor (int j = N - 2; j >= 0; j--)\n\t\t{\n\t\t\tif (mat[N-1][j] > maxv)\n\t\t\t\tmaxv = mat[N - 1][j];\n\t\t\tmaxArr[N-1][j] = maxv;\n\t\t}\nmaxv = mat[N - 1][N - 1]; \n\t\tfor (int i = N - 2; i >= 0; i--)\n\t\t{\n\t\t\tif (mat[i][N - 1] > maxv)\n\t\t\t\tmaxv = mat[i][N - 1];\n\t\t\tmaxArr[i][N - 1] = maxv;\n\t\t}\n\t\tfor (int i = N-2; i >= 0; i--)\n\t\t{\n\t\t\tfor (int j = N-2; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif (maxArr[i+1][j+1] - mat[i][j] > maxValue)\n\t\t\t\t\tmaxValue = maxArr[i + 1][j + 1] - mat[i][j];\n\t\t\t\tmaxArr[i][j] = Math.max(mat[i][j],\n\t\t\t\t\t\t\t\tMath.max(maxArr[i][j + 1], maxArr[i + 1][j]) );\n\t\t\t}\n\t\t}\n\t\treturn maxValue;\n\t}", "22": "static void youngify(int mat[][], int i, int j)\n\t{\n\t\tint downVal = (i + 1 < N) ?\n\t\t\t\t\tmat[i + 1][j] : INF;\n\t\tint rightVal = (j + 1 < N) ?\n\t\t\t\t\tmat[i][j + 1] : INF;\n\t\tif (downVal == INF && rightVal == INF)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (downVal < rightVal)\n\t\t{\n\t\t\tmat[i][j] = downVal;\n\t\t\tmat[i + 1][j] = INF;\n\t\t\tyoungify(mat, i + 1, j);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmat[i][j] = rightVal;\n\t\t\tmat[i][j + 1] = INF;\n\t\t\tyoungify(mat, i, j + 1);\n\t\t}\n\t}\nstatic int extractMin(int mat[][])\n\t{\n\t\tint ret = mat[0][0];\n\t\tmat[0][0] = INF;\n\t\tyoungify(mat, 0, 0);\n\t\treturn ret;\n\t}\nstatic void printSorted(int mat[][])\n\t{\n\t\tSystem.out.println(\"Elements of matrix in sorted order n\");\n\t\tfor (int i = 0; i < N * N; i++)\n\t\t{\n\t\t\tSystem.out.print(extractMin(mat) + \" \");\n\t\t}\n\t}", "23": "static void printSumSimple(int mat[][], int k)\n\t{\n\t\tif (k > n) return;\n\t\tfor (int i = 0; i < n-k+1; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n-k+1; j++)\n\t\t\t{\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int p = i; p < k+i; p++)\n\t\t\t\t\tfor (int q = j; q < k+j; q++)\n\t\t\t\t\t\tsum += mat[p][q];\n\t\t\t\tSystem.out.print(sum+ \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "24": "static void printSumTricky(int mat[][], int k) {\n\tif (k > n)\n\treturn;\n\tint stripSum[][] = new int[n][n];\n\tfor (int j = 0; j < n; j++) {\n\tint sum = 0;\n\tfor (int i = 0; i < k; i++)\n\t\tsum += mat[i][j];\n\tstripSum[0][j] = sum;\n\tfor (int i = 1; i < n - k + 1; i++) {\n\t\tsum += (mat[i + k - 1][j] - mat[i - 1][j]);\n\t\tstripSum[i][j] = sum;\n\t}\n\t}\n\tfor (int i = 0; i < n - k + 1; i++) {\n\tint sum = 0;\n\tfor (int j = 0; j < k; j++)\n\t\tsum += stripSum[i][j];\n\tSystem.out.print(sum + \" \");\n\tfor (int j = 1; j < n - k + 1; j++) {\n\t\tsum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n\t\tSystem.out.print(sum + \" \");\n\t}\n\tSystem.out.println();\n\t}\n}", "25": "static void transpose(int A[][], int B[][])\n\t{\n\t\tint i, j;\n\t\tfor (i = 0; i < N; i++)\n\t\t\tfor (j = 0; j < M; j++)\n\t\t\t\tB[i][j] = A[j][i];\n\t}", "26": "static void transpose(int A[][])\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = i+1; j < N; j++)\n\t\t\t{\n\t\t\t\tint temp = A[i][j];\n\t\t\t\tA[i][j] = A[j][i];\n\t\t\t\tA[j][i] = temp;\n\t\t\t}\n\t}", "27": "static int pathCountRec(int mat[][], int m, int n, int k) {\n\t\tif (m < 0 n < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (m == 0 && n == 0 && (k == mat[m][n])) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn pathCountRec(mat, m - 1, n, k - mat[m][n])\n\t\t\t\t+ pathCountRec(mat, m, n - 1, k - mat[m][n]);\n\t}\nstatic int pathCount(int mat[][], int k) {\n\t\treturn pathCountRec(mat, R - 1, C - 1, k);\n\t}", "28": "static int pathCountDPRecDP(int [][]mat, int m, int n, int k)\n\t{\n\t\tif (m < 0 n < 0) return 0;\n\t\tif (m==0 && n==0) return (k == mat[m][n] ? 1 : 0);\n\t\tif (dp[m][n][k] != -1) return dp[m][n][k];\n\t\tdp[m][n][k] = pathCountDPRecDP(mat, m-1, n, k-mat[m][n]) +\n\t\t\t\t\tpathCountDPRecDP(mat, m, n-1, k-mat[m][n]);\n\t\treturn dp[m][n][k];\n\t}\nstatic int pathCountDP(int [][]mat, int k)\n\t{\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++)\n\t\t\t\tfor(int l=0;l<MAX_K;l++)\n\t\t\t\tdp[i][j][l]=-1;\n\t\treturn pathCountDPRecDP(mat, R-1, C-1, k);\n\t}", "29": "static boolean check(int A[], int N) {\n\t\tStack<Integer> S = new Stack<Integer>();\n\t\tint B_end = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!S.empty()) {\n\t\t\t\tint top = S.peek();\n\t\t\t\twhile (top == B_end + 1) {\n\t\t\t\t\tB_end = B_end + 1;\n\t\t\t\t\tS.pop();\n\t\t\t\t\tif (S.empty()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttop = S.peek();\n\t\t\t\t}\n\t\t\t\tif (S.empty()) {\n\t\t\t\t\tS.push(A[i]);\n\t\t\t\t} else {\n\t\t\t\t\ttop = S.peek();\n\t\t\t\t\tif (A[i] < top) {\n\t\t\t\t\t\tS.push(A[i]);\n} \n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tS.push(A[i]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "30": "static int countMinReversals(String expr)\n\t{\n\t\tint len = expr.length();\n\t\tif (len%2 != 0)\n\t\treturn -1;\n\t\tStack<Character> s=new Stack<>();\n\t\tfor (int i=0; i<len; i++)\n\t\t{\n\t\t\tchar c = expr.charAt(i);\n\t\t\tif (c =='}' && !s.empty())\n\t\t\t{\n\t\t\t\tif (s.peek()=='{')\n\t\t\t\t\ts.pop();\n\t\t\t\telse\n\t\t\t\t\ts.push(c);\n\t\t\t}\n\t\t\telse\n\t\t\t\ts.push(c);\n\t\t}\n\t\tint red_len = s.size();\n\t\tint n = 0;\n\t\twhile (!s.empty() && s.peek() == '{')\n\t\t{\n\t\t\ts.pop();\n\t\t\tn++;\n\t\t}\n\t\treturn (red_len/2 + n%2);\n\t}", "31": "static int countMinReversals(String expr)\n\t{\n\t\tint len = expr.length();\n\t\tint ans;\n\t\tif (len % 2 != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tint left_brace = 0, right_brace = 0;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tchar ch = expr.charAt(i);\n\t\t\tif (ch == '{') {\n\t\t\t\tleft_brace++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (left_brace == 0) {\n\t\t\t\t\tright_brace++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tleft_brace--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (int)(Math.ceil((0.0 + left_brace) / 2)\n\t\t\t\t\t+ Math.ceil((0.0 + right_brace) / 2));\n\t\treturn ans;\n\t}", "32": "static void PrintMinNumberForPattern(String arr)\n\t{\n\t\tint curr_max = 0;\n\t\tint last_entry = 0;\n\t\tint j;\n\t\tfor (int i = 0; i < arr.length(); i++)\n\t\t{\n\t\t\tint noOfNextD = 0;\n\t\t\tswitch (arr.charAt(i))\n\t\t\t{\n\t\t\t\tcase 'I':\n\t\t\t\t\tj = i + 1;\n\t\t\t\t\twhile (j < arr.length() && arr.charAt(j) == 'D')\n\t\t\t\t\t{\n\t\t\t\t\t\tnoOfNextD++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\t\t\tSystem.out.print(\" \" + ++last_entry);\n\t\t\t\t\t\tSystem.out.print(\" \" + curr_max);\n\t\t\t\t\t\tlast_entry = curr_max;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_max = curr_max + noOfNextD + 1;\n\t\t\t\t\t\tlast_entry = curr_max;\n\t\t\t\t\t\tSystem.out.print(\" \" + last_entry);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < noOfNextD; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.print(\" \" + --last_entry);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = i + 1;\n\t\t\t\t\t\twhile (j < arr.length()&&arr.charAt(j) == 'D')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnoOfNextD++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\t\t\tSystem.out.print(\" \" + curr_max + \" \" + (curr_max - 1));\n\t\t\t\t\t\tlast_entry = curr_max - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.print(\" \" + (last_entry - 1));\n\t\t\t\t\t\tlast_entry--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}", "33": "static void printLeast(String arr)\n\t{\n\t\t\tint min_avail = 1, pos_of_I = 0;\n\t\t\tArrayList<Integer> al = new ArrayList<>();\n\t\t\tif (arr.charAt(0) == 'I')\n\t\t\t{\n\t\t\t\tal.add(1);\n\t\t\t\tal.add(2);\n\t\t\t\tmin_avail = 3;\n\t\t\t\tpos_of_I = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tal.add(2);\n\t\t\t\tal.add(1);\n\t\t\t\tmin_avail = 3;\n\t\t\t\tpos_of_I = 0;\n\t\t\t}\n\t\t\tfor (int i = 1; i < arr.length(); i++)\n\t\t\t{\n\t\t\t\tif (arr.charAt(i) == 'I')\n\t\t\t\t{\n\t\t\t\t\tal.add(min_avail);\n\t\t\t\t\tmin_avail++;\n\t\t\t\t\tpos_of_I = i + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tal.add(al.get(i));\n\t\t\t\t\tfor (int j = pos_of_I; j <= i; j++)\n\t\t\t\t\t\t\tal.set(j, al.get(j) + 1);\n\t\t\t\t\tmin_avail++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < al.size(); i++)\n\t\t\t\tSystem.out.print(al.get(i) + \" \");\n\t\t\tSystem.out.println();\n\t}", "34": "static void PrintMinNumberForPattern(String seq) {\n\t\tString result = \"\";\n\t\tStack<Integer> stk = new Stack<Integer>();\n\t\tfor (int i = 0; i <= seq.length(); i++) {\n\t\t\tstk.push(i + 1);\n\t\t\tif (i == seq.length() || seq.charAt(i) == 'I') {\n\t\t\t\twhile (!stk.empty()) {\n\t\t\t\t\tresult += String.valueOf(stk.peek());\n\t\t\t\t\tresult += \" \";\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}", "35": "static String getMinNumberForPattern(String seq)\n\t{\n\t\tint n = seq.length();\n\t\tif (n >= 9)\n\t\t\treturn \"-1\";\n\t\tchar result[] = new char[n + 1];\n\t\tint count = 1;\n\t\tfor (int i = 0; i <= n; i++)\n\t\t{\n\t\t\tif (i == n || seq.charAt(i) == 'I')\n\t\t\t{\n\t\t\t\tfor (int j = i - 1; j >= -1; j--)\n\t\t\t\t{\n\t\t\t\t\tresult[j + 1] = (char) ((int) '0' + count++);\n\t\t\t\t\tif (j >= 0 && seq.charAt(j) == 'I')\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new String(result);\n\t}", "36": "public int compare(Key k1, Key k2)\n\t{\n\t\tif (k1.freq < k2.freq)\n\t\t\treturn 1;\n\t\telse if (k1.freq > k2.freq)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\nstatic void rearrangeString(String str)\n\t{\n\t\tint n = str.length();\n\t\tint[] count = new int[MAX_CHAR];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcount[str.charAt(i) - 'a']++;\n\t\tPriorityQueue<Key> pq\n\t\t\t= new PriorityQueue<>(new KeyComparator());\n\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\tint val = c - 'a';\n\t\t\tif (count[val] > 0)\n\t\t\t\tpq.add(new Key(count[val], c));\n\t\t}\n\t\tstr = \"\";\n\t\tKey prev = new Key(-1, '#');\n\t\twhile (pq.size() != 0) {\n\t\t\tKey k = pq.peek();\n\t\t\tpq.poll();\n\t\t\tstr = str + k.ch;\n\t\t\tif (prev.freq > 0)\n\t\t\t\tpq.add(prev);\n\t\t\t(k.freq)--;\n\t\t\tprev = k;\n\t\t}\n\t\tif (n != str.length())\n\t\t\tSystem.out.println(\" Not valid String \");\n\t\telse\n\t\t\tSystem.out.println(str);\n\t}", "37": "public static int subset(int ar[], int n)\n\t{\n\t\tint res = 0;\n\t\tArrays.sort(ar);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint count = 1;\n\t\t\tfor (; i < n - 1; i++) {\n\t\t\t\tif (ar[i] == ar[i + 1])\n\t\t\t\t\tcount++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres = Math.max(res, count);\n\t\t}\n\t\treturn res;\n\t}", "38": "static int subset(int arr[], int n)\n{\n\tHashMap<Integer, Integer> mp = new HashMap<>();\n\tfor (int i = 0; i < n; i++)\n\t\tmp.put(arr[i],mp.get(arr[i]) == null?1:mp.get(arr[i])+1);\n\tint res = 0;\n\tfor (Map.Entry<Integer,Integer> entry : mp.entrySet())\n\tres = Math.max(res, entry.getValue());\n\treturn res;\n}", "39": "static boolean areElementsContiguous(int arr[], int n)\n\t{\n\tArrays.sort(arr);\n\tfor (int i = 1; i < n; i++)\n\t\tif (arr[i] - arr[i-1] > 1)\n\t\t\treturn false;\n\treturn true; \n\t}", "40": "static boolean areElementsContiguous(int arr[], int n)\n\t{\n\t\tint max = Integer.MIN_VALUE;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tmax = Math.max(max, arr[i]);\n\t\t\tmin = Math.min(min, arr[i]);\n\t\t}\n\t\tint m = max - min + 1;\n\t\tif (m > n)\n\t\t\treturn false;\n\t\tboolean visited[] = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) \n\t\tvisited[arr[i] - min] = true;\n\t\tfor (int i = 0; i < m; i++)\n\t\tif (visited[i] == false)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "41": "static Boolean areElementsContiguous(int arr[], int n)\n\t{\n\t\tHashSet<Integer> us = new HashSet<Integer>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tus.add(arr[i]);\n\t\tint count = 1;\n\t\tint curr_ele = arr[0] - 1;\n\t\twhile (us.contains(curr_ele) == true) {\n\t\t\tcount++;\n\t\t\tcurr_ele--;\n\t\t}\n\t\tcurr_ele = arr[0] + 1;\n\t\twhile (us.contains(curr_ele) == true) {\n\t\t\tcount++;\n\t\t\tcurr_ele++;\n\t\t}\n\t\treturn (count == (us.size()));\n\t}", "42": "static void longest(int a[], int n, int k)\n{\n\tint[] freq = new int[7];\n\tint start = 0, end = 0, now = 0, l = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfreq[a[i]]++;\n\t\tif (freq[a[i]] == 1)\n\t\t\tnow++;\n\t\twhile (now > k)\n\t\t{\n\t\t\tfreq[a[l]]--;\n\t\t\tif (freq[a[l]] == 0)\n\t\t\t\tnow--;\n\t\t\tl++;\n\t\t}\n\t\tif (i - l + 1 >= end - start + 1)\n\t\t{\n\t\t\tend = i;\n\t\t\tstart = l;\n\t\t}\n\t}\n\tfor (int i = start; i <= end; i++)\n\t\tSystem.out.print(a[i]+\" \");\n}", "43": "static void findSmallestRange(int arr[][], int n, int k)\n\t{\n\t\tint i, minval, maxval, minrange, minel = 0, maxel = 0, flag, minind;\n\t\tfor (i = 0; i <= k; i++) {\n\t\t\tptr[i] = 0;\n\t\t}\n\t\tminrange = Integer.MAX_VALUE;\n\t\twhile (true) {\n\t\t\tminind = -1;\n\t\t\tminval = Integer.MAX_VALUE;\n\t\t\tmaxval = Integer.MIN_VALUE;\n\t\t\tflag = 0;\n\t\t\tfor (i = 0; i < k; i++) {\n\t\t\t\tif (ptr[i] == n) {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ptr[i] < n && arr[i][ptr[i]] < minval) {\nminind = i; \n\t\t\t\t\tminval = arr[i][ptr[i]];\n\t\t\t\t}\n\t\t\t\tif (ptr[i] < n && arr[i][ptr[i]] > maxval) {\n\t\t\t\t\tmaxval = arr[i][ptr[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr[minind]++;\n\t\t\tif ((maxval - minval) < minrange) {\n\t\t\t\tminel = minval;\n\t\t\t\tmaxel = maxval;\n\t\t\t\tminrange = maxel - minel;\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"The smallest range is [%d, %d]\\n\", minel, maxel);\n\t}", "44": "static int findLargestd(int []S, int n)\n{\n\tboolean found = false;\n\tArrays.sort(S);\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tif (i == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int l = k + 1; l < n; l++)\n\t\t\t\t{\n\t\t\t\t\tif (i == l)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (S[i] == S[j] + S[k] + S[l])\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\treturn S[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (found == false)\n\t\treturn Integer.MAX_VALUE;\n\treturn -1;\n}", "45": "int getI()\n\t{\n\t\treturn i;\n\t}\nint getJ()\n\t{\n\t\treturn j;\n\t}\nstatic int findFourElements(int[] arr, int n)\n\t{\n\t\tHashMap<Integer, Indexes> map = new HashMap<>();\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tmap.put(arr[i] + arr[j], new Indexes(i, j));\n\t\t\t}\n\t\t}\n\t\tint d = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tint abs_diff = Math.abs(arr[i] - arr[j]);\n\t\t\t\tif (map.containsKey(abs_diff))\n\t\t\t\t{\n\t\t\t\t\tIndexes indexes = map.get(abs_diff);\n\t\t\t\t\tif (indexes.getI() != i && indexes.getI() != j &&\n\t\t\t\t\tindexes.getJ() != i && indexes.getJ() != j)\n\t\t\t\t\t{\n\t\t\t\t\t\td = Math.max(d, Math.max(arr[i], arr[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}", "46": "void leftRotatebyOne(int arr[], int n)\n\t{\n\t\tint i, temp;\n\t\ttemp = arr[0];\n\t\tfor (i = 0; i < n - 1; i++)\n\t\t\tarr[i] = arr[i + 1];\n\t\tarr[n-1] = temp;\n\t}\nvoid leftRotate(int arr[], int d, int n)\n\t{\n\t\tfor (int i = 0; i < d; i++)\n\t\t\tleftRotatebyOne(arr, n);\n\t}\nvoid printArray(int arr[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t}", "47": "static void pushZerosToEnd(int arr[], int n)\n\t{\nint count = 0; \n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != 0)\narr[count++] = arr[i]; \n\t\twhile (count < n)\n\t\t\tarr[count++] = 0;\n\t}", "48": "static void moveZerosToEnd(int arr[], int n) {\n\tint count = 0;\n\tint temp;\n\tfor (int i = 0; i < n; i++) {\n\tif ((arr[i] != 0)) {\n\t\ttemp = arr[count];\n\t\tarr[count] = arr[i];\n\t\tarr[i] = temp;\n\t\tcount = count + 1;\n\t}\n\t}\n}\nstatic void printArray(int arr[], int n) {\n\tfor (int i = 0; i < n; i++)\n\tSystem.out.print(arr[i] + \" \");\n}", "49": "static void pushZerosToEnd(int arr[], int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != 0)\n\t\t\t\tarr[count++] = arr[i];\n\t\twhile (count < n)\n\t\t\tarr[count++] = 0;\n\t}\nstatic void modifyAndRearrangeArr(int arr[], int n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif ((arr[i] != 0) && (arr[i] == arr[i + 1]))\n\t\t\t{\n\t\t\t\tarr[i] = 2 * arr[i];\n\t\t\t\tarr[i + 1] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tpushZerosToEnd(arr, n);\n\t}\nstatic void printArray(int arr[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}", "50": "void printArray(int A[], int size)\n{\n        for (int i = 0; i < size; i++)\n                cout << A[i] << \" \";\n        cout << endl;\n}\nvoid reverse(int arr[], int l, int r)\n{\n        if (l < r) {\n                swap(arr[l], arr[r]);\n                reverse(arr, ++l, --r);\n        }\n}\nvoid merge(int arr[], int l, int m, int r)\n{\nint i = l; \nint j = m + 1; \n        while (i <= m && arr[i] < 0)\n                i++;\n        while (j <= r && arr[j] < 0)\n                j++;\n        reverse(arr, i, m);\n        reverse(arr, m + 1, j - 1);\n        reverse(arr, i, j - 1);\n}\nvoid RearrangePosNeg(int arr[], int l, int r)\n{\n        if (l < r) {\n                int m = l + (r - l) / 2;\n                RearrangePosNeg(arr, l, m);\n                RearrangePosNeg(arr, m + 1, r);\n                merge(arr, l, m, r);\n        }\n}", "51": "void RearrangePosNeg(int arr[], int n)\n{\n        int i = 0;\n        int j = n - 1;\n        while (true) {\n                while (arr[i] < 0 && i < n)\n                        i++;\n                while (arr[j] > 0 && j >= 0)\n                        j--;\n                if (i < j) {\n                        int temp = arr[i];\n                        arr[i] = arr[j];\n                        arr[j] = temp;\n                }\n                else\n                        break;\n        }\n}", "52": "void findElements(int arr[], int n)\n{\n        for (int i = 0; i < n; i++)\n        {\n                int count = 0;\n                for (int j = 0; j < n; j++)\n                        if (arr[j] > arr[i])\n                                count++;\n                if (count >= 2)\n                        cout << arr[i] << \" \";\n        }\n}", "53": "void findElements(int arr[], int n)\n{\n        sort(arr, arr + n);\n        for (int i = 0; i < n - 2; i++)\n        cout << arr[i] << \" \";\n}", "54": "void findElements(int arr[], int n)\n{\n        int first = INT_MIN,\n                second = INT_MIN;\n        for (int i = 0; i < n; i++)\n        {\n                if (arr[i] > first)\n                {\n                        second = first;\n                        first = arr[i];\n                }\n                else if (arr[i] > second)\n                        second = arr[i];\n        }\n        for (int i = 0; i < n; i++)\n                if (arr[i] < second)\n                        cout << arr[i] << \" \";\n}", "55": "int findFirstMissing(int array[], int start, int end)\n{\n        if (start > end)\n                return end + 1;\n        if (start != array[start])\n                return start;\n        int mid = (start + end) / 2;\n        if (array[mid] == mid)\n                return findFirstMissing(array, mid+1, end);\n        return findFirstMissing(array, start, mid);\n}", "56": "int findSmallestMissinginSortedArray(vector<int> arr)\n{\n if(arr[0] != 0)\n        return 0;\n if(arr[arr.size() - 1] == arr.size() - 1)\n        return arr.size();\n int first = arr[0];\n return findFirstMissing(arr, 0, arr.size() - 1, first);\n}\nint findFirstMissing(vector<int> arr , int start , int end,int first)\n{\n if (start < end)\n {\n        int mid = (start + end) / 2;\n        if (arr[mid] != mid+first)\n        return findFirstMissing(arr, start, mid , first);\n        else\n        return findFirstMissing(arr, mid + 1, end , first);\n }\n return start + first;\n}", "57": "int FindMaxSum(vector<int> arr, int n)\n{\n        int incl = arr[0];\n        int excl = 0;\n        int excl_new;\n        int i;\n        for (i = 1; i < n; i++)\n        {\n                excl_new = (incl > excl) ? incl : excl;\n                incl = excl + arr[i];\n                excl = excl_new;\n        }\n        return ((incl > excl) ? incl : excl);\n}", "58": "void buildSparseTable(int arr[], int n)\n{\n        for (int i = 0; i < n; i++)\n                lookup[i][0] = arr[i];\n        for (int j = 1; (1 << j) <= n; j++) {\n                for (int i = 0; (i + (1 << j) - 1) < n; i++) {\n                        if (lookup[i][j - 1] <\n                                                lookup[i + (1 << (j - 1))][j - 1])\n                                lookup[i][j] = lookup[i][j - 1];\n                        else\n                                lookup[i][j] =\n                                                lookup[i + (1 << (j - 1))][j - 1];\n                }\n        }\n}\nint query(int L, int R)\n{\n        int j = (int)log2(R - L + 1);\n        if (lookup[L][j] <= lookup[R - (1 << j) + 1][j])\n                return lookup[L][j];\n        else\n                return lookup[R - (1 << j) + 1][j];\n}", "59": "void buildSparseTable(int arr[], int n)\n{\n        for (int i = 0; i < n; i++)\n                table[i][0] = arr[i];\n        for (int j = 1; j <= n; j++)\n                for (int i = 0; i <= n - (1 << j); i++)\n                        table[i][j] = __gcd(table[i][j - 1],\n                                        table[i + (1 << (j - 1))][j - 1]);\n}\nint query(int L, int R)\n{\n        int j = (int)log2(R - L + 1);\n        return __gcd(table[L][j], table[R - (1 << j) + 1][j]);\n}", "60": "int findMaxAverage(int arr[], int n, int k)\n{\n        if (k > n)\n                return -1;\n        int *csum = new int[n];\n        csum[0] = arr[0];\n        for (int i=1; i<n; i++)\n        csum[i] = csum[i-1] + arr[i];\n        int max_sum = csum[k-1], max_end = k-1;\n        for (int i=k; i<n; i++)\n        {\n                int curr_sum = csum[i] - csum[i-k];\n                if (curr_sum > max_sum)\n                {\n                        max_sum = curr_sum;\n                        max_end = i;\n                }\n        }\ndelete [] csum; \n        return max_end - k + 1;\n}", "61": "int findMaxAverage(int arr[], int n, int k)\n{\n        if (k > n)\n                return -1;\n        int sum = arr[0];\n        for (int i=1; i<k; i++)\n                sum += arr[i];\n        int max_sum = sum, max_end = k-1;\n        for (int i=k; i<n; i++)\n        {\n                int sum = sum + arr[i] - arr[i-k];\n                if (sum > max_sum)\n                {\n                        max_sum = sum;\n                        max_end = i;\n                }\n        }\n        return max_end - k + 1;\n}", "62": "bool isMajority(int arr[], int n, int x)\n{\n        int i;\n        int last_index = n % 2 ? (n / 2 + 1): (n / 2);\n        for (i = 0; i < last_index; i++)\n        {\n                if (arr[i] == x && arr[i + n / 2] == x)\n                        return 1;\n        }\n        return 0;\n}", "63": "int _binarySearch(int arr[], int low, int high, int x)\n{\n        if (high >= low)\n        {\n                int mid = (low + high)/2; \n                if ((mid == 0 x > arr[mid - 1]) &&\n                        (arr[mid] == x) )\n                        return mid;\n                else if (x > arr[mid])\n                        return _binarySearch(arr, (mid + 1), high, x);\n                else\n                        return _binarySearch(arr, low, \n                                                                (mid - 1), x);\n        }\n        return -1;\n}\nbool isMajority(int arr[], int n, int x)\n{\n        int i = _binarySearch(arr, 0, n - 1, x);\n        if (i == -1)\n                return false;\n        if (((i + n / 2) <= (n - 1)) && arr[i + n / 2] == x)\n                return true;\n        else\n                return false;\n}", "64": "bool isMajorityElement(int arr[], int n, int key)\n{\n        if (arr[n / 2] == key)\n                return true;\n        else\n                return false;\n}", "65": "void sortMat(int mat[SIZE][SIZE], int n)\n{\n        int temp[n * n];\n        int k = 0;\n        for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                        temp[k++] = mat[i][j];\n        sort(temp, temp + k);\n        k = 0;\n        for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                        mat[i][j] = temp[k++];\n}\nvoid printMat(int mat[SIZE][SIZE], int n)\n{\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++)\n                        cout << mat[i][j] << \" \";\n                cout << endl;\n        }\n}", "66": "void swap(int *xp, int *yp) \n{ \n        int temp = *xp; \n        *xp = *yp; \n        *yp = temp; \n}\nvoid selectionSort(int arr[], int n) \n{ \n        int i, j, min_idx; \n        for (i = 0; i < n-1; i++) \n        { \n                min_idx = i; \n                for (j = i+1; j < n; j++) \n                if (arr[j] < arr[min_idx]) \n                        min_idx = j; \n                swap(&arr[min_idx], &arr[i]); \n        } \n}\nvoid printArray(int arr[], int size) \n{ \n        int i; \n        for (i=0; i < size; i++) \n                cout << arr[i] << \" \"; \n        cout << endl; \n}", "67": "void swap(int *xp, int *yp)\n{\n        int temp = *xp;\n        *xp = *yp;\n        *yp = temp;\n}\nvoid bubbleSort(int arr[], int n)\n{\n int i, j;\n bool swapped;\n for (i = 0; i < n-1; i++)\n {\n        swapped = false;\n        for (j = 0; j < n-i-1; j++)\n        {\n                if (arr[j] > arr[j+1])\n                {\n                swap(&arr[j], &arr[j+1]);\n                swapped = true;\n                }\n        }\n        if (swapped == false)\n                break;\n }\n}\nvoid printArray(int arr[], int size)\n{\n        int i;\n        for (i=0; i < size; i++)\n                printf(\"%d \", arr[i]);\n        printf(\"n\");\n}", "68": "int findCrossOver(int arr[], int low, int high, int x)\n{\nif (arr[high] <= x) \n        return high;\nif (arr[low] > x) \n        return low;\nint mid = (low + high)/2; \nif (arr[mid] <= x && arr[mid+1] > x)\n        return mid;\nif(arr[mid] < x)\n        return findCrossOver(arr, mid+1, high, x);\nreturn findCrossOver(arr, low, mid - 1, x);\n}\nvoid printKclosest(int arr[], int x, int k, int n)\n{\n        int l = findCrossOver(arr, 0, n-1, x);\nint r = l+1; \nint count = 0; \n        if (arr[l] == x) l--;\n        while (l >= 0 && r < n && count < k)\n        {\n                if (x - arr[l] < arr[r] - x)\n                        printf(\"%d \", arr[l--]);\n                else\n                        printf(\"%d \", arr[r++]);\n                count++;\n        }\n        while (count < k && l >= 0)\n                printf(\"%d \", arr[l--]), count++;\n        while (count < k && r < n)\n                printf(\"%d \", arr[r++]), count++;\n}", "69": "int count( int S[], int m, int n )\n{\n        if (n == 0)\n                return 1;\n        if (n < 0)\n                return 0;\n        if (m <=0 && n >= 1)\n                return 0;\n        return count( S, m - 1, n ) + count( S, m, n-S[m-1] );\n}", "70": "int count( int S[], int m, int n )                \n{                \n int table[n+1];                \n memset(table, 0, sizeof(table));                \n table[0] = 1;                \n for(int i=0; i<m; i++)                \n for(int j=S[i]; j<=n; j++)                \n table[j] += table[j-S[i]];                \n return table[n];                \n}", "71": "int matrixChainMemoised(int* p, int i, int j)\n{\n        if (i == j)\n        {\n                return 0;\n        }\n        if (dp[i][j] != -1)\n        {\n                return dp[i][j];\n        }\n        dp[i][j] = INT_MAX;\n        for (int k = i; k < j; k++)\n        {\n                dp[i][j] = min(\n                        dp[i][j], matrixChainMemoised(p, i, k)\n                                        + matrixChainMemoised(p, k + 1, j) + p[i - 1] * p[k] * p[j]);\n        }\n        return dp[i][j];\n}\nint MatrixChainOrder(int* p, int n)\n{\n        int i = 1, j = n - 1;\n        return matrixChainMemoised(p, i, j);\n}", "72": "int MatrixChainOrder(int p[], int n)\n{\n        int m[n][n];\n        int i, j, k, L, q;\n        for (i = 1; i < n; i++)\n                m[i][i] = 0;\n        for (L = 2; L < n; L++)\n        {\n                for (i = 1; i < n - L + 1; i++)\n                {\n                        j = i + L - 1;\n                        m[i][j] = INT_MAX;\n                        for (k = i; k <= j - 1; k++)\n                        {\n                                q = m[i][k] + m[k + 1][j]\n                                        + p[i - 1] * p[k] * p[j];\n                                if (q < m[i][j])\n                                        m[i][j] = q;\n                        }\n                }\n        }\n        return m[1][n - 1];\n}", "73": "int max(int a, int b) { return (a > b)? a : b;}\nint cutRod(int price[], int n)\n{\n if (n <= 0)\n        return 0;\n int max_val = INT_MIN;\n for (int i = 0; i<n; i++)\n                max_val = max(max_val, price[i] + cutRod(price, n-i-1));\n return max_val;\n}", "74": "int max(int a, int b) { return (a > b)? a : b;}\nint cutRod(int price[], int n)\n{\n int val[n+1];\n val[0] = 0;\n int i, j;\n for (i = 1; i<=n; i++)\n {\n        int max_val = INT_MIN;\n        for (j = 0; j < i; j++)\n                max_val = max(max_val, price[j] + val[i-j-1]);\n        val[i] = max_val;\n }\n return val[n];\n}", "75": "int un_kp(int price[], int length[], int Max_len, int n)\n{\n        if (n == 0 Max_len == 0)\n        {\n                return 0;\n        }\n        if (length[n - 1] <= Max_len)\n        {\n                t[n][Max_len]\n                        = max(price[n - 1]\n                                        + un_kp(price, length, Max_len - length[n - 1], n),\n                                un_kp(price, length, Max_len, n - 1));\n        }\n        else\n        {\n                t[n][Max_len]\n                        = un_kp(price, length, Max_len, n - 1);\n        }\n        return t[n][Max_len];\n}", "76": "int multiply(int x, int y)\n{\n        if(y == 0)\n        return 0;\n        if(y > 0 )\n        return (x + multiply(x, y-1));\n        if(y < 0 )\n        return -multiply(x, -y);\n}", "77": "void SieveOfEratosthenes(int n)\n{\n        bool prime[n + 1];\n        memset(prime, true, sizeof(prime));\n        for (int p = 2; p * p <= n; p++)\n        {\n                if (prime[p] == true)\n                {\n                        for (int i = p * p; i <= n; i += p)\n                                prime[i] = false;\n                }\n        }\n        for (int p = 2; p <= n; p++)\n                if (prime[p])\n                        cout << p << \" \";\n}", "78": "int binomialCoeff(int n, int k)\n{\n        int res = 1;\n        if (k > n - k)\n        k = n - k;\n        for (int i = 0; i < k; ++i)\n        {\n                res *= (n - i);\n                res /= (i + 1);\n        }\n        return res;\n}\nvoid printPascal(int n)\n{\n        for (int line = 0; line < n; line++)\n        {\n                for (int i = 0; i <= line; i++)\n                        printf(\"%d \",\n                                        binomialCoeff(line, i));\n                printf(\"\\n\");\n        }\n}", "79": "void printPascal(int n)\n{\n        int arr[n][n];\n        for (int line = 0; line < n; line++)\n        {\n                for (int i = 0; i <= line; i++)\n                {\n                if (line == i i == 0)\n                        arr[line][i] = 1;\n                else\n                        arr[line][i] = arr[line - 1][i - 1] +\n                                                        arr[line - 1][i];\n                cout << arr[line][i] << \" \";\n                }\n                cout << \"\\n\";\n        }\n}", "80": "void printPascal(int n)\n{\nfor (int line = 1; line <= n; line++)\n{\nint C = 1; \n        for (int i = 1; i <= line; i++)\n        {\n                cout<< C<<\" \";\n                C = C * (line - i) / i;\n        }\n        cout<<\"\\n\";\n}\n}", "81": "int Add(int x, int y)\n{\n        while (y != 0)\n        {\n                int carry = x & y;\n                x = x ^ y;\n                y = carry << 1;\n        }\n        return x;\n}", "82": "unsigned int getModulo(unsigned int n, unsigned int d)\n{\nreturn ( n & (d - 1) );\n}", "83": "unsigned int countSetBits(unsigned int n)\n{\n        unsigned int count = 0;\n        while (n) {\n                count += n & 1;\n                n >>= 1;\n        }\n        return count;\n}", "84": "int countSetBits(int n)\n{\n        if (n == 0)\n                return 0;\n        else\n                return 1 + countSetBits(n & (n - 1));\n}", "85": "void initialize()\n{\n        BitsSetTable256[0] = 0;\n        for (int i = 0; i < 256; i++)\n        {\n                BitsSetTable256[i] = (i & 1) +\n                BitsSetTable256[i / 2];\n        }\n}\nint countSetBits(int n)\n{\n        return (BitsSetTable256[n & 0xff] +\n                        BitsSetTable256[(n >> 8) & 0xff] +\n                        BitsSetTable256[(n >> 16) & 0xff] + BitsSetTable256[n >> 24]);\n}", "86": "Data point is missing", "87": "unsigned int countSetBitsRec(unsigned int num)\n{\n        int nibble = 0;\n        if (0 == num)\n                return num_to_bits[0];\n        nibble = num & 0xf;\n        return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}", "88": "int countSetBits(int N)\n{\n        int count = 0;\n        for (int i = 0; i < sizeof(int) * 8; i++) {\n                if (N & (1 << i))\n                        count++;\n        }\n        return count;\n}", "89": "bool getParity(unsigned int n)\n{\n        bool parity = 0;\n        while (n)\n        {\n                parity = !parity;\n                n        = n & (n - 1);\n        }        \n        return parity;\n}", "90": "bool isPowerOfTwo(int n)\n{\n if(n==0)\n return false;\n return (ceil(log2(n)) == floor(log2(n)));\n}", "91": "bool isPowerOfTwo(int n)\n{\n        if (n == 0)\n                return 0;\n        while (n != 1)\n        {\n                if (n%2 != 0)\n                        return 0;\n                n = n/2;\n        }\n        return 1;\n}", "92": "bool powerOf2(int n)\n{\n        if (n == 1)\n        return true;\n        else if (n % 2 != 0 n ==0)\n        return false;\n        return powerOf2(n / 2);\n}", "93": "bool isPowerOfTwo (int x)\n{\n        return x && (!(x&(x-1)));\n}", "94": "int maxRepeating(int* arr, int n, int k)\n{\n        for (int i = 0; i< n; i++)\n                arr[arr[i]%k] += k;\n        int max = arr[0], result = 0;\n        for (int i = 1; i < n; i++)\n        {\n                if (arr[i] > max)\n                {\n                        max = arr[i];\n                        result = i;\n                }\n        }\n        return result;\n}", "95": "int fun(int x)\n{\n        int y = (x / 4) * 4;\n        int ans = 0;\n        for (int i = y; i <= x; i++)\n                ans ^= i;\n        return ans;\n}\nint query(int x)\n{\n        if (x == 0)\n                return 0;\n        int k = (x + 1) / 2;\n        return (x %= 2) ? 2 * fun(k) : ((fun(k - 1) * 2) ^ (k & 1));\n}\nvoid allQueries(int q, int l[], int r[])\n{\n        for (int i = 0; i < q; i++)\n                cout << (query(r[i]) ^ query(l[i] - 1)) << endl;\n}", "96": "void prefixXOR(int arr[], int preXOR[], int n)\n{\n        for (int i = 0; i < n; i++) {\n                while (arr[i] % 2 != 1)\n                        arr[i] /= 2;\n                preXOR[i] = arr[i];\n        }\n        for (int i = 1; i < n; i++)\n                preXOR[i] = preXOR[i - 1] ^ preXOR[i];\n}\nint query(int preXOR[], int l, int r)\n{\n        if (l == 0)\n                return preXOR[r];\n        else\n                return preXOR[r] ^ preXOR[l - 1];\n}", "97": "int findMinSwaps(int arr[], int n)\n{\n        int noOfZeroes[n];\n        memset(noOfZeroes, 0, sizeof(noOfZeroes));\n        int i, count = 0;\n        noOfZeroes[n - 1] = 1 - arr[n - 1];\n        for (i = n - 2; i >= 0; i--) {\n                noOfZeroes[i] = noOfZeroes[i + 1];\n                if (arr[i] == 0)\n                        noOfZeroes[i]++;\n        }\n        for (i = 0; i < n; i++) {\n                if (arr[i] == 1)\n                        count += noOfZeroes[i];\n        }\n        return count;\n}", "98": "int minswaps(int arr[], int n)\n{\n        int count = 0;\n        int num_unplaced_zeros = 0;\n        for(int index=n-1;index>=0;index--)\n        {\n                if(arr[index] == 0)\n                        num_unplaced_zeros += 1;\n                else\n                        count += num_unplaced_zeros;\n        }\n        return count;\n}", "99": "bool arraySortedOrNot(int arr[], int n)\n{\n        if (n == 0 n == 1)\n                return true;\n        for (int i = 1; i < n; i++)\n                if (arr[i - 1] > arr[i])\n                        return false;\n        return true;\n}", "100": "void printTwoOdd(int arr[], int size)\n{\n        int xor2 = arr[0]; \n        int set_bit_no; \n        int i;\n        int n = size - 2;\n        int x = 0, y = 0;\n        for(i = 1; i < size; i++)\n                xor2 = xor2 ^ arr[i];\n        set_bit_no = xor2 & ~(xor2-1);\n        for(i = 0; i < size; i++)\n        {\n                if(arr[i] & set_bit_no)\n                x = x ^ arr[i];\n                else\n                y = y ^ arr[i];\n        }\n        cout << \"The two ODD elements are \" << x << \" & \" << y;\n}", "101": "void printTwoOdd(int arr[], int size)\n{\n        map<int, int> m;\n        for (int i = 0; i < size; i++) {\n                m[arr[i]]++;\n        }\n        cout << \"The two ODD elements are \";\n        for (auto& x : m) {\n                if (x.second % 2 != 0)\n                        cout << x.first << \", \";\n        }\n}", "102": "bool findPair(int arr[], int size, int n)\n{\n        int i = 0;\n        int j = 1;\n        while (i < size && j < size)\n        {\n                if (i != j && arr[j] - arr[i] == n)\n                {\n                        cout << \"Pair Found: (\" << arr[i] << \", \" << arr[j] << \")\";\n                        return true;\n                }\n                else if (arr[j]-arr[i] < n)\n                        j++;\n                else\n                        i++;\n        }\n        cout << \"No such pair\";\n        return false;\n}", "103": "void printMax(int arr[], int k, int n)\n{\n        vector<int> brr(arr, arr + n);\n        sort(brr.begin(), brr.end(), greater<int>());\n        for (int i = 0; i < n; ++i)\n                if (binary_search(brr.begin(),\n                                brr.begin() + k, arr[i],\n                                                greater<int>()))\n                        cout << arr[i] << \" \";\n}", "104": "void printSmall(int arr[], int asize, int n)\n{\n        vector<int> copy_arr(arr, arr + asize);\n        sort(copy_arr.begin(), copy_arr.begin() + asize);\n        for (int i = 0; i < asize; ++i)\n                if (binary_search(copy_arr.begin(),\n                                copy_arr.begin() + n, arr[i]))\n                        cout << arr[i] << \" \";\n}", "105": "bool checkIsAP(int arr[], int n)\n{\n if (n == 1)\n        return true;\n sort(arr, arr + n);\n int d = arr[1] - arr[0];\n for (int i=2; i<n; i++)\n        if (arr[i] - arr[i-1] != d)\n        return false;\n return true;\n}", "106": "bool checkIsAP(int arr[], int n)\n{\n        unordered_map<int, int> hm;\n        int smallest = INT_MAX, second_smallest = INT_MAX;\n        for (int i = 0; i < n; i++) {\n                if (arr[i] < smallest) {\n                        second_smallest = smallest;\n                        smallest = arr[i];\n                }\n                else if (arr[i] != smallest && arr[i] < second_smallest)\n                        second_smallest = arr[i];\n                if (hm.find(arr[i]) == hm.end())\n                        hm[arr[i]]++;\n                else\n                        return false;\n        }\n        int diff = second_smallest - smallest;\n        for (int i = 0; i < n - 1; i++) {\n                if (hm.find(second_smallest) == hm.end())\n                        return false;\n                second_smallest += diff;\n        }\n        return true;\n}", "107": "int countPairs(int a[], int n)\n{\n        int mn = INT_MAX;\n        int mx = INT_MIN;\n        for (int i = 0; i < n; i++) {\n                mn = min(mn, a[i]);\n                mx = max(mx, a[i]);\n        }\n        int c1 = 0;\nint c2 = 0; \n        for (int i = 0; i < n; i++) {\n                if (a[i] == mn)\n                        c1++;\n                if (a[i] == mx)\n                        c2++;\n        }\n        if (mn == mx)\n                return n * (n - 1) / 2;\n        else\n                return c1 * c2;\n}", "108": "void rearrange(Node* head)\n{\nif (head == NULL) \n                return;\n        Node *prev = head, *curr = head->next;\n        while (curr) {\n                if (prev->data > curr->data)\n                        swap(prev->data, curr->data);\n                if (curr->next && curr->next->data > curr->data)\n                        swap(curr->next->data, curr->data);\n                prev = curr->next;\n                if (!curr->next)\n                        break;\n                curr = curr->next->next;\n        }\n}\nvoid push(Node** head, int k)\n{\n        Node* tem = (Node*)malloc(sizeof(Node));\n        tem->data = k;\n        tem->next = *head;\n        *head = tem;\n}\nvoid display(Node* head)\n{\n        Node* curr = head;\n        while (curr != NULL) {\n                printf(\"%d \", curr->data);\n                curr = curr->next;\n        }\n}", "109": "Node* newNode(int data)\n{\n        Node* temp = new Node;\n        temp->data = data;\n        temp->next = NULL;\n        return temp;\n}\nint getLength(Node* Node)\n{\n        int size = 0;\n        while (Node != NULL) {\n                Node = Node->next;\n                size++;\n        }\n        return size;\n}\nNode* paddZeros(Node* sNode, int diff)\n{\n        if (sNode == NULL)\n                return NULL;\n        Node* zHead = newNode(0);\n        diff--;\n        Node* temp = zHead;\n        while (diff--) {\n                temp->next = newNode(0);\n                temp = temp->next;\n        }\n        temp->next = sNode;\n        return zHead;\n}\nNode* subtractLinkedListHelper(Node* l1, Node* l2, bool& borrow)\n{\n        if (l1 == NULL && l2 == NULL && borrow == 0)\n                return NULL;\n        Node* previous\n                = subtractLinkedListHelper( l1 ? l1->next : NULL, l2 ? l2->next : NULL, borrow);\n        int d1 = l1->data;\n        int d2 = l2->data;\n        int sub = 0;\n        if (borrow) {\n                d1--;\n                borrow = false;\n        }\n        if (d1 < d2) {\n                borrow = true;\n                d1 = d1 + 10;\n        }\n        sub = d1 - d2;\n        Node* current = newNode(sub);\n        current->next = previous;\n        return current;\n}\nNode* subtractLinkedList(Node* l1, Node* l2)\n{\n        if (l1 == NULL && l2 == NULL)\n                return NULL;\n        int len1 = getLength(l1);\n        int len2 = getLength(l2);\n        Node *lNode = NULL, *sNode = NULL;\n        Node* temp1 = l1;\n        Node* temp2 = l2;\n        if (len1 != len2) {\n                lNode = len1 > len2 ? l1 : l2;\n                sNode = len1 > len2 ? l2 : l1;\n                sNode = paddZeros(sNode, abs(len1 - len2));\n        }\n        else {\n                while (l1 && l2) {\n                        if (l1->data != l2->data) {\n                                lNode = l1->data > l2->data ? temp1 : temp2;\n                                sNode = l1->data > l2->data ? temp2 : temp1;\n                                break;\n                        }\n                        l1 = l1->next;\n                        l2 = l2->next;\n                }\n        }\n        bool borrow = false;\n        return subtractLinkedListHelper(lNode, sNode, borrow);\n}\nvoid printList(struct Node* Node)\n{\n        while (Node != NULL) {\n                printf(\"%d \", Node->data);\n                Node = Node->next;\n        }\n        printf(\"\\n\");\n}", "110": "Node* getNode(int data)\n{\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->data = data;\n        newNode->next = NULL;\n        return newNode;\n}\nvoid insertAtMid(Node** head_ref, int x)\n{\n        if (*head_ref == NULL)\n                *head_ref = getNode(x);\n        else {\n                Node* newNode = getNode(x);\n                Node* ptr = *head_ref;\n                int len = 0;\n                while (ptr != NULL) {\n                        len++;\n                        ptr = ptr->next;\n                }\n                int count = ((len % 2) == 0) ? (len / 2) :\n                                                                        (len + 1) / 2;\n                ptr = *head_ref;\n                while (count-- > 1)\n                        ptr = ptr->next;\n                newNode->next = ptr->next;\n                ptr->next = newNode;\n        }\n}\nvoid display(Node* head)\n{\n        while (head != NULL) {\n                cout << head->data << \" \";\n                head = head->next;\n        }\n}", "111": "Node* getNode(int data)\n{\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->data = data;\n        newNode->next = NULL;\n        return newNode;\n}\nvoid insertAtMid(Node** head_ref, int x)\n{\n        if (*head_ref == NULL)\n                *head_ref = getNode(x);\n        else {\n                Node* newNode = getNode(x);\n                Node* slow = *head_ref;\n                Node* fast = (*head_ref)->next;\n                while (fast && fast->next) {\n                        slow = slow->next;\n                        fast = fast->next->next;\n                }\n                newNode->next = slow->next;\n                slow->next = newNode;\n        }\n}\nvoid display(Node* head)\n{\n        while (head != NULL) {\n                cout << head->data << \" \";\n                head = head->next;\n        }\n}", "112": "struct Node* getNode(int data)\n{\n        struct Node* newNode =\n                (struct Node*)malloc(sizeof(struct Node));\n        newNode->data = data;\n        newNode->prev = newNode->next = NULL;\n        return newNode;\n}\nvoid sortedInsert(struct Node** head_ref, struct Node* newNode)\n{\n        struct Node* current;\n        if (*head_ref == NULL)\n                *head_ref = newNode;\n        else if ((*head_ref)->data >= newNode->data) {\n                newNode->next = *head_ref;\n                newNode->next->prev = newNode;\n                *head_ref = newNode;\n        }\n        else {\n                current = *head_ref;\n                while (current->next != NULL && current->next->data < newNode->data)\n                        current = current->next;\n                newNode->next = current->next;\n                if (current->next != NULL)\n                        newNode->next->prev = newNode;\n                current->next = newNode;\n                newNode->prev = current;\n        }\n}\nvoid insertionSort(struct Node** head_ref)\n{\n        struct Node* sorted = NULL;\n        struct Node* current = *head_ref;\n        while (current != NULL) {\n                struct Node* next = current->next;\n                current->prev = current->next = NULL;\n                sortedInsert(&sorted, current);\n                current = next;\n        }\n        *head_ref = sorted;\n}\nvoid printList(struct Node* head)\n{\n        while (head != NULL) {\n                cout << head->data << \" \";\n                head = head->next;\n        }\n}\nvoid push(struct Node** head_ref, int new_data)\n{\n        struct Node* new_node =\n                (struct Node*)malloc(sizeof(struct Node));\n        new_node->data = new_data;\n        new_node->next = (*head_ref);\n        new_node->prev = NULL;\n        if ((*head_ref) != NULL)\n                (*head_ref)->prev = new_node;\n        (*head_ref) = new_node;\n}", "113": "void reverse(int arr[], int s, int e)\n{\n while(s < e)\n {\n        int tem = arr[s];\n        arr[s] = arr[e];\n        arr[e] = tem;\n        s = s + 1;\n        e = e - 1;\n }\n}\nvoid fun(int arr[], int k)\n{\n int n = 4 - 1;\n int v = n - k;\n if (v >= 0)\n {\n        reverse(arr, 0, v);\n        reverse(arr, v + 1, n);\n        reverse(arr, 0, n);\n }\n}", "114": "void build(int node, int l, int r, int a[])\n{\n        if (l == r)\n                seg[node] = a[l];\n        else {\n                int mid = (l + r) / 2;\n                build(2 * node, l, mid, a);\n                build(2 * node + 1, mid + 1, r, a);\n                seg[node] = (seg[2 * node] seg[2 * node + 1]);\n        }\n}\nint query(int node, int l, int r, int start, int end, int a[])\n{\n        if (l > end or r < start)\n                return 0;\n        if (start <= l and r <= end)\n                return seg[node];\n        int mid = (l + r) / 2;\n        return ((query(2 * node, l, mid, start, end, a))\n                        | (query(2 * node + 1, mid + 1, r, start, end, a)));\n}\nvoid orsum(int a[], int n, int q, int k[])\n{\n        build(1, 0, n - 1, a);\n        for (int j = 0; j < q; j++) {\n                int i = k[j] % (n / 2);\n                int sec = query(1, 0, n - 1, n / 2 - i, n - i - 1, a);\n                int first = (query(1, 0, n - 1, 0, n / 2 - 1 - i, a)\n                                        | query(1, 0, n - 1, n - i, n - 1, a));\n                int temp = sec + first;\n                cout << temp << endl;\n        }\n}", "115": "void maximumEqual(int a[], int b[], int n)\n{\n        vector<int> store(1e5);\n        for (int i = 0; i < n; i++) {\n                store[b[i]] = i + 1;\n        }\n        vector<int> ans(1e5);\n        for (int i = 0; i < n; i++) {\n                int d = abs(store[a[i]]\n                                        - (i + 1));\n                if (store[a[i]] < i + 1) {\n                        d = n - d;\n                }\n                ans[d]++;\n        }\n        int finalans = 0;\n        for (int i = 0; i < 1e5; i++)\n                finalans = max(finalans, ans[i]);\n        cout << finalans << \"\\n\";\n}", "116": "void RightRotate(int a[], int n, int k)\n{\n        k = k % n;\n        for(int i = 0; i < n; i++)\n        {\n        if(i < k)\n        {\n                cout << a[n + i - k] << \" \";\n        }\n        else\n        {\n                cout << (a[i - k]) << \" \";\n        }\n        }\n        cout << \"\\n\";\n}", "117": "void restoreSortedArray(int arr[], int n)\n{\n        for (int i = 0; i < n; i++) {\n                if (arr[i] > arr[i + 1]) {\n                        reverse(arr, arr+i+1);\n                        reverse(arr + i + 1, arr + n);\n                        reverse(arr, arr + n);\n                }\n        }\n}\nvoid printArray(int arr[], int size)\n{\n        for (int i = 0; i < size; i++)\n                cout << arr[i] << \" \";\n}", "118": "int findStartIndexOfArray(int arr[], int low,int high)\n{\n        if (low>high)\n        {\n                return -1;\n        }\n        if (low == high)\n        {\n                return low;\n        }\n        int mid = low + (high-low)/2;\n        if(arr[mid] > arr[mid+1])\n                return mid+1;\n        if(arr[mid-1] > arr[mid])\n                return mid;\n        if(arr[low] > arr[mid])\n                return findStartIndexOfArray(arr, low, mid-1);\n        else\n                return findStartIndexOfArray(arr, mid+1, high);\n}\nvoid restoreSortedArray(int arr[], int n)\n{\n        if (arr[0] < arr[n-1])\n                return;\n        int start = findStartIndexOfArray(arr, 0, n-1);\n        reverse(arr, arr + start);\n        reverse(arr + start, arr + n);\n        reverse(arr, arr + n);\n}\nvoid printArray(int arr[], int size)\n{\n        for (int i = 0; i < size; i++)\n                cout << arr[i] << \" \";\n}", "119": "void leftrotate(string &s, int d)\n{\n        reverse(s.begin(), s.begin()+d);\n        reverse(s.begin()+d, s.end());\n        reverse(s.begin(), s.end());\n}\nvoid rightrotate(string &s, int d)\n{\n leftrotate(s, s.length()-d);\n}", "120": "void insertNode(struct Node** start, int value)\n{\n        if (*start == NULL)\n        {\n                struct Node* new_node = new Node;\n                new_node->data = value;\n                new_node->next = new_node->prev = new_node;\n                *start = new_node;\n                return;\n        }\n        Node *last = (*start)->prev;\n        struct Node* new_node = new Node;\n        new_node->data = value;\n        new_node->next = *start;\n        (*start)->prev = new_node;\n        new_node->prev = last;\n        last->next = new_node;\n}\nvoid displayList(struct Node* start)\n{\n        struct Node *temp = start;\n        while (temp->next != start)\n        {\n                printf(\"%d \", temp->data);\n                temp = temp->next;\n        }\n        printf(\"%d \", temp->data);\n}\nint searchList(struct Node* start, int search)\n{\n        struct Node *temp = start;\n        int count=0,flag=0,value;\n        if(temp == NULL)\n                return -1;\n        else\n        {\n                while(temp->next != start)\n                {\n                        count++;\n                        if(temp->data == search)\n                        {\n                                flag = 1;\n                                count--;\n                                break;\n                        }\n                        temp = temp->next; \n                }\n                if(temp->data == search)\n                {\n                        count++;\n                        flag = 1;\n                }\n                if(flag == 1)\n                        cout<<\"\\n\"<<search <<\" found at location \"<<\n                                                                                        count<<endl;\n                else\n                        cout<<\"\\n\"<<search <<\" not found\"<<endl;\n        }\n}", "121": "Node* getNode(int data)\n{\n        Node* newNode = (Node*)malloc(sizeof(Node));\n        newNode->data = data;\n        return newNode;\n}\nvoid insertEnd(Node** head, Node* new_node)\n{\n        if (*head == NULL) {\n                new_node->next = new_node->prev = new_node;\n                *head = new_node;\n                return;\n        }\n        Node* last = (*head)->prev;\n        new_node->next = *head;\n        (*head)->prev = new_node;\n        new_node->prev = last;\n        last->next = new_node;\n}\nNode* reverse(Node* head)\n{\n        if (!head)\n                return NULL;\n        Node* new_head = NULL;\n        Node* last = head->prev;\n        Node *curr = last, *prev;\n        while (curr->prev != last) {\n                prev = curr->prev;\n                insertEnd(&new_head, curr);\n                curr = prev;\n        }\n        insertEnd(&new_head, curr);\n        return new_head;\n}\nvoid display(Node* head)\n{\n        if (!head)\n                return;\n        Node* temp = head;\n        cout << \"Forward direction: \";\n        while (temp->next != head) {\n                cout << temp->data << \" \";\n                temp = temp->next;\n        }\n        cout << temp->data;\n        Node* last = head->prev;\n        temp = last;\n        cout << \"\\nBackward direction: \";\n        while (temp->prev != last) {\n                cout << temp->data << \" \";\n                temp = temp->prev;\n        }\n        cout << temp->data;\n}", "122": "void addEdge(int u,int v)\n{\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n}\nvoid dfs(int cur, int prev)\n{\n        parent[cur] = prev;\n        depth[cur] = depth[prev] + 1;\n        for (int i=0; i<adj[cur].size(); i++)\n                if (adj[cur][i] != prev)\n                        dfs(adj[cur][i],cur);\n}\nvoid preprocess()\n{\n        depth[0] = -1;\n        dfs(1,0);\n}\nint LCANaive(int u,int v)\n{\n        if (u == v) return u;\n        if (depth[u] > depth[v])\n                swap(u, v);\n        v = parent[v];\n        return LCANaive(u,v);\n}", "123": "void addEdge(int u,int v)\n{\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n}\nint LCANaive(int u,int v)\n{\n        if (u == v) return u;\n        if (depth[u] > depth[v])\n                swap(u,v);\n        v = parent[v];\n        return LCANaive(u,v);\n}\nvoid dfs(int cur, int prev)\n{\n        depth[cur] = depth[prev] + 1;\n        parent[cur] = prev;\n        if (depth[cur] % block_sz == 0)\n                jump_parent[cur] = parent[cur];\n        else\n                jump_parent[cur] = jump_parent[prev];\n        for (int i = 0; i<adj[cur].size(); ++i)\n                if (adj[cur][i] != prev)\n                        dfs(adj[cur][i], cur);\n}\nint LCASQRT(int u, int v)\n{\n        while (jump_parent[u] != jump_parent[v])\n        {\n                if (depth[u] > depth[v])\n                        swap(u,v);\n                v = jump_parent[v];\n        }\n        return LCANaive(u,v);\n}\nvoid preprocess(int height)\n{\n        block_sz = sqrt(height);\n        depth[0] = -1;\n        dfs(1, 0);\n}", "124": "int find_permutations(vector<int>& arr)\n{\n        int cnt = 0;\n        int max_ind = -1, min_ind = 10000000;\n        int n = arr.size();\n        unordered_map<int, int> index_of;\n        for (int i = 0; i < n; i++) {\n                index_of[arr[i]] = i + 1;\n        }\n        for (int i = 1; i <= n; i++) {\n                max_ind = max(max_ind, index_of[i]);\n                min_ind = min(min_ind, index_of[i]);\n                if (max_ind - min_ind + 1 == i)\n                        cnt++;\n        }\n        return cnt;\n}", "125": "Data point is missing", "126": "ll int countOfNum(ll int n, ll int a, ll int b)\n{\n        ll int cnt_of_a, cnt_of_b, cnt_of_ab, sum;\n        cnt_of_a = n / a;\n        cnt_of_b = n / b;\n        sum = cnt_of_b + cnt_of_a;\n        cnt_of_ab = n / (a * b);\n        sum = sum - cnt_of_ab;\n        return sum;\n}\nll int sumOfNum(ll int n, ll int a, ll int b)\n{\n        ll int i;\n        ll int sum = 0;\n        set<ll int> ans;\n        for (i = a; i <= n; i = i + a) {\n                ans.insert(i);\n        }\n        for (i = b; i <= n; i = i + b) {\n                ans.insert(i);\n        }\n        for (auto it = ans.begin();\n                it != ans.end(); it++) {\n                sum = sum + *it;\n        }\n        return sum;\n}", "127": "void maximumArea(int l, int b, int x, int y)\n{\n        int left, right, above, below;\n        left = x * b;\n        right = (l - x - 1) * b;\n        above = l * y;\n        below = (b - y - 1) * l;\n        cout << max(max(left, right),\n                                max(above, below));\n}", "128": "void precompute()\n{\n        F[1] = 2;\n        F[2] = 3;\n        F[3] = 4;\n        for (int i = 4; i < N; i++)\n                F[i] = (F[i - 1] + F[i - 2]) % MOD;\n}", "129": "double get(double L, double R)\n{\n        double x = 1.0 / L;\n        double y = 1.0 / (R + 1.0);\n        return (x - y);\n}", "130": "int consecutiveOnes(int x)\n{\n        int p = 0;\n        while (x > 0) {\n                if (x % 2 == 1 and p == 1)\n                        return true;\n                p = x % 2;\n                x /= 2;\n        }\n        return false;\n}\nvoid preCompute()\n{\n        for (int i = 0; i <= MAX; i++) {\n                if (!consecutiveOnes(i))\n                        v.push_back(i);\n        }\n}\nint nextValid(int n)\n{\n        int it = upper_bound(v.begin(),\n                                                v.end(), n)\n                        - v.begin();\n        int val = v[it];\n        return val;\n}\nvoid performQueries(int queries[], int q)\n{\n        for (int i = 0; i < q; i++)\n                cout << nextValid(queries[i]) << \"\\n\";\n}", "131": "int changeToOnes(string str)\n{\n        int i, l, ctr = 0;\n        l = str.length();\n        for (i = l - 1; i >= 0; i--) {\n                if (str[i] == '1')\n                        ctr++;\n                else\n                        break;\n        }\n        return l - ctr;\n}\nstring removeZeroesFromFront(string str)\n{\n        string s;\n        int i = 0;\n        while (i < str.length() && str[i] == '0')\n                i++;\n        if (i == str.length())\n                s = \"0\";\n        else\n                s = str.substr(i, str.length() - i);\n        return s;\n}", "132": "int getCount(int a[], int n)\n{\n        int gcd = 0;\n        for (int i = 0; i < n; i++)\n                gcd = __gcd(gcd, a[i]);\n        int cnt = 0;\n        for (int i = 1; i * i <= gcd; i++) {\n                if (gcd % i == 0) {\n                        if (i * i == gcd)\n                                cnt++;\n                        else\n                                cnt += 2;\n                }\n        }\n        return cnt;\n}", "133": "int MinDeletion(int a[], int n)\n{\n        unordered_map<int, int> map;\n        for (int i = 0; i < n; i++)\n                map[a[i]]++;\n        int ans = 0;\n        for (auto i : map) {\n                int x = i.first;\n                int frequency = i.second;\n                if (x <= frequency) {\n                        ans += (frequency - x);\n                }\n                else\n                        ans += frequency;\n        }\n        return ans;\n}", "134": "int maxCountAB(string s[], int n)\n{\n        int A = 0, B = 0, BA = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n                string S = s[i];\n                int L = S.size();\n                for (int j = 0; j < L - 1; j++) {\n                        if (S.at(j) == 'A' &&\n                                                S.at(j + 1) == 'B') {\n                                ans++;\n                        }\n                }\n                if (S.at(0) == 'B' && S.at(L - 1) == 'A')\n                        BA++;\n                else if (S.at(0) == 'B')\n                        B++;\n                else if (S.at(L - 1) == 'A')\n                        A++;\n        }\n        if (BA == 0)\n                ans += min(B, A);\n        else if (A + B == 0)\n                ans += BA - 1;\n        else\n                ans += BA + min(B, A);\n        return ans;\n}", "135": "int MinOperations(int n, int x, int* arr)\n{\n        int total = 0;\n        for (int i = 0; i < n; ++i) {\n                if (arr[i] > x) {\n                        int difference = arr[i] - x;\n                        total = total + difference;\n                        arr[i] = x;\n                }\n        }\n        for (int i = 1; i < n; ++i) {\n                int LeftNeigbouringSum = arr[i] + arr[i - 1];\n                if (LeftNeigbouringSum > x) {\n                        int current_diff = LeftNeigbouringSum - x;\n                        arr[i] = max(0, arr[i] - current_diff);\n                        total = total + current_diff;\n                }\n        }\n        return total;\n}", "136": "void findNumbers(int arr[], int n)\n        {\n                int sumN = (n * (n + 1)) / 2;\n                int sumSqN = (n * (n + 1) * (2 * n + 1)) / 6;\n                int sum = 0, sumSq = 0, i;\n                for (i = 0; i < n; i++) {\n                        sum += arr[i];\n                        sumSq = sumSq + (pow(arr[i], 2));\n                }\n                int B = (((sumSq - sumSqN) / (sum - sumN)) + sumN - sum) / 2;\n                int A = sum - sumN + B;\n                cout << \"A = \" ;\n                cout << A << endl;\n                cout << \"B = \" ;\n                cout << B << endl;\n        }", "137": "bool is_prefix(string temp, string str)\n{\n        if (temp.length() < str.length())\n                return 0;\n        else {\n                for (int i = 0;\n                        i < str.length(); i++) {\n                        if (str[i] != temp[i])\n                                return 0;\n                }\n                return 1;\n        }\n}\nstring lexicographicallyString( string input[], int n, string str)\n{\n        sort(input, input + n);\n        for (int i = 0; i < n; i++) {\n                string temp = input[i];\n                if (is_prefix(temp, str)) {\n                        return temp;\n                }\n        }\n        return \"-1\";\n}", "138": "void Rearrange(int arr[], int K, int N)\n{\n        int ans[N + 1];\n        int f = -1;\n        for (int i = 0; i < N; i++) {\n                ans[i] = -1;\n        }\n        K = find(arr, arr + N, K) - arr;\n        vector<int> smaller, greater;\n        for (int i = 0; i < N; i++) {\n                if (arr[i] < arr[K])\n                        smaller.push_back(arr[i]);\n                else if (arr[i] > arr[K])\n                        greater.push_back(arr[i]);\n        }\n        int low = 0, high = N - 1;\n        while (low <= high) {\n                int mid = (low + high) / 2;\n                if (mid == K) {\n                        ans[mid] = arr[K];\n                        f = 1;\n                        break;\n                }\n                else if (mid < K) {\n                        if (smaller.size() == 0) {\n                                break;\n                        }\n                        ans[mid] = smaller.back();\n                        smaller.pop_back();\n                        low = mid + 1;\n                }\n                else {\n                        if (greater.size() == 0) {\n                                break;\n                        }\n                        ans[mid] = greater.back();\n                        greater.pop_back();\n                        high = mid - 1;\n                }\n        }\n        if (f == -1) {\n                cout << -1 << endl;\n                return;\n        }\n        for (int i = 0; i < N; i++) {\n                if (ans[i] == -1) {\n                        if (smaller.size()) {\n                                ans[i] = smaller.back();\n                                smaller.pop_back();\n                        }\n                        else if (greater.size()) {\n                                ans[i] = greater.back();\n                                greater.pop_back();\n                        }\n                }\n        }\n        for (int i = 0; i < N; i++)\n                cout << ans[i] << \" \";\n        cout << endl;\n}", "139": "void minimumK(vector<int> &arr, int M, int N)\n{\n        int good = ceil((N * 1.0)\n                                        / ((M + 1) * 1.0));\n        for (int i = 1; i <= N; i++) {\n                int K = i;\n                int candies = N;\n                int taken = 0;\n                while (candies > 0) {\n                        taken += min(K, candies);\n                        candies -= min(K, candies);\n                        for (int j = 0; j < M; j++) {\n                                int consume = (arr[j] * candies) / 100;\n                                candies -= consume;\n                        }\n                }\n                if (taken >= good) {\n                        cout << i;\n                        return;\n                }\n        }\n}", "140": "bool check(int K, int n, int m, vector<int> arr, int good_share)\n{\n        int candies = n, taken = 0;\n        while (candies > 0) {\n                taken += min(K, candies);\n                candies -= min(K, candies);\n                for (int j = 0; j < m; j++) {\n                        int consume = (arr[j] * candies) / 100;\n                        candies -= consume;\n                }\n        }\n        return (taken >= good_share);\n}\nvoid minimumK(vector<int> &arr, int N, int M)\n{\n        int good_share = ceil((N * 1.0)\n                                                / ((M + 1) * 1.0));\n        int lo = 1, hi = N;\n        while (lo < hi) {\n                int mid = (lo + hi) / 2;\n                if (check(mid, N, M, arr, good_share)) {\n                        hi = mid;\n                }\n                else {\n                        lo = mid + 1;\n                }\n        }\n        cout << hi;\n}", "141": "void calcTotalTime(string path)\n{\n        int time = 0;\n        int x = 0, y = 0;\n        set<pair<int, int> > s;\n        for (int i = 0; i < path.size(); i++) {\n                int p = x;\n                int q = y;\n                if (path[i] == 'N')\n                        y++;\n                else if (path[i] == 'S')\n                        y--;\n                else if (path[i] == 'E')\n                        x++;\n                else if (path[i] == 'W')\n                        x--;\n                if (s.find({ p + x, q + y })\n                        == s.end()) {\n                        time += 2;\n                        s.insert({ p + x, q + y });\n                }\n                else\n                        time += 1;\n        }\n        cout << time << endl;\n}", "142": "void calcPsquare(int N)\n{\n        for (int i = 1; i * i <= N; i++)\n                psquare.push_back(i * i);\n}\nint countWays(int index, int target)\n{\n        if (target == 0)\n                return 1;\n        if (index < 0 target < 0)\n                return 0;\n        int inc = countWays( index, target - psquare[index]);\n        int exc = countWays(index - 1, target);\n        return inc + exc;\n}", "143": "int findCost(int A[], int N)\n{\n        int totalCost = 0;\n        for (int i = 0; i < N; i++) {\n                if (A[i] == 0) {\n                        A[i] = 1;\n                        totalCost += i;\n                }\n        }\n        return totalCost;\n}", "144": "static int search(vector<int> list, int num)\n{\n        int low = 0, high = list.size() - 1;\n        int ans = -1;\n        while (low <= high)\n        {\n                int mid = low + (high - low) / 2;\n                if (list[mid] <= num)\n                {\n                        ans = mid;\n                        low = mid + 1;\n                }\n                else\n                        high = mid - 1;\n        }\n        return ans;\n}\nbool isPalindrome(int n)\n{\n        int rev = 0;\n        int temp = n;\n        while (n > 0)\n        {\n                rev = rev * 10 + n % 10;\n                n /= 10;\n        }\n        return rev == temp;\n}\nint countNumbers(int L, int R, int K)\n{\n        vector<int> list;\n        for(int i = L; i <= R; i++)\n        {\n                if (isPalindrome(i))\n                {\n                        list.push_back(i);\n                }\n        }\n        int count = 0;\n        for(int i = 0; i < list.size(); i++)\n        {\n                int right_index = search(list, list[i] + K - 1);\n                if (right_index != -1)\n                        count = max(count, right_index - i + 1);\n        }\n        return count;\n}", "145": "int peakIndex(int arr[], int N)\n{\n        if (N < 3)\n                return -1;\n        int i = 0;\n        while (i + 1 < N)\n        {\n                if (arr[i + 1] < arr[i] arr[i] == arr[i + 1])\n                        break;\n                i++;\n        }\n        if (i == 0 i == N - 1)\n                return -1;\n        int ans = i;\n        while (i < N - 1)\n        {\n                if (arr[i] < arr[i + 1] arr[i] == arr[i + 1])\n                        break;\n                i++;\n        }\n        if (i == N - 1)\n                return ans;\n        return -1;\n}", "146": "void hasArrayTwoPairs(int nums[], int n, int target)\n{\n        sort(nums, nums + n);\n        for (int i = 0; i < n; i++) {\n                int x = target - nums[i];\n                int low = 0, high = n - 1;\n                while (low <= high) {\n                        int mid = low\n                                        + ((high - low) / 2);\n                        if (nums[mid] > x) {\n                                high = mid - 1;\n                        }\n                        else if (nums[mid] < x) {\n                                low = mid + 1;\n                        }\n                        else {\n                                if (mid == i) {\n                                        if ((mid - 1 >= 0) && nums[mid - 1] == x) {\n                                                cout << nums[i] << \", \";\n                                                cout << nums[mid - 1];\n                                                return;\n                                        }\n                                        if ((mid + 1 < n) && nums[mid + 1] == x) {\n                                                cout << nums[i] << \", \";\n                                                cout << nums[mid + 1];\n                                                return;\n                                        }\n                                        break;\n                                }\n                                else {\n                                        cout << nums[i] << \", \";\n                                        cout << nums[mid];\n                                        return;\n                                }\n                        }\n                }\n        }\n        cout << -1;\n}", "147": "TreeNode* newNode(int data)\n{\n        TreeNode* Node = new TreeNode();\n        Node->data = data;\n        Node->left = NULL;\n        Node->right = NULL;\n        return (Node);\n}\npair<int, int> sumofsubtree(TreeNode* root)\n{\n        pair<int, int> p = make_pair(1, 0);\n        if (root->left) {\n                pair<int, int> ptemp\n                        = sumofsubtree(root->left);\n                p.second += ptemp.first\n                                        + ptemp.second;\n                p.first += ptemp.first;\n        }\n        if (root->right) {\n                pair<int, int> ptemp\n                        = sumofsubtree(root->right);\n                p.second += ptemp.first\n                                        + ptemp.second;\n                p.first += ptemp.first;\n        }\n        root->size = p.first;\n        return p;\n}\nvoid distance(TreeNode* root, int target, int distancesum, int n)\n{\n        if (root->data == target) {\n                sum = distancesum;\n        }\n        if (root->left) {\n                int tempsum = distancesum\n                                        - root->left->size\n                                        + (n - root->left->size);\n                distance(root->left, target, tempsum, n);\n        }\n        if (root->right) {\n                int tempsum = distancesum\n                                        - root->right->size\n                                        + (n - root->right->size);\n                distance(root->right, target, tempsum, n);\n        }\n}", "148": "int delCost(string s, int cost[], int l1, int l2)\n{\n        bool visited[l1];\n        memset(visited, 0, sizeof(visited));\n        int ans = 0;\n        for (int i = 0; i < l1; i++)\n        {\n                if (visited[i])\n                {\n                        continue;\n                }\n                int maxDel = 0;\n                int totalCost = 0;\n                visited[i] = 1;\n                for (int j = i; j < l1; j++)\n                {\n                        if (s[i] == s[j])\n                        {\n                                maxDel = max(maxDel, cost[j]);\n                                totalCost += cost[j];\n                                visited[j] = 1;\n                        }\n                }\n                ans += totalCost - maxDel;\n        }\n        return ans;\n}", "149": "int delCost(string s, int cost[])\n{\n        int ans = 0;\n        map<char, int> forMax;\n        map<char, int> forTot;\n        for (int i = 0; i < s.length(); i++) {\n                if (!forMax[s[i]]) {\n                        forMax[s[i]] = cost[i];\n                }\n                else {\n                        forMax[s[i]] = max(cost[i], forMax[s[i]]);\n                }\n                if (!forTot[s[i]]) {\n                        forTot[s[i]] = cost[i];\n                }\n                else {\n                        forTot[s[i]] = forTot[s[i]] + cost[i];\n                }\n        }\n        for (auto i : forMax) {\n                ans += forTot[i.first] - i.second;\n        }\n        return ans;\n}", "150": "int findClosest(int N, int target)\n{\n        int closest = -1;\n        int diff = INT_MAX;\n        for (int i = 1; i <= sqrt(N); i++) {\n                if (N % i == 0) {\n                        if (N / i == i) {\n                                if (abs(target - i) < diff) {\n                                        diff = abs(target - i);\n                                        closest = i;\n                                }\n                        }\n                        else {\n                                if (abs(target - i) < diff) {\n                                        diff = abs(target - i);\n                                        closest = i;\n                                }\n                                if (abs(target - N / i) < diff) {\n                                        diff = abs(target - N / i);\n                                        closest = N / i;\n                                }\n                        }\n                }\n        }\n        cout << closest;\n}", "151": "void computeDivisors()\n{\n        for (int i = 1; i <= MAX; i++) {\n                for (int j = i; j <= MAX; j += i) {\n                        divisors[j].push_back(i);\n                }\n        }\n}\nint getClosest(int val1, int val2, int target)\n{\n        if (target - val1 >= val2 - target)\n                return val2;\n        else\n                return val1;\n}\nint findClosest(vector<int>& arr, int n, int target)\n{\n        if (target <= arr[0])\n                return arr[0];\n        if (target >= arr[n - 1])\n                return arr[n - 1];\n        int i = 0, j = n, mid = 0;\n        while (i < j) {\n                mid = (i + j) / 2;\n                if (arr[mid] == target)\n                        return arr[mid];\n                if (target < arr[mid]) {\n                        if (mid > 0 && target > arr[mid - 1])\n                                return getClosest(arr[mid - 1], arr[mid], target);\n                        j = mid;\n                }\n                else {\n                        if (mid < n - 1 && target < arr[mid + 1])\n                                return getClosest(arr[mid], arr[mid + 1], target);\n                        i = mid + 1;\n                }\n        }\n        return arr[mid];\n}\nvoid printClosest(int N, int X)\n{\n        computeDivisors();\n        int ans\n                = findClosest(divisors[N], divisors[N].size(), X);\n        cout << ans;\n}", "152": "int countTriplets(int* arr, int N)\n{\n        vector<int> zero_i;\n        vector<int> one_i;\n        unordered_map<int, int> mp;\n        for (int i = 0; i < N; i++) {\n                if (arr[i] == 0)\n                        zero_i.push_back(i + 1);\n                else if (arr[i] == 1)\n                        one_i.push_back(i + 1);\n                else\n                        mp[i + 1] = 1;\n        }\n        int total = zero_i.size()\n                                * one_i.size() * mp.size();\n        for (int i = 0; i < zero_i.size(); i++) {\n                for (int j = 0; j < one_i.size(); j++) {\n                        int p = zero_i[i];\n                        int q = one_i[j];\n                        int r = 2 * p - q;\n                        if (mp[r] > 0)\n                                total--;\n                        r = 2 * q - p;\n                        if (mp[r] > 0)\n                                total--;\n                        r = (p + q) / 2;\n                        if (mp[r] > 0 && abs(r - p) == abs(r - q))\n                                total--;\n                }\n        }\n        cout << total;\n}", "153": "void checkXOR(int arr[], int N)\n{\n        if (N % 2 == 0) {\n                int xro = 0;\n                for (int i = 0; i < N; i++) {\n                        xro ^= arr[i];\n                }\n                if (xro != 0) {\n                        cout << -1 << endl;\n                        return;\n                }\n                for (int i = 0; i < N - 3; i += 2) {\n                        cout << i << \" \" << i + 1\n                                << \" \" << i + 2 << endl;\n                }\n                for (int i = 0; i < N - 3; i += 2) {\n                        cout << i << \" \" << i + 1\n                                << \" \" << N - 1 << endl;\n                }\n        }\n        else {\n                for (int i = 0; i < N - 2; i += 2) {\n                        cout << i << \" \" << i + 1 << \" \"\n                                << i + 2 << endl;\n                }\n                for (int i = 0; i < N - 2; i += 2) {\n                        cout << i << \" \" << i + 1\n                                << \" \" << N - 1 << endl;\n                }\n        }\n}", "154": "int make_array_element_even(int arr[], int N)\n{\n        int res = 0;\n        int odd_cont_seg = 0;\n        for (int i = 0; i < N; i++) {\n                if (arr[i] % 2 == 1) {\n                        odd_cont_seg++;\n                }\n                else {\n                        if (odd_cont_seg > 0) {\n                                if (odd_cont_seg % 2 == 0) {\n                                        res += odd_cont_seg / 2;\n                                }\n                                else {\n                                        res += (odd_cont_seg / 2) + 2;\n                                }\n                                odd_cont_seg = 0;\n                        }\n                }\n        }\n        if (odd_cont_seg > 0) {\n                if (odd_cont_seg % 2 == 0) {\n                        res += odd_cont_seg / 2;\n                }\n                else {\n                        res += odd_cont_seg / 2 + 2;\n                }\n        }\n        return res;\n}", "155": "int minCollectingSpeed(vector<int>& piles, int H)\n{\n        int ans = -1;\n        int low = 1, high;\n        high = *max_element(piles.begin(),\n                                                piles.end());\n        while (low <= high)\n        {\n                int K = low + (high - low) / 2;\n                int time = 0;\n                for (int ai : piles) {\n                        time += (ai + K - 1) / K;\n                }\n                if (time <= H) {\n                        ans = K;\n                        high = K - 1;\n                }\n                else {\n                        low = K + 1;\n                }\n        }\n        cout << ans;\n}", "156": "int cntDisPairs(int arr[], int N, int K)\n{\n        int cntPairs = 0;\n        sort(arr, arr + N);\n        int i = 0;\n        int j = N - 1;\n        while (i < j) {\n                if (arr[i] + arr[j] == K) {\n                        while (i < j && arr[i] == arr[i + 1]) {\n                                i++;\n                        }\n                        while (i < j && arr[j] == arr[j - 1]) {\n                                j--;\n                        }\n                        cntPairs += 1;\n                        i++;\n                        j--;\n                }\n                else if (arr[i] + arr[j] < K) {\n                        i++;\n                }\n                else {\n                        j--;\n                }\n        }\n        return cntPairs;\n}", "157": "int cntDisPairs(int arr[], int N, int K)\n{\n        int cntPairs = 0;\n        unordered_map<int, int> cntFre;\n        for (int i = 0; i < N; i++) {\n                cntFre[arr[i]]++;\n        }\n        for (auto it : cntFre) {\n                int i = it.first;\n                if (2 * i == K) {\n                        if (cntFre[i] > 1)\n                                cntPairs += 2;\n                }\n                else {\n                        if (cntFre[K - i]) {\n                                cntPairs += 1;\n                        }\n                }\n        }\n        cntPairs = cntPairs / 2;\n        return cntPairs;\n}", "158": "void push(Node** head_ref, int new_data)\n{\n        Node* new_node\n                = (Node*)malloc(sizeof(struct Node));\n        new_node->data = new_data;\n        new_node->prev = NULL;\n        new_node->next = (*head_ref);\n        if ((*head_ref) != NULL) {\n                (*head_ref)->prev = new_node;\n        }\n        (*head_ref) = new_node;\n}\nint search(Node** head_ref, int x)\n{\n        Node* temp = *head_ref;\n        int pos = 0;\n        while (temp->data != x && temp->next != NULL) {\n                pos++;\n                temp = temp->next;\n        }\n        if (temp->data != x)\n                return -1;\n        return (pos + 1);\n}", "159": "void longestSubsequence(int N, int Q, int arr[], int Queries[][2])\n{\n        for (int i = 0; i < Q; i++) {\n                int x = Queries[i][0];\n                int y = Queries[i][1];\n                arr[x - 1] = y;\n                int count = 1;\n                for (int j = 1; j < N; j++) {\n                        if (arr[j] != arr[j - 1]) {\n                                count += 1;\n                        }\n                }\n                cout << count << ' ';\n        }\n}", "160": "void longestSubsequence(int N, int Q, int arr[], int Queries[][2])\n{\n        int count = 1;\n        for (int i = 1; i < N; i++) {\n                if (arr[i] != arr[i - 1]) {\n                        count += 1;\n                }\n        }\n        for (int i = 0; i < Q; i++) {\n                int x = Queries[i][0];\n                int y = Queries[i][1];\n                if (x > 1) {\n                        if (arr[x - 1] != arr[x - 2]) {\n                                count -= 1;\n                        }\n                        if (arr[x - 2] != y) {\n                                count += 1;\n                        }\n                }\n                if (x < N) {\n                        if (arr[x] != arr[x - 1]) {\n                                count -= 1;\n                        }\n                        if (y != arr[x]) {\n                                count += 1;\n                        }\n                }\n                cout << count << ' ';\n                arr[x - 1] = y;\n        }\n}", "161": "void sum(int arr[], int n)\n{\n        map<int, vector<int> > mp;\n        for (int i = 0; i < n; i++) {\n                mp[arr[i]].push_back(i);\n        }\n        int ans[n];\n        for (int i = 0; i < n; i++) {\n                int sum = 0;\n                for (auto it : mp[arr[i]]) {\n                        sum += abs(it - i);\n                }\n                ans[i] = sum;\n        }\n        for (int i = 0; i < n; i++) {\n                cout << ans[i] << \" \";\n        }\n        return;\n}", "162": "void rearrangeArray(int A[], int B[], int N, int K)\n{\n        sort(B, B + N, greater<int>());\n        bool flag = true;\n        for (int i = 0; i < N; i++) {\n                if (A[i] + B[i] > K) {\n                        flag = false;\n                        break;\n                }\n        }\n        if (!flag) {\n                cout << \"-1\" << endl;\n        }\n        else {\n                for (int i = 0; i < N; i++) {\n                        cout << B[i] << \" \";\n                }\n        }\n}", "163": "bool isinRange(int board[][N])\n{\n        for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                        if (board[i][j] <= 0 board[i][j] > 9) {\n                                return false;\n                        }\n                }\n        }\n        return true;\n}\nbool isValidSudoku(int board[][N])\n{\n        if (isinRange(board) == false) {\n                return false;\n        }\n        bool unique[N + 1];\n        for (int i = 0; i < N; i++) {\n                memset(unique, false,\n                        sizeof(unique));\n                for (int j = 0; j < N; j++) {\n                        int Z = board[i][j];\n                        if (unique[Z]) {\n                                return false;\n                        }\n                        unique[Z] = true;\n                }\n        }\n        for (int i = 0; i < N; i++) {\n                memset(unique, false,\n                        sizeof(unique));\n                for (int j = 0; j < N; j++) {\n                        int Z = board[j][i];\n                        if (unique[Z]) {\n                                return false;\n                        }\n                        unique[Z] = true;\n                }\n        }\n        for (int i = 0; i < N - 2; i += 3) {\n                for (int j = 0; j < N - 2; j += 3) {\n                        memset(unique, false,\n                                sizeof(unique));\n                        for (int k = 0; k < 3; k++) {\n                                for (int l = 0; l < 3; l++) {\n                                        int X = i + k;\n                                        int Y = j + l;\n                                        int Z = board[X][Y];\n                                        if (unique[Z]) {\n                                                return false;\n                                        }\n                                        unique[Z] = true;\n                                }\n                        }\n                }\n        }\n        return true;\n}", "164": "string conVowUpp(string& str)\n{\n        int N = str.length();\n        for (int i = 0; i < N; i++) {\n                if (str[i] == 'a' str[i] == 'e' str[i] == 'i' str[i] == 'o' str[i] == 'u') {\n                        str[i] = str[i] - 'a' + 'A';\n                }\n        }\n        return str;\n}", "165": "int zvalue(vector<int>& nums)\n{\n        int m = *max_element(nums.begin(),\n                                                nums.end());\n        int cnt = 0;\n        for (int i = 0; i <= m; i++) {\n                cnt = 0;\n                for (int j = 0; j < nums.size(); j++) {\n                        if (nums[j] >= i)\n                                cnt++;\n                }\n                if (cnt == i)\n                        return i;\n        }\n        return -1;\n}", "166": "bool palindrome(vector<int> a, int i, int j)\n{\n        while(i<j)\n        {\n                if(a[i] != a[j])\n                        return false;\n                i++;\n                j--;\n        }\n        return true;\n}\nint findSubArray(vector<int> arr, int k)\n{\n        int n= sizeof(arr)/sizeof(arr[0]);\n        for(int i=0; i<=n-k; i++){\n                if(palindrome(arr, i, i+k-1))\n                        return i;\n        }\n        return -1;\n}", "167": "bool helper(int mid)\n{\n        int cnt = 0;\n        for (auto i : mp) {\n                int temp = i.second;\n                while (temp >= mid) {\n                        temp -= mid;\n                        cnt++;\n                }\n        }\n        return cnt >= N;\n}\nint findMaximumDays(int arr[])\n{\n        for (int i = 0; i < P; i++) {\n                mp[arr[i]]++;\n        }\n        int start = 0, end = P, ans = 0;\n        while (start <= end) {\n                int mid = start\n                                + ((end - start) / 2);\n                if (mid != 0 and helper(mid)) {\n                        ans = mid;\n                        start = mid + 1;\n                }\n                else if (mid == 0) {\n                        start = mid + 1;\n                }\n                else {\n                        end = mid - 1;\n                }\n        }\n        return ans;\n}", "168": "long long int countSubarrays( int a[], int n, int k)\n{\n        int ans = 0;\n        vector<int> pref;\n        pref.push_back(0);\n        for (int i = 0; i < n; i++)\n                pref.push_back((a[i] + pref[i]) % k);\n        for (int i = 1; i <= n; i++) {\n                for (int j = i; j <= n; j++) {\n                        if ((pref[j] - pref[i - 1] + k) % k == j - i + 1) {\n                                ans++;\n                        }\n                }\n        }\n        cout << ans << ' ';\n}", "169": "long long int countSubarrays( int a[], int n, int k)\n{\n        unordered_map<int, int> cnt;\n        long long int ans = 0;\n        vector<int> pref;\n        pref.push_back(0);\n        for (int i = 0; i < n; i++)\n                pref.push_back((a[i] + pref[i]) % k);\n        cnt[0] = 1;\n        for (int i = 1; i <= n; i++) {\n                int remIdx = i - k;\n                if (remIdx >= 0) {\n                        cnt[(pref[remIdx] - remIdx % k + k) % k]--;\n                }\n                ans += cnt[(pref[i] - i % k + k) % k];\n                cnt[(pref[i] - i % k + k) % k]++;\n        }\n        cout << ans << ' ';\n}", "170": "void countRows(int mat[M][N])\n{\n int count = 0;\n int totalSum = 0;\n for (int i = 0; i < N; i++)\n {\n        for (int j = 0; j < M; j++)\n        {\n        totalSum += mat[i][j];\n        }\n }\n for (int i = 0; i < N; i++)\n {\n        int currSum = 0;\n        for (int j = 0; j < M; j++)\n        {\n        currSum += mat[i][j];\n        }\n        if (currSum > totalSum - currSum)\n        count++;\n }\n cout << count;\n}", "171": "bool isCrossed(string path)\n{\n        if (path.size() == 0)\n                return false;\n        bool ans = false;\n        set<pair<int, int> > set;\n        int x = 0, y = 0;\n        set.insert({ x, y });\n        for (int i = 0; i < path.size(); i++) {\n                if (path[i] == 'N')\n                        set.insert({ x, y++ });\n                if (path[i] == 'S')\n                        set.insert({ x, y-- });\n                if (path[i] == 'E')\n                        set.insert({ x++, y });\n                if (path[i] == 'W')\n                        set.insert({ x--, y });\n                if (set.find({ x, y })\n                        != set.end()) {\n                        ans = true;\n                        break;\n                }\n        }\n        if (ans)\n                cout << \"Crossed\";\n        else\n                cout << \"Not Crossed\";\n}", "172": "int maxWidth(int N, int M, vector<int> cost, vector<vector<int> > s)\n{\n        vector<int> adj[N];\n        for (int i = 0; i < M; i++) {\n                adj[s[i][0]].push_back( s[i][1]);\n        }\n        int result = 0;\n        queue<int> q;\n        q.push(0);\n        while (!q.empty()) {\n                int count = q.size();\n                result = max(count, result);\n                while (count--) {\n                        int temp = q.front();\n                        q.pop();\n                        for (int i = 0; i < adj[temp].size(); i++) {\n                                q.push(adj[temp][i]);\n                        }\n                }\n        }\n        return result;\n}", "173": "void SieveOfEratosthenes()\n{\n        memset(isPrime, true, sizeof(isPrime));\n        for (int p = 2; p * p <= MAX; p++) {\n                if (isPrime[p] == true) {\n                        for (int i = p * p; i <= MAX; i += p)\n                                isPrime[i] = false;\n                }\n        }\n        for (int p = 2; p <= MAX; p++)\n                if (isPrime[p])\n                        primes.push_back(p);\n}\nint prime_search(vector<int> primes, int diff)\n{\n        int low = 0;\n        int high = primes.size() - 1;\n        int res;\n        while (low <= high) {\n                int mid = (low + high) / 2;\n                if (primes[mid] == diff) {\n                        return primes[mid];\n                }\n                else if (primes[mid] < diff) {\n                        low = mid + 1;\n                }\n                else {\n                        res = primes[mid];\n                        high = mid - 1;\n                }\n        }\n        return res;\n}\nint minCost(int arr[], int n)\n{\n        SieveOfEratosthenes();\n        int res = 0;\n        for (int i = 1; i < n; i++) {\n                if (arr[i] < arr[i - 1]) {\n                        int diff = arr[i - 1] - arr[i];\n                        int closest_prime\n                                = prime_search(primes, diff);\n                        res += closest_prime;\n                        arr[i] += closest_prime;\n                }\n        }\n        return res;\n}", "174": "pair<string, int> lexico_smallest(string s1, string s2)\n{\n        map<char, int> M;\n        set<char> S;\n        pair<string, int> pr;\n        for (int i = 0; i <= s1.size() - 1; ++i) {\n                M[s1[i]]++;\n                S.insert(s1[i]);\n        }\n        for (int i = 0; i <= s2.size() - 1; ++i) {\n                M[s2[i]]--;\n        }\n        char c = s2[0];\n        int index = 0;\n        string res = \"\";\n        for (auto x : S) {\n                if (x != c) {\n                        for (int i = 1; i <= M[x]; ++i) {\n                                res += x;\n                        }\n                }\n                else {\n                        int j = 0;\n                        index = res.size();\n                        while (s2[j] == x) {\n                                j++;\n                        }\n                        if (s2[j] < c) {\n                                res += s2;\n                                for (int i = 1; i <= M[x]; ++i) {\n                                        res += x;\n                                }\n                        }\n                        else {\n                                for (int i = 1; i <= M[x]; ++i) {\n                                        res += x;\n                                }\n                                index += M[x];\n                                res += s2;\n                        }\n                }\n        }\n        pr.first = res;\n        pr.second = index;\n        return pr;\n}\nstring lexico_largest(string s1, string s2)\n{\n        pair<string, int> pr = lexico_smallest(s1, s2);\n        string d1 = \"\";\n        for (int i = pr.second - 1; i >= 0; i--) {\n                d1 += pr.first[i];\n        }\n        string d2 = \"\";\n        for (int i = pr.first.size() - 1;\n                i >= pr.second + s2.size(); --i) {\n                d2 += pr.first[i];\n        }\n        string res = d2 + s2 + d1;\n        return res;\n}", "175": "void addEdge(vector<int> v[], int x, int y)\n{\n        v[x].push_back(y);\n        v[y].push_back(x);\n}\nvoid dfs(vector<int> tree[], vector<int>& temp, int ancestor[], int u, int parent, int k)\n{\n        temp.push_back(u);\n        for (auto i : tree[u]) {\n                if (i == parent)\n                        continue;\n                dfs(tree, temp, ancestor, i, u, k);\n        }\n        temp.pop_back();\n        if (temp.size() < k) {\n                ancestor[u] = -1;\n        }\n        else {\n                ancestor[u]\n                        = temp[temp.size() - k];\n        }\n}\nvoid KthAncestor(int N, int K, int E, int edges[][2])\n{\n        vector<int> tree[N + 1];\n        for (int i = 0; i < E; i++) {\n                addEdge(tree, edges[i][0], edges[i][1]);\n        }\n        vector<int> temp;\n        int ancestor[N + 1];\n        dfs(tree, temp, ancestor, 1, 0, K);\n        for (int i = 1; i <= N; i++) {\n                cout << ancestor[i] << \" \";\n        }\n}", "176": "void build(vector<int>& sum, vector<int>& a, int l, int r, int rt)\n{\n        if (l == r) {\n                sum[rt] = a[l - 1];\n                return;\n        }\n        int m = (l + r) >> 1;\n        build(sum, a, l, m, rt << 1);\n        build(sum, a, m + 1, r, rt << 1 1);\n}\nvoid pushDown(vector<int>& sum, vector<int>& add, int rt, int ln, int rn)\n{\n        if (add[rt]) {\n                add[rt << 1] += add[rt];\n                add[rt << 1 1] += add[rt];\n                sum[rt << 1] += add[rt] * ln;\n                sum[rt << 1 1] += add[rt] * rn;\n                add[rt] = 0;\n        }\n}\nvoid update(vector<int>& sum, vector<int>& add, int L, int R, int C, int l, int r, int rt)\n{\n        if (L <= l && r <= R) {\n                sum[rt] += C * (r - l + 1);\n                add[rt] += C;\n                return;\n        }\n        int m = (l + r) >> 1;\n        pushDown(sum, add, rt, m - l + 1, r - m);\n        if (L <= m)\n                update(sum, add, L, R, C, l, m, rt << 1);\n        if (R > m)\n                update(sum, add, L, R, C, m + 1, r, rt << 1 1);\n}\nint query(vector<int>& sum, vector<int>& add, int L, int R, int l, int r, int rt)\n{\n        if (L <= l && r <= R) {\n                return sum[rt];\n        }\n        int m = (l + r) >> 1;\n        pushDown(sum, add, rt, m - l + 1, r - m);\n        int ans = 0;\n        if (L <= m)\n                ans += query(sum, add, L, R, l, m, rt << 1);\n        if (R > m)\n                ans += query(sum, add, L, R, m + 1, r, rt << 1 1);\n        return ans;\n}\nvoid sequenceMaintenance(int n, int q, vector<int>& a, vector<int>& b, int m)\n{\n        sort(a.begin(), a.end());\n        vector<int> sum, add, ans;\n        sum.assign(n << 2, 0);\n        add.assign(n << 2, 0);\n        build(sum, a, 1, n, 1);\n        for (int i = 0; i < q; i++) {\n                int l = 1, r = n, pos = -1;\n                while (l <= r) {\n                        int m = (l + r) >> 1;\n                        if (query(sum, add, m, m, 1, n, 1) >= b[i]) {\n                                r = m - 1;\n                                pos = m;\n                        }\n                        else {\n                                l = m + 1;\n                        }\n                }\n                if (pos == -1)\n                        ans.push_back(0);\n                else {\n                        ans.push_back(n - pos + 1);\n                        update(sum, add, pos, n, -m, 1, n, 1);\n                }\n        }\n        for (int i = 0; i < ans.size(); i++) {\n                cout << ans[i] << \" \";\n        }\n}", "177": "int count(string s)\n{\n        int cnt = 0;\n        for(char c : s)\n        {\n                cnt += c == '0' ? 1 : 0;\n        }\n        if (cnt % 3 != 0)\n                return 0;\n        int res = 0, k = cnt / 3, sum = 0;\n        map<int, int> mp;\n        for(int i = 0; i < s.length(); i++)\n        {\n                sum += s[i] == '0' ? 1 : 0;\n                if (sum == 2 * k && mp.find(k) != mp.end() &&\n                        i < s.length() - 1 && i > 0)\n                {\n                        res += mp[k];\n                }\n                mp[sum]++;\n        }\n        return res;\n}", "178": "int splitstring(string s)\n{\n        int n = s.length();\n        int zeros = 0;\n        for (int i = 0; i < n; i++)\n                if (s[i] == '0')\n                        zeros++;\n        if (zeros % 3 != 0)\n                return 0;\n        if (zeros == 0)\n                return ((n - 1) * (n - 2)) / 2;\n        int zerosInEachSubstring = zeros / 3;\n        int waysOfFirstCut = 0, waysOfSecondCut = 0;\n        int count = 0;\n        for (int i = 0; i < n; i++)\n        {\n                if (s[i] == '0')\n                        count++;\n                if (count == zerosInEachSubstring)\n                        waysOfFirstCut++;\n                else if (count == 2 * zerosInEachSubstring)\n                        waysOfSecondCut++;\n        }\n        return waysOfFirstCut * waysOfSecondCut;\n}", "179": "int check(string& s, int k)\n{\n        int n = s.size();\n        for (int i = 0; i < k; i++) {\n                for (int j = i; j < n; j += k) {\n                        if (s[i] != s[j])\n                                return false;\n                }\n        }\n        int c = 0;\n        for (int i = 0; i < k; i++) {\n                if (s[i] == '0')\n                        c++;\n                else\n                        c--;\n        }\n        if (c == 0)\n                return true;\n        else\n                return false;\n}", "180": "void addEdge(int a, int b)\n{\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n}\nvoid dfs(int x)\n{\n        vis[x] = true;\n        subtreeSize[x] = 1;\n        for (auto i : tree[x]) {\n                if (!vis[i]) {\n                        dfs(i);\n                        subtreeSize[x]\n                                += subtreeSize[i];\n                }\n        }\n}\nvoid countPairs(int a, int b)\n{\n        int sub = min(subtreeSize[a], subtreeSize[b]);\n        cout << sub * (n - sub)\n                << endl;\n}", "181": "int revNum(int N)\n{\n        int x = 0;\n        while (N) {\n                x = x * 10 + N % 10;\n                N = N / 10;\n        }\n        return x;\n}\nint ctNonPalin(int arr[], int N)\n{\n        int Res = 0;\n        for (int i = 0; i < N; i++) {\n                int x = revNum(arr[i]);\n                if (x == arr[i]) {\n                        continue;\n                }\n                else {\n                        Res += (arr[i] % 10 == N % 10);\n                }\n        }\n        return Res;\n}", "182": "bool isSame(string str, int n)\n{\n        map<int, int> mp;\n        for (int i = 0; i < str.length(); i++) {\n                mp[str[i] - 'a']++;\n        }\n        for (auto it : mp) {\n                if ((it.second) >= n) {\n                        return true;\n                }\n        }\n        return false;\n}", "183": "bool canTransform(string str1, string str2)\n{\n        string s1 = \"\";\n        string s2 = \"\";\n        for (char c : str1) {\n                if (c != 'C') {\n                        s1 += c;\n                }\n        }\n        for (char c : str2) {\n                if (c != 'C') {\n                        s2 += c;\n                }\n        }\n        if (s1 != s2)\n                return false;\n        int i = 0;\n        int j = 0;\n        int n = str1.length();\n        while (i < n and j < n) {\n                if (str1[i] == 'C') {\n                        i++;\n                }\n                else if (str2[j] == 'C') {\n                        j++;\n                }\n                else {\n                        if ((str1[i] == 'A' and i < j)\n                                or (str1[i] == 'B' and i > j)) {\n                                return false;\n                        }\n                        i++;\n                        j++;\n                }\n        }\n        return true;\n}\nint main()\n{\n        string str1 = \"BCCABCBCA\";\n        string str2 = \"CBACCBBAC\";\n        if (canTransform(str1, str2)) {\n                cout << \"Yes\";\n        }\n        else {\n                cout << \"No\";\n        }\n        return 0;\n}", "184": "double func(double a, double b, double c, double x)\n{\n        return a * x * x + b * x + c;\n}\ndouble findRoot(double a, double b, double c, double low, double high)\n{\n        double x;\n        while (fabs(high - low) > eps) {\n                x = (low + high) / 2;\n                if (func(a, b, c, low)\n                                * func(a, b, c, x) <= 0) {\n                        high = x;\n                }\n                else {\n                        low = x;\n                }\n        }\n        return x;\n}\nvoid solve(double a, double b, double c, double A, double B)\n{\n        if (func(a, b, c, A)\n                        * func(a, b, c, B) > 0) {\n                cout << \"No solution\";\n        }\n        else {\n                cout << fixed\n                        << setprecision(4)\n                        << findRoot(a, b, c, A, B);\n        }\n}", "185": "bool hasCoprimePair(vector<int>& arr, int n)\n{\n        for (int i = 0; i < n - 1; i++) {\n                for (int j = i + 1; j < n; j++) {\n                        if (__gcd(arr[i], arr[j]) == 1) {\n                                return true;\n                        }\n                }\n        }\n        return false;\n}", "186": "int findPermutation(unordered_set<int>& arr, int N)\n{\n        int pos = arr.size() + 1;\n        if (pos > N)\n                return 1;\n        int res = 0;\n        for (int i = 1; i <= N; i++) {\n                if (arr.find(i) == arr.end()) {\n                        if (i % pos == 0 or pos % i == 0) {\n                                arr.insert(i);\n                                res += findPermutation(arr, N);\n                                arr.erase(arr.find(i));\n                        }\n                }\n        }\n        return res;\n}", "187": "void solve(int arr[], int n, int X, int Y)\n{\n        int diff = Y - X;\n        for (int i = 0; i < n; i++) {\n                if (arr[i] != 1) {\n                        diff = diff % (arr[i] - 1);\n                }\n        }\n        if (diff == 0)\n                cout << \"Yes\";\n        else\n                cout << \"No\";\n}", "188": "int Numberofways(int n)\n{\n        int count = 0;\n        for (int a = 1; a < n; a++) {\n                for (int b = 1; b < n; b++) {\n                        int c = n - (a + b);\n                        if (a + b > c && a + c > b && b + c > a) {\n                                count++;\n                        }\n                }\n        }\n        return count;\n}", "189": "int maxsubstringLength(string S, int N)\n{\n        int arr[N];\n        for (int i = 0; i < N; i++)\n                if (S[i] == 'a' S[i] == 'e' S[i] == 'i' S[i] == 'o' S[i] == 'u')\n                        arr[i] = 1;\n                else\n                        arr[i] = -1;\n        int maxLen = 0;\n        int curr_sum = 0;\n        unordered_map<int, int> hash;\n        for (int i = 0; i < N; i++) {\n                curr_sum += arr[i];\n                if (curr_sum == 0)\n                        maxLen = max(maxLen, i + 1);\n                if (hash.find(curr_sum) != hash.end())\n                        maxLen = max(maxLen, i - hash[curr_sum]);\n                else\n                        hash[curr_sum] = i;\n        }\n        return maxLen;\n}", "190": "vector<int> findPrevious(vector<int> a, int n)\n{\n        vector<int> ps(n);\n        ps[0] = -1;\n        stack<int> Stack;\n        Stack.push(0);\n        for(int i = 1; i < n; i++)\n        {\n                while (Stack.size() > 0 &&\n                        a[Stack.top()] >= a[i])\n                        Stack.pop();\n                ps[i] = Stack.size() > 0 ?\n                                Stack.top() : -1;\n                Stack.push(i);\n        }\n        return ps;\n}\nvector<int> findNext(vector<int> a, int n)\n{\n        vector<int> ns(n);\n        ns[n - 1] = n;\n        stack<int> Stack;\n        Stack.push(n - 1);\n        for(int i = n - 2; i >= 0; i--)\n        {\n                while (Stack.size() > 0 &&\n                        a[Stack.top()] >= a[i])\n                        Stack.pop();\n                ns[i] = Stack.size() > 0 ?\n                                Stack.top() : n;\n                Stack.push(i);\n        }\n        return ns;\n}\nint findMaximumSum(vector<int> a, int n)\n{\n        vector<int> prev_smaller = findPrevious(a, n);\n        vector<int> next_smaller = findNext(a, n);\n        int max_value = 0;\n        for(int i = 0; i < n; i++)\n        {\n                max_value = max(max_value, a[i] *\n                                        (next_smaller[i] - prev_smaller[i] - 1));\n        }\n        return max_value;\n}", "191": "bool possible(ll mid, vector<ll>& a)\n{\n        ll n = a.size();\n        ll total = (n * (n - 1)) / 2;\n        ll need = (total + 1) / 2;\n        ll count = 0;\n        ll start = 0, end = 1;\n        while (end < n) {\n                if (a[end] - a[start] <= mid) {\n                        end++;\n                }\n                else {\n                        count += (end - start - 1);\n                        start++;\n                }\n        }\n        if (end == n && start < end && a[end - 1] - a[start] <= mid) {\n                ll t = end - start - 1;\n                count += (t * (t + 1) / 2);\n        }\n        if (count >= need)\n                return true;\n        else\n                return false;\n}\nll findMedian(vector<ll>& a)\n{\n        ll n = a.size();\n        ll low = 0, high = a[n - 1] - a[0];\n        while (low <= high) {\n                ll mid = (low + high) / 2;\n                if (possible(mid, a))\n                        high = mid - 1;\n                else\n                        low = mid + 1;\n        }\n        return high + 1;\n}", "192": "void FindMinimumDistance()\n{\n        queue<pair<int, int> > q;\n        q.push({ x, y });\n        mat[x][y] = 0;\n        while (!q.empty()) {\n                x = q.front().first;\n                y = q.front().second;\n                q.pop();\n                for (int i = 0; i < 8; i++) {\n                        int a = x + dx[i];\n                        int b = y + dy[i];\n                        if (a < 0 a >= r b >= c b < 0)\n                                continue;\n                        if (mat[a][b] == 0) {\n                                mat[a][b] = mat[x][y] + 1;\n                                q.push({ a, b });\n                        }\n                }\n        }\n}", "193": "void addEdge(int u, int v)\n{\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n}\nvoid dfs1(int cur, int par)\n{\n        for (auto u : adj[cur]) {\n                if (u != par) {\n                        dfs1(u, cur);\n                        height[cur]\n                                = max(height[cur], height[u]);\n                }\n        }\n        height[cur] += 1;\n}\nvoid dfs2(int cur, int par)\n{\n        int max1 = 0;\n        int max2 = 0;\n        for (auto u : adj[cur]) {\n                if (u != par) {\n                        if (height[u] >= max1) {\n                                max2 = max1;\n                                max1 = height[u];\n                        }\n                        else if (height[u] > max2) {\n                                max2 = height[u];\n                        }\n                }\n        }\n        int sum = 0;\n        for (auto u : adj[cur]) {\n                if (u != par) {\n                        sum = ((max1 == height[u]) ? max2 : max1);\n                        if (max1 == height[u])\n                                dist[u]\n                                        = 1 + max(1 + max2, dist[cur]);\n                        else\n                                dist[u]\n                                        = 1 + max(1 + max1, dist[cur]);\n                        dfs2(u, cur);\n                }\n        }\n}", "194": "void countPairs(int N, int arr[])\n{\n        int count = 0;\n        for(int i = 0; i < N; i++)\n        {\n                if (i == arr[arr[i] - 1] - 1)\n                {\n                        count++;\n                }\n        }\n        cout << (count / 2) << endl;\n}", "195": "int minOperations(string S, int K)\n{\n        int ans = 0;\n        for (int i = 0; i < K; i++) {\n                int zero = 0, one = 0;\n                for (int j = i;\n                        j < S.size(); j += K) {\n                        if (S[j] == '0')\n                                zero++;\n                        else\n                                one++;\n                }\n                ans += min(zero, one);\n        }\n        return ans;\n}", "196": "void UniversalSubset(vector<string> A, vector<string> B)\n{\n        int n1 = A.size();\n        int n2 = B.size();\n        vector<string> res;\n        int A_fre[n1][26];\n        for (int i = 0; i < n1; i++) {\n                for (int j = 0; j < 26; j++)\n                        A_fre[i][j] = 0;\n        }\n        for (int i = 0; i < n1; i++) {\n                for (int j = 0; j < A[i].size(); j++) {\n                        A_fre[i][A[i][j] - 'a']++;\n                }\n        }\n        int B_fre[26] = { 0 };\n        for (int i = 0; i < n2; i++) {\n                int arr[26] = { 0 };\n                for (int j = 0; j < B[i].size(); j++) {\n                        arr[B[i][j] - 'a']++;\n                        B_fre[B[i][j] - 'a']\n                                = max(B_fre[B[i][j] - 'a'], arr[B[i][j] - 'a']);\n                }\n        }\n        for (int i = 0; i < n1; i++) {\n                int flag = 0;\n                for (int j = 0; j < 26; j++) {\n                        if (A_fre[i][j] < B_fre[j]) {\n                                flag = 1;\n                                break;\n                        }\n                }\n                if (flag == 0)\n                        res.push_back(A[i]);\n        }\n        if (res.size()) {\n                for (int i = 0; i < res.size(); i++) {\n                        for (int j = 0; j < res[i].size(); j++)\n                                cout << res[i][j];\n                }\n                cout << \" \";\n        }\n        else\n                cout << \"-1\";\n}", "197": "void findPair(int a[], int n)\n{\n int min_dist = INT_MAX;\n int index_a = -1, index_b = -1;\n for (int i = 0; i < n; i++)\n {\n        for (int j = i + 1; j < n; j++)\n        {\n        if (j - i < min_dist)\n        {\n                if (a[i] % a[j] == 0 a[j] % a[i] == 0)\n                {\n                min_dist = j - i;\n                index_a = i;\n                index_b = j;\n                }\n        }\n        }\n }\n if (index_a == -1)\n {\n        cout << (\"-1\");\n }\n else\n {\n        cout << \"(\" << a[index_a] << \", \" << a[index_b] << \")\";\n }\n}", "198": "void printNum(int L, int R)\n{\n        for (int i = L; i <= R; i++) {\n                int temp = i;\n                int c = 10;\n                int flag = 0;\n                while (temp > 0) {\n                        if (temp % 10 >= c) {\n                                flag = 1;\n                                break;\n                        }\n                        c = temp % 10;\n                        temp /= 10;\n                }\n                if (flag == 0)\n                        cout << i << \" \";\n        }\n}", "199": "int findMissing(int arr[], int left, int right, int diff)\n{\n        if (right <= left)\n                return INT_MAX;\n        int mid = left + (right - left) / 2;\n        if (arr[mid + 1] - arr[mid] != diff)\n                return (arr[mid] + diff);\n        if (mid > 0 && arr[mid] - arr[mid - 1] != diff)\n                return (arr[mid - 1] + diff);\n        if (arr[mid] == arr[0] + mid * diff)\n                return findMissing(arr, mid + 1, right, diff);\n        return findMissing(arr, left, mid - 1, diff);\n}\nint missingElement(int arr[], int n)\n{\n        sort(arr, arr + n);\n        int diff = (arr[n - 1] - arr[0]) / n;\n        return findMissing(arr, 0, n - 1, diff);\n}", "200": "int missingElement(int arr[], int n)\n{\n        int max_ele = arr[0];\n        int min_ele = arr[0];\n        int x = 0;\n        int d;\n        for (int i = 0; i < n; i++) {\n                if (arr[i] > max_ele)\n                        max_ele = arr[i];\n                if (arr[i] < min_ele)\n                        min_ele = arr[i];\n        }\n        d = (max_ele - min_ele) / n;\n        for (int i = 0; i < n; i++) {\n                x = x ^ arr[i];\n        }\n        for (int i = 0; i <= n; i++) {\n                x = x ^ (min_ele + (i * d));\n        }\n        return x;\n}", "201": "int power(int x, unsigned int y)\n{\n        int temp;\n        if (y == 0)\n                return 1;\n        temp = power(x, y / 2);\n        if (y % 2 == 0)\n                return temp * temp;\n        else\n                return x * temp * temp;\n}\nint nthRootSearch(int low, int high, int N, int K)\n{\n        if (low <= high) {\n                int mid = (low + high) / 2;\n                if ((power(mid, K) <= N)\n                        && (power(mid + 1, K) > N)) {\n                        return mid;\n                }\n                else if (power(mid, K) < N) {\n                        return nthRootSearch(mid + 1, high, N, K);\n                }\n                else {\n                        return nthRootSearch(low, mid - 1, N, K);\n                }\n        }\n        return low;\n}", "202": "int get_subset_count(int arr[], int K, int N)\n{\n        sort(arr, arr + N);\n        int left, right;\n        left = 0;\n        right = N - 1;\n        int ans = 0;\n        while (left <= right) {\n                if (arr[left] + arr[right] < K) {\n                        ans += 1 << (right - left);\n                        left++;\n                }\n                else {\n                        right--;\n                }\n        }\n        return ans;\n}", "203": "int minMaxDiff(int arr[], int n, int k)\n{\n        int max_adj_dif = INT_MIN;\n        for (int i = 0; i < n - 1; i++)\n                max_adj_dif\n                        = max(max_adj_dif,\n                                abs(arr[i] - arr[i + 1]));\n        if (max_adj_dif == 0)\n                return 0;\n        int best = 1;\n        int worst = max_adj_dif;\n        int mid, required;\n        while (best < worst) {\n                mid = (best + worst) / 2;\n                required = 0;\n                for (int i = 0; i < n - 1; i++) {\n                        required += (abs(arr[i] - arr[i + 1]) - 1)\n                                                / mid;\n                }\n                if (required > k)\n                        best = mid + 1;\n                else\n                        worst = mid;\n        }\n        return worst;\n}", "204": "void checkMin(int arr[], int len)\n{\n        int smallest = INT_MAX, secondSmallest = INT_MAX;\n        for (int i = 0; i < len; i++) {\n                if (arr[i] < smallest) {\n                        secondSmallest = smallest;\n                        smallest = arr[i];\n                }\n                else if (arr[i] < secondSmallest) {\n                        secondSmallest = arr[i];\n                }\n        }\n        if (2 * smallest <= secondSmallest)\n                cout << \"Yes\";\n        else\n                cout << \"No\";\n}", "205": "void createHash(set<int>& hash, int maxElement)\n{\n        int prev = 0, curr = 1;\n        hash.insert(prev);\n        hash.insert(curr);\n        while (curr <= maxElement) {\n                int temp = curr + prev;\n                hash.insert(temp);\n                prev = curr;\n                curr = temp;\n        }\n}\nvoid fibonacci(int arr[], int n)\n{\n        int max_val\n                = *max_element( arr, arr + n);\n        set<int> hash;\n        createHash(hash, max_val);\n        int minimum = INT_MAX;\n        int maximum = INT_MIN;\n        for (int i = 0; i < n; i++) {\n                if (hash.find(arr[i]) != hash.end()) {\n                        minimum = min(minimum, arr[i]);\n                        maximum = max(maximum, arr[i]);\n                }\n        }\n        cout << minimum << \", \"\n                << maximum << endl;\n}", "206": "bool isValidLen(string s, int len, int k)\n{\n        int n = s.size();\n        unordered_map<char, int> mp;\n        int right = 0;\n        while (right < len) {\n                mp[s[right]]++;\n                right++;\n        }\n        if (mp.size() <= k)\n                return true;\n        while (right < n) {\n                mp[s[right]]++;\n                mp[s[right - len]]--;\n                if (mp[s[right - len]] == 0)\n                        mp.erase(s[right - len]);\n                if (mp.size() <= k)\n                        return true;\n                right++;\n        }\n        return mp.size() <= k;\n}\nint maxLenSubStr(string s, int k)\n{\n        set<char> uni;\n        for (auto x : s)\n                uni.insert(x);\n        if (uni.size() < k)\n                return -1;\n        int n = s.size();\n        int lo = -1, hi = n + 1;\n        while (hi - lo > 1) {\n                int mid = lo + hi >> 1;\n                if (isValidLen(s, mid, k))\n                        lo = mid;\n                else\n                        hi = mid;\n        }\n        return lo;\n}", "207": "bool isSquarePossible(int arr[], int n, int l)\n{\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n                if (arr[i] >= l)\n                        cnt++;\n                if (cnt >= l)\n                        return true;\n        }\n        return false;\n}\nint maxArea(int arr[], int n)\n{\n        int l = 0, r = n;\n        int len = 0;\n        while (l <= r) {\n                int m = l + ((r - l) / 2);\n                if (isSquarePossible(arr, n, m)) {\n                        len = m;\n                        l = m + 1;\n                }\n                else\n                        r = m - 1;\n        }\n        return (len * len);\n}", "208": "bool sortby(const pair<int, int>& a, const pair<int, int>& b)\n{\n        if (a.first != b.first)\n                return a.first < b.first;\n        return (a.second < b.second);\n}\nbool kOverlap(vector<pair<int, int> > pairs, int k)\n{\n        vector<pair<int, int> > vec;\n        for (int i = 0; i < pairs.size(); i++) {\n                vec.push_back({ pairs[i].first, -1 });\n                vec.push_back({ pairs[i].second, +1 });\n        }\n        sort(vec.begin(), vec.end());\n        stack<pair<int, int> > st;\n        for (int i = 0; i < vec.size(); i++) {\n                pair<int, int> cur = vec[i];\n                if (cur.second == -1) {\n                        st.push(cur);\n                }\n                else {\n                        st.pop();\n                }\n                if (st.size() >= k) {\n                        return true;\n                }\n        }\n        return false;\n}", "209": "void insertNames(string arr[], int n)\n{\n        unordered_set<string> set;\n        for (int i = 0; i < n; i++) {\n                if (set.find(arr[i]) == set.end()) {\n                        cout << \"No\\n\";\n                        set.insert(arr[i]);\n                }\n                else {\n                        cout << \"Yes\\n\";\n                }\n        }\n}", "210": "int countLessThan(int arr[], int n, int key)\n{\n        int l = 0, r = n - 1;\n        int index = -1;\n        while (l <= r) {\n                int m = (l + r) / 2;\n                if (arr[m] < key) {\n                        l = m + 1;\n                        index = m;\n                }\n                else {\n                        r = m - 1;\n                }\n        }\n        return (index + 1);\n}\nint countGreaterThan(int arr[], int n, int key)\n{\n        int l = 0, r = n - 1;\n        int index = -1;\n        while (l <= r) {\n                int m = (l + r) / 2;\n                if (arr[m] <= key) {\n                        l = m + 1;\n                }\n                else {\n                        r = m - 1;\n                        index = m;\n                }\n        }\n        if (index == -1)\n                return 0;\n        return (n - index);\n}\nint countTriplets(int n, int* a, int* b, int* c)\n{\n        sort(a, a + n);\n        sort(b, b + n);\n        sort(c, c + n);\n        int count = 0;\n        for (int i = 0; i < n; ++i) {\n                int current = b[i];\n                int a_index = -1, c_index = -1;\n                int low = countLessThan(a, n, current);\n                int high = countGreaterThan(c, n, current);\n                count += (low * high);\n        }\n        return count;\n}", "211": "void Printksubstring(string str, int n, int k)\n{\n        int total = (n * (n + 1)) / 2;\n        if (k > total) {\n                printf(\"-1\\n\");\n                return;\n        }\n        int substring[n + 1];\n        substring[0] = 0;\n        int temp = n;\n        for (int i = 1; i <= n; i++) {\n                substring[i] = substring[i - 1] + temp;\n                temp--;\n        }\n        int l = 1;\n        int h = n;\n        int start = 0;\n        while (l <= h) {\n                int m = (l + h) / 2;\n                if (substring[m] > k) {\n                        start = m;\n                        h = m - 1;\n                }\n                else if (substring[m] < k)\n                        l = m + 1;\n                else {\n                        start = m;\n                        break;\n                }\n        }\n        int end = n - (substring[start] - k);\n        for (int i = start - 1; i < end; i++)\n                cout << str[i];\n}", "212": "int LowerInsertionPoint(int arr[], int n, int X)\n{\n        if (X < arr[0])\n                return 0;\n        else if (X > arr[n - 1])\n                return n;\n        int lowerPnt = 0;\n        int i = 1;\n        while (i < n && arr[i] < X) {\n                lowerPnt = i;\n                i = i * 2;\n        }\n        while (lowerPnt < n && arr[lowerPnt] < X)\n                lowerPnt++;\n        return lowerPnt;\n}", "213": "int LongestFibSubseq(int A[], int n)\n{\n        unordered_set<int> S(A, A + n);\n        int maxLen = 0, x, y;\n        for (int i = 0; i < n; ++i) {\n                for (int j = i + 1; j < n; ++j) {\n                        x = A[j];\n                        y = A[i] + A[j];\n                        int length = 2;\n                        while (S.find(y) != S.end()) {\n                                int z = x + y;\n                                x = y;\n                                y = z;\n                                maxLen = max(maxLen, ++length);\n                        }\n                }\n        }\n        return maxLen >= 3 ? maxLen : 0;\n}", "214": "int getCount(int M, int N)\n{\n        int count = 0;\n        if (M == 1)\n                return N;\n        if (N == 1)\n                return M;\n        if (N > M) {\n                for (int i = 1; i <= M; i++) {\n                        int numerator = N * i - N + M - i;\n                        int denominator = M - 1;\n                        if (numerator % denominator == 0) {\n                                int j = numerator / denominator;\n                                if (j >= 1 && j <= N)\n                                        count++;\n                        }\n                }\n        }\n        else {\n                for (int j = 1; j <= N; j++) {\n                        int numerator = M * j - M + N - j;\n                        int denominator = N - 1;\n                        if (numerator % denominator == 0) {\n                                int i = numerator / denominator;\n                                if (i >= 1 && i <= M)\n                                        count++;\n                        }\n                }\n        }\n        return count;\n}", "215": "bool swapElement(int arr1[], int arr2[], int n)\n{\n        int wrongIdx = 0;\n        for (int i = 1; i < n; i++) {\n                if (arr1[i] < arr1[i - 1])\n                        wrongIdx = i;\n        int maximum = INT_MIN;\n        int maxIdx = -1;\n        bool res = false;\n        for (int i = 0; i < n; i++) {\n                if (arr2[i] > maximum && arr2[i] >= arr1[wrongIdx - 1]) {\n                        if (wrongIdx + 1 <= n - 1 && arr2[i] <= arr1[wrongIdx + 1]) {\n                                maximum = arr2[i];\n                                maxIdx = i;\n                                res = true;\n                        }\n                }\n        }\n        if (res)\n                swap(arr1[wrongIdx], arr2[maxIdx]);\n        return res;\n}\nvoid getSortedArray(int arr1[], int arr2[], int n)\n{\n        if (swapElement(arr1, arr2, n))\n                for (int i = 0; i < n; i++)\n                        cout << arr1[i] << \" \";\n        else\n                cout << \"Not Possible\" << endl;\n}\nint main()\n{\n        int arr1[] = { 1, 3, 7, 4, 10 };\n        int arr2[] = { 2, 1, 6, 8, 9 };\n        int n = sizeof(arr1) / sizeof(arr1[0]);\n        getSortedArray(arr1, arr2, n);\n}\nvoid getSortedArray(int arr1[], int arr2[], int n)\n{\n        if (swapElement(arr1, arr2, n))\n                for (int i = 0; i < n; i++)\n                        cout << arr1[i] << \" \";\n        else\n                cout << \"Not Possible\" << endl;\n}", "216": "int costToBalance(string s)\n{\n        if (s.length() == 0)\n                cout << 0 << endl;\n        int ans = 0;\n        int o = 0, c = 0;\n        for (int i = 0; i < s.length(); i++) {\n                if (s[i] == '(')\n                        o++;\n                if (s[i] == ')')\n                        c++;\n        }\n        if (o != c)\n                return -1;\n        int a[s.size()];\n        if (s[0] == '(')\n                a[0] = 1;\n        else\n                a[0] = -1;\n        if (a[0] < 0)\n                ans += abs(a[0]);\n        for (int i = 1; i < s.length(); i++) {\n                if (s[i] == '(')\n                        a[i] = a[i - 1] + 1;\n                else\n                        a[i] = a[i - 1] - 1;\n                if (a[i] < 0)\n                        ans += abs(a[i]);\n        }\n        return ans;\n}", "217": "int middleOfThree(int a, int b, int c)\n{\nint middleOfThree(int a, int b, int c)\n{\n        if ((a < b && b < c) || (c < b && b < a))\n        return b;\n        else if ((b < a && a < c) || (c < a && a < b))\n        return a;\n        else\n        return c;\n}\nint main()\n{\n        int a = 20, b = 30, c = 40;\n        cout << middleOfThree(a, b, c);\n        return 0;\n}\nint middleOfThree(int a, int b, int c)\n{\n        if ((a < b && b < c) || (c < b && b < a))\n        return b;\n        else if ((b < a && a < c) || (c < a && a < b))\n        return a;\n        else\n        return c;\n}", "218": "int middleOfThree(int a, int b, int c)\n{\n        if (a > b)\n        {\n                if (b > c)\n                        return b;\n                else if (a > c)\n                        return c;\n                else\n                        return a;\n        }\n        else\n        {\n                if (a > c)\n                        return a;\n                else if (b > c)\n                        return c;\n                else\n                        return b;\n        }\n}", "219": "int middleOfThree(int a, int b, int c)\n{\n        int x = a - b;\nint y = b - c; \nint z = a - c; \n        if (x * y > 0)\n                return b;\n        else if (x * z > 0)\n                return c;\n        else\n                return a;\n}", "220": "void missing4(int arr[], int n)\n{\n        int helper[4];\n        for (int i = 0; i < n; i++) {\n                int temp = abs(arr[i]);\n                if (temp <= n)\n                        arr[temp - 1] *= (-1);\n                else if (temp > n) {\n                        if (temp % n != 0)\n                                helper[temp % n - 1] = -1;\n                        else\n                                helper[(temp % n) + n - 1] = -1;\n                }\n        }\n        for (int i = 0; i < n; i++)\n                if (arr[i] > 0)\n                        cout << (i + 1) << \" \";\n        for (int i = 0; i < 4; i++)\n                if (helper[i] >= 0)\n                        cout << (n + i + 1) << \" \";\n        return;\n}", "221": "void lexiMiddleSmallest(int K, int N)\n{\n        if (K % 2 == 0) {\n                cout << K / 2 << \" \";\n                for (int i = 0; i < N - 1; ++i) {\n                        cout << K << \" \";\n                }\n                cout << \"\\n\";\n                exit(0);\n        }\n        vector<int> a(N, (K + 1) / 2);\n        for (int i = 0; i < N / 2; ++i) {\n                if (a.back() == 1) {\n                        a.pop_back();\n                }\n                else {\n                        --a.back();\n                        while ((int)a.size() < N) {\n                                a.push_back(K);\n                        }\n                }\n        }\n        for (auto i : a) {\n                cout << i << \" \";\n        }\n        cout << \"\\n\";\n}", "222": "vector<vector<int> > transpose( vector<vector<int> > mat, int row, int col)\n{\n        vector<vector<int> > tr(\n                col, vector<int>(row));\n        for (int i = 0; i < row; i++) {\n                for (int j = 0; j < col; j++) {\n                        tr[j][i] = mat[i][j];\n                }\n        }\n        return tr;\n}\nvoid RowWiseSort(vector<vector<int> >& B)\n{\n        for (int i = 0; i < (int)B.size(); i++) {\n                sort(B[i].begin(), B[i].end());\n        }\n}\nvoid sortCol(vector<vector<int> > mat, int N, int M)\n{\n        vector<vector<int> > B\n                = transpose(mat, N, M);\n        RowWiseSort(B);\n        mat = transpose(B, M, N);\n        for (int i = 0; i < N; i++) {\n                for (int j = 0; j < M; j++) {\n                        cout << mat[i][j] << \" \";\n                }\n                cout << '\\n';\n        }\n}", "223": "void largestArea(int N, int M, int H[], int V[], int h, int v)\n{\n set<int> s1;\n set<int> s2;\n for (int i = 1; i <= N + 1; i++)\n        s1.insert(i);\n for (int i = 1; i <= M + 1; i++)\n        s2.insert(i);\n for (int i = 0; i < h; i++) {\n        s1.erase(H[i]);\n }\n for (int i = 0; i < v; i++) {\n        s2.erase(V[i]);\n }\n int list1[s1.size()];\n int list2[s2.size()];\n int i = 0;\n for (auto it1 = s1.begin(); it1 != s1.end(); it1++) \n {\n        list1[i++] = *it1;\n }\n i = 0;\n for (auto it2 = s2.begin(); it2 != s2.end(); it2++) \n {\n        list2[i++] = *it2;\n }\n sort(list1, list1 + s1.size());\n sort(list2, list2 + s2.size());\n int maxH = 0, p1 = 0, maxV = 0, p2 = 0;\n for (int j = 0; j < s1.size(); j++) {\n        maxH = max(maxH, list1[j] - p1);\n        p1 = list1[j];\n }\n for (int j = 0; j < s2.size(); j++) {\n        maxV = max(maxV, list2[j] - p2);\n        p2 = list2[j];\n }\n cout << (maxV * maxH) << endl;\n}", "224": "void findLastElement(int arr[], int N)\n{\n        sort(arr, arr + N);\n        int i = 0;\n        for (i = 1; i < N; i++) {\n                if (arr[i] - arr[i - 1] != 0 && arr[i] - arr[i - 1] != 2) {\n                        cout << \"-1\" << endl;\n                        return;\n                }\n        }\n        cout << arr[N - 1] << endl;\n}", "225": "bool checkifSorted(int A[], int B[], int N)\n{\n bool flag = false;\n for (int i = 0; i < N - 1; i++) {\n        if (A[i] > A[i + 1]) {\n        flag = true;\n        break;\n        }\n }\n if (!flag) {\n        return true;\n }\n int count = 0;\n for (int i = 0; i < N; i++) {\n        if (B[i] == 0) {\n        count++;\n        break;\n        }\n }\n for (int i = 0; i < N; i++) {\n        if (B[i] == 1) {\n        count++;\n        break;\n        }\n }\n if (count == 2) {\n        return true;\n }\n return false;\n}", "226": "void maxDivisions(int arr[], int N, int X)\n{\n        sort(arr, arr + N, greater<int>());\n        int maxSub = 0;\n        int size = 0;\n        for (int i = 0; i < N; i++) {\n                size++;\n                if (arr[i] * size >= X) {\n                        maxSub++;\n                        size = 0;\n                }\n        }\n        cout << maxSub << endl;\n}", "227": "void maxPossibleSum(int arr[], int N)\n{\n        sort(arr, arr + N);\n        int sum = 0;\n        int j = N - 3;\n        while (j >= 0)\n        {\n                sum += arr[j];\n                j -= 3;\n        }\n        cout << sum;\n}", "228": "int minSteps(string A, string B, int M, int N)\n{\n        if (A[0] > B[0])\n                return 0;\n        if (B[0] > A[0]) {\n                return 1;\n        }\n        if (M <= N && A[0] == B[0]\n                && count(A.begin(), A.end(), A[0]) == M\n                && count(B.begin(), B.end(), B[0]) == N)\n                return -1;\n        for (int i = 1; i < N; i++) {\n                if (B[i] > B[0])\n                        return 1;\n        }\n        for (int i = 1; i < M; i++) {\n                if (A[i] < A[0])\n                        return 1;\n        }\n        for (int i = 1; i < M; i++) {\n                if (A[i] > A[0]) {\n                        swap(A[i], B[0]);\n                        swap(A[0], B[0]);\n                        return 2;\n                }\n        }\n        for (int i = 1; i < N; i++) {\n                if (B[i] < B[0]) {\n                        swap(A[0], B[i]);\n                        swap(A[0], B[0]);\n                        return 2;\n                }\n        }\n        return 0;\n}", "229": "int CountMaximum(int arr[], int n, int k)\n{\n        sort(arr, arr + n);\n        int sum = 0, count = 0;\n        for (int i = 0; i < n; i++) {\n                sum += arr[i];\n                if (sum > k)\n                        break;\n                count++;\n        }\n        return count;\n}", "230": "int CountMaximum(int arr[], int n, int k)\n{\n        sort(arr, arr + n);\n        int sum = 0, count = 0;\n        for (int i = 0; i < n; i++) {\n                sum += arr[i];\n                if (sum > k)\n                        break;\n                count++;\n        }\n        return count;\n}", "231": "void swap(int* xp, int* yp)\n{\n        int temp = *xp;\n        *xp = *yp;\n        *yp = temp;\n}\nvoid selectionSort(int arr[], int n)\n{\n        int i, j, min_idx;\n        for (i = 0; i < n - 1; i++) {\n                min_idx = i;\n                for (j = i + 1; j < n; j++)\n                        if (arr[j] < arr[min_idx])\n                                min_idx = j;\n                swap(&arr[min_idx], &arr[i]);\n        }\n}\nvoid printArray(int arr[], int size)\n{\n        int i;\n        for (i = 0; i < size; i++) {\n                cout << arr[i] << \" \";\n        }\n        cout << endl;\n}", "232": "void swap(int* xp, int* yp)\n{\n        int temp = *xp;\n        *xp = *yp;\n        *yp = temp;\n}\nvoid selectionSort(int arr[], int n)\n{\n        int i, j, min_idx;\n        for (i = 0; i < n - 1; i++) {\n                min_idx = i;\n                for (j = i + 1; j < n; j++)\n                        if (arr[j] < arr[min_idx])\n                                min_idx = j;\n                swap(&arr[min_idx], &arr[i]);\n        }\n}\nvoid printArray(int arr[], int size)\n{\n        int i;\n        for (i = 0; i < size; i++) {\n                cout << arr[i] << \" \";\n        }\n        cout << endl;\n}", "233": "int getPairs(int arr[], int N, int K)\n{\n        int count = 0;\n        for (int i = 0; i < N; i++) {\n                for (int j = i + 1; j < N; j++) {\n                        if (arr[i] > K * arr[i + 1])\n                                count++;\n                }\n        }\n        cout << count;\n}", "234": "int merge(int arr[], int temp[], int l, int m, int r, int K)\n{\n        int i = l;\n        int j = m + 1;\n        int cnt = 0;\n        for (int l = 0; i <= m; i++) {\n                bool found = false;\n                while (j <= r) {\n                        if (arr[i] >= K * arr[j]) {\n                                found = true;\n                        }\n                        else\n                                break;\n                        j++;\n                }\n                if (found) {\n                        cnt += j - (m + 1);\n                        j--;\n                }\n        }\n        int k = l;\n        i = l;\n        j = m + 1;\n        while (i <= m && j <= r) {\n                if (arr[i] <= arr[j])\n                        temp[k++] = arr[i++];\n                else\n                        temp[k++] = arr[j++];\n        }\n        while (i <= m)\n                temp[k++] = arr[i++];\n        while (j <= r)\n                temp[k++] = arr[j++];\n        for (int i = l; i <= r; i++)\n                arr[i] = temp[i];\n        return cnt;\n}\nint mergeSortUtil(int arr[], int temp[], int l, int r, int K)\n{\n        int cnt = 0;\n        if (l < r) {\n                int m = (l + r) / 2;\n                cnt += mergeSortUtil(arr, temp, l, m, K);\n                cnt += mergeSortUtil(arr, temp, m + 1, r, K);\n                cnt += merge(arr, temp, l, m, r, K);\n        }\n        return cnt;\n}\nint mergeSort(int arr[], int N, int K)\n{\n        int temp[N];\n        cout << mergeSortUtil(arr, temp, 0, N - 1, K);\n}", "235": "void minRemovals(int A[], int N)\n{\n        sort(A, A + N);\n        int mx = A[N - 1];\n        int sum = 1;\n        for (int i = 0; i < N; i++) {\n                sum += A[i];\n        }\n        if (sum - mx >= mx) {\n                cout << 0 << \"\\n\";\n        }\n        else {\n                cout << 2 * mx - sum << \"\\n\";\n        }\n}", "236": "void rearrangeArray(int a[], int n)\n{\n        sort(a, a + n);\n        for (int i = 0; i < n - 1; i++) {\n                if (a[i] == i + 1) {\n                        swap(a[i], a[i + 1]);\n                }\n        }\n        if (a[n - 1] == n) {\n                swap(a[n - 1], a[n - 2]);\n        }\n        for (int i = 0; i < n; i++) {\n                cout << a[i] << \" \";\n        }\n}", "237": "bool checkStr1CanConStr2(string& str1, string& str2)\n{\n        int N = str1.length();\n        int M = str2.length();\n        set<int> st1;\n        set<int> st2;\n        int hash1[256] = { 0 };\n        for (int i = 0; i < N; i++) {\n                hash1[str1[i]]++;\n        }\n        for (int i = 0; i < N; i++) {\n                st1.insert(str1[i]);\n        }\n        for (int i = 0; i < M; i++) {\n                st2.insert(str2[i]);\n        }\n        if (st1 != st2) {\n                return false;\n        }\n        int hash2[256] = { 0 };\n        for (int i = 0; i < M; i++) {\n                hash2[str2[i]]++;\n        }\n        sort(hash1, hash1 + 256);\n        sort(hash2, hash2 + 256);\n        for (int i = 0; i < 256; i++) {\n                if (hash1[i] != hash2[i]) {\n                        return false;\n                }\n        }\n        return true;\n}", "238": "int minOperations(int arr1[], int arr2[], int i, int j, int n)\n{\n int f = 0;\n for (int i = 0; i < n; i++)\n {\n        if (arr1[i] != arr2[i])\n        f = 1;\n        break;\n }\n if (f == 0)\n        return 0;\n if (i >= n j >= n)\n        return 0;\n if (arr1[i] < arr2[j])\n        return 1 + minOperations(arr1, arr2, i + 1, j + 1, n);\n return max(minOperations(arr1, arr2, i, j + 1, n),\n                        minOperations(arr1, arr2, i + 1, j, n));\n}\nvoid minOperationsUtil(int arr[], int n)\n{\n int brr[n];\n for (int i = 0; i < n; i++)\n        brr[i] = arr[i];\n sort(brr, brr + n);\n int f = 0;\n for (int i = 0; i < n; i++)\n {\n        if (arr[i] != brr[i])\n        f = 1;\n        break;\n }\n if (f == 1)\n        cout << (minOperations(arr, brr, 0, 0, n));\n else\n        cout << \"0\";\n}", "239": "int minOperations(int arr[], int n)\n{\n        vector<pair<int, int>> vect;\n        for (int i = 0; i < n; i++) {\n                vect.push_back(make_pair(arr[i], i));\n        }\n        sort(vect.begin(), vect.end());\n        int res = 1;\n        int streak = 1;\n        int prev = vect[0].second;\n        for (int i = 1; i < n; i++) {\n                if (prev < vect[i].second) {\n                        res++;\n                        streak = max(streak, res);\n                }\n                else\n                        res = 1;\n                prev = vect[i].second;\n        }\n        return n - streak;\n}", "240": "void canTransform(string& s, string& t)\n{\n        int n = s.length();\n        vector<int> occur[26];\n        for (int x = 0; x < n; x++) {\n                char ch = s[x] - 'a';\n                occur[ch].push_back(x);\n        }\n        vector<int> idx(26, 0);\n        bool poss = true;\n        for (int x = 0; x < n; x++) {\n                char ch = t[x] - 'a';\n                if (idx[ch] >= occur[ch].size()) {\n                        poss = false;\n                        break;\n                }\n                for (int small = 0; small < ch; small++) {\n                        if (idx[small] < occur[small].size() && occur[small][idx[small]] < occur[ch][idx[ch]]) {\n                                poss = false;\n                                break;\n                        }\n                }\n                idx[ch]++;\n        }\n        if (poss) {\n                cout << \"Yes\" << endl;\n        }\n        else {\n                cout << \"No\" << endl;\n        }\n}", "241": "int getMaxSum(int i, int j, int k, int arr1[], int arr2[], int arr3[])\n{\n        int cnt = 0;\n        if (i >= n1)\n                cnt++;\n        if (j >= n2)\n                cnt++;\n        if (k >= n3)\n                cnt++;\n        if (cnt >= 2)\n                return 0;\n        if (dp[i][j][k] != -1)\n                return dp[i][j][k];\n        int ans = 0;\n        if (i < n1 && j < n2)\n                ans = max(ans,\n                                getMaxSum(i + 1, j + 1, k, arr1, arr2, arr3) + arr1[i] * arr2[j]);\n        if (i < n1 && k < n3)\n                ans = max(ans,\n                                getMaxSum(i + 1, j, k + 1, arr1, arr2, arr3) + arr1[i] * arr3[k]);\n        if (j < n2 && k < n3)\n                ans = max(ans,\n                                getMaxSum(i, j + 1, k + 1, arr1, arr2, arr3) + arr2[j] * arr3[k]);\n        dp[i][j][k] = ans;\n        return dp[i][j][k];\n}\nint maxProductSum(int arr1[], int arr2[], int arr3[])\n{\n        memset(dp, -1, sizeof(dp));\n        sort(arr1, arr1 + n1);\n        reverse(arr1, arr1 + n1);\n        sort(arr2, arr2 + n2);\n        reverse(arr2, arr2 + n2);\n        sort(arr3, arr3 + n3);\n        reverse(arr3, arr3 + n3);\n        return getMaxSum(0, 0, 0, arr1, arr2, arr3);\n}", "242": "void findTriplet(int arr[], int N)\n{\n        sort(arr, arr + N);\n        int flag = 0, i;\n        for (i = N - 1; i - 2 >= 0; i--) {\n                if (arr[i - 2] + arr[i - 1] > arr[i]) {\n                        flag = 1;\n                        break;\n                }\n        }\n        if (flag) {\n                cout << arr[i - 2] << \" \"\n                        << arr[i - 1] << \" \"\n                        << arr[i] << endl;\n        }\n        else {\n                cout << -1 << endl;\n        }\n}", "243": "int inversionCount(string& s)\n{\n        int freq[26] = { 0 };\n        int inv = 0;\n        for (int i = 0; i < s.length(); i++) {\n                int temp = 0;\n                for (int j = 0; j < int(s[i] - 'a'); j++)\n                        temp += freq[j];\n                inv += (i - temp);\n                freq[s[i] - 'a']++;\n        }\n        return inv;\n}\nbool haveRepeated(string& S1, string& S2)\n{\n        int freq[26] = { 0 };\n        for (char i : S1) {\n                if (freq[i - 'a'] > 0)\n                        return true;\n                freq[i - 'a']++;\n        }\n        for (int i = 0; i < 26; i++)\n                freq[i] = 0;\n        for (char i : S2) {\n                if (freq[i - 'a'] > 0)\n                        return true;\n                freq[i - 'a']++;\n        }\n        return false;\n}\nvoid checkToMakeEqual(string S1, string S2)\n{\n        int freq[26] = { 0 };\n        for (int i = 0; i < S1.length(); i++) {\n                freq[S1[i] - 'a']++;\n        }\n        bool flag = 0;\n        for (int i = 0; i < S2.length(); i++) {\n                if (freq[S2[i] - 'a'] == 0) {\n                        flag = true;\n                        break;\n                }\n                freq[S2[i] - 'a']--;\n        }\n        if (flag == true) {\n                cout << \"No\\n\";\n                return;\n        }\n        int invCount1 = inversionCount(S1);\n        int invCount2 = inversionCount(S2);\n        if (invCount1 == invCount2\n                || (invCount1 & 1) == (invCount2 & 1)\n                || haveRepeated(S1, S2)) {\n                cout << \"Yes\\n\";\n        }\n        else\n                cout << \"No\\n\";\n}", "244": "int numberofpairs(int arr[], int N)\n{\n        int answer = 0;\n        sort(arr, arr + N);\n        int minDiff = INT_MAX;\n        for (int i = 0; i < N - 1; i++)\n                minDiff = min(minDiff, arr[i + 1] - arr[i]);\n        for (int i = 0; i < N - 1; i++) {\n                if (arr[i + 1] - arr[i] == minDiff)\n                        answer++;\n        }\n        return answer;\n}", "245": "void sortArr(int a[], int n)\n{\n        int i, k;\n        k = (int)log2(n);\n        k = pow(2, k);\n        while (k > 0) {\n                for (i = 0; i + k < n; i++)\n                        if (a[i] > a[i + k])\n                                swap(a[i], a[i + k]);\n                k = k / 2;\n        }\n        for (i = 0; i < n; i++) {\n                cout << a[i] << \" \";\n        }\n}", "246": "void maximumSum(int arr[], int n, int k)\n{\n        int elt = n / k;\n        int sum = 0;\n        sort(arr, arr + n);\n        int count = 0;\n        int i = n - 1;\n        while (count < k) {\n                sum += arr[i];\n                i--;\n                count++;\n        }\n        count = 0;\n        i = 0;\n        while (count < k) {\n                sum += arr[i];\n                i += elt - 1;\n                count++;\n        }\n        cout << sum << \"\\n\";\n}", "247": "int findMinSum(int arr[], int K, int L, int size)\n{\n        if (K * L > size)\n                return -1;\n        int minsum = 0;\n        sort(arr, arr + size);\n        for (int i = 0; i < K; i++)\n                minsum += arr[i];\n        return minsum;\n}", "248": "void find_max_length( vector<int>& arr, int index, int sum, int k)\n{\n        sum = sum + arr[index];\n        store.push_back(arr[index]);\n        if (sum == k) {\n                if (max_length < store.size()) {\n                        max_length = store.size();\n                        ans = store;\n                }\n        }\n        for (int i = index + 1;\n                i < arr.size(); i++) {\n                if (sum + arr[i] <= k) {\n                        find_max_length(arr, i, sum, k);\n                        store.pop_back();\n                }\n                else\n                        return;\n        }\n        return;\n}\nint longestSubsequence(vector<int> arr, int n, int k)\n{\n        sort(arr.begin(), arr.end());\n        for (int i = 0; i < n; i++) {\n                if (max_length >= n - i)\n                        break;\n                store.clear();\n                find_max_length(arr, i, 0, k);\n        }\n        return max_length;\n}", "249": "int findKthSmallest(int arr[], int n, int k)\n{\n        int max = 0;\n        for (int i = 0; i < n; i++)\n        {\n                if (arr[i] > max)\n                        max = arr[i];\n        }\n        int counter[max + 1] = { 0 };\n        int smallest = 0;\n        for (int i = 0; i < n; i++)\n        {\n                counter[arr[i]]++;\n        }\n        for (int num = 1; num <= max; num++)\n        {\n                if (counter[num] > 0) {\n                        smallest += counter[num];\n                }\n                if (smallest >= k)\n                {\n                        return num;\n                }\n        }\n}", "250": "void lexNumbers(int n)\n{\n        vector<string> s;\n        for (int i = 1; i <= n; i++) {\n                s.push_back(to_string(i));\n        }\n        sort(s.begin(), s.end());\n        vector<int> ans;\n        for (int i = 0; i < n; i++)\n                ans.push_back(stoi(s[i]));\n        for (int i = 0; i < n; i++)\n                cout << ans[i] << \" \";\n}", "251": "void lexNumbers(int n)\n{\n        vector<int> sol;\n        dfs(1, n, sol);\n        cout << \"[\" << sol[0];\n        for (int i = 1; i < sol.size(); i++)\n        cout << \", \"<< sol[i]; cout << \"]\";\n}\nvoid dfs(int temp, int n, vector<int> &sol)\n{\n        if (temp > n)\n                return;\n        sol.push_back(temp);\n        dfs(temp * 10, n, sol);\n        if (temp % 10 != 9)\n                dfs(temp + 1, n, sol);\n}", "252": "void func(int a[][N])\n{\n        for (int i = 0; i < N; i++) {\n                if (i % 2 == 0) {\n                        for (int j = 0; j < N; j++) {\n                                for (int k = j + 1; k < N; ++k) {\n                                        if (a[i][j] > a[i][k]) {\n                                                int temp = a[i][j];\n                                                a[i][j] = a[i][k];\n                                                a[i][k] = temp;\n                                        }\n                                }\n                        }\n                }\n                else {\n                        for (int j = 0; j < N; j++) {\n                                for (int k = j + 1; k < N; ++k) {\n                                        if (a[i][j] < a[i][k]) {\n                                                int temp = a[i][j];\n                                                a[i][j] = a[i][k];\n                                                a[i][k] = temp;\n                                        }\n                                }\n                        }\n                }\n        }\n        for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                        printf(\"%d \", a[i][j]);\n                }\n                printf(\"\\n\");\n        }\n}", "253": "int partition(int arr[], int l, int h)\n{\n        int pivot = arr[l];\n        int i = l + 1;\n        int j = h;\n        while (i <= j) {\n                while (i <= h && arr[i] < pivot) {\n                        i++;\n                }\n                while (j > l && arr[j] > pivot) {\n                        j--;\n                }\n                if (i < j) {\n                        int temp = arr[i];\n                        arr[i] = arr[j];\n                        arr[j] = temp;\n                        i++;\n                        j--;\n                }\n                else\n                        i++;\n        }\n        arr[l] = arr[j];\n        arr[j] = pivot;\n        return j;\n}\nvoid sortArray(int arr[], int l, int h)\n{\n        if (l >= h)\n                return;\n        int pivot = partition(arr, l, h);\n        sortArray(arr, l, pivot - 1);\n        sortArray(arr, pivot + 1, h);\n}\nint findMaxIntervals(int start[], int end[], int n, int R)\n{\n        int ans = 0;\n        int prev = 0;\n        int currActive = 0;\n        int i = 0;\n        int j = 0;\n        if (start[0] > 0)\n                ans++;\n        while (i < n && j < n) {\n                if (start[i] < end[j]) {\n                        i++;\n                        currActive++;\n                }\n                else if (start[i] > end[j]) {\n                        j++;\n                        currActive--;\n                }\n                else {\n                        i++;\n                        j++;\n                }\n                if (currActive == 0) {\n                        ans++;\n                }\n        }\n        if (end[n - 1] < R)\n                ans++;\n        return ans;\n}"}, "Python": {"0": "static int minCost(cost):\n        dist = [INF for i in range(N)]\n        dist[0] = 0\n        for i in range(N):\n                for j in range(i+1, N):\n                        if dist[j] > dist[i] + cost[i][j]:\n                                dist[j] = dist[i] + cost[i][j]\n        return dist[N-1]", "1": "def numOfways(n, k):\n    p = 1\n    if k % 2 != 0:\n        p = -1\n    return (math.pow(n - 1, k) + p * (n - 1)) / n", "2": "def fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\ndef findVertices(n):\n    return fib(n + 2)", "3": "def reverse(head_ref):\n    temp = None\n    current = head_ref\n    while current != None:\n        temp = current.prev\n        current.prev = current.next\n        current.next = temp\n        current = current.prev\n    if temp != None:\n        head_ref = temp.prev\n        return head_ref\ndef merge(first, second):\n    if first == None:\n        return second\n    if second == None:\n        return first\n    if first.data < second.data:\n        first.next = merge(first.next, second)\n        first.next.prev = first\n        first.prev = None\n        return first\n    else:\n        second.next = merge(first, second.next)\n        second.next.prev = second\n        second.prev = None\n        return second\ndef sort(head):\n    if head == None or head.next == None:\n        return head\n    current = head.next\n    while current != None:\n        if current.data < current.prev.data:\n            break\n        current = current.next\n    if current == None:\n        return head\n    current.prev.next = None\n    current.prev = None\n    current = reverse(current)\n    return merge(head, current)\ndef push(head_ref, new_data):\n    new_node = Node()\n    new_node.data = new_data\n    new_node.prev = None\n    new_node.next = (head_ref)\n    if ((head_ref) != None):\n        (head_ref).prev = new_node\n    (head_ref) = new_node\n    return head_ref\ndef printList(head):\n    if head == None:\n        print(\"Doubly Linked list empty\")\n    while head != None:\n        print(head.data),\n        head = head.next", "4": "class Node:\n        def __init__(self, data):\n                self.data = data\n                self.next = None\n\ndef newNode(key):\n        temp = Node(key)\n        return temp\n\ndef printlist(head):\n        if head == None:\n                print(\"Empty List\")\n                return\n        while head != None:\n                print(head.data, end = \" \")\n                if head.next != None:\n                        print(\"-> \", end = \" \")\n                head = head.next\n        print()\n\ndef isVowel(x):\n        return (x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u')\n\ndef arrange(head):\n        newHead = head\n        latestVowel = None\n        curr = head\n        if head == None:\n                return None\n        if isVowel(head.data):\n                latestVowel = head\n        else:\n                while curr.next != None and not isVowel(curr.next.data):\n                        curr = curr.next\n                if curr.next == None:\n                        return head\n                latestVowel = newHead = curr.next\n                curr.next = curr.next.next\n                latestVowel.next = head\n        while curr != None and curr.next != None:\n                if isVowel(curr.next.data):\n                        if curr == latestVowel:\n                                latestVowel = curr = curr.next\n                        else:\n                                temp = latestVowel.next\n                                latestVowel.next = curr.next\n                                latestVowel = latestVowel.next\n                                curr.next = curr.next.next\n                                latestVowel.next = temp\n                else:\n                        curr = curr.next\n        return newHead", "5": "class Node:\n    def __init__(self, data=None, right=None, left=None):\n        self.data = data\n        self.right = right\n        self.left = left\n\ndef newNode(data):\n\ttemp = Node(data)\n\ttemp.data = data\n\ttemp.right = None\n\ttemp.left = None\n\treturn temp\n\ndef KthLargestUsingMorrisTraversal(root, k):\n\tcurr = root\n\tKlargest = None\n\tcount = 0\n\twhile (curr != None):\n\t\tif (curr.right == None):\n\t\t\tif (++count == k):\n\t\t\t\tKlargest = curr\n\t\t\tcurr = curr.left\n\t\telse:\n\t\t\tsucc = curr.right\n\t\t\twhile (succ.left != None and succ.left != curr):\n\t\t\t\tsucc = succ.left\n\t\t\tif (succ.left == None):\n\t\t\t\tsucc.left = curr\n\t\t\t\tcurr = curr.right\n\t\t\telse:\n\t\t\t\tsucc.left = None\n\t\t\t\tif (++count == k):\n\t\t\t\t\tKlargest = curr\n\t\t\t\tcurr = curr.left\n\treturn Klargest", "6": "def sortByRow(mat, n, ascending):\n        for i in range(n):\n                if ascending:\n                        mat[i].sort()\n                else:\n                        mat[i].sort(reverse=True)\ndef transpose(mat, n):\n        for i in range(n):\n                for j in range(i + 1, n):\n                        temp = mat[i][j]\n                        mat[i][j] = mat[j][i]\n                        mat[j][i] = temp\ndef sortMatRowAndColWise(mat, n):\n        sortByRow(mat, n, True)\n        transpose(mat, n)\n        sortByRow(mat, n, False)\n        transpose(mat, n)\ndef printMat(mat, n):\n        for i in range(n):\n                for j in range(n):\n                        print(mat[i][j], end=\" \")\n                print()", "7": "def sortByRow(mat, n):\n    for i in range(n):\n        mat[i].sort()\n\ndef transpose(mat, n):\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp=mat[i][j]\n            mat[i][j]=mat[j][i]\n            mat[j][i]=temp\n\ndef sortMatRowAndColWise(mat, n):\n    sortByRow(mat, n)\n    transpose(mat, n)\n    sortByRow(mat, n)\n    transpose(mat, n)\n\ndef printMat(mat, n):\n    for i in range(n):\n        for j in range(n):\n            print(mat[i][j], end=\" \")\n        print()", "8": "def doublyEven(n):\n\tarr = []\n\tfor i in range(n):\n\t\trow = []\n\t\tfor j in range(n):\n\t\t\trow.append((n*i) + j + 1)\n\t\tarr.append(row)\n\tfor i in range(n//4):\n\t\tfor j in range(n//4):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j]\n\tfor i in range(n//4):\n\t\tfor j in range(3 * (n//4)):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j]\n\tfor i in range(3 * n//4):\n\t\tfor j in range(0, n//4):\n\t\t\tarr[i][j] = (n*n+1) - arr[i][j]\n\tfor i in range(3 * n//4):\n\t\tfor j in range(3 * n//4):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j]\n\tfor i in range(n//4, 3 * n//4):\n\t\tfor j in range(n//4, 3 * n//4):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j]\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tprint(arr[i][j], end = ' ')\n\t\tprint()", "9": "def kroneckerproduct(A, B):\n    C = [[0 for i in range(len(A[0]) * len(B[0]))] for i in range(len(A) * len(B))]\n    for i in range(len(A)):\n        for k in range(len(B)):\n            for j in range(len(A[0])):\n                for l in range(len(B[0])):\n                    C[i + l + 1][j + k + 1] = A[i][j] * B[k][l]\n                    print(C[i + l + 1][j + k + 1], end = \" \")\n            print()\n    return C", "10": "def isLowerTriangularMatrix(mat):\n\tfor i in range(N):\n\t\tfor j in range(i + 1, N):\n\t\t\tif mat[i][j] != 0:\n\t\t\t\treturn False\n\treturn True", "11": "def isUpperTriangularMatrix(mat):\n\tfor i in range(1,N):\n\t\tfor j in range(0,i):\n\t\t\tif (mat[i][j] != 0):\n\t\t\t\treturn false\n\treturn true", "12": NaN, "13": "def transpose(mat, tr, N):\n\tfor i in range(0, N):\n\t\tfor j in range(0, N):\n\t\t\ttr[i][j] = mat[j][i]\n\ndef isSymmetric(mat, N):\n\ttr = [[0 for x in range(MAX)] for y in range(N)] \n\ttranspose(mat, tr, N)\n\tfor i in range(0, N):\n\t\tfor j in range(0, N):\n\t\t\tif (mat[i][j] != tr[i][j]):\n\t\t\t\treturn false\n\treturn true", "14": "def isSymmetric(mat, N):\n    for i in range(N):\n        for j in range(N):\n            if mat[i][j] != mat[j][i]:\n                return false\n    return true", "15": "def findNormal(mat, n):\n    sum = 0\n    for i in range(n):\n        for j in range(n):\n            sum += mat[i][j]*mat[i][j]\n    return math.sqrt(sum)\ndef findTrace(mat, n):\n    sum = 0\n    for i in range(n):\n        sum += mat[i][i]\n    return sum", "16": "def maxDet(n):\n\treturn (2 * n * n * n)\n\ndef resMatrix(n):\n\tfor i in range(3):\n\t\tfor j in range(3):\n\t\t\tif i == 0 and j == 2:\n\t\t\t\tprint(\"0 \", end='')\n\t\t\telif i == 1 and j == 0:\n\t\t\t\tprint(\"0 \", end='')\n\t\t\telif i == 2 and j == 1:\n\t\t\t\tprint(\"0 \", end='')\n\t\t\telse:\n\t\t\t\tprint(n, end=' ')\n\t\tprint('')", "17": "def countNegative(M, n, m):\n\tcount = 0;\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif (M[i][j] < 0):\n\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tbreak\n\treturn count", "18": "def countNegative(M, n, m):\n\tcount = 0\n\ti = 0\n\tj = m - 1\n\twhile j >= 0 and i < n:\n\t\tif M[i][j] < 0:\n\t\t\tcount += j + 1\n\t\t\ti += 1\n\t\telse:\n\t\t\tj -= 1\n\treturn count", "19": "def getLastNegativeIndex(array, start, end):\n    if start == end:\n        return start\n    mid = start + (end - start) // 2\n    if array[mid] < 0:\n        if mid + 1 < len(array) and array[mid + 1] >= 0:\n            return mid\n        return getLastNegativeIndex(array, mid + 1, end)\n    else:\n        return getLastNegativeIndex(array, start, mid - 1)\ndef countNegative(M, n, m):\n    count = 0\n    nextEnd = m - 1\n    for i in range(n):\n        if M[i][0] >= 0:\n            break\n        nextEnd = getLastNegativeIndex(M[i], 0, nextEnd)\n        count += nextEnd + 1\n    return count", "20": "def findMaxValue(N, mat):\n    maxValue = -100000000\n    for a in range (0, N - 1):\n        for b in range (0, N - 1):\n            for d in range (a + 1, N):\n                for e in range (b + 1, N):\n                    if (maxValue < (mat[d][e] - mat[a][b])):\n                        maxValue = mat[d][e] - mat[a][b]\n    return maxValue", "21": "def findMaxValue(N,mat):\n    maxValue = min(N,mat)\n    maxArr = N*[N*[0]]\n    maxArr[N-1][N-1] = mat[N-1][N-1]\n    for j in range(N-2,-1,-1):\n        if mat[N-1][j] > maxv:\n            maxv = mat[N - 1][j]\n        maxArr[N-1][j] = maxv\n    maxv = mat[N - 1][N - 1]\n    for i in range(N-2,-1,-1):\n        if mat[i][N - 1] > maxv:\n            maxv = mat[i][N - 1]\n        maxArr[i][N - 1] = maxv\n    for i in range(N-2,-1,-1):\n        for j in range(N-2,-1,-1):\n            if maxArr[i+1][j+1] - mat[i][j] > maxValue:\n                maxValue = maxArr[i + 1][j + 1] - mat[i][j]\n            maxArr[i][j] = max(mat[i][j],max(maxArr[i][j + 1], maxArr[i + 1][j]))\n    return maxValue", "22": "static void youngify(int[][] mat, int i, int j):\n\tdownVal = (i + 1 < N) ?\n\t\t\t\t\tmat[i + 1][j] : INF\n\trightVal = (j + 1 < N) ?\n\t\t\t\t\tmat[i][j + 1] : INF\n\tif downVal == INF and rightVal == INF:\n\t\treturn\n\tif downVal < rightVal:\n\t\tmat[i][j] = downVal\n\t\tmat[i + 1][j] = INF\n\t\tyoungify(mat, i + 1, j)\n\telse:\n\t\tmat[i][j] = rightVal\n\t\tmat[i][j + 1] = INF\n\t\tyoungify(mat, i, j + 1)\n\nstatic int extractMin(int[][] mat):\n\tret = mat[0][0]\n\tmat[0][0] = INF\n\tyoungify(mat, 0, 0)\n\treturn ret\n\nstatic void printSorted(int[][] mat):\n\tprint(\"Elements of matrix in sorted order n\")\n\tfor i in range(0, N * N):\n\t\tprint(extractMin(mat) + \" \")", "23": "def printSumSimple(mat, k):\n    if k > n: \n        return\n    for i in range(0, n-k+1):\n        for j in range(0, n-k+1):\n            sum = 0\n            for p in range(i, k+i):\n                for q in range(j, k+j):\n                    sum += mat[p][q]\n            print (sum, \" \")\n        print ()", "24": "def printSumTricky(mat, k):\n    if k > n:\n        return\n    stripSum = [[0] * n for i in range(n)]\n    for j in range(n):\n        sum = 0\n        for i in range(k):\n            sum += mat[i][j]\n        stripSum[0][j] = sum\n        for i in range(1, n - k + 1):\n            sum += (mat[i + k - 1][j] - mat[i - 1][j])\n            stripSum[i][j] = sum\n    for i in range(n - k + 1):\n        sum = 0\n        for j in range(k):\n            sum += stripSum[i][j]\n        print(sum + \" \", end = \"\")\n        for j in range(1, n - k + 1):\n            sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1])\n            print(sum + \" \", end = \"\")\n        print()", "25": "def transpose(A, B):\n\t\tfor i in range(0, len(A)):\n\t\t\tfor j in range(0, len(A[i])):\n\t\t\t\tB[i][j] = A[j][i]", "26": "def transpose(A):\n\tfor i in range(0, len(A)):\n\t\tfor j in range(i+1, len(A)):\n\t\t\ttemp = A[i][j]\n\t\t\tA[i][j] = A[j][i]\n\t\t\tA[j][i] = temp", "27": "def pathCountRec(mat, m, n, k):\n\tif (m < 0 or n < 0):\n\t\treturn 0\n\tif (m == 0 and n == 0 and (k == mat[m][n])):\n\t\treturn 1\n\treturn pathCountRec(mat, m - 1, n, k - mat[m][n]) + pathCountRec(mat, m, n - 1, k - mat[m][n])\nstatic int pathCount(int mat[][], int k):\n\treturn pathCountRec(mat, R - 1, C - 1, k)", "28": "def pathCountDPRecDP(mat, m, n, k):\n        if m < 0 n < 0: return 0\n        if (m==0 and n==0): return (k == mat[m][n]) ? 1 : 0\n        if dp[m][n][k] != -1: return dp[m][n][k]\n        dp[m][n][k] = pathCountDPRecDP(mat, m-1, n, k-mat[m][n]) +\n                                pathCountDPRecDP(mat, m, n-1, k-mat[m][n])\n        return dp[m][n][k]\ndef pathCountDP(mat, k):\n        for i in range(R):\n                for j in range(C):\n                        for l in range(MAX_K):\n                        dp[i][j][l]=-1\n        return pathCountDPRecDP(mat, R-1, C-1, k)", "29": "def check(A, N):\n    S = []\n    B_end = 0\n    for i in range(0, N):\n        if not S:\n            S.append(A[i])\n        else:\n            top = S[-1]\n            while top == B_end + 1:\n                B_end = B_end + 1\n                S.pop()\n                if not S:\n                    break\n                top = S[-1]\n            if not S:\n                S.append(A[i])\n            else:\n                top = S[-1]\n                if A[i] < top:\n                    S.append(A[i])\n                else:\n                    return false\n    return true", "30": "def countMinReversals(expr): \n\t\n\tlen = len(expr) \n\t\n\tif len % 2 != 0: \n\t\treturn -1\n\n\ts = [] \n\n\tfor i in range(len): \n\t\n\t\tif expr[i] == '}' and len(s) != 0: \n\t\t\n\t\t\tif s[len(s) - 1] == '{': \n\t\t\t\ts.pop() \n\t\t\telse: \n\t\t\t\ts.append(expr[i]) \n\t\telse: \n\t\t\ts.append(expr[i]) \n\t\t\t\n\tred_len = len(s) \n\tn = 0\n\n\twhile len(s) != 0 and s[len(s) - 1] == '{': \n\t\ts.pop() \n\t\tn += 1\n\t\t\n\treturn (int)(red_len/2 + n % 2)", "31": "def countMinReversals(expr):\n\tlen = expr.length()\n\tans\n\tif len % 2 != 0:\n\t\treturn -1\n\tleft_brace = 0, right_brace = 0\n\tfor i in range(0, len):\n\t\tchar = expr.charAt(i)\n\t\tif char == '{':\n\t\t\tleft_brace = left_brace + 1\n\t\telse:\n\t\t\tif left_brace == 0:\n\t\t\t\tright_brace = right_brace + 1\n\t\t\telse:\n\t\t\t\tleft_brace = left_brace - 1\n\tans = (int)(ceil((0.0 + left_brace) / 2)\n\t\t\t\t+ ceil((0.0 + right_brace) / 2))\n\treturn ans", "32": "def printMinNumberForPattern(arr): \n\tcurr_max = 0\n\tlast_entry = 0\n\tfor i in range(len(arr)):\n\t\tnoOfNextD = 0\n\t\tif (arr[i] == 'I'):\n\t\t\tj = i + 1\n\t\t\twhile (j < len(arr) and arr[j] == 'D'):\n\t\t\t\tnoOfNextD = noOfNextD + 1\n\t\t\t\tj = j + 1\n\t\t\tif (i == 0):\n\t\t\t\tcurr_max = noOfNextD + 2\n\t\t\t\tlast_entry = last_entry + 1\n\t\t\t\tprint(last_entry, end=' ')\n\t\t\t\tlast_entry = curr_max\n\t\t\t\tprint(last_entry, end=' ')\n\t\t\telse:\n\t\t\t\tcurr_max = curr_max + noOfNextD + 1\n\t\t\t\tlast_entry = curr_max\n\t\t\t\tprint(last_entry, end=' ')\n\t\t\tfor k in range(noOfNextD):\n\t\t\t\tlast_entry = last_entry - 1\n\t\t\t\tprint(last_entry, end=' ')\n\t\t\t\ti = i + 1\n\t\telif (arr[i] == 'D'):\n\t\t\tif (i == 0):\n\t\t\t\tj = i + 1\n\t\t\t\twhile (j < len(arr) and arr[j] == 'D'):\n\t\t\t\t\tnoOfNextD = noOfNextD + 1\n\t\t\t\t\tj = j + 1\n\t\t\t\tcurr_max = noOfNextD + 2\n\t\t\t\tprint(curr_max, end=' ')\n\t\t\t\tprint(curr_max - 1, end=' ')\n\t\t\t\tlast_entry = curr_max - 1\n\t\t\telse:\n\t\t\t\tlast_entry = last_entry - 1\n\t\t\t\tprint(last_entry, end=' ')", "33": "def printLeast(arr): \n\tmin_avail = 1\n\tpos_of_I = 0\n\tal = []\n\tif (arr[0] == 'I'): \n\t\tal.append(1) \n\t\tal.append(2) \n\t\tmin_avail = 3\n\t\tpos_of_I = 1\n\telse: \n\t\tal.append(2) \n\t\tal.append(1) \n\t\tmin_avail = 3\n\t\tpos_of_I = 0\n\tfor i in range(1, len(arr)): \n\t\tif (arr[i] == 'I'): \n\t\t\tal.append(min_avail) \n\t\t\tmin_avail += 1\n\t\t\tpos_of_I = i + 1\n\t\telse: \n\t\t\tal.append(al[i]) \n\t\t\tfor j in range(pos_of_I, i + 1): \n\t\t\t\tal[j] += 1\n\t\t\tmin_avail += 1\n\tfor i in range(0, len(al)): \n\t\tprint(al[i], end = ' ') \n\tprint()", "34": "def PrintMinNumberForPattern(seq): \n    \n    result = \"\" \n    stk = [] \n   \n    for i in range(len(seq) + 1): \n        stk.append(i + 1) \n       \n        if i == len(seq) or seq[i] == 'I': \n            while len(stk) != 0: \n                result += str(stk[-1]) \n                result += \" \"\n                stk.pop() \n   \n    print(result)", "35": "static String getMinNumberForPattern(String seq)\n    {\n        n = len(seq)\n        if (n >= 9)\n            return \"-1\"\n        result = [''] * (n + 1)\n        count = 1\n        for i in range(0, n + 1):\n            if i == n or seq[i] == 'I':\n                for j in range(i - 1, -2, -1):\n                    result[j + 1] = chr(ord('0') + count)\n                    count += 1\n                    if j >= 0 and seq[j] == 'I':\n                        break\n    return ''.join(result)", "36": "def compare(k1, k2):\n    if (k1.freq < k2.freq):\n        return 1\n    elif (k1.freq > k2.freq):\n        return -1\n    return 0\ndef rearrangeString(str):\n    n = len(str)\n    count = [0] * MAX_CHAR\n    for i in range(0, n):\n        count[ord(str[i]) - ord('a')] += 1\n    pq = PriorityQueue(compare)\n    for c in range(ord('a'), ord('z') + 1):\n        val = c - ord('a')\n        if count[val] > 0:\n            pq.add(Key(count[val], chr(c)))\n    str = \"\"\n    prev = Key(-1, \"#\")\n    while pq.size() != 0:\n        k = pq.peek()\n        pq.poll()\n        str = str + k.ch\n        if prev.freq > 0:\n            pq.add(prev)\n        k.freq -= 1\n        prev = k\n    if n != len(str):\n        print \" Not valid String \"\n    else:\n        print str", "37": "def subset(ar, n):\n    res = 0\n    ar.sort()\n    for i in range(0, n):\n        count = 1\n        for k in range(i, n - 1):\n            if ar[k] == ar[k + 1]:\n                count++\n            else:\n                break\n        res = max(res, count)\n    return res", "38": "def subset(arr, n):\n    mp = {}\n    for i in range(n):\n        if arr[i] not in mp:\n            mp[arr[i]] = 1\n        else:\n            mp[arr[i]] += 1\n    res = 0\n    for k, v in mp.items():\n        res = max(res, v)\n    return res", "39": "static boolean areElementsContiguous(int arr[], int n):\n    arr.sort()\n    for i in range(1, n):\n        if arr[i] - arr[i-1] > 1:\n            return false\n    return true", "40": "def areElementsContiguous(arr, n):\n\tmax = Integer.MIN_VALUE\n\tmin = Integer.MAX_VALUE\n\tfor i in range(0, n):\n\t\tmax = Math.max(max, arr[i])\n\t\tmin = Math.min(min, arr[i])\n\tm = max - min + 1\n\tif (m > n):\n\t\treturn false\n\tvisited = [False] * n\n\tfor i in range(0, n):\n\t\tvisited[arr[i] - min] = true\n\tfor i in range(0, m):\n\t\tif (visited[i] == false):\n\t\t\treturn false\n\treturn true", "41": "static Boolean areElementsContiguous(arr, n):\n    us = set()\n    for i in range(n):\n        us.add(arr[i])\n    count = 1\n    curr_ele = arr[0] - 1\n    while curr_ele in us:\n        count++\n        curr_ele--\n    curr_ele = arr[0] + 1\n    while curr_ele in us:\n        count++\n        curr_ele++\n    return count == len(us)", "42": "def longest(arr, n, k): \n  \n    freq = [0] * 7\n      \n    start, end, now, l = 0, 0, 0, 0\n    for i in range(n): \n          \n        freq[arr[i]] += 1\n        if (freq[arr[i]] == 1): \n            now += 1\n              \n        while (now > k): \n            freq[arr[l]] -= 1\n            if (freq[arr[l]] == 0): \n                now -= 1\n            l += 1\n              \n        if (i - l + 1 >= end - start + 1): \n            end = i \n            start = l \n              \n    for i in range(start, end + 1): \n        print(arr[i], end = \" \")", "43": "def findSmallestRange(arr, n, k):\n    i = 0\n    minval = Integer.MAX_VALUE\n    maxval = Integer.MIN_VALUE\n    minrange = Integer.MAX_VALUE\n    minel = 0\n    maxel = 0\n    flag = 0\n    minind = -1\n    ptr = [0] * k\n    while True:\n        minind = -1\n        minval = Integer.MAX_VALUE\n        maxval = Integer.MIN_VALUE\n        flag = 0\n        for i in range(0, k):\n            if ptr[i] == n:\n                flag = 1\n                break\n            if ptr[i] < n and arr[i][ptr[i]] < minval:\n                minind = 1\n                minval = arr[i][ptr[i]]\n            if ptr[i] < n and arr[i][ptr[i]] > maxval:\n                maxval = arr[i][ptr[i]]\n        if flag == 1:\n            break\n        ptr[minind] += 1\n        if (maxval - minval) < minrange:\n            minel = minval\n            maxel = maxval\n            minrange = maxel - minel\n    print(\"The smallest range is [%d, %d]\" % (minel, maxel))", "44": "def findLargestd(S, n):\n\tfound = False\n\tS.sort()\n\tfor i in range(n - 1, -1, -1):\n\t\tfor j in range(0, n):\n\t\t\tif i == j:\n\t\t\t\tcontinue\n\t\t\tfor k in range(j + 1, n):\n\t\t\t\tif i == k:\n\t\t\t\t\tcontinue\n\t\t\t\tfor l in range(k + 1, n):\n\t\t\t\t\tif i == l:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tif S[i] == S[j] + S[k] + S[l]:\n\t\t\t\t\t\tfound = True\n\t\t\t\t\t\treturn S[i]\n\tif found == False:\n\t\treturn -1", "45": "def getI():\n\treturn i\ndef getJ():\n\treturn j\ndef findFourElements(arr, n):\n\tmap = {}\n\tfor i in range(0, n-1):\n\t\tfor j in range(i+1, n):\n\t\t\tmap[arr[i]+arr[j]] = Indexes(i,j)\n\td = -999999999999\n\tfor i in range(0, n-1):\n\t\tfor j in range(i+1, n):\n\t\t\tabs_diff = abs(arr[i]-arr[j])\n\t\t\tif abs_diff in map:\n\t\t\t\tindexes = map.get(abs_diff)\n\t\t\t\tif indexes.getI() != i and indexes.getI() != j and indexes.getJ() != i and indexes.getJ() != j:\n\t\t\t\t\td = max(d, max(arr[i], arr[j]))\n\treturn d", "46": "def leftRotatebyOne(arr, n):\n    temp = arr[0]\n    for i in range(0, n-1):\n        arr[i] = arr[i+1]\n    arr[n-1] = temp\n\ndef leftRotate(arr, d, n):\n    for i in range(0, d):\n        leftRotatebyOne(arr, n)\n\ndef printArray(arr, n):\n    for i in range(0, n):\n        print(arr[i]),", "47": "def pushZerosToEnd(arr, n): \n\tcount = 0\n\tfor i in range(n): \n\t\tif arr[i] != 0: \n\t\t\tarr[count] = arr[i] \n\t\t\tcount+=1\n\twhile count < n: \n\t\tarr[count] = 0\n\t\tcount += 1", "48": "static void moveZerosToEnd(int arr[], int n) {\n\tint count = 0;\n\tint temp;\n\tfor (int i = 0; i < n; i++) {\n\tif ((arr[i] != 0)) {\n\t\ttemp = arr[count];\n\t\tarr[count] = arr[i];\n\t\tarr[i] = temp;\n\t\tcount = count + 1;\n\t}\n\t}\n}\nstatic void printArray(int arr[], int n) {\n\tfor (int i = 0; i < n; i++)\n\tSystem.out.print(arr[i] + \" \");\n}", "49": "public static void main(String args[])\n\t{\n\t\tint arr[] = { 2, 0, 2, 2, 0, 4, 0, 4, 4 };\n\t\tint n = arr.length;\n\t\tmodifyAndRearrangeArr(arr, n);\n\t\tprintArray(arr, n);\n\t}\n\ndef pushZerosToEnd(arr, n):\n\tcount = 0\n\tfor i in range(n):\n\t\tif arr[i] != 0:\n\t\t\tarr[count] = arr[i]\n\t\t\tcount += 1\n\twhile count < n:\n\t\tarr[count] = 0\n\t\tcount += 1\n\ndef modifyAndRearrangeArr(arr, n):\n\tif n == 1:\n\t\treturn\n\tfor i in range(n - 1):\n\t\tif arr[i] != 0 and arr[i] == arr[i + 1]:\n\t\t\tarr[i] = 2 * arr[i]\n\t\t\tarr[i + 1] = 0\n\t\t\ti += 1\n\tpushZerosToEnd(arr, n)\n\ndef printArray(arr, n):\n\tfor i in range(n):\n\t\tprint(arr[i], end=' ')\n\tprint()\n\narr = [2, 0, 2, 2, 0, 4, 0, 4, 4]\nn = len(arr)\nmodifyAndRearrangeArr(arr, n)\nprintArray(arr, n)", "50": "def printArray(A, size):\n        for i in range(size):\n                print(A[i] + \" \")\n        print(endl)\ndef reverse(arr, l, r):\n        if (l < r):\n                swap(arr[l], arr[r])\n                reverse(arr, ++l, --r)\ndef merge(arr, l, m, r):\ni = l \nj = m + 1\n        while (i <= m and arr[i] < 0):\n                i++\n        while (j <= r and arr[j] < 0):\n                j++\n        reverse(arr, i, m)\n        reverse(arr, m + 1, j - 1)\n        reverse(arr, i, j - 1)\ndef RearrangePosNeg(arr, l, r):\n        if (l < r):\n                m = l + (r - l) / 2\n                RearrangePosNeg(arr, l, m)\n                RearrangePosNeg(arr, m + 1, r)\n                merge(arr, l, m, r)", "51": "def rearrangePosNeg(arr, n):\n        i = 0\n        j = n - 1\n        while true:\n                while arr[i] < 0 and i < n:\n                        i++\n                while arr[j] > 0 and j >= 0:\n                        j--\n                if i < j:\n                        temp = arr[i]\n                        arr[i] = arr[j]\n                        arr[j] = temp\n                else\n                        break", "52": "def findElements(arr, n):\n        for i in range(n):\n                count = 0\n                for j in range(n):\n                        if (arr[j] > arr[i]):\n                                count += 1\n                if (count >= 2):\n                        print(arr[i] + \" \")", "53": "def findElements(arr, n):\n        arr.sort()\n        for i in range(0, n - 2):\n                print(arr[i], \" \")", "54": "def findElements(arr, n):\n        first = -9999999\n        second = -9999999\n        for i in range(0, n):\n                if arr[i] > first:\n                        second = first\n                        first = arr[i]\n                elif arr[i] > second:\n                        second = arr[i]\n        for i in range(0, n):\n                if arr[i] < second:\n                        print(arr[i], end=\" \")", "55": "def findFirstMissing(array, start, end):\n        if (start > end):\n                return end + 1;\n        if (start != array[start]):\n                return start;\n        mid = (start + end) / 2;\n        if (array[mid] == mid):\n                return findFirstMissing(array, mid+1, end);\n        return findFirstMissing(array, start, mid);", "56": "def findSmallestMissinginSortedArray(arr):\n    if(arr[0] != 0):\n        return 0\n    if(arr[len(arr) - 1] == len(arr) - 1):\n        return len(arr)\n    first = arr[0]\n    return findFirstMissing(arr, 0, len(arr) - 1, first)\ndef findFirstMissing(arr, start, end, first):\n    if (start < end):\n        mid = (start + end) // 2\n        if (arr[mid] != mid+first):\n            return findFirstMissing(arr, start, mid , first)\n        else:\n            return findFirstMissing(arr, mid + 1, end , first)\n    return start + first", "57": "def FindMaxSum(arr, n):\n        incl = arr[0]\n        excl = 0\n        excl_new\n        i\n        for i in range(1, n):\n                excl_new = (incl > excl) ? incl : excl\n                incl = excl + arr[i]\n                excl = excl_new\n        return ((incl > excl) ? incl : excl)", "58": "def buildSparseTable(arr, n):\n        for i in range(n):\n                lookup[i][0] = arr[i]\n        for j in range(1, (1 << j) <= n):\n                for i in range(0, (i + (1 << j) - 1) < n):\n                        if lookup[i][j - 1] < lookup[i + (1 << (j - 1))][j - 1]):\n                                lookup[i][j] = lookup[i][j - 1]\n                        else:\n                                lookup[i][j] = lookup[i + (1 << (j - 1))][j - 1]\n\ndef query(L, R):\n        j = (int)log2(R - L + 1)\n        if lookup[L][j] <= lookup[R - (1 << j) + 1][j]):\n                return lookup[L][j]\n        else:\n                return lookup[R - (1 << j) + 1][j]", "59": "def buildSparseTable(arr, n):\n        for i in range(n):\n                table[i][0] = arr[i]\n        for j in range(1, n+1):\n                for i in range(n - (1 << j)):\n                        table[i][j] = __gcd(table[i][j - 1],\n                                        table[i + (1 << (j - 1))][j - 1])\n\ndef query(L, R):\n        j = (int)log2(R - L + 1)\n        return __gcd(table[L][j], table[R - (1 << j) + 1][j])", "60": "def findMaxAverage(arr, n, k):\n        if (k > n):\n                return -1;\n        csum = [0] * n;\n        csum[0] = arr[0];\n        for i in range(1, n):\n                csum[i] = csum[i-1] + arr[i];\n        max_sum = csum[k-1];\n        max_end = k-1;\n        for i in range(k, n):\n                curr_sum = csum[i] - csum[i-k];\n                if (curr_sum > max_sum):\n                        max_sum = curr_sum;\n                        max_end = i;\n        \n        return max_end - k + 1;", "61": "def findMaxAverage(arr, n, k):\n        if k > n:\n                return -1\n        sum = arr[0]\n        for i in range(1, k):\n                sum += arr[i]\n        max_sum = sum\n        max_end = k - 1\n        for i in range(k, n):\n                sum = sum + arr[i] - arr[i-k]\n                if sum > max_sum:\n                        max_sum = sum\n                        max_end = i\n        return max_end - k + 1", "62": "def isMajority(arr, n, x):\n        last_index = n % 2 ? (n / 2 + 1): (n / 2)\n        for i in range(0, last_index):\n                if (arr[i] == x and arr[i + n / 2] == x):\n                        return 1\n        return 0", "63": "def _binarySearch(arr, low, high, x):\n        if high >= low:\n                mid = (low + high)/2\n                if ((mid == 0 and x > arr[mid - 1]) and\n                        (arr[mid] == x) ):\n                        return mid\n                elif x > arr[mid]:\n                        return _binarySearch(arr, (mid + 1), high, x)\n                else:\n                        return _binarySearch(arr, low, \n                                                                (mid - 1), x)\n        return -1\ndef isMajority(arr, n, x):\n        i = _binarySearch(arr, 0, n - 1, x)\n        if i == -1:\n                return false\n        if (((i + n / 2) <= (n - 1)) and arr[i + n / 2] == x):\n                return true\n        else:\n                return false", "64": "def isMajorityElement(arr, n, key):\n        if (arr[n / 2] == key):\n                return true;\n        else:\n                return false;", "65": "def sortMat(mat, n):\n        temp = [n * n]\n        k = 0\n        for i in range(0,n):\n                for j in range(0,n):\n                        temp[k] = mat[i][j]\n                        k = k + 1\n        temp.sort()\n        k = 0\n        for i in range(0,n):\n                for j in range(0,n):\n                        mat[i][j] = temp[k]\n                        k = k + 1\n\ndef printMat(mat, n):\n        for i in range(0,n):\n                for j in range(0,n):\n                        print(mat[i][j], end = \" \")\n                print()", "66": "def swap(xp, yp): \n        temp = xp \n        xp = yp \n        yp = temp \ndef selectionSort(arr, n): \n        for i in range(n-1): \n                min_idx = i \n                for j in range(i+1, n): \n                        if arr[j] < arr[min_idx]: \n                                min_idx = j \n                swap(arr[min_idx], arr[i]) \ndef printArray(arr, size): \n        for i in range(size): \n                print(arr[i], end=\" \") \n        print()", "67": "def bubbleSort(arr):\n \n    n = len(arr)\n \n    for i in range(n):\n \n        for j in range(0, n-i-1):\n \n            if arr[j] > arr[j+1] :\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n \ndef printArray(arr):\n \n    n = len(arr)\n    for i in range(n):\n        print (\"%d\" %arr[i]),\n \narr = [64, 34, 25, 12, 22, 11, 90]\n \nbubbleSort(arr)\n \nprint (\"Sorted array is:\")\nprintArray(arr)", "68": "def findCrossOver(arr, low, high, x):\n    if (arr[high] <= x): \n        return high;\n    if (arr[low] > x): \n        return low;\n    mid = (low + high)/2; \n    if (arr[mid] <= x and arr[mid+1] > x):\n        return mid;\n    if(arr[mid] < x):\n        return findCrossOver(arr, mid+1, high, x);\n    return findCrossOver(arr, low, mid - 1, x);\n\ndef printKclosest(arr, x, k, n):\n    l = findCrossOver(arr, 0, n-1, x);\n    r = l+1; \n    count = 0; \n    if (arr[l] == x): l = l-1;\n    while (l >= 0 and r < n and count < k):\n        if (x - arr[l] < arr[r] - x):\n            print(arr[l] + \" \", end=\"\"); l = l - 1;\n        else:\n            print(arr[r] + \" \", end=\"\"); r = r + 1;\n        count = count + 1;\n    while (count < k and l >= 0):\n        print(arr[l] + \" \", end=\"\"); l = l - 1;\n        count = count + 1;\n    while (count < k and r < n):\n        print(arr[r] + \" \", end=\"\"); r = r + 1; \n        count = count + 1;", "69": "def count(S,m,n):\n        if n==0:\n                return 1\n        if n<0:\n                return 0\n        if m<=0 and n>=1:\n                return 0\n        return count(S,m-1,n)+count(S,m,n-S[m-1])", "70": "def count(arr, m, n): \n    table = [0 for k in range(n+1)] \n    table[0] = 1\n    for i in range(0, m): \n        for j in range(S[i], n+1): \n            table[j] += table[j - S[i]] \n    return table[n]", "71": "def matrixChainMemoised(p, i, j, dp):\n        if i == j:\n                return 0\n        if dp[i][j] != -1:\n                return dp[i][j]\n        dp[i][j] = INT_MAX\n        for k in range(i, j):\n                dp[i][j] = min(\n                        dp[i][j], matrixChainMemoised(p, i, k, dp)\n                                        + matrixChainMemoised(p, k + 1, j, dp) + p[i - 1] * p[k] * p[j])\n        return dp[i][j]\n\ndef MatrixChainOrder(p, n):\n        dp = [[-1 for x in range(n)] for x in range(n)]\n        return matrixChainMemoised(p, 1, n - 1, dp)", "72": "def matrixChainOrder(p, n): \n    m = [[0 for x in range(n)] for x in range(n)] \n    for i in range(1, n): \n        m[i][i] = 0\n    for L in range(2, n): \n        for i in range(1, n - L + 1): \n            j = i + L - 1\n            m[i][j] = float(\"inf\")\n            for k in range(i, j): \n                q = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j] \n                if q < m[i][j]: \n                    m[i][j] = q \n    return m[1][n-1]", "73": "def max(a,b):\n        if a>b:\n                return a\n        else:\n                return b\ndef cutRod(price,n):\n        if n<=0:\n                return 0\n        max_val=0\n        for i in range(0,n):\n                max_val = max(max_val, price[i] + cutRod(price, n-i-1))\n        return max_val", "74": "def cutrod(price, n):  \n    val = [0]*(n+1) \n    for i in range(1, n+1): \n        max_val = INT_MIN \n        for j in range(i): \n                max_val = max(max_val, price[j] + val[i-j-1]) \n        val[i] = max_val \n    return val[n] \n  \narr = [1, 5, 8, 9, 10, 17, 17, 20] \nsize = len(arr) \nprint(\"Maximum Obtainable Value is \" + str(cutrod(arr, size)))", "75": "def un_kp(price, length, Max_len, n):\n        if n == 0 and Max_len == 0:\n                return 0\n        if length[n - 1] <= Max_len:\n                t[n][Max_len]\n                        = max(price[n - 1]\n                                        + un_kp(price, length, Max_len - length[n - 1], n),\n                                un_kp(price, length, Max_len, n - 1))\n        else:\n                t[n][Max_len]\n                        = un_kp(price, length, Max_len, n - 1)\n        return t[n][Max_len]", "76": "def multiply(x, y):\n    if y == 0:\n        return 0\n    if y > 0:\n        return x + multiply(x, y - 1)\n    if y < 0:\n        return -multiply(x, -y)", "77": "def sieveOfEratosthenes(n): \n    prime = [True for i in range(n + 1)] \n    p = 2\n    while (p * p <= n): \n        if prime[p]: \n            for i in range(p * p, n + 1, p): \n                prime[i] = False\n        p += 1\n    for p in range(2, n): \n        if prime[p]: \n            print(p),", "78": "def binomialCoeff(n, k):\n        res = 1\n        if (k > n - k):\n                k = n - k\n        for i in range(0, k):\n                res *= (n - i)\n                res /= (i + 1)\n        return res\ndef printPascal(n):\n        for line in range(0, n):\n                for i in range(0, line + 1):\n                        print(binomialCoeff(line, i), end = ' ')\n                print()", "79": "def printPascal(n):\n        arr = n*[n*[0]]\n        for line in range(n):\n                for i in range(line+1):\n                        if line == i or i == 0:\n                                arr[line][i] = 1\n                        else:\n                                arr[line][i] = arr[line - 1][i - 1] + arr[line - 1][i]\n                                \n                print(\" \".join([str(arr[line][i]) for i in range(line+1)]))", "80": "def printPascal(n): \n    for line in range(1, n + 1): \n        C = 1 \n        for i in range(1, line + 1): \n            print(C, end = \" \") \n            C = int(C * (line - i) / i) \n        print(\"\")", "81": "def Add(x, y):\n        while y != 0:\n                carry = x & y\n                x = x ^ y\n                y = carry << 1\n        return x", "82": "def getModulo(n, d):\n    return ( n & (d - 1) )", "83": "def countSetBits(n):\n        count = 0\n        while (n):\n                count += n & 1\n                n >>= 1\n        return count", "84": "def countSetBits(n):\n        if (n == 0):\n                return 0\n        else:\n                return 1 + countSetBits(n & (n - 1))", "85": "def initialize():\n        BitsSetTable256 = {}\n        for i in range(256):\n                BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2]\n\ndef countSetBits(n):\n        return (BitsSetTable256[n & 0xff] + BitsSetTable256[(n >> 8) & 0xff] + BitsSetTable256[(n >> 16) & 0xff] + BitsSetTable256[n >> 24])", "86": NaN, "87": "def countSetBitsRec(num):\n       nibble = 0\n       if (0 == num):\n               return num_to_bits[0]\n       nibble = num & 0xf\n       return num_to_bits[nibble] + countSetBitsRec(num >> 4)", "88": "def countSetBits(n): \n    count = 0\n    for i in range(0, 8*sizeof(int)): \n        if (n & (1 << i)): \n            count+=1\n    return count", "89": "def getParity(n):\n        parity = 0\n        while n:\n                parity = not parity\n                n = n & (n - 1)\n        return parity", "90": "def isPowerOfTwo(n):\n    if(n==0):\n        return false\n    return (ceil(log2(n)) == floor(log2(n)))", "91": "def isPowerOfTwo(n):\n        if (n == 0):\n                return 0;\n        while (n != 1):\n                if (n%2 != 0):\n                        return 0;\n                n = n/2;\n        return 1;", "92": "def powerOf2(n):\n    if (n == 1):\n        return true;\n    else if (n % 2 != 0 or n == 0):\n        return false;\n    return powerOf2(n / 2);", "93": "def isPowerOfTwo(x):\n        return x and not(x&(x-1))", "94": "def maxRepeating(arr, n, k):\n        for i in range(0,n):\n                arr[arr[i]%k] += k\n        max = arr[0]\n        result = 0\n        for i in range(1,n):\n                if arr[i]>max:\n                        max = arr[i]\n                        result = i\n        return result", "95": "def fun(x):\n        y = (x / 4) * 4\n        ans = 0\n        for i in range(y, x+1):\n                ans ^= i\n        return ans\ndef query(x):\n        if x == 0:\n                return 0\n        k = (x + 1) / 2\n        return (x %= 2) ? 2 * fun(k) : ((fun(k - 1) * 2) ^ (k & 1))\ndef allQueries(q, l, r):\n        for i in range(q):\n                print(query(r[i]) ^ query(l[i] - 1))", "96": "def prefixXOR(arr, preXOR, n):\n    for i in range(n):\n        while arr[i] % 2 != 1:\n            arr[i] /= 2\n        preXOR[i] = arr[i]\n    for i in range(1, n):\n        preXOR[i] = preXOR[i - 1] ^ preXOR[i]\ndef query(preXOR, l, r):\n    if l == 0:\n        return preXOR[r]\n    else:\n        return preXOR[r] ^ preXOR[l - 1]", "97": "def findMinSwaps(arr, n):\n        noOfZeroes = [0] * n\n        noOfZeroes[n - 1] = 1 - arr[n - 1]\n        for i in range(n - 2, -1, -1):\n                noOfZeroes[i] = noOfZeroes[i + 1]\n                if (arr[i] == 0):\n                        noOfZeroes[i] += 1\n        count = 0\n        for i in range(n):\n                if (arr[i] == 1):\n                        count += noOfZeroes[i]\n        return count", "98": "def minswaps(arr, n):\n        count = 0\n        num_unplaced_zeros = 0\n        for index in range(n-1, 0, -1):\n                if(arr[index] == 0):\n                        num_unplaced_zeros += 1\n                else:\n                        count += num_unplaced_zeros\n        return count", "99": "def arraySortedOrNot(arr, n):\n        if n == 0 n == 1:\n                return true\n        for i in range(1, n):\n                if arr[i - 1] > arr[i]:\n                        return false\n        return true", "100": "def printTwoOdd(arr, size):\n        xor2 = arr[0]\n        set_bit_no\n        i\n        n = size - 2\n        x = 0\n        y = 0\n        for i in range(1, size):\n                xor2 = xor2 ^ arr[i]\n        set_bit_no = xor2 & ~(xor2-1)\n        for i in range(0, size):\n                if(arr[i] & set_bit_no):\n                        x = x ^ arr[i]\n                else:\n                        y = y ^ arr[i]\n        print(\"The two ODD elements are \" + str(x) + \" & \" + str(y))", "101": "def printTwoOdd(arr, size): \n        m = {}\n        for i in range(size): \n                m[arr[i]]++\n        print(\"The two ODD elements are \")\n        for x in m: \n                if (x.second % 2 != 0): \n                        print(x.first, \", \")", "102": "def findPair(arr, size, n):\n        i = 0\n        j = 1\n        while i < size and j < size:\n                if i != j and arr[j] - arr[i] == n:\n                        print(\"Pair Found: (\" + str(arr[i]) + ', ' + str(arr[j]) + ')'\n                        return True\n                else if arr[j]-arr[i] < n:\n                        j++\n                else:\n                        i++\n        print(\"No such pair\")\n        return False", "103": "def printMax(arr, k, n): \n    brr = sorted(arr, reverse = True) \n    for i in range(0 , n): \n        if arr[i] in brr[:k]: \n            print(arr[i], end = \" \")", "104": "def printSmall(arr, asize, n):\n        copy_arr = sorted(arr[:asize])\n        for i in range(asize):\n                if copy_arr[i] in arr[:n]:\n                        print(arr[i], end=\" \")", "105": "def checkIsAP(arr, n):\n    if(n == 1):\n        return true\n    arr.sort()\n    d = arr[1] - arr[0]\n    for i in range(2, n):\n        if(arr[i] - arr[i - 1] != d):\n            return false\n    return true", "106": "def checkIsAP(arr, n):\n        hm = {}\n        smallest = INT_MAX\n        second_smallest = INT_MAX\n        for i in range(0, n):\n                if arr[i] < smallest:\n                        second_smallest = smallest\n                        smallest = arr[i]\n                elif arr[i] != smallest and arr[i] < second_smallest:\n                        second_smallest = arr[i]\n                if not hm.get(arr[i]):\n                        hm[arr[i]] = 1\n                else:\n                        return False\n        diff = second_smallest - smallest\n        for i in range(0, n - 1):\n                if not hm.get(second_smallest):\n                        return False\n                second_smallest += diff\n        return True", "107": "def countPairs(a, n):\n        mn = min(a)\n        mx = max(a)\n        c1 = 0\n        c2 = 0\n        for i in range(0, n):\n                if (a[i] == mn):\n                        c1 = c1 + 1\n                if (a[i] == mx):\n                        c2 = c2 + 1\n        if (mn == mx):\n                return n * (n - 1) / 2\n        else:\n                return c1 * c2", "108": "def rearrange(head):\n    if not head:\n        return\n    prev = head\n    curr = head.next\n    while curr:\n        if prev.data > curr.data:\n            swap(prev.data, curr.data)\n        if curr.next and curr.next.data > curr.data:\n            swap(curr.next.data, curr.data)\n        prev = curr.next\n        if not curr.next:\n            break\n        curr = curr.next.next\n\ndef push(head, k):\n    tem = Node()\n    tem.data = k\n    tem.next = head\n    return tem\n\ndef display(head):\n    curr = head\n    while curr:\n        print(curr.data, end=\" \")\n        curr = curr.next", "109": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef getLength(node):\n    size = 0\n    while (node != None):\n        node = node.next\n        size += 1\n    return size\n\ndef paddZeros(node, diff):\n    if (node == None):\n        return None\n    zHead = Node(0)\n    diff -= 1\n    temp = zHead\n    while (diff != 0):\n        temp.next = Node(0)\n        temp = temp.next\n        diff -= 1\n    temp.next = node\n    return zHead\n\ndef subtractLinkedListHelper(l1, l2, borrow):\n    if (l1 == None and l2 == None and borrow == 0):\n        return None\n    previous = subtractLinkedListHelper(l1.next if l1 != None else None, l2.next if l2 != None else None, borrow)\n    d1 = l1.data\n    d2 = l2.data\n    sub = 0\n    if (borrow):\n        d1 -= 1\n        borrow = False\n    if (d1 < d2):\n        borrow = True\n        d1 += 10\n    sub = d1 - d2\n    current = Node(sub)\n    current.next = previous\n    return current\n\ndef subtractLinkedList(l1, l2):\n    if (l1 == None and l2 == None):\n        return None\n    len1 = getLength(l1)\n    len2 = getLength(l2)\n    lNode = None\n    sNode = None\n    temp1 = l1\n    temp2 = l2\n    if (len1 != len2):\n        lNode = l1 if len1 > len2 else l2\n        sNode = l2 if len1 > len2 else l1\n        sNode = paddZeros(sNode, abs(len1 - len2))\n    else:\n        while (l1 != None and l2 != None):\n            if (l1.data != l2.data):\n                lNode = temp1 if l1.data > l2.data else temp2\n                sNode = temp2 if l1.data > l2.data else temp1\n                break\n            l1 = l1.next\n            l2 = l2.next\n    borrow = False\n    return subtractLinkedListHelper(lNode, sNode, borrow)\n\ndef printList(node):\n    while (node != None):\n        print(node.data, end = \" \")\n        node = node.next\n    print(\"\")", "110": "class Node:\n    def __init__(self,data):\n        self.data = data\n        self.next = None\n\ndef getNode(data):\n        newNode = Node(data)\n        return newNode\n\ndef insertAtMid(head_ref, x):\n        if (head_ref == None):\n                head_ref = getNode(x)\n        else:\n                newNode = getNode(x)\n                ptr = head_ref\n                len = 0\n                while (ptr != None):\n                        len += 1\n                        ptr = ptr.next\n                count = ((len % 2) == 0) ? (len / 2) : (len + 1) / 2\n                ptr = head_ref\n                while (count > 1):\n                        ptr = ptr.next\n                        count -= 1\n                newNode.next = ptr.next\n                ptr.next = newNode\n\ndef display(head):\n        while (head != None):\n                print(head.data, \" \")\n                head = head.next", "111": "def getNode(data):\n        newNode = Node()\n        newNode.data = data\n        newNode.next = None\n        return newNode\n\ndef insertAtMid(head_ref, x):\n        if head_ref == None:\n                head_ref = getNode(x)\n        else:\n                newNode = getNode(x)\n                slow = head_ref\n                fast = head_ref.next\n                while fast and fast.next:\n                        slow = slow.next\n                        fast = fast.next.next\n                newNode.next = slow.next\n                slow.next = newNode\n\ndef display(head):\n        while head != None:\n                print(head.data, \" \")\n                head = head.next", "112": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n\ndef get_node(data):\n    new_node = Node(data)\n    return new_node\n\n\ndef sorted_insert(head, new_node):\n    if head is None:\n        head = new_node\n    else:\n        if head.data >= new_node.data:\n            new_node.next = head\n            new_node.next.prev = new_node\n            head = new_node\n        else:\n            current = head\n            while current.next and current.next.data < new_node.data:\n                current = current.next\n            new_node.next = current.next\n            if current.next is not None:\n                new_node.next.prev = new_node\n            current.next = new_node\n            new_node.prev = current\n\n\ndef insertion_sort(head):\n    sorted = None\n    current = head\n    while current is not None:\n        next = current.next\n        current.prev = current.next = None\n        sorted_insert(sorted, current)\n        current = next\n    return sorted\n\n\ndef print_list(head):\n    while head is not None:\n        print(head.data)\n        head = head.next\n\n\ndef push(head, data):\n    new_node = Node(data)\n    new_node.next = head\n    if head is not None:\n        head.prev = new_node\n    head = new_node\n    return head", "113": "def reverse(arr, s, e):\n while(s < e):\n        tem = arr[s]\n        arr[s] = arr[e]\n        arr[e] = tem\n        s = s + 1\n        e = e - 1\n \ndef fun(arr, k):\n n = 4 - 1\n v = n - k\n if (v >= 0):\n        reverse(arr, 0, v)\n        reverse(arr, v + 1, n)\n        reverse(arr, 0, n)", "114": "def build(node, l, r, a):\n        if (l == r):\n                seg[node] = a[l]\n        else:\n                mid = (l + r) // 2\n                build(2 * node, l, mid, a)\n                build(2 * node + 1, mid + 1, r, a)\n                seg[node] = (seg[2 * node] seg[2 * node + 1])\n                \ndef query(node, l, r, start, end, a):\n        if (l > end or r < start):\n                return 0\n        if (start <= l and r <= end):\n                return seg[node]\n        mid = (l + r) // 2\n        return ((query(2 * node, l, mid, start, end, a)\n                        | (query(2 * node + 1, mid + 1, r, start, end, a))))\n                        \ndef orsum(a, n, q, k):\n        build(1, 0, n - 1, a)\n        for j in range(q):\n                i = k[j] % (n // 2)\n                sec = query(1, 0, n - 1, n // 2 - i, n - i - 1, a)\n                first = (query(1, 0, n - 1, 0, n // 2 - 1 - i, a)\n                                        | query(1, 0, n - 1, n - i, n - 1, a))\n                temp = sec + first\n                print(temp)", "115": "def maximumEqual(arr1, arr2, n):\n        store = [0]*(10**5)\n        for i in range(n):\n                store[arr2[i]] = i + 1\n        ans = [0]*(10**5)\n        for i in range(n):\n                d = abs(store[arr1[i]] - (i + 1))\n                if store[arr1[i]] < i + 1:\n                        d = n - d\n                ans[d] += 1\n        finalans = 0\n        for i in range(10**5):\n                finalans = max(finalans, ans[i])\n        return finalans", "116": "def RightRotate(a, n, k):\n        k = k % n\n        for i in range(0, n):\n                if(i < k):\n                        print(a[n + i - k], end = \" \")\n                else:\n                        print(a[i - k], end = \" \")\n        print(\"\\n\")", "117": "def restoreSortedArray(arr, n):\n        for i in range(0, n):\n                if (arr[i] > arr[i + 1]):\n                        arr = arr[:i+1][::-1] + arr[i+1:] \n                        arr = arr[:n][::-1] + arr[n:] \n                        arr = arr[::-1]\n                        break\ndef printArray(arr, size):\n        for i in range(0, size):\n                print(arr[i], end = \" \")", "118": "def findStartIndexOfArray(arr, low, high):\n        if (low>high):\n                return -1\n        if (low == high):\n                return low\n        mid = low + (high-low)//2\n        if(arr[mid] > arr[mid+1]):\n                return mid+1\n        if(arr[mid-1] > arr[mid]):\n                return mid\n        if(arr[low] > arr[mid]):\n                return findStartIndexOfArray(arr, low, mid-1)\n        else:\n                return findStartIndexOfArray(arr, mid+1, high)\ndef restoreSortedArray(arr, n):\n        if (arr[0] < arr[n-1]):\n                return\n        start = findStartIndexOfArray(arr, 0, n-1)\n        arr = arr[start:] + arr[:start]\ndef printArray(arr, size):\n        for i in range(0, size):\n                print(arr[i], \" \")", "119": "def leftrotate(s, d): \n    return s[d:] + s[:d] \n  \ndef rightrotate(s, d): \n    return s[-d:] + s[:-d]", "120": "def insertNode(start, value):\n        if (start == NULL):\n                new_node = Node()\n                new_node.data = value\n                new_node.next = new_node.prev = new_node\n                start = new_node\n                return\n        last = (start)->prev\n        new_node = Node()\n        new_node.data = value\n        new_node.next = start\n        (start).prev = new_node\n        new_node.prev = last\n        last.next = new_node\ndef displayList(start):\n        temp = start\n        while (temp.next != start):\n                print(temp.data, \" \")\n                temp = temp.next\n        print(temp.data, \" \")\nint searchList(start, search):\n        temp = start\n        count=0\n        flag=0\n        if(temp == NULL):\n                return -1\n        else:\n                while(temp.next != start):\n                        count++\n                        if(temp.data == search):\n                                flag = 1\n                                count--\n                                break\n                        temp = temp.next\n                if(temp.data == search):\n                        count++\n                        flag = 1\n                if(flag == 1):\n                        print(\"\\n\"+search+\" found at location \"+count)\n                else:\n                        print(\"\\n\"+search+\" not found\")", "121": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\ndef getNode(data):\n    newNode = Node(data)\n    return newNode\n\ndef insertEnd(head, new_node):\n    if head == None:\n        new_node.next = new_node.prev = new_node\n        head = new_node\n        return\n    last = head.prev\n    new_node.next = head\n    head.prev = new_node\n    new_node.prev = last\n    last.next = new_node\n\ndef reverse(head):\n    if not head:\n        return None\n    new_head = None\n    last = head.prev\n    curr = last\n    prev = None\n    while curr.prev != last:\n        prev = curr.prev\n        insertEnd(new_head, curr)\n        curr = prev\n    insertEnd(new_head, curr)\n    return new_head\n\ndef display(head):\n    if not head:\n        return\n    temp = head\n    print(\"Forward direction: \", end = \"\")\n    while temp.next != head:\n        print(temp.data, \" \", end = \"\")\n        temp = temp.next\n    print(temp.data)\n    last = head.prev\n    temp = last\n    print(\"Backward direction: \", end = \"\")\n    while temp.prev != last:\n        print(temp.data, \" \", end = \"\")\n        temp = temp.prev\n    print(temp.data)", "122": "def addEdge(u,v):\n        adj[u].append(v)\n        adj[v].append(u)\ndef dfs(cur, prev):\n        parent[cur] = prev\n        depth[cur] = depth[prev] + 1\n        for i in range(0,len(adj[cur])):\n                if (adj[cur][i] != prev):\n                        dfs(adj[cur][i],cur)\ndef preprocess():\n        depth[0] = -1\n        dfs(1,0)\ndef LCANaive(u,v):\n        if (u == v): return u\n        if (depth[u] > depth[v]):\n                swap(u, v)\n        v = parent[v]\n        return LCANaive(u,v)", "123": "def addEdge(u,v):\n        adj[u].append(v)\n        adj[v].append(u)\ndef LCANaive(u,v):\n        if (u == v): return u\n        if (depth[u] > depth[v]):\n                swap(u,v)\n        v = parent[v]\n        return LCANaive(u,v)\ndef dfs(cur, prev):\n        depth[cur] = depth[prev] + 1\n        parent[cur] = prev\n        if (depth[cur] % block_sz == 0):\n                jump_parent[cur] = parent[cur]\n        else:\n                jump_parent[cur] = jump_parent[prev]\n        for (i in range(0, len(adj[cur]), 1)):\n                if (adj[cur][i] != prev):\n                        dfs(adj[cur][i], cur)\ndef LCASQRT(u, v):\n        while (jump_parent[u] != jump_parent[v]):\n                if (depth[u] > depth[v]):\n                        swap(u,v)\n                v = jump_parent[v]\n        return LCANaive(u,v)\ndef preprocess(height):\n        block_sz = sqrt(height)\n        depth[0] = -1\n        dfs(1, 0)", "124": "def find_permutations(arr):\n        cnt = 0\n        max_ind = -1\n        min_ind = 10000000\n        n = len(arr)\n        index_of = {}\n        for i in range(0, n):\n                index_of[arr[i]] = i + 1\n        for i in range(1, n+1):\n                max_ind = max(max_ind, index_of[i])\n                min_ind = min(min_ind, index_of[i])\n                if max_ind - min_ind + 1 == i:\n                        cnt += 1\n        return cnt", "125": NaN, "126": "def countOfNum(n, a, b):\n        cnt_of_a, cnt_of_b, cnt_of_ab, sum;\n        cnt_of_a = n / a\n        cnt_of_b = n / b\n        sum = cnt_of_b + cnt_of_a\n        cnt_of_ab = n / (a * b)\n        sum = sum - cnt_of_ab\n        return sum\ndef sumOfNum(n, a, b):\n        i\n        sum = 0\n        ans = set()\n        for i in range(a, n+1, a):\n                ans.add(i)\n        for i in range(b, n+1, b):\n                ans.add(i)\n        for it in ans:\n                sum = sum + it\n        return sum", "127": "def maximumArea(l, b, x, y):\n        left, right, above, below;\n        left = x * b;\n        right = (l - x - 1) * b;\n        above = l * y;\n        below = (b - y - 1) * l;\n        print (max(max(left, right),\n                                max(above, below)));", "128": "def precompute():\n        F[1] = 2\n        F[2] = 3\n        F[3] = 4\n        for i in range(4, N):\n                F[i] = (F[i - 1] + F[i - 2]) % MOD", "129": "def get(L, R):\n        x = 1.0 / L\n        y = 1.0 / (R + 1.0)\n        return (x - y)", "130": "def consecutiveOnes(x):\n        p = 0\n        while (x > 0):\n                if (x % 2 == 1 and p == 1):\n                        return true\n                p = x % 2\n                x /= 2\n        return false\ndef preCompute():\n        for i in range(0, MAX):\n                if (!consecutiveOnes(i)):\n                        v.append(i)\ndef nextValid(n):\n        it = upper_bound(v.begin(),\n                                                v.end(), n)\n                        - v.begin()\n        val = v[it]\n        return val\ndef performQueries(queries, q):\n        for i in range(0, q):\n                print(nextValid(queries[i]))", "131": "def changeToOnes(str):\n        i = len(str) - 1\n        ctr = 0\n        while (i >= 0):\n                if (str[i] == '1'):\n                        ctr = ctr + 1\n                else:\n                        break\n                i = i - 1\n        return len(str) - ctr\n\ndef removeZeroesFromFront(str):\n        s = \"\"\n        i = 0\n        while (i < len(str) and str[i] == '0'):\n                i = i + 1\n        if (i == len(str)):\n                s = \"0\"\n        else:\n                s = str[i:len(str)]\n        return s", "132": "def getCount(a, n):\n        gcd = 0\n        for i in range(n):\n                gcd = __gcd(gcd, a[i])\n        cnt = 0\n        for i in range(1, gcd):\n                if (gcd % i == 0):\n                        if (i * i == gcd):\n                                cnt += 1\n                        else:\n                                cnt += 2\n        return cnt", "133": "def MinDeletion(a, n):\n        map = {}\n        for i in range(n):\n                map[a[i]] = map.get(a[i], 0) + 1\n        ans = 0\n        for key, val in map.items():\n                if key <= val:\n                        ans += (val - key)\n                else:\n                        ans += val\n        return ans", "134": "def maxCountAB(s, n):\n        A = 0\n        B = 0\n        BA = 0\n        ans = 0\n        for i in range(n):\n                S = s[i]\n                L = len(S)\n                for j in range(L - 1):\n                        if S[j] == 'A' and S[j + 1] == 'B':\n                                ans += 1\n                if S[0] == 'B' and S[L - 1] == 'A':\n                        BA += 1\n                elif S[0] == 'B':\n                        B += 1\n                elif S[L - 1] == 'A':\n                        A += 1\n        if BA == 0:\n                ans += min(B, A)\n        elif A + B == 0:\n                ans += BA - 1\n        else:\n                ans += BA + min(B, A)\n        return ans", "135": "def MinOperations(n, x, arr):\n        total = 0\n        for i in range(0,n):\n                if arr[i]>x:\n                        difference=arr[i]-x\n                        total = total+difference\n                        arr[i] = x\n        for i in range(1,n):\n                LeftNeigbouringSum = arr[i]+arr[i-1]\n                if LeftNeigbouringSum>x:\n                        current_diff = LeftNeigbouringSum-x\n                        arr[i] = max(0,arr[i]-current_diff)\n                        total = total+current_diff\n        return total", "136": "def findNumbers(arr, n):\n    sumN = (n * (n + 1)) // 2\n    sumSqN = (n * (n + 1) * (2 * n + 1)) // 6\n    sum = 0\n    sumSq = 0\n    for i in range(0, n):\n        sum += arr[i]\n        sumSq = sumSq + (pow(arr[i], 2))\n    B = (((sumSq - sumSqN) // (sum - sumN)) + sumN - sum) // 2\n    A = sum - sumN + B\n    print(\"A = \")\n    print(A)\n    print(\"B = \")\n    print(B)", "137": "def is_prefix(temp, str):\n        if len(temp) < len(str):\n                return 0\n        else:\n                for i in range(0, len(str)):\n                        if str[i] != temp[i]:\n                                return 0\n                return 1\n\ndef lexicographicallyString(input, n, str):\n        input.sort()\n        for i in range(0, n):\n                temp = input[i]\n                if is_prefix(temp, str):\n                        return temp\n        return \"-1\"", "138": "def Rearrange(arr, K, N):\n        ans = [N + 1]\n        f = -1\n        for i in range(0, N):\n                ans[i] = -1\n        K = find(arr, arr + N, K) - arr\n        smaller = []\n        greater = []\n        for i in range(0, N):\n                if (arr[i] < arr[K]):\n                        smaller.append(arr[i])\n                elif (arr[i] > arr[K]):\n                        greater.append(arr[i])\n        low = 0\n        high = N - 1\n        while (low <= high):\n                mid = (low + high) / 2\n                if (mid == K):\n                        ans[mid] = arr[K]\n                        f = 1\n                        break\n                elif (mid < K):\n                        if (len(smaller) == 0):\n                                break\n                        ans[mid] = smaller.back()\n                        smaller.pop()\n                        low = mid + 1\n                else:\n                        if (len(greater) == 0):\n                                break\n                        ans[mid] = greater.back()\n                        greater.pop()\n                        high = mid - 1\n        if (f == -1):\n                print(-1)\n                return\n        for i in range(0, N):\n                if (ans[i] == -1):\n                        if (len(smaller)):\n                                ans[i] = smaller.back()\n                                smaller.pop()\n                        elif (len(greater)):\n                                ans[i] = greater.back()\n                                greater.pop()\n        for i in range(0, N):\n                print(ans[i], \" \")\n        print()", "139": "def minimumK(arr, M, N):\n        good = math.ceil((N * 1.0)\n                                        / ((M + 1) * 1.0))\n        for i in range(1, N+1):\n                K = i\n                candies = N\n                taken = 0\n                while (candies > 0):\n                        taken += min(K, candies)\n                        candies -= min(K, candies)\n                        for j in range(0,M):\n                                consume = (arr[j] * candies) / 100\n                                candies -= consume\n                if (taken >= good):\n                        return i", "140": "def check(K, n, m, arr, good_share): \n       \n        candies = n \n        taken = 0\n        while (candies > 0) : \n                taken += min(K, candies) \n                candies -= min(K, candies) \n                for j in range(0, m) : \n                        consume = (arr[j] * candies) // 100\n                        candies -= consume \n      \n        return (taken >= good_share) \n          \ndef minimumK(arr, N, M) : \n       \n        good_share = math.ceil((N * 1.0) \n                                                / ((M + 1) * 1.0)) \n        lo = 1\n        hi = N \n        while (lo < hi) : \n                mid = (lo + hi) // 2\n                if (check(mid, N, M, arr, good_share)) : \n                        hi = mid \n                else : \n                        lo = mid + 1\n  \n        print(hi)", "141": "def calcTotalTime(path):\n        time = 0\n        x = 0\n        y = 0\n        s = set()\n        for i in range(0, len(path)):\n                p = x\n                q = y\n                if path[i] == 'N':\n                        y += 1\n                elif path[i] == 'S':\n                        y -= 1\n                elif path[i] == 'E':\n                        x += 1\n                elif path[i] == 'W':\n                        x -= 1\n                if {p + x, q + y} not in s:\n                        time += 2\n                        s.add({p + x, q + y})\n                else:\n                        time += 1\n        print(time)", "142": "def calcPsquare(N):\n        for i in range(1,N):\n                psquare.append(i*i)\ndef countWays(index, target):\n        if target == 0:\n                return 1\n        if index < 0 or target < 0:\n                return 0\n        inc = countWays( index, target - psquare[index])\n        exc = countWays(index - 1, target)\n        return inc + exc", "143": "def findCost(A, N):\n        totalCost = 0\n        for i in range(0, N):\n                if A[i] == 0:\n                        A[i] = 1\n                        totalCost += i\n        return totalCost", "144": "def search(list, num):\n        low = 0\n        high = len(list) - 1\n        ans = -1\n        while (low <= high):\n                mid = low + (high - low) // 2\n                if (list[mid] <= num):\n                        ans = mid\n                        low = mid + 1\n                else:\n                        high = mid - 1\n        return ans\n\ndef isPalindrome(n):\n        rev = 0\n        temp = n\n        while (n > 0):\n                rev = rev * 10 + n % 10\n                n //= 10\n        return rev == temp\n\ndef countNumbers(L, R, K):\n        list = []\n        for i in range(L, R+1):\n                if isPalindrome(i):\n                        list.append(i)\n        count = 0\n        for i in range(len(list)):\n                right_index = search(list, list[i] + K - 1)\n                if (right_index != -1):\n                        count = max(count, right_index - i + 1)\n        return count", "145": "def peakIndex(arr, N):\n        if (N < 3):\n                return -1\n        i = 0\n        while (i + 1 < N):\n                if (arr[i + 1] < arr[i]):\n                        break\n                i++\n        if (i == 0) or (i == N - 1):\n                return -1\n        ans = i\n        while (i < N - 1):\n                if (arr[i] < arr[i + 1]):\n                        break\n                i++\n        if (i == N - 1):\n                return ans\n        return -1", "146": "def hasArrayTwoPairs(nums, n, target):\n        nums.sort()\n        for i in range(n):\n                x = target - nums[i]\n                low = 0\n                high = n - 1\n                while low <= high:\n                        mid = low + ((high - low) / 2)\n                        if nums[mid] > x:\n                                high = mid - 1\n                        elif nums[mid] < x:\n                                low = mid + 1\n                        else:\n                                if mid == i:\n                                        if (mid - 1 >= 0) and nums[mid - 1] == x:\n                                                print(nums[i], \", \", nums[mid - 1])\n                                                return\n                                        if (mid + 1 < n) and nums[mid + 1] == x:\n                                                print(nums[i], \", \", nums[mid + 1])\n                                                return\n                                        break\n                                else:\n                                        print(nums[i], \", \", nums[mid])\n                                        return\n        print(-1)", "147": "def newnode(data):\n        Node = new TreeNode()\n        Node.data = data\n        Node.left = null\n        Node.right = null\n        return (Node)\n\ndef sumofsubtree(root):\n        p = make_pair(1,0)\n        if root.left:\n                ptemp = sumofsubtree(root.left)\n                p.second += ptemp.first + ptemp.second\n                p.first += ptemp.first\n        if root.right:\n                ptemp = sumofsubtree(root.right)\n                p.second += ptemp.first + ptemp.second\n                p.first += ptemp.first\n        root.size = p.first\n        return p\n\ndef distance(root, target, distancesum, n):\n        if root.data == target:\n                sum = distancesum\n        if root.left:\n                tempsum = distancesum - root.left.size + (n - root.left.size)\n                distance(root.left, target, tempsum, n)\n        if root.right:\n                tempsum = distancesum - root.right.size + (n - root.right.size)\n                distance(root.right, target, tempsum, n)", "148": "def delCost(s, cost, l1, l2):\n        visited = [0] * l1\n        ans = 0\n        for i in range(l1):\n                if (visited[i]):\n                        continue\n                maxDel = 0\n                totalCost = 0\n                visited[i] = 1\n                for j in range(i, l1):\n                        if (s[i] == s[j]):\n                                maxDel = max(maxDel, cost[j])\n                                totalCost += cost[j]\n                                visited[j] = 1\n                ans += totalCost - maxDel\n        return ans", "149": "def delCost(s, cost):\n        ans = 0\n        forMax = {}\n        forTot = {}\n        for i in range(len(s)):\n                if not s[i] in forMax.keys():\n                        forMax[s[i]] = cost[i]\n                else:\n                        forMax[s[i]] = max(cost[i], forMax[s[i]])\n                if not s[i] in forTot.keys():\n                        forTot[s[i]] = cost[i]\n                else:\n                        forTot[s[i]] = forTot[s[i]] + cost[i]\n        for i in forMax.keys():\n                ans += forTot[i] - i\n        return ans", "150": "def findClosest(N, target):\n        closest = -1\n        diff = INT_MAX\n        for i in range(1, sqrt(N)):\n                if (N % i == 0):\n                        if (N / i == i):\n                                if (abs(target - i) < diff):\n                                        diff = abs(target - i)\n                                        closest = i\n                        else:\n                                if (abs(target - i) < diff):\n                                        diff = abs(target - i)\n                                        closest = i\n                                if (abs(target - N / i) < diff):\n                                        diff = abs(target - N / i)\n                                        closest = N / i\n        print closest", "151": "def computeDivisors(MAX):\n        for i in range (1, MAX+1):\n                for j in range (i, MAX+1, i):\n                        divisors[j].append(i)\n\ndef getClosest(val1, val2, target):\n        if target - val1 >= val2 - target:\n                return val2\n        else:\n                return val1\n\ndef findClosest(arr, n, target):\n        if target <= arr[0]:\n                return arr[0]\n        if target >= arr[n - 1]:\n                return arr[n - 1]\n        i = 0\n        j = n\n        mid = 0\n        while i < j:\n                mid = (i + j) // 2\n                if arr[mid] == target:\n                        return arr[mid]\n                if target < arr[mid]:\n                        if mid > 0 and target > arr[mid - 1]:\n                                return getClosest(arr[mid - 1], arr[mid], target)\n                        j = mid\n                else:\n                        if mid < n - 1 and target < arr[mid + 1]:\n                                return getClosest(arr[mid], arr[mid + 1], target)\n                        i = mid + 1\n        return arr[mid]\n\ndef printClosest(N, X):\n        computeDivisors(MAX)\n        ans = findClosest(divisors[N], divisors[N].size(), X)\n        print(ans)", "152": "def countTriplets(arr, N):\n        zero_i = []\n        one_i = []\n        mp = {}\n        for i in range(0, N):\n                if (arr[i] == 0):\n                        zero_i.append(i + 1)\n                elif (arr[i] == 1):\n                        one_i.append(i + 1)\n                else:\n                        mp[i + 1] = 1\n        total = len(zero_i) * len(one_i) * len(mp.keys())\n        for i in range(0, len(zero_i)):\n                for j in range(0, len(one_i)):\n                        p = zero_i[i]\n                        q = one_i[j]\n                        r = 2 * p - q\n                        if (r in mp.keys()):\n                                total -= 1\n                        r = 2 * q - p\n                        if (r in mp.keys()):\n                                total -= 1\n                        r = (p + q) / 2\n                        if (r in mp.keys() and abs(r - p) == abs(r - q)):\n                                total -= 1\n        print(total)", "153": "def checkXOR(arr, N):\n        if N % 2 == 0:\n                xro = 0\n                for i in range(0, N):\n                        xro ^= arr[i]\n                if xro != 0:\n                        print(-1)\n                        return\n                for i in range(0, N - 3, 2):\n                        print(i, i + 1, i + 2)\n                for i in range(0, N - 3, 2):\n                        print(i, i + 1, N - 1)\n        else:\n                for i in range(0, N - 2, 2):\n                        print(i, i + 1, i + 2)\n                for i in range(0, N - 2, 2):\n                        print(i, i + 1, N - 1)", "154": "def make_array_element_even(arr, N):\n        res = 0\n        odd_cont_seg = 0\n        for i in range(0, N):\n                if (arr[i] % 2 == 1):\n                        odd_cont_seg = odd_cont_seg + 1\n                else:\n                        if (odd_cont_seg > 0):\n                                if (odd_cont_seg % 2 == 0):\n                                        res = res + odd_cont_seg / 2\n                                else:\n                                        res = res + odd_cont_seg / 2 + 2\n                                odd_cont_seg = 0\n        if (odd_cont_seg > 0):\n                if (odd_cont_seg % 2 == 0):\n                        res = res + odd_cont_seg / 2\n                else:\n                        res = res + odd_cont_seg / 2 + 2\n        return res", "155": "def minCollectingSpeed(piles, H):\n        ans = -1\n        low = 1\n        high = max(piles)\n\n        while low <= high:\n                K = low + (high - low) // 2\n                time = 0\n                for ai in piles:\n                        time += (ai + K - 1) // K\n                if time <= H:\n                        ans = K\n                        high = K - 1\n                else:\n                        low = K + 1\n\n        print(ans)", "156": "def cntDisPairs(arr, N, K):\n        cntPairs = 0\n        arr.sort()\n        i = 0\n        j = N - 1\n        while i < j:\n                if arr[i] + arr[j] == K:\n                        while i < j and arr[i] == arr[i + 1]:\n                                i += 1\n                        while i < j and arr[j] == arr[j - 1]:\n                                j -= 1\n                        cntPairs += 1\n                        i += 1\n                        j -= 1\n                elif arr[i] + arr[j] < K:\n                        i += 1\n                else:\n                        j -= 1\n        return cntPairs", "157": "def cntDisPairs(arr, N, K):\n        cntPairs = 0\n        cntFre = {}\n        for i in range(0, N):\n                if(arr[i] in cntFre):\n                        cntFre[arr[i]] += 1\n                else:\n                        cntFre[arr[i]] = 1\n        for it in cntFre:\n                i = it\n                if (2 * i == K):\n                        if (cntFre[i] > 1):\n                                cntPairs += 2\n                else:\n                        if (K-i in cntFre):\n                                cntPairs += 1\n        cntPairs = cntPairs / 2\n        return cntPairs", "158": "def push(head, new_data):\n        new_node = Node(new_data)\n        new_node.prev = None\n        new_node.next = head\n        if head is not None:\n                head.prev = new_node\n        head = new_node\ndef search(head, x):\n        temp = head\n        pos = 0\n        while temp.data != x and temp.next is not None:\n                pos += 1\n                temp = temp.next\n        if temp.data != x:\n                return -1\n        return (pos + 1)", "159": "def longestSubsequence(N, Q, arr, Queries):\n        for i in range(0, Q):\n                x = Queries[i][0]\n                y = Queries[i][1]\n                arr[x - 1] = y\n                count = 1\n                for j in range(1, N):\n                        if arr[j] != arr[j - 1]:\n                                count += 1\n                print(count, ' ')", "160": "def longestSubsequence(N, Q, arr, Queries):\n        count = 1\n        for i in range(1, N):\n                if arr[i] != arr[i - 1]:\n                        count += 1\n        for i in range(0, Q):\n                x = Queries[i][0]\n                y = Queries[i][1]\n                if x > 1:\n                        if arr[x - 1] != arr[x - 2]:\n                                count -= 1\n                        if arr[x - 2] != y:\n                                count += 1\n                if x < N:\n                        if arr[x] != arr[x - 1]:\n                                count -= 1\n                        if y != arr[x]:\n                                count += 1\n                print(count, ' ')\n                arr[x - 1] = y", "161": "def sum(arr, n):\n    mp = {}\n    for i in range(n):\n        if arr[i] not in mp:\n            mp[arr[i]] = [i]\n        else:\n            mp[arr[i]].append(i)\n    ans = [0] * n\n    for i in range(n):\n        sum = 0\n        for it in mp[arr[i]]:\n            sum += abs(it - i)\n        ans[i] = sum\n    for i in range(n):\n        print(ans[i], end = \" \")\n    return", "162": "def rearrangeArray(A, B, N, K): \n        B.sort(reverse = True) \n        flag = True\n        for i in range(0, N): \n                if A[i] + B[i] > K: \n                        flag = False\n                        break\n        if not flag: \n                print (\"-1\") \n        else: \n                for i in range(0, N): \n                        print (B[i], end = \" \")", "163": "def isinRange(board):\n        for i in range(N):\n                for j in range(N):\n                        if (board[i][j] <= 0 and board[i][j] > 9):\n                                return false\n        return true\n\ndef isValidSudoku(board):\n        if (isinRange(board) == false):\n                return false\n        unique = [false for x in range(N + 1)]\n        for i in range(N):\n                for j in range(N):\n                        Z = board[i][j]\n                        if (unique[Z]):\n                                return false\n                        unique[Z] = true\n        for i in range(N):\n                unique = [false for x in range(N + 1)]\n                for j in range(N):\n                        Z = board[j][i]\n                        if (unique[Z]):\n                                return false\n                        unique[Z] = true\n        for i in range(0, N - 2, 3):\n                for j in range(0, N - 2, 3):\n                        unique = [false for x in range(N + 1)]\n                        for k in range(3):\n                                for l in range(3):\n                                        X = i + k\n                                        Y = j + l\n                                        Z = board[X][Y]\n                                        if (unique[Z]):\n                                                return false\n                                        unique[Z] = true\n        return true", "164": "def conVowUpp(str):\n        N = len(str)\n        for i in range(0, N):\n                if (str[i] == 'a' or str[i] == 'e' or str[i] == 'i' or str[i] == 'o' or str[i] == 'u'):\n                        str[i] = chr(ord(str[i]) - ord('a') + ord('A'))\n        return str", "165": "def zvalue(nums):\n        m = max(nums)\n        cnt = 0\n        for i in range(0, m+1):\n                cnt = 0\n                for j in range(0, len(nums)):\n                        if nums[j] >= i:\n                                cnt += 1\n                if cnt == i:\n                        return i\n        return -1", "166": "def palindrome(a, i, j):\n        while(i<j):\n                if(a[i] != a[j]):\n                        return false\n                i=i+1\n                j=j-1\n        return true\n\ndef findSubArray(arr, k):\n        n=SizeOf(arr)/SizeOf(arr[0])\n        for(int i=0; i<=n-k; i++){\n                if(palindrome(arr, i, i+k-1))\n                        return i\n        }\n        return -1", "167": "def helper(mid):\n        cnt = 0\n        for k in mp:\n                temp = mp.get(k)\n                while temp >= mid:\n                        temp -= mid\n                        cnt++\n        return cnt >= N\n\ndef findMaximumDays(arr):\n        for i in range(P):\n                mp[arr[i]] += 1\n        start = 0\n        end = P\n        ans = 0\n        while start <= end:\n                mid = start + ((end - start) // 2)\n                if mid != 0 and helper(mid):\n                        ans = mid\n                        start = mid + 1\n                elif mid == 0:\n                        start = mid + 1\n                else:\n                        end = mid - 1\n        return ans", "168": "def countSubarrays(arr, n, k) : \n    ans = 0\n    pref = [0]\n    for i in range(0, n) : \n        pref.append((arr[i] + pref[i]) % k) \n    for i in range(1, n + 1) : \n        for j in range(i, n + 1) : \n            if ((pref[j] - pref[i - 1] + k) % k == j - i + 1) : \n                ans = ans + 1\n    print(ans, end = ' ')", "169": "def countSubarrays(a, n, k):\n        cnt = {}\n        ans = 0\n        pref = []\n        pref.append(0)\n        for i in range(0, n):\n                pref.append((a[i] + pref[i]) % k)\n        cnt[0] = 1\n        for i in range(1, n+1):\n                remIdx = i - k\n                if remIdx >= 0:\n                        cnt[(pref[remIdx] - remIdx % k + k) % k] -= 1\n                ans += cnt[(pref[i] - i % k + k) % k]\n                cnt[(pref[i] - i % k + k) % k] += 1\n        print(ans, end = ' ')", "170": "def countRows(mat):\n    count = 0\n    totalSum = 0\n    for i in range(N):\n        for j in range(M):\n            totalSum += mat[i][j]\n    for i in range(N):\n        currSum = 0\n        for j in range(M):\n            currSum += mat[i][j]\n        if currSum > totalSum - currSum:\n            count += 1\n    return count", "171": "def isCrossed(path): \n        if len(path) == 0: \n                return False\n        ans = False\n        set = dict() \n        x, y = 0, 0\n        set[(x, y)] = True\n        for i in range(0, len(path)): \n                if path[i] == 'N': \n                        set[(x, y + 1)] = True\n                        y += 1\n                if path[i] == 'S': \n                        set[(x, y - 1)] = True\n                        y -= 1\n                if path[i] == 'E': \n                        set[(x + 1, y)] = True\n                        x += 1\n                if path[i] == 'W': \n                        set[(x - 1, y)] = True\n                        x -= 1\n                if (x, y) in set: \n                        ans = True\n                        break\n        if ans == True: \n                print(\"Crossed\")\n        else: \n                print(\"Not Crossed\")", "172": "def maxWidth(N, M, cost, s):\n        adj = [[] for i in range(N)]\n        for i in range(M):\n                adj[s[i][0]].append( s[i][1])\n        result = 0\n        q = []\n        q.append(0)\n        while (len(q) != 0):\n                count = len(q)\n                result = max(count, result)\n                while (count != 0):\n                        temp = q[0]\n                        q.pop(0)\n                        for i in range(len(adj[temp])):\n                                q.append(adj[temp][i])\n                        count -= 1\n        return result", "173": "def SieveOfEratosthenes():\n        isPrime = []\n        for p in range(2, MAX + 1):\n                if (isPrime[p] == true):\n                        for i in range(p * p, MAX + 1, p):\n                                isPrime[i] = false\n                if (isPrime[p]):\n                        primes.push_back(p)\ndef prime_search(primes, diff):\n        low = 0\n        high = primes.size() - 1\n        res = 0\n        while (low <= high):\n                mid = (low + high) // 2\n                if (primes[mid] == diff):\n                        return primes[mid]\n                else if (primes[mid] < diff):\n                        low = mid + 1\n                else:\n                        res = primes[mid]\n                        high = mid - 1\n        return res\ndef minCost(arr, n):\n        SieveOfEratosthenes()\n        res = 0\n        for i in range(1, n):\n                if (arr[i] < arr[i - 1]):\n                        diff = arr[i - 1] - arr[i]\n                        closest_prime = prime_search(primes, diff)\n                        res += closest_prime\n                        arr[i] += closest_prime\n        return res", "174": "def lexico_smallest(s1, s2):\n        M = {}\n        S = set()\n        pr = []\n        for i in range(0, len(s1)):\n                M[s1[i]]= M.get(s1[i], 0) + 1\n                S.add(s1[i])\n        for i in range(0, len(s2)):\n                M[s2[i]]= M.get(s2[i], 0) - 1\n        c = s2[0]\n        index = 0\n        res = \"\"\n        for x in S:\n                if x != c:\n                        for i in range(1, M[x] + 1):\n                                res += x\n                else:\n                        j = 0\n                        index = len(res)\n                        while s2[j] == x:\n                                j+=1\n                        if s2[j] < c:\n                                res += s2\n                                for i in range(1, M[x] + 1):\n                                        res += x\n                        else:\n                                for i in range(1, M[x] + 1):\n                                        res += x\n                                index += M[x]\n                                res += s2\n        pr.append(res)\n        pr.append(index)\n        return pr\n\ndef lexico_largest(s1, s2):\n        pr = lexico_smallest(s1, s2)\n        d1 = \"\"\n        for i in range(pr[1] - 1, -1, -1):\n                d1 += pr[0][i]\n        d2 = \"\"\n        for i in range(len(pr[0]) - 1, pr[1] + len(s2) - 1, -1):\n                d2 += pr[0][i]\n        res = d2 + s2 + d1\n        return res", "175": "def addEdge(v, x, y):\n        v[x].append(y)\n        v[y].append(x)\ndef dfs(tree, temp, ancestor, u, parent, k):\n        temp.append(u)\n        for i in tree[u]:\n                if (i == parent):\n                        continue\n                dfs(tree, temp, ancestor, i, u, k)\n        temp.pop()\n        if (len(temp) < k):\n                ancestor[u] = -1\n        else:\n                ancestor[u] = temp[len(temp) - k]\ndef KthAncestor(N, K, E, edges):\n        tree = [[] for i in range(N + 1)]\n        for i in range(E):\n                addEdge(tree, edges[i][0], edges[i][1])\n        temp = []\n        ancestor = [0] * (N + 1)\n        dfs(tree, temp, ancestor, 1, 0, K)\n        for i in range(1, N + 1):\n                print(ancestor[i], end = \" \")", "176": "def build(sum, a, l, r, rt):\n        if (l == r):\n                sum[rt] = a[l - 1]\n                return\n        int m = (l + r) >> 1\n        build(sum, a, l, m, rt << 1)\n        build(sum, a, m + 1, r, rt << 1 1)\n\ndef pushDown(sum, add, rt, ln, rn):\n        if (add[rt]):\n                add[rt << 1] += add[rt]\n                add[rt << 1 1] += add[rt]\n                sum[rt << 1] += add[rt] * ln\n                sum[rt << 1 1] += add[rt] * rn\n                add[rt] = 0\n\ndef update(sum, add, L, R, C, l, r, rt):\n        if (L <= l and r <= R):\n                sum[rt] += C * (r - l + 1)\n                add[rt] += C\n                return\n        int m = (l + r) >> 1\n        pushDown(sum, add, rt, m - l + 1, r - m)\n        if (L <= m):\n                update(sum, add, L, R, C, l, m, rt << 1)\n        if (R > m):\n                update(sum, add, L, R, C, m + 1, r, rt << 1 1)\n\ndef query(sum, add, L, R, l, r, rt):\n        if (L <= l and r <= R):\n                return sum[rt]\n        int m = (l + r) >> 1\n        pushDown(sum, add, rt, m - l + 1, r - m)\n        int ans = 0\n        if (L <= m):\n                ans += query(sum, add, L, R, l, m, rt << 1)\n        if (R > m):\n                ans += query(sum, add, L, R, m + 1, r, rt << 1 1)\n        return ans\n\ndef sequenceMaintenance(n, q, a, b, m):\n        a.sort()\n        sum = [0] * (n << 2)\n        add = [0] * (n << 2)\n        build(sum, a, 1, n, 1)\n        for i in range(q):\n                l = 1\n                r = n\n                pos = -1\n                while (l <= r):\n                        m = (l + r) >> 1\n                        if (query(sum, add, m, m, 1, n, 1) >= b[i]):\n                                r = m - 1\n                                pos = m\n                        else:\n                                l = m + 1\n                if (pos == -1):\n                        ans.push_back(0)\n                else:\n                        ans.push_back(n - pos + 1)\n                        update(sum, add, pos, n, -m, 1, n, 1)\n        for i in range(len(ans)):\n                print(ans[i], end = \" \")", "177": "def count(s):\n        cnt = 0\n        for c in s:\n                cnt += c == '0' ? 1 : 0\n        if cnt % 3 != 0:\n                return 0\n        res = 0\n        k = cnt / 3\n        sum = 0\n        mp = {}\n        for i in range(len(s)):\n                sum += s[i] == '0' ? 1 : 0\n                if sum == 2 * k and k in mp and i < len(s) - 1 and i > 0:\n                        res += mp[k]\n                if sum in mp:\n                        mp[sum] += 1\n                else:\n                        mp[sum] = 1\n        return res", "178": "def splitstring(s):\n        n = len(s)\n        zeros = 0\n        for i in range(n):\n                if (s[i] == '0'):\n                        zeros = zeros + 1\n        if (zeros % 3 != 0):\n                return 0\n        if (zeros == 0):\n                return ((n - 1) * (n - 2)) / 2\n        zerosInEachSubstring = zeros / 3\n        waysOfFirstCut = 0\n        waysOfSecondCut = 0\n        count = 0\n        for i in range(n):\n                if (s[i] == '0'):\n                        count = count + 1\n                if (count == zerosInEachSubstring):\n                        waysOfFirstCut = waysOfFirstCut + 1\n                elif (count == 2 * zerosInEachSubstring):\n                        waysOfSecondCut = waysOfSecondCut + 1\n        return waysOfFirstCut * waysOfSecondCut", "179": "def check(self, s, k):\n        n = len(s)\n        for i in range(k):\n                for j in range(i, n, k):\n                        if s[i] != s[j]:\n                                return False\n        c = 0\n        for i in range(k):\n                if s[i] == '0':\n                        c = c + 1\n                else:\n                        c = c - 1\n        if c == 0:\n                return True\n        else:\n                return False", "180": "def addEdge(a, b):\n        tree[a].append(b)\n        tree[b].append(a)\ndef dfs(x):\n        vis[x] = true\n        subtreeSize[x] = 1\n        for i in tree[x]:\n                if not vis[i]:\n                        dfs(i)\n                        subtreeSize[x]\n                                += subtreeSize[i]\ndef countPairs(a, b):\n        sub = min(subtreeSize[a], subtreeSize[b])\n        print(sub * (n - sub))", "181": "def revNum(N):\n        x = 0\n        while (N):\n                x = x * 10 + N % 10\n                N = N / 10\n        return x\ndef ctNonPalin(arr, N):\n        Res = 0\n        for i in range (0, N):\n                x = revNum(arr[i])\n                if (x == arr[i]):\n                        continue\n                else:\n                        Res += (arr[i] % 10 == N % 10)\n        return Res", "182": "def isSame(str, n):\n\n        mp = {}\n\n        for i in range(0, len(str)):\n                if str[i] in mp:\n                        mp[str[i]] += 1\n                else:\n                        mp[str[i]] = 1\n\n        for k,v in mp.items():\n                if v >= n:\n                        return True\n\n        return False", "183": "def canTransform(str1, str2):\n        s1 = \"\"\n        s2 = \"\"\n        for c in str1:\n                if c != 'C':\n                        s1 += c\n        for c in str2:\n                if c != 'C':\n                        s2 += c\n        if s1 != s2:\n                return False\n        i = 0\n        j = 0\n        n = len(str1)\n        while i < n and j < n:\n                if str1[i] == 'C':\n                        i += 1\n                elif str2[j] == 'C':\n                        j += 1\n                else:\n                        if (str1[i] == 'A' and i < j) or (str1[i] == 'B' and i > j):\n                                return False\n                        i += 1\n                        j += 1\n        return True\n\nstr1 = \"BCCABCBCA\"\nstr2 = \"CBACCBBAC\"\nif canTransform(str1, str2):\n        print(\"Yes\")\nelse:\n        print(\"No\")", "184": "def func(a, b, c, x):\n        return a * x * x + b * x + c\ndef findRoot(a, b, c, low, high):\n        x = (low + high) / 2\n        while abs(high - low) > eps:\n                if func(a, b, c, low) * func(a, b, c, x) <= 0:\n                        high = x\n                else:\n                        low = x\n                x = (low + high) / 2\n        return x\ndef solve(a, b, c, A, B):\n        if func(a, b, c, A) * func(a, b, c, B) > 0:\n                print(\"No solution\")\n        else:\n                print(\"{0:.4f}\".format(findRoot(a, b, c, A, B)))", "185": "def hasCoprimePair(arr, n):\n        for i in range(0, n - 1):\n                for j in range(i + 1, n):\n                        if math.gcd(arr[i], arr[j]) == 1:\n                                return True\n        return False", "186": "def findPermutation(arr, N):\n        pos = arr.size() + 1\n        if (pos > N):\n                return 1\n        res = 0\n        for i in range(1, N+1):\n                if (i not in arr):\n                        if (i % pos == 0 or pos % i == 0):\n                                arr.add(i)\n                                res += findPermutation(arr, N)\n                                arr.remove(i)\n        return res", "187": "def solve(arr, n, X, Y):\n        diff = Y - X\n        for i in range(width):\n                if (arr[i] != 1):\n                        diff = diff % (arr[i] - 1)\n        if (diff == 0):\n                print(\"Yes\")\n        else:\n                print(\"No\")", "188": "def Numberofways(n):\n        count = 0\n        for a in range(1, n):\n                for b in range(1, n):\n                        c = n - (a + b)\n                        if a + b > c and a + c > b and b + c > a:\n                                count += 1\n        return count", "189": "def maxsubstringLength(S, N):\n        arr=[]\n        for i in range(N):\n                if S[i] == 'a' S[i] == 'e' S[i] == 'i' S[i] == 'o' S[i] == 'u':\n                        arr[i] = 1\n                else:\n                        arr[i] = -1\n        maxLen = 0\n        curr_sum = 0\n        hash = {}\n        for i in range(N):\n                curr_sum += arr[i]\n                if curr_sum == 0:\n                        maxLen = max(maxLen, i + 1)\n                if curr_sum in hash:\n                        maxLen = max(maxLen, i - hash[curr_sum])\n                else:\n                        hash[curr_sum] = i\n        return maxLen", "190": "def findPrevious(a, n):\n        ps = [0] * n\n        ps[0] = -1\n        Stack = []\n        Stack.append(0)\n        for i in range(1, n):\n                while (len(Stack) > 0 and\n                        a[Stack[-1]] >= a[i]):\n                        Stack.pop()\n                ps[i] = Stack[-1] if (len(Stack) > 0) else -1\n                Stack.append(i)\n        return ps\ndef findNext(a, n):\n        ns = [0] * n\n        ns[n - 1] = n\n        Stack = []\n        Stack.append(n - 1)\n        for i in range(n - 2, -1, -1):\n                while (len(Stack) > 0 and\n                        a[Stack[-1]] >= a[i]):\n                        Stack.pop()\n                ns[i] = Stack[-1] if (len(Stack) > 0) else n\n                Stack.append(i)\n        return ns\ndef findMaximumSum(a, n):\n        prev_smaller = findPrevious(a, n)\n        next_smaller = findNext(a, n)\n        max_value = 0\n        for i in range(n):\n                max_value = max(max_value, a[i] *\n                                        (next_smaller[i] - prev_smaller[i] - 1))\n        return max_value", "191": "def possible(mid, a):\n        n = len(a)\n        total = (n * (n - 1)) / 2\n        need = (total + 1) / 2\n        count = 0\n        start = 0\n        end = 1\n        while end < n:\n                if a[end] - a[start] <= mid:\n                        end+-\n                else:\n                        count += (end - start - 1)\n                        start++\n        if end == n and start < end and a[end - 1] - a[start] <= mid:\n                t = end - start - 1\n                count += (t * (t + 1) / 2)\n        if count >= need:\n                return True\n        else:\n                return False\n\ndef findMedian(a):\n        n = len(a)\n        low = 0\n        high = a[n - 1] - a[0]\n        while low <= high:\n                mid = (low + high) / 2\n                if possible(mid, a):\n                        high = mid - 1\n                else:\n                        low = mid + 1\n        return high + 1", "192": "def FindMinimumDistance():\n        q = []\n        q.append([ x, y ])\n        mat[x][y] = 0\n        while not q:\n                x = q.front().first\n                y = q.front().second\n                q.pop()\n                for i in range(0, 8):\n                        a = x + dx[i]\n                        b = y + dy[i]\n                        if (a < 0 a >= r b >= c b < 0):\n                                continue\n                        if (mat[a][b] == 0):\n                                mat[a][b] = mat[x][y] + 1\n                                q.append([ a, b ])", "193": "def addEdge(u, v):\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n\ndef dfs1(cur, par):\n        for u in adj[cur]:\n                if (u != par):\n                        dfs1(u, cur);\n                        height[cur]\n                                = max(height[cur], height[u]);\n\ndef dfs2(cur, par):\n        max1 = 0;\n        max2 = 0;\n        for u in adj[cur]:\n                if (u != par):\n                        if (height[u] >= max1):\n                                max2 = max1;\n                                max1 = height[u];\n                        else if (height[u] > max2):\n                                max2 = height[u];\n        sum = 0;\n        for u in adj[cur]:\n                if (u != par):\n                        sum = ((max1 == height[u]) ? max2 : max1);\n                        if (max1 == height[u]):\n                                dist[u]\n                                        = 1 + max(1 + max2, dist[cur]);\n                        else:\n                                dist[u]\n                                        = 1 + max(1 + max1, dist[cur]);\n                        dfs2(u, cur);", "194": "def countPairs(N, arr):\n        count = 0\n        for i in range(N):\n                if i == arr[arr[i] - 1] - 1:\n                        count += 1\n        print(count / 2)", "195": "def minOperations(S, K):\n        ans = 0\n        for i in range(0,K):\n                zero = 0\n                one = 0\n                for j in range(i,len(S),K):\n                        if S[j] == '0':\n                                zero += 1\n                        else:\n                                one += 1\n                ans += min(zero, one)\n        return ans", "196": "def UniversalSubset(A, B): \n        n1 = len(A) \n        n2 = len(B) \n        res = [] \n        A_fre = [[0 for i in range(26)]  \n                        for j in range(n1)] \n                \n        for i in range(n1): \n                for j in range(26): \n                        A_fre[i][j] = 0\n                          \n        for i in range(n1): \n                for j in range(len(A[i])): \n                        A_fre[i][ord(A[i][j]) - ord('a')] += 1\n                          \n        B_fre = [0] * 26\n        for i in range(n2): \n                arr = [0] * 26\n                for j in range(len(B[i])): \n                        arr[ord(B[i][j]) - ord('a')] += 1\n                        B_fre[ord(B[i][j]) - ord('a')] = max(B_fre[ord(B[i][j]) - ord('a')], arr[ord(B[i][j]) - ord('a')]) \n                          \n        for i in range(n1): \n                flag = 0\n                for j in range(26): \n                        if (A_fre[i][j] < B_fre[j]): \n                                flag = 1\n                                break\n                if (flag == 0): \n                        res.append(A[i]) \n                          \n        if (res): \n                for i in range(len(res)): \n                        for j in range(len(res[i])): \n                                print(res[i][j], end = \"\") \n                print(\" \", end = \"\") \n        else: \n                print(\"-1\", end = \"\")", "197": "def findPair(a, n) : \n    min_dist = INT_MAX\n    index_a = -1\n    index_b = -1\n    \n    for i in range(0, n) : \n        for j in range(i+1, n) : \n            if (j - i < min_dist) : \n                if (a[i] % a[j] == 0 and a[j] % a[i] == 0) : \n                    min_dist = j - i\n                    index_a = i\n                    index_b = j\n                    \n    if (index_a == -1) : \n        print(\"-1\")\n    else : \n        print(\"(\" + str(a[index_a]) + \", \" + str(a[index_b]) + \")\")", "198": "def printNum(L, R):\n        for i in range(L, R+1):\n                temp = i\n                c = 10\n                flag = 0\n                while (temp > 0):\n                        if (temp % 10 >= c):\n                                flag = 1\n                                break\n                        c = temp % 10\n                        temp /= 10\n                if (flag == 0):\n                        print(i, end=\" \")", "199": "def findMissing(arr, left, right, diff):\n        if (right <= left):\n                return INT_MAX;\n        int mid = left + (right - left) / 2;\n        if (arr[mid + 1] - arr[mid] != diff):\n                return (arr[mid] + diff);\n        if (mid > 0 && arr[mid] - arr[mid - 1] != diff):\n                return (arr[mid - 1] + diff);\n        if (arr[mid] == arr[0] + mid * diff):\n                return findMissing(arr, mid + 1, right, diff);\n        return findMissing(arr, left, mid - 1, diff);\ndef missingElement(arr, n):\n        arr.sort();\n        int diff = (arr[n - 1] - arr[0]) / n;\n        return findMissing(arr, 0, n - 1, diff);", "200": "def missingElement(arr, n):\n        max_ele = arr[0]\n        min_ele = arr[0]\n        x = 0\n        d\n        for i in range(0, n):\n                if arr[i] > max_ele:\n                        max_ele = arr[i]\n                if arr[i] < min_ele:\n                        min_ele = arr[i]\n        d = (max_ele - min_ele) / n\n        for i in range(0, n):\n                x = x ^ arr[i]\n        for i in range(0, n):\n                x = x ^ (min_ele + (i * d))\n        return x", "201": "def power(x, y):\n    temp = None\n    if y == 0:\n        return 1\n    temp = power(x, y / 2)\n    if y % 2 == 0:\n        return temp * temp\n    else:\n        return x * temp * temp\n\ndef nthRootSearch(low, high, N, K):\n    if low <= high:\n        mid = (low + high) / 2\n        if ((power(mid, K) <= N) and (power(mid + 1, K) > N)):\n            return mid\n        elif power(mid, K) < N:\n            return nthRootSearch(mid + 1, high, N, K)\n        else:\n            return nthRootSearch(low, mid - 1, N, K)\n    return low", "202": "def get_subset_count(arr, K, N):\n        arr = sorted(arr)\n        left = 0\n        right = N - 1\n        ans = 0\n        while left <= right:\n                if arr[left] + arr[right] < K:\n                        ans += 1 << (right - left)\n                        left += 1\n                else:\n                        right -= 1\n        return ans", "203": "def minMaxDiff(arr, n, k):\n        max_adj_dif = -99999999\n        for i in range(0, n - 1):\n                max_adj_dif\n                        = max(max_adj_dif,\n                                abs(arr[i] - arr[i + 1]))\n        if (max_adj_dif == 0):\n                return 0\n        best = 1\n        worst = max_adj_dif\n        mid = 0\n        required = 0\n        while (best < worst):\n                mid = int((best + worst) / 2)\n                required = 0\n                for i in range(0, n - 1):\n                        required += int((abs(arr[i] - arr[i + 1]) - 1)\n                                                / mid)\n                if (required > k):\n                        best = mid + 1\n                else:\n                        worst = mid\n        return worst", "204": "def checkMin(arr, len):\n        smallest = INT_MAX\n        secondSmallest = INT_MAX\n        for i in range(0, len):\n                if (arr[i] < smallest):\n                        secondSmallest = smallest\n                        smallest = arr[i]\n                elif (arr[i] < secondSmallest):\n                        secondSmallest = arr[i]\n        if (2 * smallest <= secondSmallest):\n                print(\"Yes\")\n        else:\n                print(\"No\")", "205": "def createHash(hash, maxElement):\n        prev = 0\n        curr = 1\n        hash.insert(prev)\n        hash.insert(curr)\n        while (curr <= maxElement):\n                temp = curr + prev\n                hash.insert(temp)\n                prev = curr\n                curr = temp\ndef fibonacci(arr, n):\n        max_val = max(arr)\n        hash = set()\n        createHash(hash, max_val)\n        minimum = INT_MAX\n        maximum = INT_MIN\n        for i in range(0, n):\n                if arr[i] in hash:\n                        minimum = min(minimum, arr[i])\n                        maximum = max(maximum, arr[i])\n        print(minimum, \",\", maximum)", "206": "def isValidLen(s, len, k):\n        n = len(s)\n        mp = {}\n        right = 0\n        while (right < len):\n                if s[right] in mp:\n                        mp[s[right]] += 1\n                else:\n                        mp[s[right]] = 1\n                right += 1\n        if len(mp) <= k:\n                return True\n        while (right < n):\n                if s[right] in mp:\n                        mp[s[right]] += 1\n                else:\n                        mp[s[right]] = 1\n                mp[s[right - len]] -= 1\n                if mp[s[right - len]] == 0:\n                        del mp[s[right - len]]\n                if len(mp) <= k:\n                        return True\n                right += 1\n        return len(mp) <= k\n\ndef maxLenSubStr(s, k):\n        uni = set(s)\n        if len(uni) < k:\n                return -1\n        n = len(s)\n        lo = -1\n        hi = n + 1\n        while (hi - lo > 1):\n                mid = lo + hi // 2\n                if isValidLen(s, mid, k):\n                        lo = mid\n                else:\n                        hi = mid\n        return lo", "207": "def isSquarePossible(arr, n, l):\n        cnt = 0\n        for i in range(n):\n                if (arr[i] >= l):\n                        cnt++\n                if (cnt >= l):\n                        return True\n        return False\ndef maxArea(arr, n):\n        l = 0\n        r = n\n        len = 0\n        while (l <= r):\n                m = l + ((r - l) // 2)\n                if (isSquarePossible(arr, n, m)):\n                        len = m\n                        l = m + 1\n                else:\n                        r = m - 1\n        return (len * len)", "208": "def sortby(a, b):\n        if (a[0] != b[0]):\n                return a[0] < b[0];\n        return (a[1] < b[1]);\n\ndef kOverlap(pairs, k):\n        vec = []\n        for i in range(0, len(pairs)):\n                vec.append([pairs[i][0], -1])\n                vec.append([pairs[i][1], +1])\n        sort(vec, key = functools.cmp_to_key(sortby))\n        st = []\n        for i in range(0, len(vec)):\n                cur = vec[i]\n                if (cur[1] == -1):\n                        st.append(cur)\n                else:\n                        st.pop()\n                if (len(st) >= k):\n                        return true\n        return false", "209": "def insertNames(arr, n):\n        set = set()\n        for i in range(0, n):\n                if arr[i] not in set:\n                        print(\"No\")\n                        set.add(arr[i])\n                else:\n                        print(\"Yes\")", "210": "def countLessThan(arr, n, key):\n        l = 0\n        r = n - 1\n        index = -1\n        while (l <= r):\n                m = (l + r) // 2\n                if (arr[m] < key):\n                        l = m + 1\n                        index = m\n                else:\n                        r = m - 1\n        return (index + 1)\ndef countGreaterThan(arr, n, key):\n        l = 0\n        r = n - 1\n        index = -1\n        while (l <= r):\n                m = (l + r) // 2\n                if (arr[m] <= key):\n                        l = m + 1\n                else:\n                        r = m - 1\n                        index = m\n        if (index == -1):\n                return 0\n        return (n - index)\ndef countTriplets(n, a, b, c):\n        a.sort()\n        b.sort()\n        c.sort()\n        count = 0\n        for i in range(0, n):\n                current = b[i]\n                a_index = -1\n                c_index = -1\n                low = countLessThan(a, n, current)\n                high = countGreaterThan(c, n, current)\n                count += (low * high)\n        return count", "211": "def Printksubstring(str, n, k):\n        total = (n * (n + 1)) / 2\n        if k > total:\n                print(\"-1\")\n                return\n        substring = [0] * (n + 1)\n        temp = n\n        for i in range(1, n + 1):\n                substring[i] = substring[i - 1] + temp\n                temp -= 1\n        l = 1\n        h = n\n        start = 0\n        while l <= h:\n                m = (l + h) / 2\n                if substring[m] > k:\n                        start = m\n                        h = m - 1\n                elif substring[m] < k:\n                        l = m + 1\n                else:\n                        start = m\n                        break\n        end = n - (substring[start] - k)\n        for i in range(start - 1, end):\n                print(str[i])", "212": "def LowerInsertionPoint(arr, n, X):\n        if (X < arr[0]):\n                return 0\n        elif (X > arr[n - 1]):\n                return n\n        lowerPnt = 0\n        i = 1\n        while (i < n and arr[i] < X):\n                lowerPnt = i\n                i = i * 2\n        while (lowerPnt < n and arr[lowerPnt] < X):\n                lowerPnt++\n        return lowerPnt", "213": "def LongestFibSubseq(A, n):\n        S = set(A)\n        maxLen = 0\n        for i in range(0, n):\n                for j in range(i + 1, n):\n                        x = A[j]\n                        y = A[i] + A[j]\n                        length = 2\n                        while y in S:\n                                z = x + y\n                                x = y\n                                y = z\n                                maxLen = max(maxLen, length + 1)\n        return maxLen if maxLen >= 3 else 0", "214": "def get_count(M, N):\n    count = 0\n    if M == 1:\n        return N\n    if N == 1:\n        return M\n    if N > M:\n        for i in range(1, M+1):\n            numerator = N * i - N + M - i\n            denominator = M - 1\n            if numerator % denominator == 0:\n                j = numerator // denominator\n                if j >= 1 and j <= N:\n                    count += 1\n    else:\n        for j in range(1, N+1):\n            numerator = M * j - M + N - j\n            denominator = N - 1\n            if numerator % denominator == 0:\n                i = numerator // denominator\n                if i >= 1 and i <= M:\n                    count += 1\n    return count", "215": "def swapElement(arr1, arr2, n):\n        wrongIdx = 0\n        for i in range(1, n):\n                if arr1[i] < arr1[i - 1]:\n                        wrongIdx = i\n        maximum = INT_MIN\n        maxIdx = -1\n        res = False\n        for i in range(0, n):\n                if arr2[i] > maximum and arr2[i] >= arr1[wrongIdx - 1]:\n                        if wrongIdx + 1 <= n - 1 and arr2[i] <= arr1[wrongIdx + 1]:\n                                maximum = arr2[i]\n                                maxIdx = i\n                                res = True\n        if res:\n                arr1[wrongIdx], arr2[maxIdx] = arr2[maxIdx], arr1[wrongIdx]\n        return res\ndef getSortedArray(arr1, arr2, n):\n        if swapElement(arr1, arr2, n):\n                for i in range(0, n):\n                        print(arr1[i])\n        else:\n                print(\"Not Possible\")\narr1 = [ 1, 3, 7, 4, 10 ]\narr2 = [ 2, 1, 6, 8, 9 ]\nn = len(arr1)\ngetSortedArray(arr1, arr2, n)", "216": "def costToBalance(s):\n        if (s.length() == 0):\n                print(0)\n        ans = 0\n        o = 0\n        c = 0\n        for i in range(0, s.length()):\n                if (s[i] == '('):\n                        o = o + 1\n                if (s[i] == ')'):\n                        c = c + 1\n        if (o != c):\n                return -1\n        a = [0] * s.size()\n        if (s[0] == '('):\n                a[0] = 1\n        else:\n                a[0] = -1\n        if (a[0] < 0):\n                ans = ans + abs(a[0])\n        for i in range(1, s.length()):\n                if (s[i] == '('):\n                        a[i] = a[i - 1] + 1\n                else:\n                        a[i] = a[i - 1] - 1\n                if (a[i] < 0):\n                        ans = ans + abs(a[i])\n        return ans", "217": "def middleOfThree(a, b, c):\n        if ((a < b and b < c) or (c < b and b < a)):\n        return b\n        elif ((b < a and a < c) or (c < a and a < b)):\n        return a\n        else:\n        return c\nint main():\n        a = 20\n        b = 30\n        c = 40\n        print(middleOfThree(a, b, c))\n        return 0", "218": "def middleOfThree(a, b, c):\n        if (a > b):\n                if (b > c):\n                        return b;\n                else if (a > c):\n                        return c;\n                else:\n                        return a;\n        else:\n                if (a > c):\n                        return a;\n                else if (b > c):\n                        return c;\n                else:\n                        return b;", "219": "def middleOfThree(a, b, c):\n        x = a - b\n        y = b - c\n        z = a - c\n        if (x * y > 0):\n                return b\n        else if (x * z > 0):\n                return c\n        else:\n                return a", "220": "def missing4(arr, n):\n        helper = [0] * 4\n        for i in range(n):\n                temp = abs(arr[i])\n                if temp <= n:\n                        arr[temp - 1] *= (-1)\n                else if temp > n:\n                        if temp % n != 0:\n                                helper[temp % n - 1] = -1\n                        else:\n                                helper[(temp % n) + n - 1] = -1\n        for i in range(n):\n                if arr[i] > 0:\n                        print(i + 1)\n        for i in range(4):\n                if helper[i] >= 0:\n                        print(n + i + 1)\n        return", "221": "def lexiMiddleSmallest(K, N):\n        if (K % 2 == 0):\n                print(K / 2, end = \" \")\n                for i in range(0, N - 1):\n                        print(K, end = \" \")\n                print(\"\\n\")\n                exit(0)\n\n        a = [0] * N\n        for i in range(0, N):\n                a[i] = (K + 1) / 2\n\n        for i in range(0, N // 2):\n                if (a[-1] == 1):\n                        a.pop()\n                else:\n                        a[-1] -= 1\n                        while (len(a) < N):\n                                a.append(K)\n\n        for i in a:\n                print(i, end = \" \")\n        print(\"\\n\")", "222": "def transpose(mat, row, col):\n    tr = []\n    for i in range(0, col):\n        tr.append([])\n    for i in range(0, row):\n        for j in range(0, col):\n            tr[j].append(mat[i][j])\n    return tr\n\ndef RowWiseSort(B):\n    for i in range(0, len(B)):\n        B[i].sort()\n\ndef sortCol(mat, N, M):\n    B = transpose(mat, N, M)\n    RowWiseSort(B)\n    mat = transpose(B, M, N)\n    for i in range(0, N):\n        for j in range(0, M):\n            print(mat[i][j], \" \", end=\"\")\n        print()", "223": "def largestArea(N, M, H, V, h, v):\n    s1 = set()\n    s2 = set()\n    for i in range(1, N + 1):\n        s1.add(i)\n    for i in range(1, M + 1):\n        s2.add(i)\n    for i in range(0, h):\n        s1.remove(H[i])\n    for i in range(0, v):\n        s2.remove(V[i])\n    list1 = list(s1)\n    list2 = list(s2)\n    list1.sort()\n    list2.sort()\n    maxH = 0\n    p1 = 0\n    maxV = 0\n    p2 = 0\n    for j in range(0, len(list1)):\n        maxH = max(maxH, list1[j] - p1)\n        p1 = list1[j]\n    for j in range(0, len(list2)):\n        maxV = max(maxV, list2[j] - p2)\n        p2 = list2[j]\n    print(maxV * maxH)", "224": "def findLastElement(arr, N):\n        arr.sort()\n        i = 0\n        for i in range(1,N):\n                if (arr[i] - arr[i - 1] != 0 and arr[i] - arr[i - 1] != 2):\n                        print(\"-1\")\n                        return\n        print(arr[N - 1])", "225": "def checkifSorted(A, B, N):\n flag = False\n for i in range(0, N - 1):\n        if (A[i] > A[i + 1]):\n            flag = True\n            break\n if (!flag):\n        return True\n count = 0\n for i in range(0, N):\n        if (B[i] == 0):\n            count = count + 1\n            break\n for i in range(0, N):\n        if (B[i] == 1):\n            count = count + 1\n            break\n if (count == 2):\n        return True\n return False", "226": "def maxDivisions(arr, N, X):\n        arr.sort(reverse=True)\n        maxSub = 0\n        size = 0\n        for i in range(0, N):\n                size = size + 1\n                if arr[i] * size >= X:\n                        maxSub = maxSub + 1\n                        size = 0\n        print(maxSub)", "227": "def maxPossibleSum(arr, N):\n        arr.sort()\n        sum = 0\n        j = N - 3\n        while (j >= 0):\n                sum += arr[j]\n                j -= 3\n        print(sum)", "228": "def minSteps(self, A, B, M, N): \n        if (A[0] > B[0]): \n                return 0\n        if (B[0] > A[0]): \n                return 1\n        if (M <= N and A[0] == B[0] and count(A.begin(), A.end(), A[0]) == M and count(B.begin(), B.end(), B[0]) == N): \n                return -1\n        for (int i = 1; i < N; i++): \n                if (B[i] > B[0]): \n                        return 1\n        for (int i = 1; i < M; i++): \n                if (A[i] < A[0]): \n                        return 1\n        for (int i = 1; i < M; i++): \n                if (A[i] > A[0]): \n                        swap(A[i], B[0])\n                        swap(A[0], B[0])\n                        return 2\n        for (int i = 1; i < N; i++): \n                if (B[i] < B[0]): \n                        swap(A[0], B[i])\n                        swap(A[0], B[0])\n                        return 2\n        return 0", "229": "def CountMaximum(arr,n,k):\n        arr.sort()\n        sum = 0\n        count = 0\n        for i in range(0,n):\n                sum += arr[i]\n                if (sum > k):\n                        break\n                count += 1\n        return count", "230": "def CountMaximum(arr, n, k):\n        arr.sort()\n        sum = 0\n        count = 0\n        for i in range(0, n):\n                sum += arr[i]\n                if (sum > k):\n                        break\n                count++\n        return count", "231": "def swap(xp, yp):\n        temp = xp\n        xp = yp\n        yp = temp\ndef selectionSort(arr, n):\n        for i in range(n - 1):\n                min_idx = i\n                for j in range(i + 1, n):\n                        if (arr[j] < arr[min_idx]):\n                                min_idx = j\n                swap(arr[min_idx], arr[i])\ndef printArray(arr, size):\n        for i in range(size):\n                print(arr[i], \" \")\n        print(endl)", "232": "def swap(xp, yp):\n        temp = xp\n        xp = yp\n        yp = temp\n\ndef selectionSort(arr, n):\n        for i in range(0, n - 1):\n                min_idx = i\n                for j in range(i + 1, n):\n                        if arr[j] < arr[min_idx]:\n                                min_idx = j\n                swap(arr[min_idx], arr[i])\n\ndef printArray(arr, size):\n        for i in range(0, size):\n                print(arr[i], \" \")\n        print(endl)", "233": "def getPairs(arr, N, K): \n        count = 0\n        for i in range(0, N): \n                for j in range(i + 1, N): \n                        if (arr[i] > K * arr[i + 1]): \n                                count = count + 1\n        print(count)", "234": "def merge(arr, temp, l, m, r, K):\n        i = l\n        j = m + 1\n        cnt = 0\n        for l in range(0, i <= m):\n                found = false\n                while j <= r:\n                        if arr[i] >= K * arr[j]:\n                                found = true\n                        else:\n                                break\n                        j += 1\n                if found:\n                        cnt += j - (m + 1)\n                        j -= 1\n        k = l\n        i = l\n        j = m + 1\n        while i <= m and j <= r:\n                if arr[i] <= arr[j]:\n                        temp[k] = arr[i]\n                        k += 1\n                        i += 1\n                else:\n                        temp[k] = arr[j]\n                        k += 1\n                        j += 1\n        while i <= m:\n                temp[k] = arr[i]\n                k += 1\n                i += 1\n        while j <= r:\n                temp[k] = arr[j]\n                k += 1\n                j += 1\n        for i in range(l, r):\n                arr[i] = temp[i]\n        return cnt\ndef mergeSortUtil(arr, temp, l, r, K):\n        cnt = 0\n        if l < r:\n                m = (l + r) // 2\n                cnt += mergeSortUtil(arr, temp, l, m, K)\n                cnt += mergeSortUtil(arr, temp, m + 1, r, K)\n                cnt += merge(arr, temp, l, m, r, K)\n        return cnt\ndef mergeSort(arr, N, K):\n        temp = [0] * N\n        print(mergeSortUtil(arr, temp, 0, N - 1, K))", "235": "def minRemovals(A, N):\n        A.sort()\n        mx = A[N - 1]\n        sum = 1\n        for i in range(N):\n                sum += A[i]\n        if sum - mx >= mx:\n                print(0)\n        else:\n                print(2 * mx - sum)", "236": "def rearrangeArray(a, n):\n        a.sort()\n        for i in range(0, n - 1):\n                if (a[i] == i + 1):\n                        temp = a[i]\n                        a[i] = a[i + 1]\n                        a[i + 1] = temp\n        if (a[n - 1] == n):\n                temp = a[n - 1]\n                a[n - 1] = a[n - 2]\n                a[n - 2] = temp\n        for i in range(0, n):\n                print(a[i], end = ' ')", "237": "def checkStr1CanConStr2(str1, str2):\n        N = len(str1)\n        M = len(str2)\n        st1 = set()\n        st2 = set()\n        hash1 = [0]*256\n        for i in range(N):\n                hash1[ord(str1[i])] += 1\n        for i in range(N):\n                st1.add(str1[i])\n        for i in range(M):\n                st2.add(str2[i])\n        if st1 != st2:\n                return False\n        hash2 = [0]*256\n        for i in range(M):\n                hash2[ord(str2[i])] += 1\n        hash1.sort()\n        hash2.sort()\n        for i in range(256):\n                if hash1[i] != hash2[i]:\n                        return False\n        return True", "238": "def minOperations(arr1, arr2, i, j, n):\n    f = 0\n    for i in range(0, n):\n        if arr1[i] != arr2[i]:\n            f = 1\n            break\n    if f == 0:\n        return 0\n    if i >= n or j >= n:\n        return 0\n    if arr1[i] < arr2[j]:\n        return 1 + minOperations(arr1, arr2, i + 1, j + 1, n)\n    return max(minOperations(arr1, arr2, i, j + 1, n), minOperations(arr1, arr2, i + 1, j, n))\n\n\ndef minOperationsUtil(arr, n):\n    brr = [0] * n\n    for i in range(0, n):\n        brr[i] = arr[i]\n    brr.sort()\n    f = 0\n    for i in range(0, n):\n        if arr[i] != brr[i]:\n            f = 1\n            break\n    if f == 1:\n        print(minOperations(arr, brr, 0, 0, n))\n    else:\n        print(\"0\")", "239": "def minOperations(arr, n):\n\tvect = []\n\tfor i in range(n):\n\t\tvect.append([arr[i], i])\n\tvect.sort()\n\tres = 1\n\tstreak = 1\n\tprev = vect[0][1]\n\tfor i in range(1, n):\n\t\tif prev < vect[i][1]:\n\t\t\tres += 1\n\t\t\tstreak = max(streak, res)\n\t\telse:\n\t\t\tres = 1\n\t\tprev = vect[i][1]\n\treturn n - streak", "240": "def canTransform(s, t):\n        n = len(s)\n        occur = [0]*26\n        for x in range(n):\n                ch = ord(s[x]) - ord('a')\n                occur[ch].append(x)\n        idx = [0]*26\n        poss = True\n        for x in range(n):\n                ch = ord(t[x]) - ord('a')\n                if idx[ch] >= len(occur[ch]):\n                        poss = False\n                        break\n                for small in range(ch):\n                        if idx[small] < len(occur[small]) and occur[small][idx[small]] < occur[ch][idx[ch]]:\n                                poss = False\n                                break\n                idx[ch] += 1\n        if poss:\n                print(\"Yes\")\n        else:\n                print(\"No\")", "241": "def getMaxSum(i, j, k, arr1, arr2, arr3):\n        cnt = 0;\n        if (i >= n1):\n                cnt++;\n        if (j >= n2):\n                cnt++;\n        if (k >= n3):\n                cnt++;\n        if (cnt >= 2):\n                return 0;\n        if (dp[i][j][k] != -1):\n                return dp[i][j][k];\n        ans = 0;\n        if (i < n1 && j < n2):\n                ans = max(ans,\n                                getMaxSum(i + 1, j + 1, k, arr1, arr2, arr3) + arr1[i] * arr2[j]);\n        if (i < n1 && k < n3):\n                ans = max(ans,\n                                getMaxSum(i + 1, j, k + 1, arr1, arr2, arr3) + arr1[i] * arr3[k]);\n        if (j < n2 && k < n3):\n                ans = max(ans,\n                                getMaxSum(i, j + 1, k + 1, arr1, arr2, arr3) + arr2[j] * arr3[k]);\n        dp[i][j][k] = ans;\n        return dp[i][j][k];\ndef maxProductSum(arr1, arr2, arr3):\n        memset(dp, -1, sizeof(dp));\n        sort(arr1, arr1 + n1);\n        reverse(arr1, arr1 + n1);\n        sort(arr2, arr2 + n2);\n        reverse(arr2, arr2 + n2);\n        sort(arr3, arr3 + n3);\n        reverse(arr3, arr3 + n3);\n        return getMaxSum(0, 0, 0, arr1, arr2, arr3);", "242": "def findTriplet(arr, N):\n        arr.sort()\n        flag = 0\n        for i in range (N - 1, 2, -1):\n                if(arr[i-2] + arr[i-1] > arr[i]):\n                        flag = 1\n                        break\n        if (flag):\n                print(arr[i-2], arr[i-1], arr[i])\n        else:\n                print(-1)", "243": "def inversionCount(s):\n        freq=[0]*26\n        inv=0\n        for i in range(0,len(s)):\n                temp=0\n                for j in range(0,ord(s[i])-ord('a')):\n                        temp+=freq[j]\n                inv+=(i-temp)\n                freq[ord(s[i])-ord('a')]+=1\n        return inv\ndef haveRepeated(S1,S2):\n        freq=[0]*26\n        for i in S1:\n                if(freq[ord(i)-ord('a')]>0):\n                        return true\n                freq[ord(i)-ord('a')]+=1\n        for i in range(0,26):\n                freq[i]=0\n        for i in S2:\n                if(freq[ord(i)-ord('a')]>0):\n                        return true\n                freq[ord(i)-ord('a')]+=1\n        return false\ndef checkToMakeEqual(S1,S2):\n        freq=[0]*26\n        for i in range(0,len(S1)):\n                freq[ord(S1[i])-ord('a')]+=1\n        flag=0\n        for i in range(0,len(S2)):\n                if(freq[ord(S2[i])-ord('a')]==0):\n                        flag=1\n                        break\n                freq[ord(S2[i])-ord('a')]-=1\n        if(flag==true):\n                print(\"No\")\n                return\n        invCount1=inversionCount(S1)\n        invCount2=inversionCount(S2)\n        if(invCount1==invCount2 or (invCount1&1)==(invCount2&1) or haveRepeated(S1,S2)):\n                print(\"Yes\")\n        else:\n                print(\"No\")", "244": "def numberofpairs(arr, N):\n        answer = 0\n        arr.sort()\n        minDiff = INT_MAX\n        for i in range(0, N - 1):\n                minDiff = min(minDiff, arr[i + 1] - arr[i])\n        for i in range(0, N - 1):\n                if arr[i + 1] - arr[i] == minDiff:\n                        answer = answer + 1\n        return answer", "245": "def sortArr(a, n):\n        k = math.log2(n)\n        k = 2**k\n        while (k > 0):\n                for i in range(0, n - k):\n                        if (a[i] > a[i + k]):\n                                swap(a[i], a[i + k])\n                k = k / 2\n        for i in range(0, n):\n                print(a[i], end = ' ')", "246": "def maximumSum(arr, n, k):\n        elt = n / k\n        sum = 0\n        arr.sort()\n        count = 0\n        i = n - 1\n        while count < k:\n                sum += arr[i]\n                i -= 1\n                count += 1\n        count = 0\n        i = 0\n        while count < k:\n                sum += arr[i]\n                i += elt - 1\n                count += 1\n        print sum", "247": "def findMinSum(arr, K, L, size):\n        if (K * L > size):\n                return -1\n        minsum = 0\n        arr.sort()\n        for i in range(0, K):\n                minsum += arr[i]\n        return minsum", "248": "def find_max_length(arr, index, sum, k):\n        sum = sum + arr[index]\n        store.append(arr[index])\n        if (sum == k) {\n                if (max_length < len(store)):\n                        max_length = len(store)\n                        ans = store\n        for i in range(index + 1, len(arr)):\n                if (sum + arr[i] <= k):\n                        find_max_length(arr, i, sum, k)\n                        store.pop()\n                else:\n                        return\n        return\n    \ndef longestSubsequence(arr, n, k):\n        arr.sort()\n        for i in range(0, n):\n                if (max_length >= n - i):\n                        break\n                store.clear()\n                find_max_length(arr, i, 0, k)\n        return max_length", "249": "def findKthSmallest(arr, n, k):\n        max = 0\n        for i in range(0,n):\n                if arr[i] > max:\n                        max = arr[i]\n        counter = [0] * (max + 1)\n        smallest = 0\n        for i in range(0,n):\n                counter[arr[i]] += 1\n        for num in range(1,max+1):\n                if counter[num] > 0:\n                        smallest += counter[num]\n                if smallest >= k:\n                        return num", "250": "def lexNumbers(n):\n        s = []\n        for i in range(1, n+1):\n                s.append(str(i))\n        s.sort()\n        ans = []\n        for i in range(0, n):\n                ans.append(int(s[i]))\n        for i in range(0, n):\n                print(ans[i], end = ' ')", "251": "def lexNumbers(n):\n    sol = []\n    dfs(1, n, sol)\n    print(\"[\" + sol[0], end=\"\")\n    for i in range(1, len(sol)):\n        print(\", \" + sol[i], end=\"\")\n    print(\"]\")\ndef dfs(temp, n, sol):\n    if temp > n:\n        return\n    sol.append(temp)\n    dfs(temp * 10, n, sol)\n    if temp % 10 != 9:\n        dfs(temp + 1, n, sol)", "252": "def func(a):\n        for i in range(len(a)):\n                if i % 2 == 0:\n                        for j in range(len(a)):\n                                for k in range(j + 1, len(a)):\n                                        if a[i][j] > a[i][k]:\n                                                temp = a[i][j]\n                                                a[i][j] = a[i][k]\n                                                a[i][k] = temp\n                else:\n                        for j in range(len(a)):\n                                for k in range(j + 1, len(a)):\n                                        if a[i][j] < a[i][k]:\n                                                temp = a[i][j]\n                                                a[i][j] = a[i][k]\n                                                a[i][k] = temp\n        for i in range(len(a)):\n                for j in range(len(a)):\n                        print(a[i][j], end = \" \")\n                print()", "253": "def partition(arr, l, h):\n        pivot = arr[l]\n        i = l + 1\n        j = h\n        while (i <= j):\n                while (i <= h and arr[i] < pivot):\n                        i += 1\n                while (j > l and arr[j] > pivot):\n                        j -= 1\n                if (i < j):\n                        temp = arr[i]\n                        arr[i] = arr[j]\n                        arr[j] = temp\n                        i += 1\n                        j -= 1\n                else:\n                        i += 1\n        arr[l] = arr[j]\n        arr[j] = pivot\n        return j\ndef sortArray(arr, l, h):\n        if (l >= h):\n                return\n        pivot = partition(arr, l, h)\n        sortArray(arr, l, pivot - 1)\n        sortArray(arr, pivot + 1, h)\ndef findMaxIntervals(start, end, n, R):\n        ans = 0\n        prev = 0\n        currActive = 0\n        i = 0\n        j = 0\n        if (start[0] > 0):\n                ans += 1\n        while (i < n and j < n):\n                if (start[i] < end[j]):\n                        i += 1\n                        currActive += 1\n                elif (start[i] > end[j]):\n                        j += 1\n                        currActive -= 1\n                else:\n                        i += 1\n                        j += 1\n                if (currActive == 0):\n                        ans += 1\n        if (end[n - 1] < R):\n                ans += 1\n        return ans"}}, "Python - C++": {"ID": {"0": 451, "1": 455, "2": 496, "3": 617, "4": 647, "5": 694, "6": 803, "7": 815, "8": 818, "9": 821, "10": 832, "11": 833, "12": 846, "13": 861, "14": 862, "15": 883, "16": 895, "17": 918, "18": 919, "19": 920, "20": 926, "21": 927, "22": 953, "23": 955, "24": 956, "25": 958, "26": 959, "27": 965, "28": 966, "29": 1064, "30": 1072, "31": 1073, "32": 1074, "33": 1075, "34": 1252, "35": 1253, "36": 1344, "37": 1345, "38": 1346, "39": 1366, "40": 1390, "41": 1405, "42": 1406, "43": 1428, "44": 1468, "45": 1469, "46": 1473, "47": 1474, "48": 1478, "49": 1473}, "Python": {"0": "def minCost(cost):\n        dist=[0 for i in range(N)]\n        for i in range(N):\n                dist[i] = INF\n        dist[0] = 0\n        for i in range(N):\n                for j in range(i+1,N):\n                        if (dist[j] > dist[i] + cost[i][j]):\n                                dist[j] = dist[i] + cost[i][j]\n        return dist[N-1]", "1": "def numOfways(n,k):\n        p = 1\n        if (k % 2):\n                p = -1\n        return (pow(n - 1, k) +\n                                p * (n - 1)) / n", "2": "def fib(n):\n        if n <= 1:\n                return n\n        return fib(n - 1) + fib(n - 2)\ndef findVertices(n):\n        return fib(n + 2)", "3": "def reverse( head_ref):\n        temp = None\n        current = head_ref\n        while (current != None):\n                temp = current.prev\n                current.prev = current.next\n                current.next = temp\n                current = current.prev\n        if (temp != None):\n                head_ref = temp.prev\n                return head_ref\ndef merge( first, second):\n        if (first == None):\n                return second\n        if (second == None):\n                return first\n        if (first.data < second.data):\n                first.next = merge(first.next, second)\n                first.next.prev = first\n                first.prev = None\n                return first\n        else:\n                second.next = merge(first, second.next)\n                second.next.prev = second\n                second.prev = None\n                return second\ndef sort( head):\n        if (head == None or head.next == None):\n                return head\n        current = head.next\n        while (current != None) :\n                if (current.data < current.prev.data):\n                        break\n                current = current.next\n        if (current == None):\n                return head\n        current.prev.next = None\n        current.prev = None\n        current = reverse(current)\n        return merge(head, current)\ndef push( head_ref, new_data):\n        new_node =Node()\n        new_node.data = new_data\n        new_node.prev = None\n        new_node.next = (head_ref)\n        if ((head_ref) != None):\n                (head_ref).prev = new_node\n        (head_ref) = new_node\n        return head_ref\ndef printList( head):\n        if (head == None):\n                print(\"Doubly Linked list empty\")\n        while (head != None):\n                print(head.data, end= \" \")\n                head = head.next\ndef __init__(self, next = None, prev = None, data = None):\n                self.next = next\n                self.prev = prev\n                self.data = data", "4": "def printlist(head):\n        if (not head):\n                print(\"Empty List\")\n                return\n        while (head != None):\n                print(head.data, end = \" \")\n                if (head.next):\n                        print(end = \"-> \")\n                head = head.next\n        print()\ndef isVowel(x):\n        return (x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U')\ndef arrange(head):\n        newHead = head\n        latestVowel = None\n        curr = head\n        if (head == None):\n                return None\n        if (isVowel(head.data)):\n                latestVowel = head\n        else:\n                while (curr.next != None and\n                        not isVowel(curr.next.data)):\n                        curr = curr.next\n                if (curr.next == None):\n                        return head\n                latestVowel = newHead = curr.next\n                curr.next = curr.next.next\n                latestVowel.next = head\n        while (curr != None and curr.next != None):\n                if (isVowel(curr.next.data)):\n                        if (curr == latestVowel):\n                                latestVowel = curr = curr.next\n                        else:\n                                temp = latestVowel.next\n                                latestVowel.next = curr.next\n                                latestVowel = latestVowel.next\n                                curr.next = curr.next.next\n                                latestVowel.next = temp\n                else:\n                        curr = curr.next\n        return newHead\ndef __init__(self, x):\n                self.data = x\n                self.next = None", "5": "def KthLargestUsingMorrisTraversal(root, k):\n        curr = root\n        Klargest = None\n        count = 0\n        while (curr != None):\n                if (curr.right == None):\n                        count += 1\n                        if (count == k):\n                                Klargest = curr\n                        curr = curr.left\n                else:\n                        succ = curr.right\n                        while (succ.left != None and succ.left != curr):\n                                succ = succ.left\n                        if (succ.left == None):\n                                succ.left = curr\n                                curr = curr.right\n                        else:\n                                succ.left = None\n                                count += 1\n                                if (count == k):\n                                        Klargest = curr\n                                curr = curr.left\n        return Klargest\ndef __init__(self, data):\n                self.data = data\n                self.right = self.left = None", "6": "def sortByRow(mat, n, ascending):\n        for i in range(n):\n                if (ascending): \n                        mat[i].sort()\n                else:\n                        mat[i].sort(reverse=True)\ndef transpose(mat, n):\n        for i in range(n):\n                for j in range(i + 1, n):\n                        temp = mat[i][j]\n                        mat[i][j] = mat[j][i]\n                        mat[j][i] = temp\ndef sortMatRowAndColWise(mat, n):\n        sortByRow(mat, n, True)\n        transpose(mat, n)\n        sortByRow(mat, n, False)\n        transpose(mat, n)\ndef printMat(mat, n):\n        for i in range(n):\n                for j in range(n):\n                        print(mat[i][j] , \" \", end=\"\")\n                print()", "7": "def sortByRow(mat, n):\n        for i in range (n):\n                for j in range(n-1):\n                        if mat[i][j] > mat[i][j + 1]:\n                                temp = mat[i][j]\n                                mat[i][j] = mat[i][j + 1]\n                                mat[i][j + 1] = temp\ndef transpose(mat, n):\n        for i in range (n):\n                for j in range(i + 1, n):\n                        t = mat[i][j]\n                        mat[i][j] = mat[j][i]\n                        mat[j][i] = t\ndef sortMatRowAndColWise(mat, n):\n        sortByRow(mat, n)\n        transpose(mat, n)\n        sortByRow(mat, n)\n        transpose(mat, n)\ndef printMat(mat, n):\n        for i in range(n):\n                for j in range(n):\n                        print(str(mat[i][j] ), end = \" \")\n                print();", "8": "def DoublyEven(n):\n        arr = [[(n*y)+x+1 for x in range(n)]for y in range(n)]\n        for i in range(0,n/4):\n                for j in range(0,n/4):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(0,n/4):\n                for j in range(3 * (n/4),n):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(3 * (n/4),n):\n                for j in range(0,n/4):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(3 * (n/4),n):\n                for j in range(3 * (n/4),n):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(n/4,3 * (n/4)):\n                for j in range(n/4,3 * (n/4)):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(n):\n                for j in range(n):\n                        print '%2d ' %(arr[i][j]),\n                print", "9": "def Kroneckerproduct( A , B ):\n        C = [[0 for j in range(cola * colb)] for i in range(rowa * rowb)]\n        for i in range(0, rowa):\n                for k in range(0, rowb):\n                        for j in range(0, cola):\n                                for l in range(0, colb):\n                                        C[i + l + 1][j + k + 1] = A[i][j] * B[k][l]\n                                        print (C[i + l + 1][j + k + 1],end=' ')\n                        print (\"\\n\")", "10": "def islowertriangular(M):\n        for i in range(0, len(M)):\n                for j in range(i + 1, len(M)):\n                        if(M[i][j] != 0):\n                                        return False\n        return True", "11": "def isuppertriangular(M):\n        for i in range(1, len(M)):\n                for j in range(0, i):\n                        if(M[i][j] != 0):\n                                        return False\n        return True", "12": "def countSets(a):\n        res = 0\n        for i in range(n):\n                u = 0\n                v = 0\n                for j in range(m):\n                        if a[i][j]:\n                                u += 1\n                        else:\n                                v += 1\n                res += pow(2, u) - 1 + pow(2, v) - 1\n        for i in range(m):\n                u = 0\n                v = 0\n                for j in range(n):\n                        if a[j][i]:\n                                u += 1\n                        else:\n                                v += 1\n                res += pow(2, u) - 1 + pow(2, v) - 1\n        return res - (n*m)", "13": "def transpose(mat, tr, N):\n        for i in range(N):\n                for j in range(N):\n                        tr[i][j] = mat[j][i]\ndef isSymmetric(mat, N):\n        tr = [ [0 for j in range(len(mat[0])) ] for i in range(len(mat)) ]\n        transpose(mat, tr, N)\n        for i in range(N):\n                for j in range(N):\n                        if (mat[i][j] != tr[i][j]):\n                                return False\n        return True", "14": "def isSymmetric(mat, N):\n        for i in range(N):\n                for j in range(N):\n                        if (mat[i][j] != mat[j][i]):\n                                return False\n        return True", "15": "def findNormal(mat, n):\n        sum = 0;\n        for i in range(n):\n                for j in range(n):\n                        sum += mat[i][j] * mat[i][j];\n        return math.floor(math.sqrt(sum));\ndef findTrace(mat, n):\n        sum = 0;\n        for i in range(n):\n                sum += mat[i][i];\n        return sum;", "16": "def maxDet(n):\n        return 2 * n * n * n\ndef resMatrix(n):\n        for i in range(3):\n                for j in range(3):\n                        if i == 0 and j == 2:\n                                print(\"0\", end = \" \")\n                        elif i == 1 and j == 0:\n                                print(\"0\", end = \" \")\n                        elif i == 2 and j == 1:\n                                print(\"0\", end = \" \")\n                        else:\n                                print(n, end = \" \")\n                print(\"\\n\")", "17": "def countNegative(M, n, m):\n        count = 0\n        for i in range(n):\n                for j in range(m):\n                        if M[i][j] < 0:\n                                count += 1\n                        else:\n                                break\n        return count", "18": "def countNegative(M, n, m):\n        count = 0 \n        i = 0\n        j = m - 1 \n        while j >= 0 and i < n:\n                if M[i][j] < 0:\n                        count += (j + 1)\n                        i += 1\n                else:\n                        j -= 1\n        return count", "19": "def getLastNegativeIndex(array, start, end, n):\n        if (start == end):\n                return start\n        mid = start + (end - start) // 2\n        if (array[mid] < 0):\n                if (mid + 1 < n and array[mid + 1] >= 0):\n                        return mid\n                return getLastNegativeIndex(array, mid + 1, end, n)\n        else:\n                return getLastNegativeIndex(array, start, mid - 1, n)\ndef countNegative(M, n, m):\n        count = 0\n        nextEnd = m - 1\n        for i in range(n):\n                if (M[i][0] >= 0):\n                        break\n                nextEnd = getLastNegativeIndex(M[i], 0, nextEnd, 4)\n                count += nextEnd + 1\n        return count", "20": "def findMaxValue(mat):\n        maxValue = 0\n        for a in range(N - 1):\n                for b in range(N - 1):\n                        for d in range(a + 1, N):\n                                for e in range(b + 1, N):\n                                        if maxValue < int (mat[d][e] - mat[a][b]):\n                                                maxValue = int(mat[d][e] - mat[a][b]);\n        return maxValue;", "21": "def findMaxValue(mat):\n        maxValue = -sys.maxsize -1\n        maxArr = [[0 for x in range(N)] for y in range(N)]\n        maxArr[N - 1][N - 1] = mat[N - 1][N - 1]\n        maxv = mat[N - 1][N - 1];\n        for j in range (N - 2, -1, -1):\n                if (mat[N - 1][j] > maxv):\n                        maxv = mat[N - 1][j]\n                maxArr[N - 1][j] = maxv\n        maxv = mat[N - 1][N - 1];\n        for i in range (N - 2, -1, -1):\n                if (mat[i][N - 1] > maxv):\n                        maxv = mat[i][N - 1]\n                maxArr[i][N - 1] = maxv\n        for i in range (N - 2, -1, -1):\n                for j in range (N - 2, -1, -1):\n                        if (maxArr[i + 1][j + 1] - mat[i][j] > maxValue):\n                                maxValue = (maxArr[i + 1][j + 1] - mat[i][j])\n                        maxArr[i][j] = max(mat[i][j],\n                                                max(maxArr[i][j + 1], maxArr[i + 1][j]))\n        return maxValue", "22": "def youngify(mat, i, j):\n        downVal = mat[i + 1][j] if (i + 1 < N) else INF\n        rightVal = mat[i][j + 1] if (j + 1 < N) else INF\n        if (downVal == INF and rightVal == INF):\n                return\n        if (downVal < rightVal):\n                mat[i][j] = downVal\n                mat[i + 1][j] = INF\n                youngify(mat, i + 1, j)\n        else:\n                mat[i][j] = rightVal\n                mat[i][j + 1] = INF\n                youngify(mat, i, j + 1)\ndef extractMin(mat):\n        ret = mat[0][0]\n        mat[0][0] = INF\n        youngify(mat, 0, 0)\n        return ret\ndef printSorted(mat):\n        print(\"Elements of matrix in sorted order n\")\n        i = 0\n        while i < N * N:\n                print(extractMin(mat), end = \" \")\n                i += 1", "23": "def printSumSimple(mat, k):\n        if (k > n):\n                return\n        for i in range(n - k + 1):\n                for j in range(n - k + 1):\n                        sum = 0\n                        for p in range(i, k + i):\n                                for q in range(j, k + j):\n                                        sum += mat[p][q]\n                        print(sum, end = \" \")\n                print()", "24": "def printSumTricky(mat, k):\n        global n\n        if k > n:\n                return\n        stripSum = [[None] * n for i in range(n)]\n        for j in range(n):\n                Sum = 0\n                for i in range(k):\n                        Sum += mat[i][j]\n                stripSum[0][j] = Sum\n                for i in range(1, n - k + 1):\n                        Sum += (mat[i + k - 1][j] - mat[i - 1][j])\n                        stripSum[i][j] = Sum\n        for i in range(n - k + 1):\n                Sum = 0\n                for j in range(k):\n                        Sum += stripSum[i][j]\n                print(Sum, end = \" \")\n                for j in range(1, n - k + 1):\n                        Sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1])\n                        print(Sum, end = \" \")\n                print()", "25": "def transpose(A, B):\n        for i in range(N):\n                for j in range(M):\n                        B[i][j] = A[j][i]", "26": "def transpose(A):\n        for i in range(N):\n                for j in range(i+1, N):\n                        A[i][j], A[j][i] = A[j][i], A[i][j]", "27": "def pathCountRec(mat, m, n, k):\n        if m < 0 or n < 0:\n                return 0\n        elif m == 0 and n == 0:\n                return k == mat[m][n]\n        return (pathCountRec(mat, m-1, n, k-mat[m][n])\n                + pathCountRec(mat, m, n-1, k-mat[m][n]))\ndef pathCount(mat, k):\n        return pathCountRec(mat, R-1, C-1, k)", "28": "def pathCountDPRecDP(mat, m, n, k):\n        if m < 0 or n < 0:\n                return 0\n        elif m == 0 and n == 0:\n                return k == mat[m][n]\n        if (dp[m][n][k] != -1):\n                return dp[m][n][k]\n        dp[m][n][k] = (pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) +\n                                pathCountDPRecDP(mat, m, n - 1, k - mat[m][n]))\n        return dp[m][n][k]\ndef pathCountDP(mat, k):\n        return pathCountDPRecDP(mat, R - 1, C - 1, k)", "29": "def countMinReversals(expr):\n        lenn = len(expr)\n        if (lenn % 2) :\n                return -1\n        s = []\n        for i in range(lenn):\n                if (expr[i] =='' and len(s)):\n                        if (s[0] == '') :\n                                s.pop(0)\n                        else:\n                                s.insert(0, expr[i])\n                else:\n                        s.insert(0, expr[i])\n        red_len = len(s)\n        n = 0\n        while (len(s)and s[0] == '') :\n                        s.pop(0)\n                        n += 1\n        return (red_len // 2 + n % 2)", "30": "def PrintMinNumberForPattern(arr):\n        curr_max = 0\n        last_entry = 0\n        i = 0\n        while i < len(arr):\n                noOfNextD = 0\n                if arr[i] == \"I\":\n                        j = i + 1\n                        while j < len(arr) and arr[j] == \"D\":\n                                noOfNextD += 1\n                                j += 1\n                        if i == 0:\n                                curr_max = noOfNextD + 2\n                                last_entry += 1\n                                print(\"\", last_entry, end = \"\")\n                                print(\"\", curr_max, end = \"\")\n                                last_entry = curr_max\n                        else:\n                                curr_max += noOfNextD + 1\n                                last_entry = curr_max\n                                print(\"\", last_entry, end = \"\")\n                        for k in range(noOfNextD):\n                                last_entry -= 1\n                                print(\"\", last_entry, end = \"\")\n                                i += 1\n                elif arr[i] == \"D\":\n                        if i == 0:\n                                j = i + 1\n                                while j < len(arr) and arr[j] == \"D\":\n                                        noOfNextD += 1\n                                        j += 1\n                                curr_max = noOfNextD + 2\n                                print(\"\", curr_max, curr_max - 1, end = \"\")\n                                last_entry = curr_max - 1\n                        else:\n                                print(\"\", last_entry - 1, end = \"\")\n                                last_entry -= 1\n                i += 1\n        print()", "31": "def printLeast(arr):\n        min_avail = 1\n        pos_of_I = 0\n        v = []\n        if (arr[0] == 'I'):\n                v.append(1)\n                v.append(2)\n                min_avail = 3\n                pos_of_I = 1\n        else:\n                v.append(2)\n                v.append(1)\n                min_avail = 3\n                pos_of_I = 0\n        for i in range(1, len(arr)):\n                if (arr[i] == 'I'):\n                        v.append(min_avail)\n                        min_avail += 1\n                        pos_of_I = i + 1\n                else:\n                        v.append(v[i])\n                        for j in range(pos_of_I, i + 1):\n                                v[j] += 1\n                        min_avail += 1\n        print(*v, sep = ' ')", "32": "def PrintMinNumberForPattern(Strr):\n        res = ''\n        stack = []\n        for i in range(len(Strr) + 1):\n                stack.append(i + 1)\n                if (i == len(Strr) or Strr[i] == 'I'):\n                        while len(stack) > 0:\n                                res += str(stack.pop())\n                                res += ' '\n        print(res)", "33": "def getMinNumberForPattern(seq):\n        n = len(seq)\n        if (n >= 9):\n                return \"-1\"\n        result = [None] * (n + 1)\n        count = 1\n        for i in range(n + 1):\n                if (i == n or seq[i] == 'I'):\n                        for j in range(i - 1, -2, -1):\n                                result[j + 1] = int('0' + str(count))\n                                count += 1\n                                if(j >= 0 and seq[j] == 'I'):\n                                        break\n        return result", "34": "def subset(ar, n):\n        res = 0\n        ar.sort()\n        for i in range(0, n) :\n                count = 1\n                for i in range(n - 1):\n                        if ar[i] == ar[i + 1]:\n                                count+=1\n                        else:\n                                break\n                res = max(res, count)\n        return res", "35": "def subset(arr, n):\n        mp = {i:0 for i in range(10)}\n        for i in range(n):\n                mp[arr[i]] += 1\n        res = 0\n        for key, value in mp.items():\n                res = max(res, value)\n        return res", "36": "def areElementsContiguous(arr, n):\n        arr.sort()\n        for i in range(1,n):\n                if (arr[i] - arr[i-1] > 1) :\n                        return 0\n        return 1", "37": "def areElementsContiguous(arr, n):\n        max1 = max(arr)\n        min1 = min(arr)\n        m = max1 - min1 + 1\n        if (m > n):\n                return False\n        visited = [0] * m\n        for i in range(0,n) :\n                visited[arr[i] - min1] = True\n        for i in range(0, m):\n                if (visited[i] == False):\n                        return False\n        return True", "38": "def areElementsContiguous(arr):\n        us = set()\n        for i in arr: us.add(i)\n        count = 1\n        curr_ele = arr[0] - 1\n        while curr_ele in us:\n                count += 1\n                curr_ele -= 1\n        curr_ele = arr[0] + 1\n        while curr_ele in us:\n                count += 1\n                curr_ele += 1\n        return (count == len(us))", "39": "def longest(a, n, k):\n        freq = collections.defaultdict(int)\n        start = 0\n        end = 0\n        now = 0\n        l = 0\n        for i in range(n):\n                freq[a[i]] += 1\n                if (freq[a[i]] == 1):\n                        now += 1\n                while (now > k) :\n                        freq[a[l]] -= 1\n                        if (freq[a[l]] == 0):\n                                now -= 1\n                        l += 1\n                if (i - l + 1 >= end - start + 1):\n                        end = i\n                        start = l\n        for i in range(start, end + 1):\n                print(a[i], end = \" \")", "40": "def findSmallestRange(arr, n, k):\n        i, minval, maxval, minrange, minel, maxel, flag, minind = 0, 0, 0, 0, 0, 0, 0, 0\n        for i in range(k + 1):\n                ptr[i] = 0\n        minrange = 10**9\n        while(1): \n                minind = -1\n                minval = 10**9\n                maxval = -10**9\n                flag = 0\n                for i in range(k):\n                        if(ptr[i] == n):\n                                flag = 1 \n                                break\n                        if(ptr[i] < n and arr[i][ptr[i]] < minval):\n                                minind = i \n                                minval = arr[i][ptr[i]]\n                        if(ptr[i] < n and arr[i][ptr[i]] > maxval):\n                                maxval = arr[i][ptr[i]]\n                if(flag):\n                        break\n                ptr[minind] += 1\n                if((maxval-minval) < minrange):\n                        minel = minval\n                        maxel = maxval\n                        minrange = maxel - minel\n        print(\"The smallest range is [\", minel, maxel, \"]\")", "41": "def findLargestd(S, n) :\n        found = False\n        S.sort()\n        for i in range(n-1, -1, -1) :\n                for j in range(0, n) :\n                        if (i == j) :\n                                continue\n                        for k in range(j + 1, n) :\n                                if (i == k) :\n                                        continue\n                                for l in range(k+1, n) :\n                                        if (i == l) :\n                                                continue\n                                        if (S[i] == S[j] + S[k] + S[l]) :\n                                                found = True\n                                                return S[i]                                \n        if (found == False) :\n                return -1", "42": "def findFourElements(arr, n):\n        mp = dict()\n        for i in range(n - 1):\n                for j in range(i + 1, n):\n                        mp[arr[i] + arr[j]] =(i, j)\n        d = -10**9\n        for i in range(n - 1):\n                for j in range(i + 1, n):\n                        abs_diff = abs(arr[i] - arr[j])\n                        if abs_diff in mp.keys():\n                                p = mp[abs_diff]\n                                if (p[0] != i and p[0] != j and p[1] != i and p[1] != j):\n                                        d = max(d, max(arr[i], arr[j]))\n        return d", "43": "def leftRotatebyOne(arr, n):\n        temp = arr[0]\n        for i in range(n-1):\n                arr[i] = arr[i + 1]\n        arr[n-1] = temp\ndef leftRotate(arr, d, n):\n        for i in range(d):\n                leftRotatebyOne(arr, n)\ndef printArray(arr, size):\n        for i in range(size):\n                print (\"% d\"% arr[i], end =\" \")", "44": "def pushZerosToEnd(arr, n):\n        count = 0 \n        for i in range(n):\n                if arr[i] != 0:\n                        arr[count] = arr[i]\n                        count+=1\n        while count < n:\n                arr[count] = 0\n                count += 1", "45": "def moveZerosToEnd (arr, n):\n        count = 0;\n        for i in range(0, n):\n                if (arr[i] != 0):\n                        arr[count], arr[i] = arr[i], arr[count]\n                        count+=1\ndef printArray(arr, n):\n        for i in range(0, n):\n                print(arr[i],end=\" \")", "46": "def pushZerosToEnd(arr, n):\n        count = 0\n        for i in range(0, n):\n                if arr[i] != 0:\n                        arr[count] = arr[i]\n                        count+=1\n        while (count < n):\n                arr[count] = 0\n                count+=1\ndef modifyAndRearrangeArr(ar, n):\n        if n == 1:\n                return\n        for i in range(0, n - 1):\n                if (arr[i] != 0) and (arr[i] == arr[i + 1]):\n                        arr[i] = 2 * arr[i]\n                        arr[i + 1] = 0\n                        i+=1\n        pushZerosToEnd(arr, n)\ndef printArray(arr, n):\n        for i in range(0, n):\n                print(arr[i],end=\" \")", "47": "def shiftAllZeroToLeft(arr, n):\n        lastSeenNonZero = 0\n        for index in range(0, n):\n                if (array[index] != 0):\n                        array[index], array[lastSeenNonZero] = array[lastSeenNonZero], array[index]\n                        lastSeenNonZero+=1", "48": "def printArray(arr, n):\n        for i in range(n):\n                print(arr[i], end = \" \")\n        print()\ndef RearrangePosNeg(arr, n):\n        for i in range(1, n):\n                key = arr[i]\n                if (key > 0):\n                        continue\n                j = i - 1\n                while (j >= 0 and arr[j] > 0):\n                        arr[j + 1] = arr[j]\n                        j = j - 1\n                arr[j + 1] = key", "49": "static void pushZerosToEnd(int arr[], int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != 0)\n\t\t\t\tarr[count++] = arr[i];\n\t\twhile (count < n)\n\t\t\tarr[count++] = 0;\n\t}\nstatic void modifyAndRearrangeArr(int arr[], int n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif ((arr[i] != 0) && (arr[i] == arr[i + 1]))\n\t\t\t{\n\t\t\t\tarr[i] = 2 * arr[i];\n\t\t\t\tarr[i + 1] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tpushZerosToEnd(arr, n);\n\t}\nstatic void printArray(int arr[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}"}, "C++": {"0": "int minCost(int cost[][N]) {\n        int dist[N];\n        for (int i = 0; i < N; i++)\n                dist[i] = INF;\n        dist[0] = 0;\n        for (int i = 0; i < N; i++)\n                for (int j = i+1; j < N; j++)\n                        if (dist[j] > dist[i] + cost[i][j])\n                                dist[j] = dist[i] + cost[i][j];\n        return dist[N-1];\n}", "1": "double numOfways(double n, double k)\n{\n        double p = 1;\n        if (k % 2)\n        {\n                p = -1;\n        }\n        return (pow(n - 1, k) + p * (n - 1)) / n;\n}", "2": "int fib(int n) \n{ \n    if (n <= 1) \n        return n; \n    return findVertices(n-1) + findVertices(n-2); \n} \nint findVertices(int n) \n{ \n    return fib(n+2); \n}", "3": "void reverse(DoublyLinkedList head_ref) {\n        temp = nullptr;\n        current = head_ref;\n        while (current != nullptr) {\n                temp = current->prev;\n                current->prev = current->next;\n                current->next = temp;\n                current = current->prev;\n        }\n        if (temp != nullptr) {\n                head_ref = temp->prev;\n                return head_ref;\n        }\n}\n\nDoublyLinkedList merge(DoublyLinkedList first, DoublyLinkedList second) {\n        if (first == nullptr) {\n                return second;\n        }\n        if (second == nullptr) {\n                return first;\n        }\n        if (first->data < second->data) {\n                first->next = merge(first->next, second);\n                first->next->prev = first;\n                first->prev = nullptr;\n                return first;\n        }\n        else {\n                second->next = merge(first, second->next);\n                second->next->prev = second;\n                second->prev = nullptr;\n                return second;\n        }\n}\n\nDoublyLinkedList sort(DoublyLinkedList head) {\n        if (head == nullptr || head->next == nullptr) {\n                return head;\n        }\n        current = head->next;\n        while (current != nullptr) {\n                if (current->data < current->prev->data) {\n                        break;\n                }\n                current = current->next;\n        }\n        if (current == nullptr) {\n                return head;\n        }\n        current->prev->next = nullptr;\n        current->prev = nullptr;\n        current = reverse(current);\n        return merge(head, current);\n}\n\nDoublyLinkedList push(DoublyLinkedList head_ref, int new_data) {\n        new_node = Node();\n        new_node->data = new_data;\n        new_node->prev = nullptr;\n        new_node->next = head_ref;\n        if (head_ref != nullptr) {\n                head_ref->prev = new_node;\n        }\n        head_ref = new_node;\n        return head_ref;\n}\n\nvoid printList(DoublyLinkedList head) {\n        if (head == nullptr) {\n                cout << \"Doubly Linked list empty\";\n        }\n        while (head != nullptr) {\n                cout << head->data << \" \";\n                head = head->next;\n        }\n}\n\nvoid __init__(self, next = nullptr, prev = nullptr, data = nullptr) {\n                self->next = next;\n                self->prev = prev;\n                self->data = data;\n}", "4": "void printlist(node *head)\n{\n        if (not head)\n        {\n                print(\"Empty List\");\n                return;\n        }\n        while (head != NULL)\n        {\n                print(head->data, end = \" \");\n                if (head->next)\n                {\n                        print(end = \"-> \");\n                }\n                head = head->next;\n        }\n        print();\n}\nbool isVowel(char x)\n{\n        return (x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U');\n}\nnode *arrange(node *head)\n{\n        node *newHead = head;\n        node *latestVowel = NULL;\n        node *curr = head;\n        if (head == NULL)\n        {\n                return NULL;\n        }\n        if (isVowel(head->data))\n        {\n                latestVowel = head;\n        }\n        else\n        {\n                while (curr->next != NULL &&\n                        not isVowel(curr->next->data))\n                {\n                        curr = curr->next;\n                }\n                if (curr->next == NULL)\n                {\n                        return head;\n                }\n                latestVowel = newHead = curr->next;\n                curr->next = curr->next->next;\n                latestVowel->next = head;\n        }\n        while (curr != NULL && curr->next != NULL)\n        {\n                if (isVowel(curr->next->data))\n                {\n                        if (curr == latestVowel)\n                        {\n                                latestVowel = curr = curr->next;\n                        }\n                        else\n                        {\n                                node *temp = latestVowel->next;\n                                latestVowel->next = curr->next;\n                                latestVowel = latestVowel->next;\n                                curr->next = curr->next->next;\n                                latestVowel->next = temp;\n                        }\n                }\n                else\n                {\n                        curr = curr->next;\n                }\n        }\n        return newHead;\n}\nnode *__init__(int x)\n{\n                data = x;\n                next = NULL;\n}", "5": "template <typename T>\nint KthLargestUsingMorrisTraversal(node<T> *root, int k)\n{\n        node<T> *curr = root;\n        node<T> *Klargest = nullptr;\n        int count = 0;\n        while (curr != nullptr)\n        {\n                if (curr->right == nullptr)\n                {\n                        count += 1;\n                        if (count == k)\n                        {\n                                Klargest = curr;\n                        }\n                        curr = curr->left;\n                }\n                else\n                {\n                        succ = curr->right;\n                        while (succ->left != nullptr && succ->left != curr)\n                        {\n                                succ = succ->left;\n                        }\n                        if (succ->left == nullptr)\n                        {\n                                succ->left = curr;\n                                curr = curr->right;\n                        }\n                        else\n                        {\n                                succ->left = nullptr;\n                                count += 1;\n                                if (count == k)\n                                {\n                                        Klargest = curr;\n                                }\n                                curr = curr->left;\n                        }\n                }\n        }\n        return Klargest;\n}", "6": "void sortByRow(int mat[][], int n, bool ascending){\n        for(int i = 0; i < n; i++){\n                if(ascending){\n                        mat[i].sort();\n                }\n                else{\n                        mat[i].sort(reverse=true);\n                }\n        }\n}\nvoid transpose(int mat[][], int n){\n        for(int i = 0; i < n; i++){\n                for(int j = i + 1; j < n; j++){\n                        temp = mat[i][j];\n                        mat[i][j] = mat[j][i];\n                        mat[j][i] = temp;\n                }\n        }\n}\nvoid sortMatRowAndColWise(int mat[][], int n){\n        sortByRow(mat, n, true);\n        transpose(mat, n);\n        sortByRow(mat, n, false);\n        transpose(mat, n);\n}\nvoid printMat(int mat[][], int n){\n        for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                        cout << mat[i][j] << \" \";\n                }\n                cout<<endl;\n        }\n}", "7": "void sortByRow(int mat[][10], int n) \n{ \n    for (int i = 0; i < n; i++) \n    { \n        for (int j = 0; j < n-1; j++) \n        { \n            if (mat[i][j] > mat[i][j + 1]) \n            { \n                int temp = mat[i][j]; \n                mat[i][j] = mat[i][j + 1]; \n                mat[i][j + 1] = temp; \n            } \n        } \n    } \n} \nvoid transpose(int mat[][10], int n) \n{ \n    for (int i = 0; i < n; i++) \n    { \n        for (int j = 0; j < i + 1; j++) \n        { \n            int t = mat[i][j]; \n            mat[i][j] = mat[j][i]; \n            mat[j][i] = t; \n        } \n    } \n} \nvoid sortMatRowAndColWise(int mat[][10], int n) \n{ \n    sortByRow(mat, n); \n    transpose(mat, n); \n    sortByRow(mat, n); \n    transpose(mat, n); \n} \nvoid printMat(int mat[][10], int n) \n{ \n    for (int i = 0; i < n; i++) \n    { \n        for (int j = 0; j < n; j++) \n        { \n            System.out.print(mat[i][j] + \" \"); \n        } \n        System.out.println(); \n    } \n}", "8": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid DoublyEven(int n) {\n        vector< vector<int> > arr;\n        arr.resize(n);\n        for (int i = 0; i < n; i++) {\n                arr[i].resize(n);\n        }\n        for (int y = 0; y < n; y++) {\n                for (int x = 0; x < n; x++) {\n                        arr[y][x] = (n*y)+x+1;\n                }\n        }\n        for (int i = 0; i < n/4; i++) {\n                for (int j = 0; j < n/4; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for (int i = 0; i < n/4; i++) {\n                for (int j = 3 * (n/4); j < n; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for (int i = 3 * (n/4); i < n; i++) {\n                for (int j = 0; j < n/4; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for (int i = 3 * (n/4); i < n; i++) {\n                for (int j = 3 * (n/4); j < n; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for (int i = n/4; i < 3 * (n/4); i++) {\n                for (int j = n/4; j < 3 * (n/4); j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                        cout << '%2d ' %(arr[i][j]);\n                }\n                cout << '\\n';\n        }\n}\n\nint main() {\n        int n;\n        cin >> n;\n        DoublyEven(n);\n        return 0;\n}", "9": "int Kroneckerproduct(int A[][], int B[][], int rowa, int cola, int rowb, int colb) {\n\tint C[][] = new int[rowa * rowb][cola * colb];\n\tfor (int i = 0; i < rowa; i++) {\n\t\tfor (int k = 0; k < rowb; k++) {\n\t\t\tfor (int j = 0; j < cola; j++) {\n\t\t\t\tfor (int l = 0; l < colb; l++) {\n\t\t\t\t\tC[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n\t\t\t\t\tcout << C[i + l + 1][j + k + 1] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}", "10": "bool islowertriangular(vector<vector<int>> M){\n        for(int i = 0; i < M.size(); i++){\n                for(int j = i + 1; j < M.size(); j++){\n                        if(M[i][j] != 0){\n                                        return false;\n                        }\n                }\n        }\n        return true;\n}", "11": "bool isuppertriangular(std::vector<std::vector<int>> M){\n        for (int i = 1; i < M.size(); i++){\n                for(int j = 0; j < i; j++){\n                        if (M[i][j] != 0){\n                                return false;\n                        }\n                }\n        }\n        return true;\n}", "12": "int countSets(int **a, int n, int m) {\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n                int u = 0;\n                int v = 0;\n                for (int j = 0; j < m; j++) {\n                        if (a[i][j]) {\n                                u += 1;\n                        } else {\n                                v += 1;\n                        }\n                }\n                res += pow(2, u) - 1 + pow(2, v) - 1;\n        }\n        for (int i = 0; i < m; i++) {\n                int u = 0;\n                int v = 0;\n                for (int j = 0; j < n; j++) {\n                        if (a[j][i]) {\n                                u += 1;\n                        } else {\n                                v += 1;\n                        }\n                }\n                res += pow(2, u) - 1 + pow(2, v) - 1;\n        }\n        return res - (n*m);\n}", "13": "bool isSymmetric(vector<int> mat[], int N){\n        vector<int> tr[N];\n        for(int i=0;i<N;i++){\n                tr[i] = new vector<int>[N];\n                for(int j=0;j<N;j++){\n                        tr[i][j] = mat[j][i];\n                }\n        }\n        for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                        if(mat[i][j]!=tr[i][j]){\n                                return false;\n                        }\n                }\n        }\n        return true;\n}", "14": "bool isSymmetric(int** mat, int N){\n        for (int i=0; i<N; i++){\n                for (int j=0; j<N; j++){\n                        if (mat[i][j] != mat[j][i]){\n                                return false;\n                        }\n                }\n        }\n        return true;\n}", "15": "#include <iostream>\n#include <math.h>\nusing namespace std;\nint findNormal(int mat[][4], int n) {\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                        sum += mat[i][j] * mat[i][j];\n                }\n        }\n        return floor(sqrt(sum));\n}\nint findTrace(int mat[][4], int n) {\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n                sum += mat[i][i];\n        }\n        return sum;\n}", "16": "#include <iostream>\nusing namespace std;\n\nint maxDet(int n){\n        return 2 * n * n * n;\n}\nvoid resMatrix(int n){\n        for (int i = 0; i < 3; i++){\n                for (int j = 0; j < 3; j++){\n                        if (i == 0 && j == 2){\n                                cout << \"0\" << \" \";\n                        }\n                        else if (i == 1 && j == 0){\n                                cout << \"0\" << \" \";\n                        }\n                        else if (i == 2 && j == 1){\n                                cout << \"0\" << \" \";\n                        }\n                        else{\n                                cout << n << \" \";\n                        }\n                }\n                cout << \"\\n\";\n        }\n}", "17": "int countNegative(vector<vector<int> > M, int n, int m) {\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                        if (M[i][j] < 0) {\n                                count++;\n                        }\n                        else {\n                                break;\n                        }\n                }\n        }\n        return count;\n}", "18": "int countNegative(int M[][], int n, int m) {\n        int count = 0;\n        int i = 0;\n        int j = m - 1;\n        while (j >= 0 && i < n) {\n                if (M[i][j] < 0) {\n                        count += (j + 1);\n                        i++;\n                } else {\n                        j--;\n                }\n        }\n        return count;\n}", "19": "int getLastNegativeIndex(int array[], int start, int end, int n){\n        if (start == end){\n                return start;\n        }\n        int mid = start + (end - start) // 2;\n        if (array[mid] < 0){\n                if (mid + 1 < n && array[mid + 1] >= 0){\n                        return mid;\n                }\n                return getLastNegativeIndex(array, mid + 1, end, n);\n        }\n        else{\n                return getLastNegativeIndex(array, start, mid - 1, n);\n        }\n}\nint countNegative(int M[][4], int n, int m){\n        int count = 0;\n        int nextEnd = m - 1;\n        for (int i = 0; i < n; i++){\n                if (M[i][0] >= 0){\n                        break;\n                }\n                nextEnd = getLastNegativeIndex(M[i], 0, nextEnd, 4);\n                count += nextEnd + 1;\n        }\n        return count;\n}", "20": "int findMaxValue(int mat[N][N], int N)\n{\n        int maxValue = 0;\n        for (int a = 0; a < N - 1; a++)\n        {\n                for (int b = 0; b < N - 1; b++)\n                {\n                        for (int d = a + 1; d < N; d++)\n                        {\n                                for (int e = b + 1; e < N; e++)\n                                {\n                                        if (maxValue < int (mat[d][e] - mat[a][b]))\n                                        {\n                                                maxValue = int(mat[d][e] - mat[a][b]);\n                                        }\n                                }\n                        }\n                }\n        }\n        return maxValue;\n}", "21": "int findMaxValue(mat) {\n        int maxValue = -sys.maxsize -1;\n        int maxArr[N][N];\n        maxArr[N - 1][N - 1] = mat[N - 1][N - 1];\n        int maxv = mat[N - 1][N - 1];\n        for (int j = N - 2; j >= 0; j--) {\n                if (mat[N - 1][j] > maxv) {\n                        maxv = mat[N - 1][j]\n                }\n                maxArr[N - 1][j] = maxv;\n        }\n        maxv = mat[N - 1][N - 1];\n        for (int i = N - 2; i >= 0; i--) {\n                if (mat[i][N - 1] > maxv) {\n                        maxv = mat[i][N - 1]\n                }\n                maxArr[i][N - 1] = maxv;\n        }\n        for (int i = N - 2; i >= 0; i--) {\n                for (int j = N - 2; j >= 0; j--) {\n                        if (maxArr[i + 1][j + 1] - mat[i][j] > maxValue) {\n                                maxValue = (maxArr[i + 1][j + 1] - mat[i][j])\n                        }\n                        maxArr[i][j] = max(mat[i][j],\n                                                max(maxArr[i][j + 1], maxArr[i + 1][j]));\n                }\n        }\n        return maxValue;\n}", "22": "void youngify(int** mat, int i, int j)\n{\n        int downVal = mat[i + 1][j] if (i + 1 < N) else INF\n        int rightVal = mat[i][j + 1] if (j + 1 < N) else INF\n        if (downVal == INF and rightVal == INF)\n        {\n                return\n        }\n        if (downVal < rightVal)\n        {\n                mat[i][j] = downVal\n                mat[i + 1][j] = INF\n                youngify(mat, i + 1, j)\n        }\n        else\n        {\n                mat[i][j] = rightVal\n                mat[i][j + 1] = INF\n                youngify(mat, i, j + 1)\n        }\n}\nint extractMin(int** mat)\n{\n        int ret = mat[0][0]\n        mat[0][0] = INF\n        youngify(mat, 0, 0)\n        return ret\n}\nvoid printSorted(int** mat)\n{\n        cout << \"Elements of matrix in sorted order n\" << endl;\n        int i = 0;\n        while (i < N * N)\n        {\n                cout << extractMin(mat) << \" \";\n                i += 1;\n        }\n}", "23": "void printSumSimple(int mat[][], int k) {\n        if (k > n) {\n                return;\n        }\n        for (int i = 0; i < (n - k + 1); i++) {\n                for (int j = 0; j < (n - k + 1); j++) {\n                        int sum = 0;\n                        for (int p = i; p < (k + i); p++) {\n                                for (int q = j; q < (k + j); q++){\n                                        sum += mat[p][q];\n                                }\n                        }\n                        cout << sum << \" \";\n                }\n                cout << endl;\n        }\n}", "24": "void printSumTricky(int** mat, int k, int n)\n{\n        if (k > n)\n                return;\n        int** stripSum = new int* [n];\n        for (int i = 0; i < n; i++)\n                stripSum[i] = new int[n];\n        for (int j = 0; j < n; j++)\n        {\n                int Sum = 0;\n                for (int i = 0; i < k; i++)\n                        Sum += mat[i][j];\n                stripSum[0][j] = Sum;\n                for (int i = 1; i < n - k + 1; i++)\n                {\n                        Sum += (mat[i + k - 1][j] - mat[i - 1][j]);\n                        stripSum[i][j] = Sum;\n                }\n        }\n        for (int i = 0; i < n - k + 1; i++)\n        {\n                int Sum = 0;\n                for (int j = 0; j < k; j++)\n                        Sum += stripSum[i][j];\n                cout << Sum << \" \";\n                for (int j = 1; i < n - k + 1; j++)\n                {\n                        Sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n                        cout << Sum << \" \";\n                }\n                cout << endl;\n        }\n}", "25": "void transpose(int A[][M], int B[][N]) {\n        for (int i = 0; i < N; i++) {\n                for (int j = 0; j < M; j++) {\n                        B[i][j] = A[j][i];\n                }\n        }\n}", "26": "void transpose(int A[][N]) \n{ \n    for (int i = 0; i < N; i++) \n        for (int j = i+1; j < N; j++) \n            swap(A[i][j], A[j][i]); \n}", "27": "#include <iostream>\n\nusing namespace std;\n\nint pathCountRec(int** mat, int m, int n, int k) {\n        if(m < 0 || n < 0) {\n                return 0;\n        }\n        else if(m == 0 && n == 0) {\n                return k == mat[m][n];\n        }\n        else {\n                return (pathCountRec(mat, m-1, n, k-mat[m][n])\n                        + pathCountRec(mat, m, n-1, k-mat[m][n]));\n        }\n}\n\nint pathCount(int** mat, int k) {\n        return pathCountRec(mat, R-1, C-1, k);\n}\n\nint main() {\n        int R = 3;\n        int C = 3;\n        int k = 6;\n\n        int** mat = new int*[R];\n        for(int i = 0; i < R; i++) {\n                mat[i] = new int[C];\n        }\n\n        for(int i = 0; i < R; i++) {\n                for(int j = 0; j < C; j++) {\n                        mat[i][j] = 1;\n                }\n        }\n\n        cout << pathCount(mat, k) << endl;\n}", "28": "int pathCountDPRecDP(mat, int m, int n, int k) {\n        if (m < 0 || n < 0) {\n                return 0;\n        } else if (m == 0 && n == 0) {\n                return k == mat[m][n];\n        }\n        if (dp[m][n][k] != -1) {\n                return dp[m][n][k];\n        }\n        dp[m][n][k] = (pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) +\n                                pathCountDPRecDP(mat, m, n - 1, k - mat[m][n]));\n        return dp[m][n][k];\n}\nint pathCountDP(mat, int k) {\n        return pathCountDPRecDP(mat, R - 1, C - 1, k);\n}", "29": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nint countMinReversals(string expr)\n{\n    int len = expr.length();\n    if (len%2)\n    {\n        return -1;\n    }\n\n    stack<char> s;\n\n    for (int i=0; i<len; i++)\n    {\n        if (expr[i] == '}' && !s.empty())\n        {\n            if (s.top()=='{')\n            {\n                s.pop();\n            }\n            else\n            {\n                s.push(expr[i]);\n            }\n        }\n        else\n        {\n            s.push(expr[i]);\n        }\n    }\n\n    int red_len = s.size();\n    int n = 0;\n\n    while (!s.empty() && s.top() == '{')\n    {\n        s.pop();\n        n++;\n    }\n\n    return (red_len/2 + n%2);\n}\n\nint main()\n{\n    string expr = \"}}{{\";\n    cout << countMinReversals(expr);\n    return 0;\n}", "30": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvoid PrintMinNumberForPattern(string arr[], int n)\n{\n    int curr_max = 0;\n    int last_entry = 0;\n    int i = 0;\n    while (i < n)\n    {\n        int noOfNextD = 0;\n        if (arr[i] == \"I\")\n        {\n            int j = i + 1;\n            while (j < n && arr[j] == \"D\")\n            {\n                noOfNextD++;\n                j++;\n            }\n            if (i == 0)\n            {\n                curr_max = noOfNextD + 2;\n                last_entry += 1;\n                cout << last_entry << \" \" << curr_max << \" \";\n                last_entry = curr_max;\n            }\n            else\n            {\n                curr_max += noOfNextD + 1;\n                last_entry = curr_max;\n                cout << last_entry << \" \";\n            }\n            for (int k = 0; k < noOfNextD; k++)\n            {\n                last_entry -= 1;\n                cout << last_entry << \" \";\n                i++;\n            }\n        }\n        else if (arr[i] == \"D\")\n        {\n            if (i == 0)\n            {\n                int j = i + 1;\n                while (j < n && arr[j] == \"D\")\n                {\n                    noOfNextD++;\n                    j++;\n                }\n                curr_max = noOfNextD + 2;\n                cout << curr_max << \" \" << curr_max - 1 << \" \";\n                last_entry = curr_max - 1;\n            }\n            else\n            {\n                cout << last_entry - 1 << \" \";\n                last_entry -= 1;\n            }\n        }\n        i++;\n    }\n    cout << endl;\n}\n\nint main()\n{\n    string arr[] = {\"D\", \"I\", \"I\", \"D\", \"I\",\n                    \"D\", \"I\", \"D\", \"I\", \"D\",\n                    \"D\", \"I\", \"D\", \"D\", \"I\",\n                    \"D\", \"I\", \"D\", \"D\"};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    PrintMinNumberForPattern(arr, n);\n    return 0;\n}", "31": "void printLeast(vector<char> arr)\n{\n        int min_avail = 1;\n        int pos_of_I = 0;\n        vector<int> v;\n        if (arr[0] == 'I')\n        {\n                v.push_back(1);\n                v.push_back(2);\n                min_avail = 3;\n                pos_of_I = 1;\n        }\n        else\n        {\n                v.push_back(2);\n                v.push_back(1);\n                min_avail = 3;\n                pos_of_I = 0;\n        }\n        for (int i = 1; i < arr.size(); i++)\n        {\n                if (arr[i] == 'I')\n                {\n                        v.push_back(min_avail);\n                        min_avail += 1;\n                        pos_of_I = i + 1;\n                }\n                else\n                {\n                        v.push_back(v[i]);\n                        for (int j = pos_of_I; j < i + 1; j++)\n                        {\n                                v[j] += 1;\n                        }\n                        min_avail += 1;\n                }\n        }\n        for (int i = 0; i < v.size(); i++)\n        {\n                cout << v[i] << ' ';\n        }\n        cout << endl;\n}", "32": "void printMinNumberForPattern(string str) \n{ \n    // Initialize current index as 1 in stack \n    stack<int> stk; \n    stk.push(1); \n  \n    // Traverse the given string to get characters \n    for (int i = 0; i < str.length(); ++i) \n    { \n        // If character is 'i', we need to pop two \n        // elements from stack, print them and push \n        // one element to the stack \n        if (str[i] == 'I') \n        { \n            cout << stk.top(); \n            stk.pop(); \n  \n            // Add current element to the stack \n            stk.push(i + 1); \n        } \n  \n        // If character is 'd', we simply push it to the stack \n        else\n            stk.push(i + 1); \n    } \n  \n    // Pop and print all the remaining elements from stack \n    while (!stk.empty()) \n    { \n        cout << stk.top(); \n        stk.pop(); \n    } \n}", "33": "int getMinNumberForPattern(string seq){\n        int n = seq.length();\n        if (n >= 9){\n                return -1;\n        }\n        int result[n + 1];\n        int count = 1;\n        for (int i = 0; i < n + 1; i++){\n                if (i == n || seq[i] == 'I'){\n                        for (int j = i - 1; j >= -2; j--){\n                                result[j + 1] = int('0' + to_string(count));\n                                count += 1;\n                                if(j >= 0 && seq[j] == 'I'){\n                                        break;\n                                }\n                        }\n                }\n        }\n        return result;\n}", "34": "int subset(int ar[], int n) {\n        res = 0;\n        sort(ar, ar+n);\n        for(int i = 0; i < n; i++) {\n                int count = 1;\n                for(int i = 0; i < n-1; i++) {\n                        if(ar[i] == ar[i+1])\n                                count++;\n                        else\n                                break;\n                }\n                res = max(res, count);\n        }\n        return res;\n}", "35": "#include <bits/stdc++.h>\nusing namespace std;\n \nint subset(int arr[], int n)\n{\n        map<int, int> mp;\n        for (int i = 0; i < n; i++)\n                mp[arr[i]]++;\n        int res = 0;\n        for (auto it : mp)\n                res = max(res, it.second);\n        return res;\n}", "36": "bool areElementsContiguous(int arr[], unsigned int n) \n{ \n    sort(arr, arr+n); \n  \n    for (unsigned int i = 1; i < n; i++) \n        if ( (arr[i] - arr[i-1]) > 1) \n            return false; \n  \n    return true; \n}", "37": "bool areElementsContiguous(int arr[], int n) \n{ \n    int max1 = *max_element(arr, arr+n); \n    int min1 = *min_element(arr, arr+n); \n    int m = max1 - min1 + 1; \n    if (m > n) \n        return false; \n    bool visited[m]; \n    memset(visited, false, sizeof(visited)); \n    for (int i = 0; i < n; i++) \n        visited[arr[i] - min1] = true; \n    for (int i = 0; i < m; i++) \n        if (visited[i] == false) \n            return false; \n    return true; \n}", "38": "#include <iostream> \n#include <set> \nusing namespace std; \n\nbool areElementsContiguous(int arr[], int n) \n{ \n    set<int> us; \n    for (int i = 0; i < n; i++) \n        us.insert(arr[i]); \n\n    int count = 1; \n    int curr_ele = arr[0] - 1; \n    while (us.find(curr_ele) != us.end()) \n    { \n        count++; \n        curr_ele--; \n    } \n\n    curr_ele = arr[0] + 1; \n    while (us.find(curr_ele) != us.end()) \n    { \n        count++; \n        curr_ele++; \n    } \n\n    return (count == us.size()); \n} \n\nint main() \n{ \n    int arr[] = {5, 10, 15, 20, 25}; \n    int n = sizeof(arr) / sizeof(arr[0]); \n    if (areElementsContiguous(arr, n)) \n        cout << \"Yes\"; \n    else\n        cout << \"No\"; \n    return 0; \n}", "39": "def longest(a, n, k):\n        freq = collections.defaultdict(int)\n        start = 0\n        end = 0\n        now = 0\n        l = 0\n        for i in range(n):\n                freq[a[i]] += 1\n                if (freq[a[i]] == 1):\n                        now += 1\n                while (now > k) :\n                        freq[a[l]] -= 1\n                        if (freq[a[l]] == 0):\n                                now -= 1\n                        l += 1\n                if (i - l + 1 >= end - start + 1):\n                        end = i\n                        start = l\n        for i in range(start, end + 1):\n                print(a[i], end = \" \")", "40": "#include <bits/stdc++.h> \nusing namespace std; \n  \n#define N 5 \n  \n\nvoid findSmallestRange(int arr[][N], int n, int k) \n{ \n    int i, minval, maxval, minrange, minel, maxel, flag, minind; \n  \n\n    int ptr[100]; \n    for(i = 0;i <= k;i++) \n        ptr[i] = 0; \n  \n    minrange = INT_MAX; \n  \n    while(1) \n    { \n        minind = -1; \n        minval = INT_MAX; \n        maxval = -INT_MAX; \n        flag = 0; \n  \n        for(i = 0;i < k;i++) \n        { \n          \n            if(ptr[i] == n) \n            { \n                flag = 1; \n                break; \n            } \n  \n            \n            if(ptr[i] < n && arr[i][ptr[i]] < minval) \n            { \n                minind = i; \n                minval = arr[i][ptr[i]]; \n            } \n  \n            \n            if(ptr[i] < n && arr[i][ptr[i]] > maxval) \n            { \n                maxval = arr[i][ptr[i]]; \n            } \n        } \n  \n        \n        if(flag) \n            break; \n  \n        ptr[minind] += 1; \n  \n      \n        if((maxval-minval) < minrange) \n        { \n            minel = minval; \n            maxel = maxval; \n            minrange = maxel - minel; \n        } \n    } \n  \n    printf(\"The smallest range is [%d , %d]\\n\",minel,maxel); \n} \n  \nint main() \n{ \n  \n    int arr[][N] = { \n                    {4, 7, 9, 12, 15}, \n                    {0, 8, 10, 14, 20}, \n                    {6, 12, 16, 30, 50} \n                  }; \n  \n    int k = sizeof(arr)/sizeof(arr[0]); \n  \n    findSmallestRange(arr,N,k); \n  \n    return 0; \n}", "41": "int findLargestd(vector<int> S, int n) {\n        int found = false;\n        sort(S.begin(), S.end());\n        for (int i = n - 1; i >= 0; i--) {\n                for (int j = 0; j < n; j++) {\n                        if (i == j) {\n                                continue;\n                        }\n                        for (int k = j + 1; k < n; k++) {\n                                if (i == k) {\n                                        continue;\n                                }\n                                for (int l = k + 1; l < n; l++) {\n                                        if (i == l) {\n                                                continue;\n                                        }\n                                        if (S[i] == S[j] + S[k] + S[l]) {\n                                                found = true;\n                                                return S[i];\n                                        }\n                                }\n                        }\n                }\n        }\n        if (found == false) {\n                return -1;\n        }\n}", "42": "#include <bits/stdc++.h> \nusing namespace std; \n\n#define MAX 100000 \n\nint findFourElements(int arr[], int n) \n{ \n\tunordered_map<int, pair<int, int> > mp; \n\n\tfor (int i = 0; i < n - 1; i++) { \n\t\tfor (int j = i + 1; j < n; j++) { \n\t\t\tmp[arr[i] + arr[j]] = make_pair(i, j); \n\t\t} \n\t} \n\n\tint d = -1e9; \n\tfor (int i = 0; i < n - 1; i++) { \n\t\tfor (int j = i + 1; j < n; j++) { \n\t\t\tint abs_diff = abs(arr[i] - arr[j]); \n\t\t\tif (mp.find(abs_diff) != mp.end()) { \n\t\t\t\tpair<int, int> p = mp[abs_diff]; \n\t\t\t\tif (p.first != i && p.first != j && \n\t\t\t\t\tp.second != i && p.second != j) { \n\t\t\t\t\td = max(d, max(arr[i], arr[j])); \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n\n\treturn d; \n} \n\nint main() \n{ \n\tint arr[] = { 3, 4, 7, 1, 2, 9, 8 }; \n\tint n = sizeof(arr) / sizeof(arr[0]); \n\tcout << findFourElements(arr, n); \n\treturn 0; \n}", "43": "void leftRotatebyOne(int arr[], int n)\n{\n    int temp = arr[0], i;\n    for (i = 0; i < n - 1; i++)\n        arr[i] = arr[i + 1];\n \n    arr[i] = temp;\n}\n \n\nvoid leftRotate(int arr[], int d, int n)\n{\n    for (int i = 0; i < d; i++)\n        leftRotatebyOne(arr, n);\n}\n \n\nvoid printArray(int arr[], int n)\n{\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n}", "44": "void pushZerosToEnd(int arr[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (arr[i] != 0)\n            arr[count++] = arr[i];\n    while (count < n)\n        arr[count++] = 0;\n}", "45": "int moveZerosToEnd(int arr[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (arr[i] != 0)\n            swap(arr[count++], arr[i]);\n\n    return count;\n}\n\nvoid printArray(int arr[], int n)\n{\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n}", "46": "#include <iostream>\nusing namespace std;\n\nvoid pushZerosToEnd(int arr[], int n) {\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n                if (arr[i] != 0) {\n                        arr[count] = arr[i];\n                        count+=1;\n                }\n        }\n        while (count < n) {\n                arr[count] = 0;\n                count+=1;\n        }\n}\nvoid modifyAndRearrangeArr(int arr[], int n) {\n        if (n == 1) {\n                return;\n        }\n        for (int i = 0; i < n - 1; i++) {\n                if ((arr[i] != 0) && (arr[i] == arr[i + 1])) {\n                        arr[i] = 2 * arr[i];\n                        arr[i + 1] = 0;\n                        i+=1;\n                }\n        }\n        pushZerosToEnd(arr, n);\n}\nvoid printArray(int arr[], int n) {\n        for (int i = 0; i < n; i++) {\n                cout << arr[i] << \" \";\n        }\n}\n\nint main() {\n        int arr[] = {0, 2, 2, 2, 0, 6, 6, 0, 0, 8};\n        int n = sizeof(arr) / sizeof(arr[0]);\n        modifyAndRearrangeArr(arr, n);\n        printArray(arr, n);\n        return 0;\n}", "47": "#include <iostream>\nusing namespace std;\n\nint main() {\n        int n;\n        cin >> n;\n        for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= n - i; j++) {\n                        cout << \" \";\n                }\n                for (int j = 1; j <= i; j++) {\n                        cout << \"#\";\n                }\n                cout << \"\\n\";\n        }\n        return 0;\n}", "48": "#include <iostream>\nusing namespace std;\n\nvoid printArray(int arr[], int n)\n{\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n}\nvoid RearrangePosNeg(int arr[], int n)\n{\n    for (int i = 1; i < n; i++)\n    {\n        int key = arr[i];\n        if (key > 0)\n            continue;\n        int j = i - 1;\n        while (j >= 0 && arr[j] > 0)\n        {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\nint main()\n{\n    int arr[] = {12, 11, -13, -5, 6, -7, 5, -3, -6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    cout << \"Given array is\" << endl;\n    printArray(arr, n);\n    RearrangePosNeg(arr, n);\n    cout << \"Rearranged array is\" << endl;\n    printArray(arr, n);\n    return 0;\n}", "49": "public static void main(String args[])\n\t{\n\t\tint arr[] = { 2, 0, 2, 2, 0, 4, 0, 4, 4 };\n\t\tint n = arr.length;\n\t\tmodifyAndRearrangeArr(arr, n);\n\t\tprintArray(arr, n);\n\t}\n\ndef pushZerosToEnd(arr, n):\n\tcount = 0\n\tfor i in range(n):\n\t\tif arr[i] != 0:\n\t\t\tarr[count] = arr[i]\n\t\t\tcount += 1\n\twhile count < n:\n\t\tarr[count] = 0\n\t\tcount += 1\n\ndef modifyAndRearrangeArr(arr, n):\n\tif n == 1:\n\t\treturn\n\tfor i in range(n - 1):\n\t\tif arr[i] != 0 and arr[i] == arr[i + 1]:\n\t\t\tarr[i] = 2 * arr[i]\n\t\t\tarr[i + 1] = 0\n\t\t\ti += 1\n\tpushZerosToEnd(arr, n)\n\ndef printArray(arr, n):\n\tfor i in range(n):\n\t\tprint(arr[i], end=' ')\n\tprint()\n\narr = [2, 0, 2, 2, 0, 4, 0, 4, 4]\nn = len(arr)\nmodifyAndRearrangeArr(arr, n)\nprintArray(arr, n)"}}, "Python - Javascript": {"ID": {"0": 451, "1": 455, "2": 496, "3": 617, "4": 647, "5": 694, "6": 803, "7": 815, "8": 818, "9": 821, "10": 832, "11": 833, "12": 846, "13": 861, "14": 862, "15": 883, "16": 895, "17": 918, "18": 919, "19": 920, "20": 926, "21": 927, "22": 953, "23": 955, "24": 956, "25": 958, "26": 959, "27": 965, "28": 966, "29": 1064, "30": 1072, "31": 1073, "32": 1074, "33": 1075, "34": 1252, "35": 1253, "36": 1344, "37": 1345, "38": 1346, "39": 1366, "40": 1390, "41": 1405, "42": 1406, "43": 1428, "44": 1468, "45": 1469, "46": 1473, "47": 1474, "48": 1478, "49": 1473}, "Python": {"0": "def minCost(cost):\n        dist=[0 for i in range(N)]\n        for i in range(N):\n                dist[i] = INF\n        dist[0] = 0\n        for i in range(N):\n                for j in range(i+1,N):\n                        if (dist[j] > dist[i] + cost[i][j]):\n                                dist[j] = dist[i] + cost[i][j]\n        return dist[N-1]", "1": "def numOfways(n,k):\n        p = 1\n        if (k % 2):\n                p = -1\n        return (pow(n - 1, k) +\n                                p * (n - 1)) / na", "2": "def fib(n):\n        if n <= 1:\n                return n\n        return fib(n - 1) + fib(n - 2)\ndef findVertices(n):\n        return fib(n + 2)", "3": "def reverse( head_ref):\n        temp = None\n        current = head_ref\n        while (current != None):\n                temp = current.prev\n                current.prev = current.next\n                current.next = temp\n                current = current.prev\n        if (temp != None):\n                head_ref = temp.prev\n                return head_ref\ndef merge( first, second):\n        if (first == None):\n                return second\n        if (second == None):\n                return first\n        if (first.data < second.data):\n                first.next = merge(first.next, second)\n                first.next.prev = first\n                first.prev = None\n                return first\n        else:\n                second.next = merge(first, second.next)\n                second.next.prev = second\n                second.prev = None\n                return second\ndef sort( head):\n        if (head == None or head.next == None):\n                return head\n        current = head.next\n        while (current != None) :\n                if (current.data < current.prev.data):\n                        break\n                current = current.next\n        if (current == None):\n                return head\n        current.prev.next = None\n        current.prev = None\n        current = reverse(current)\n        return merge(head, current)\ndef push( head_ref, new_data):\n        new_node =Node()\n        new_node.data = new_data\n        new_node.prev = None\n        new_node.next = (head_ref)\n        if ((head_ref) != None):\n                (head_ref).prev = new_node\n        (head_ref) = new_node\n        return head_ref\ndef printList( head):\n        if (head == None):\n                print(\"Doubly Linked list empty\")\n        while (head != None):\n                print(head.data, end= \" \")\n                head = head.next\ndef __init__(self, next = None, prev = None, data = None):\n                self.next = next\n                self.prev = prev\n                self.data = data", "4": "def printlist(head):\n        if (not head):\n                print(\"Empty List\")\n                return\n        while (head != None):\n                print(head.data, end = \" \")\n                if (head.next):\n                        print(end = \"-> \")\n                head = head.next\n        print()\ndef isVowel(x):\n        return (x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U')\ndef arrange(head):\n        newHead = head\n        latestVowel = None\n        curr = head\n        if (head == None):\n                return None\n        if (isVowel(head.data)):\n                latestVowel = head\n        else:\n                while (curr.next != None and\n                        not isVowel(curr.next.data)):\n                        curr = curr.next\n                if (curr.next == None):\n                        return head\n                latestVowel = newHead = curr.next\n                curr.next = curr.next.next\n                latestVowel.next = head\n        while (curr != None and curr.next != None):\n                if (isVowel(curr.next.data)):\n                        if (curr == latestVowel):\n                                latestVowel = curr = curr.next\n                        else:\n                                temp = latestVowel.next\n                                latestVowel.next = curr.next\n                                latestVowel = latestVowel.next\n                                curr.next = curr.next.next\n                                latestVowel.next = temp\n                else:\n                        curr = curr.next\n        return newHead\ndef __init__(self, x):\n                self.data = x\n                self.next = None", "5": "def KthLargestUsingMorrisTraversal(root, k):\n        curr = root\n        Klargest = None\n        count = 0\n        while (curr != None):\n                if (curr.right == None):\n                        count += 1\n                        if (count == k):\n                                Klargest = curr\n                        curr = curr.left\n                else:\n                        succ = curr.right\n                        while (succ.left != None and succ.left != curr):\n                                succ = succ.left\n                        if (succ.left == None):\n                                succ.left = curr\n                                curr = curr.right\n                        else:\n                                succ.left = None\n                                count += 1\n                                if (count == k):\n                                        Klargest = curr\n                                curr = curr.left\n        return Klargest\ndef __init__(self, data):\n                self.data = data\n                self.right = self.left = None", "6": "def sortByRow(mat, n, ascending):\n        for i in range(n):\n                if (ascending): \n                        mat[i].sort()\n                else:\n                        mat[i].sort(reverse=True)\ndef transpose(mat, n):\n        for i in range(n):\n                for j in range(i + 1, n):\n                        temp = mat[i][j]\n                        mat[i][j] = mat[j][i]\n                        mat[j][i] = temp\ndef sortMatRowAndColWise(mat, n):\n        sortByRow(mat, n, True)\n        transpose(mat, n)\n        sortByRow(mat, n, False)\n        transpose(mat, n)\ndef printMat(mat, n):\n        for i in range(n):\n                for j in range(n):\n                        print(mat[i][j] , \" \", end=\"\")\n                print()", "7": "def sortByRow(mat, n):\n        for i in range (n):\n                for j in range(n-1):\n                        if mat[i][j] > mat[i][j + 1]:\n                                temp = mat[i][j]\n                                mat[i][j] = mat[i][j + 1]\n                                mat[i][j + 1] = temp\ndef transpose(mat, n):\n        for i in range (n):\n                for j in range(i + 1, n):\n                        t = mat[i][j]\n                        mat[i][j] = mat[j][i]\n                        mat[j][i] = t\ndef sortMatRowAndColWise(mat, n):\n        sortByRow(mat, n)\n        transpose(mat, n)\n        sortByRow(mat, n)\n        transpose(mat, n)\ndef printMat(mat, n):\n        for i in range(n):\n                for j in range(n):\n                        print(str(mat[i][j] ), end = \" \")\n                print();", "8": "def DoublyEven(n):\n        arr = [[(n*y)+x+1 for x in range(n)]for y in range(n)]\n        for i in range(0,n/4):\n                for j in range(0,n/4):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(0,n/4):\n                for j in range(3 * (n/4),n):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(3 * (n/4),n):\n                for j in range(0,n/4):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(3 * (n/4),n):\n                for j in range(3 * (n/4),n):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(n/4,3 * (n/4)):\n                for j in range(n/4,3 * (n/4)):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(n):\n                for j in range(n):\n                        print '%2d ' %(arr[i][j]),\n                print", "9": "def Kroneckerproduct( A , B ):\n        C = [[0 for j in range(cola * colb)] for i in range(rowa * rowb)]\n        for i in range(0, rowa):\n                for k in range(0, rowb):\n                        for j in range(0, cola):\n                                for l in range(0, colb):\n                                        C[i + l + 1][j + k + 1] = A[i][j] * B[k][l]\n                                        print (C[i + l + 1][j + k + 1],end=' ')\n                        print (\"\\n\")", "10": "def islowertriangular(M):\n        for i in range(0, len(M)):\n                for j in range(i + 1, len(M)):\n                        if(M[i][j] != 0):\n                                        return False\n        return True", "11": "def isuppertriangular(M):\n        for i in range(1, len(M)):\n                for j in range(0, i):\n                        if(M[i][j] != 0):\n                                        return False\n        return True", "12": "def countSets(a):\n        res = 0\n        for i in range(n):\n                u = 0\n                v = 0\n                for j in range(m):\n                        if a[i][j]:\n                                u += 1\n                        else:\n                                v += 1\n                res += pow(2, u) - 1 + pow(2, v) - 1\n        for i in range(m):\n                u = 0\n                v = 0\n                for j in range(n):\n                        if a[j][i]:\n                                u += 1\n                        else:\n                                v += 1\n                res += pow(2, u) - 1 + pow(2, v) - 1\n        return res - (n*m)", "13": "def transpose(mat, tr, N):\n        for i in range(N):\n                for j in range(N):\n                        tr[i][j] = mat[j][i]\ndef isSymmetric(mat, N):\n        tr = [ [0 for j in range(len(mat[0])) ] for i in range(len(mat)) ]\n        transpose(mat, tr, N)\n        for i in range(N):\n                for j in range(N):\n                        if (mat[i][j] != tr[i][j]):\n                                return False\n        return True", "14": "def isSymmetric(mat, N):\n        for i in range(N):\n                for j in range(N):\n                        if (mat[i][j] != mat[j][i]):\n                                return False\n        return True", "15": "def findNormal(mat, n):\n        sum = 0;\n        for i in range(n):\n                for j in range(n):\n                        sum += mat[i][j] * mat[i][j];\n        return math.floor(math.sqrt(sum));\ndef findTrace(mat, n):\n        sum = 0;\n        for i in range(n):\n                sum += mat[i][i];\n        return sum;", "16": "def maxDet(n):\n        return 2 * n * n * n\ndef resMatrix(n):\n        for i in range(3):\n                for j in range(3):\n                        if i == 0 and j == 2:\n                                print(\"0\", end = \" \")\n                        elif i == 1 and j == 0:\n                                print(\"0\", end = \" \")\n                        elif i == 2 and j == 1:\n                                print(\"0\", end = \" \")\n                        else:\n                                print(n, end = \" \")\n                print(\"\\n\")", "17": "def countNegative(M, n, m):\n        count = 0\n        for i in range(n):\n                for j in range(m):\n                        if M[i][j] < 0:\n                                count += 1\n                        else:\n                                break\n        return count", "18": "def countNegative(M, n, m):\n        count = 0 \n        i = 0\n        j = m - 1 \n        while j >= 0 and i < n:\n                if M[i][j] < 0:\n                        count += (j + 1)\n                        i += 1\n                else:\n                        j -= 1\n        return count", "19": "def getLastNegativeIndex(array, start, end, n):\n        if (start == end):\n                return start\n        mid = start + (end - start) // 2\n        if (array[mid] < 0):\n                if (mid + 1 < n and array[mid + 1] >= 0):\n                        return mid\n                return getLastNegativeIndex(array, mid + 1, end, n)\n        else:\n                return getLastNegativeIndex(array, start, mid - 1, n)\ndef countNegative(M, n, m):\n        count = 0\n        nextEnd = m - 1\n        for i in range(n):\n                if (M[i][0] >= 0):\n                        break\n                nextEnd = getLastNegativeIndex(M[i], 0, nextEnd, 4)\n                count += nextEnd + 1\n        return count", "20": "def findMaxValue(mat):\n        maxValue = 0\n        for a in range(N - 1):\n                for b in range(N - 1):\n                        for d in range(a + 1, N):\n                                for e in range(b + 1, N):\n                                        if maxValue < int (mat[d][e] - mat[a][b]):\n                                                maxValue = int(mat[d][e] - mat[a][b]);\n        return maxValue;", "21": "def findMaxValue(mat):\n        maxValue = -sys.maxsize -1\n        maxArr = [[0 for x in range(N)] for y in range(N)]\n        maxArr[N - 1][N - 1] = mat[N - 1][N - 1]\n        maxv = mat[N - 1][N - 1];\n        for j in range (N - 2, -1, -1):\n                if (mat[N - 1][j] > maxv):\n                        maxv = mat[N - 1][j]\n                maxArr[N - 1][j] = maxv\n        maxv = mat[N - 1][N - 1];\n        for i in range (N - 2, -1, -1):\n                if (mat[i][N - 1] > maxv):\n                        maxv = mat[i][N - 1]\n                maxArr[i][N - 1] = maxv\n        for i in range (N - 2, -1, -1):\n                for j in range (N - 2, -1, -1):\n                        if (maxArr[i + 1][j + 1] - mat[i][j] > maxValue):\n                                maxValue = (maxArr[i + 1][j + 1] - mat[i][j])\n                        maxArr[i][j] = max(mat[i][j],\n                                                max(maxArr[i][j + 1], maxArr[i + 1][j]))\n        return maxValue", "22": "def youngify(mat, i, j):\n        downVal = mat[i + 1][j] if (i + 1 < N) else INF\n        rightVal = mat[i][j + 1] if (j + 1 < N) else INF\n        if (downVal == INF and rightVal == INF):\n                return\n        if (downVal < rightVal):\n                mat[i][j] = downVal\n                mat[i + 1][j] = INF\n                youngify(mat, i + 1, j)\n        else:\n                mat[i][j] = rightVal\n                mat[i][j + 1] = INF\n                youngify(mat, i, j + 1)\ndef extractMin(mat):\n        ret = mat[0][0]\n        mat[0][0] = INF\n        youngify(mat, 0, 0)\n        return ret\ndef printSorted(mat):\n        print(\"Elements of matrix in sorted order n\")\n        i = 0\n        while i < N * N:\n                print(extractMin(mat), end = \" \")\n                i += 1", "23": "def printSumSimple(mat, k):\n        if (k > n):\n                return\n        for i in range(n - k + 1):\n                for j in range(n - k + 1):\n                        sum = 0\n                        for p in range(i, k + i):\n                                for q in range(j, k + j):\n                                        sum += mat[p][q]\n                        print(sum, end = \" \")\n                print()", "24": "def printSumTricky(mat, k):\n        global n\n        if k > n:\n                return\n        stripSum = [[None] * n for i in range(n)]\n        for j in range(n):\n                Sum = 0\n                for i in range(k):\n                        Sum += mat[i][j]\n                stripSum[0][j] = Sum\n                for i in range(1, n - k + 1):\n                        Sum += (mat[i + k - 1][j] - mat[i - 1][j])\n                        stripSum[i][j] = Sum\n        for i in range(n - k + 1):\n                Sum = 0\n                for j in range(k):\n                        Sum += stripSum[i][j]\n                print(Sum, end = \" \")\n                for j in range(1, n - k + 1):\n                        Sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1])\n                        print(Sum, end = \" \")\n                print()", "25": "def transpose(A, B):\n        for i in range(N):\n                for j in range(M):\n                        B[i][j] = A[j][i]", "26": "def transpose(A):\n        for i in range(N):\n                for j in range(i+1, N):\n                        A[i][j], A[j][i] = A[j][i], A[i][j]", "27": "def pathCountRec(mat, m, n, k):\n        if m < 0 or n < 0:\n                return 0\n        elif m == 0 and n == 0:\n                return k == mat[m][n]\n        return (pathCountRec(mat, m-1, n, k-mat[m][n])\n                + pathCountRec(mat, m, n-1, k-mat[m][n]))\ndef pathCount(mat, k):\n        return pathCountRec(mat, R-1, C-1, k)", "28": "def pathCountDPRecDP(mat, m, n, k):\n        if m < 0 or n < 0:\n                return 0\n        elif m == 0 and n == 0:\n                return k == mat[m][n]\n        if (dp[m][n][k] != -1):\n                return dp[m][n][k]\n        dp[m][n][k] = (pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) +\n                                pathCountDPRecDP(mat, m, n - 1, k - mat[m][n]))\n        return dp[m][n][k]\ndef pathCountDP(mat, k):\n        return pathCountDPRecDP(mat, R - 1, C - 1, k)", "29": "def countMinReversals(expr):\n        lenn = len(expr)\n        if (lenn % 2) :\n                return -1\n        s = []\n        for i in range(lenn):\n                if (expr[i] =='' and len(s)):\n                        if (s[0] == '') :\n                                s.pop(0)\n                        else:\n                                s.insert(0, expr[i])\n                else:\n                        s.insert(0, expr[i])\n        red_len = len(s)\n        n = 0\n        while (len(s)and s[0] == '') :\n                        s.pop(0)\n                        n += 1\n        return (red_len // 2 + n % 2)", "30": "def PrintMinNumberForPattern(arr):\n        curr_max = 0\n        last_entry = 0\n        i = 0\n        while i < len(arr):\n                noOfNextD = 0\n                if arr[i] == \"I\":\n                        j = i + 1\n                        while j < len(arr) and arr[j] == \"D\":\n                                noOfNextD += 1\n                                j += 1\n                        if i == 0:\n                                curr_max = noOfNextD + 2\n                                last_entry += 1\n                                print(\"\", last_entry, end = \"\")\n                                print(\"\", curr_max, end = \"\")\n                                last_entry = curr_max\n                        else:\n                                curr_max += noOfNextD + 1\n                                last_entry = curr_max\n                                print(\"\", last_entry, end = \"\")\n                        for k in range(noOfNextD):\n                                last_entry -= 1\n                                print(\"\", last_entry, end = \"\")\n                                i += 1\n                elif arr[i] == \"D\":\n                        if i == 0:\n                                j = i + 1\n                                while j < len(arr) and arr[j] == \"D\":\n                                        noOfNextD += 1\n                                        j += 1\n                                curr_max = noOfNextD + 2\n                                print(\"\", curr_max, curr_max - 1, end = \"\")\n                                last_entry = curr_max - 1\n                        else:\n                                print(\"\", last_entry - 1, end = \"\")\n                                last_entry -= 1\n                i += 1\n        print()", "31": "def printLeast(arr):\n        min_avail = 1\n        pos_of_I = 0\n        v = []\n        if (arr[0] == 'I'):\n                v.append(1)\n                v.append(2)\n                min_avail = 3\n                pos_of_I = 1\n        else:\n                v.append(2)\n                v.append(1)\n                min_avail = 3\n                pos_of_I = 0\n        for i in range(1, len(arr)):\n                if (arr[i] == 'I'):\n                        v.append(min_avail)\n                        min_avail += 1\n                        pos_of_I = i + 1\n                else:\n                        v.append(v[i])\n                        for j in range(pos_of_I, i + 1):\n                                v[j] += 1\n                        min_avail += 1\n        print(*v, sep = ' ')", "32": "def PrintMinNumberForPattern(Strr):\n        res = ''\n        stack = []\n        for i in range(len(Strr) + 1):\n                stack.append(i + 1)\n                if (i == len(Strr) or Strr[i] == 'I'):\n                        while len(stack) > 0:\n                                res += str(stack.pop())\n                                res += ' '\n        print(res)", "33": "def getMinNumberForPattern(seq):\n        n = len(seq)\n        if (n >= 9):\n                return \"-1\"\n        result = [None] * (n + 1)\n        count = 1\n        for i in range(n + 1):\n                if (i == n or seq[i] == 'I'):\n                        for j in range(i - 1, -2, -1):\n                                result[j + 1] = int('0' + str(count))\n                                count += 1\n                                if(j >= 0 and seq[j] == 'I'):\n                                        break\n        return result", "34": "def subset(ar, n):\n        res = 0\n        ar.sort()\n        for i in range(0, n) :\n                count = 1\n                for i in range(n - 1):\n                        if ar[i] == ar[i + 1]:\n                                count+=1\n                        else:\n                                break\n                res = max(res, count)\n        return res", "35": "def subset(arr, n):\n        mp = {i:0 for i in range(10)}\n        for i in range(n):\n                mp[arr[i]] += 1\n        res = 0\n        for key, value in mp.items():\n                res = max(res, value)\n        return res", "36": "def areElementsContiguous(arr, n):\n        arr.sort()\n        for i in range(1,n):\n                if (arr[i] - arr[i-1] > 1) :\n                        return 0\n        return 1", "37": "def areElementsContiguous(arr, n):\n        max1 = max(arr)\n        min1 = min(arr)\n        m = max1 - min1 + 1\n        if (m > n):\n                return False\n        visited = [0] * m\n        for i in range(0,n) :\n                visited[arr[i] - min1] = True\n        for i in range(0, m):\n                if (visited[i] == False):\n                        return False\n        return True", "38": "def areElementsContiguous(arr):\n        us = set()\n        for i in arr: us.add(i)\n        count = 1\n        curr_ele = arr[0] - 1\n        while curr_ele in us:\n                count += 1\n                curr_ele -= 1\n        curr_ele = arr[0] + 1\n        while curr_ele in us:\n                count += 1\n                curr_ele += 1\n        return (count == len(us))", "39": "def longest(a, n, k):\n        freq = collections.defaultdict(int)\n        start = 0\n        end = 0\n        now = 0\n        l = 0\n        for i in range(n):\n                freq[a[i]] += 1\n                if (freq[a[i]] == 1):\n                        now += 1\n                while (now > k) :\n                        freq[a[l]] -= 1\n                        if (freq[a[l]] == 0):\n                                now -= 1\n                        l += 1\n                if (i - l + 1 >= end - start + 1):\n                        end = i\n                        start = l\n        for i in range(start, end + 1):\n                print(a[i], end = \" \")", "40": "def findSmallestRange(arr, n, k):\n        i, minval, maxval, minrange, minel, maxel, flag, minind = 0, 0, 0, 0, 0, 0, 0, 0\n        for i in range(k + 1):\n                ptr[i] = 0\n        minrange = 10**9\n        while(1): \n                minind = -1\n                minval = 10**9\n                maxval = -10**9\n                flag = 0\n                for i in range(k):\n                        if(ptr[i] == n):\n                                flag = 1 \n                                break\n                        if(ptr[i] < n and arr[i][ptr[i]] < minval):\n                                minind = i \n                                minval = arr[i][ptr[i]]\n                        if(ptr[i] < n and arr[i][ptr[i]] > maxval):\n                                maxval = arr[i][ptr[i]]\n                if(flag):\n                        break\n                ptr[minind] += 1\n                if((maxval-minval) < minrange):\n                        minel = minval\n                        maxel = maxval\n                        minrange = maxel - minel\n        print(\"The smallest range is [\", minel, maxel, \"]\")", "41": "def findLargestd(S, n) :\n        found = False\n        S.sort()\n        for i in range(n-1, -1, -1) :\n                for j in range(0, n) :\n                        if (i == j) :\n                                continue\n                        for k in range(j + 1, n) :\n                                if (i == k) :\n                                        continue\n                                for l in range(k+1, n) :\n                                        if (i == l) :\n                                                continue\n                                        if (S[i] == S[j] + S[k] + S[l]) :\n                                                found = True\n                                                return S[i]                                \n        if (found == False) :\n                return -1", "42": "def findFourElements(arr, n):\n        mp = dict()\n        for i in range(n - 1):\n                for j in range(i + 1, n):\n                        mp[arr[i] + arr[j]] =(i, j)\n        d = -10**9\n        for i in range(n - 1):\n                for j in range(i + 1, n):\n                        abs_diff = abs(arr[i] - arr[j])\n                        if abs_diff in mp.keys():\n                                p = mp[abs_diff]\n                                if (p[0] != i and p[0] != j and p[1] != i and p[1] != j):\n                                        d = max(d, max(arr[i], arr[j]))\n        return d", "43": "def leftRotatebyOne(arr, n):\n        temp = arr[0]\n        for i in range(n-1):\n                arr[i] = arr[i + 1]\n        arr[n-1] = temp\ndef leftRotate(arr, d, n):\n        for i in range(d):\n                leftRotatebyOne(arr, n)\ndef printArray(arr, size):\n        for i in range(size):\n                print (\"% d\"% arr[i], end =\" \")", "44": "def pushZerosToEnd(arr, n):\n        count = 0 \n        for i in range(n):\n                if arr[i] != 0:\n                        arr[count] = arr[i]\n                        count+=1\n        while count < n:\n                arr[count] = 0\n                count += 1", "45": "def moveZerosToEnd (arr, n):\n        count = 0;\n        for i in range(0, n):\n                if (arr[i] != 0):\n                        arr[count], arr[i] = arr[i], arr[count]\n                        count+=1\ndef printArray(arr, n):\n        for i in range(0, n):\n                print(arr[i],end=\" \")", "46": "def pushZerosToEnd(arr, n):\n        count = 0\n        for i in range(0, n):\n                if arr[i] != 0:\n                        arr[count] = arr[i]\n                        count+=1\n        while (count < n):\n                arr[count] = 0\n                count+=1\ndef modifyAndRearrangeArr(ar, n):\n        if n == 1:\n                return\n        for i in range(0, n - 1):\n                if (arr[i] != 0) and (arr[i] == arr[i + 1]):\n                        arr[i] = 2 * arr[i]\n                        arr[i + 1] = 0\n                        i+=1\n        pushZerosToEnd(arr, n)\ndef printArray(arr, n):\n        for i in range(0, n):\n                print(arr[i],end=\" \")", "47": "def shiftAllZeroToLeft(arr, n):\n        lastSeenNonZero = 0\n        for index in range(0, n):\n                if (array[index] != 0):\n                        array[index], array[lastSeenNonZero] = array[lastSeenNonZero], array[index]\n                        lastSeenNonZero+=1", "48": "def printArray(arr, n):\n        for i in range(n):\n                print(arr[i], end = \" \")\n        print()\ndef RearrangePosNeg(arr, n):\n        for i in range(1, n):\n                key = arr[i]\n                if (key > 0):\n                        continue\n                j = i - 1\n                while (j >= 0 and arr[j] > 0):\n                        arr[j + 1] = arr[j]\n                        j = j - 1\n                arr[j + 1] = key", "49": "static void pushZerosToEnd(int arr[], int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != 0)\n\t\t\t\tarr[count++] = arr[i];\n\t\twhile (count < n)\n\t\t\tarr[count++] = 0;\n\t}\nstatic void modifyAndRearrangeArr(int arr[], int n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif ((arr[i] != 0) && (arr[i] == arr[i + 1]))\n\t\t\t{\n\t\t\t\tarr[i] = 2 * arr[i];\n\t\t\t\tarr[i + 1] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tpushZerosToEnd(arr, n);\n\t}\nstatic void printArray(int arr[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}"}, "Javascript": {"0": "function minCost(cost){\n        var dist = [];\n        for (var i = 0; i < N; i++) {\n                dist[i] = INF;\n        }\n        dist[0] = 0;\n        for (var i = 0; i < N; i++) {\n                for (var j = i + 1; j < N; j++) {\n                        if (dist[j] > dist[i] + cost[i][j]) {\n                                dist[j] = dist[i] + cost[i][j];\n                        }\n                }\n        }\n        return dist[N - 1];\n}", "1": "function numOfways(n,k){\n        p = 1\n        if (k % 2){\n                p = -1\n        }\n        return (Math.pow(n - 1, k) +\n                                p * (n - 1)) / na\n\n}", "2": "function fib(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n\nfunction findVertices(n) {\n    return fib(n + 2);\n}", "3": "function reverse( head_ref){\n        temp = None\n        current = head_ref\n        while (current != None){\n                temp = current.prev\n                current.prev = current.next\n                current.next = temp\n                current = current.prev\n        if (temp != None){\n                head_ref = temp.prev\n                return head_ref\n}\nfunction merge( first, second){\n        if (first == None){\n                return second\n        }\n        if (second == None){\n                return first\n        }\n        if (first.data < second.data){\n                first.next = merge(first.next, second)\n                first.next.prev = first\n                first.prev = None\n                return first\n        }\n        else{\n                second.next = merge(first, second.next)\n                second.next.prev = second\n                second.prev = None\n                return second\n}\nfunction sort( head){\n        if (head == None || head.next == None){\n                return head\n        }\n        current = head.next\n        while (current != None) {\n                if (current.data < current.prev.data){\n                        break\n                }\n                current = current.next\n        }\n        if (current == None){\n                return head\n        }\n        current.prev.next = None\n        current.prev = None\n        current = reverse(current)\n        return merge(head, current)\n}\nfunction push( head_ref, new_data){\n        new_node =Node()\n        new_node.data = new_data\n        new_node.prev = None\n        new_node.next = (head_ref)\n        if ((head_ref) != None){\n                (head_ref).prev = new_node\n        }\n        (head_ref) = new_node\n        return head_ref\n}\nfunction printList( head){\n        if (head == None){\n                print(\"Doubly Linked list empty\")\n        }\n        while (head != None){\n                print(head.data, end= \" \")\n                head = head.next\n}\nfunction __init__(self, next = None, prev = None, data = None){\n                self.next = next\n                self.prev = prev\n                self.data = data\n}", "4": "function printlist(head){\n        if (not head){\n                print(\"Empty List\")\n                return\n        }\n        while (head != null){\n                print(head.data, end = \" \")\n                if (head.next){\n                        print(end = \"-> \")\n                }\n                head = head.next\n        }\n}\nfunction isVowel(x){\n        return (x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u' || x == 'A' || x == 'E' || x == 'I' || x == 'O' || x == 'U')\n}\nfunction arrange(head){\n        newHead = head\n        latestVowel = null\n        curr = head\n        if (head == null){\n                return null\n        }\n        if (isVowel(head.data)){\n                latestVowel = head\n        }\n        else {\n                while (curr.next != null &&\n                        !isVowel(curr.next.data)){\n                        curr = curr.next\n                }\n                if (curr.next == null){\n                        return head\n                }\n                latestVowel = newHead = curr.next\n                curr.next = curr.next.next\n                latestVowel.next = head\n        }\n        while (curr != null && curr.next != null){\n                if (isVowel(curr.next.data)){\n                        if (curr == latestVowel){\n                                latestVowel = curr = curr.next\n                        }\n                        else {\n                                temp = latestVowel.next\n                                latestVowel.next = curr.next\n                                latestVowel = latestVowel.next\n                                curr.next = curr.next.next\n                                latestVowel.next = temp\n                        }\n                }\n                else {\n                        curr = curr.next\n                }\n        }\n        return newHead\n}\nfunction __init__(self, x){\n                self.data = x\n                self.next = null\n}", "5": "function KthLargestUsingMorrisTraversal(root, k) {\n        curr = root\n        Klargest = null\n        count = 0\n        while (curr != null) {\n                if (curr.right == null) {\n                        count += 1\n                        if (count == k) {\n                                Klargest = curr\n                        }\n                        curr = curr.left\n                } else {\n                        succ = curr.right\n                        while (succ.left != null && succ.left != curr) {\n                                succ = succ.left\n                        }\n                        if (succ.left == null) {\n                                succ.left = curr\n                                curr = curr.right\n                        } else {\n                                succ.left = null\n                                count += 1\n                                if (count == k) {\n                                        Klargest = curr\n                                }\n                                curr = curr.left\n                        }\n                }\n        return Klargest\n}\nfunction __init__(self, data) {\n                self.data = data\n                self.right = self.left = null\n}", "6": "function sortByRow(mat, n, ascending) {\n        for (i = 0; i < n; i++) {\n                if (ascending) {\n                        mat[i].sort();\n                }\n                else {\n                        mat[i].sort(reverse=True);\n                }\n        }\n}\nfunction transpose(mat, n) {\n        for (i = 0; i < n; i++) {\n                for (j = 0; j < (i + 1, n); j++) {\n                        temp = mat[i][j];\n                        mat[i][j] = mat[j][i];\n                        mat[j][i] = temp;\n                }\n        }\n}\nfunction sortMatRowAndColWise(mat, n) {\n        sortByRow(mat, n, True);\n        transpose(mat, n);\n        sortByRow(mat, n, False);\n        transpose(mat, n);\n}\nfunction printMat(mat, n) {\n        for (i = 0; i < n; i++) {\n                for (j = 0; j < n; j++) {\n                        console.log(mat[i][j], \" \", end=\"\");\n                }\n                console.log();\n        }\n}", "7": "function sortByRow(mat, n) {\n        for (i = 0; i < n; i++) {\n                for (j = 0; j < n - 1; j++) {\n                        if (mat[i][j] > mat[i][j + 1]) {\n                                temp = mat[i][j]\n                                mat[i][j] = mat[i][j + 1]\n                                mat[i][j + 1] = temp\n                        }\n                }\n        }\n}\nfunction transpose(mat, n) {\n        for (i = 0; i < n; i++) {\n                for (j = 0; j < i + 1; j++) {\n                        t = mat[i][j]\n                        mat[i][j] = mat[j][i]\n                        mat[j][i] = t\n                }\n        }\n}\nfunction sortMatRowAndColWise(mat, n) {\n        sortByRow(mat, n)\n        transpose(mat, n)\n        sortByRow(mat, n)\n        transpose(mat, n)\n}\nfunction printMat(mat, n) {\n        for (i = 0; i < n; i++) {\n                for (j = 0; j < n; j++) {\n                        console.log(str(mat[i][j]), end = \" \")\n                }\n                console.log();\n        }\n}", "8": "function DoublyEven(n) {\n        var arr = [[(n*y)+x+1 for x in range(n)]for y in range(n)];\n        for (var i = 0; i < n/4; i++) {\n                for (var j = 0; j < n/4; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for (var i = 0; i < n/4; i++) {\n                for (var j = 3 * (n/4); j < n; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for (var i = 3 * (n/4); i < n; i++) {\n                for (var j = 0; j < n/4; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for (var i = 3 * (n/4); i < n; i++) {\n                for (var j = 3 * (n/4); j < n; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for (var i = n/4; i < 3 * (n/4); i++) {\n                for (var j = n/4; j < 3 * (n/4); j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for (var i = 0; i < n; i++) {\n                for (var j = 0; j < n; j++) {\n                        console.log('%2d ', arr[i][j]);\n                }\n                console.log();\n        }\n}", "9": "function kroneckerproduct(a, b) {\n        c = [[0 for j in range(a.length * b[0].length)] for i in range(a.length * b.length)];\n        for (i = 0; i < a.length; i++) {\n                for (k = 0; k < b.length; k++) {\n                        for (j = 0; j < a[0].length; j++) {\n                                for (l = 0; l < b[0].length; l++) {\n                                        c[i + l + 1][j + k + 1] = a[i][j] * b[k][l];\n                                        console.log(c[i + l + 1][j + k + 1], end = ' ');\n                                }\n                        console.log(\"\\n\");\n                        }\n                }\n        }\n}", "10": "function islowertriangular(M){\n        for (i = 0; i < len(M); i++) {\n                for (j = i + 1; j < len(M); j++) {\n                        if (M[i][j] != 0) {\n                                        return false\n                        }\n                }\n        }\n        return true\n}", "11": "function isuppertriangular(M) {\n        for (var i = 1; i < M.length; i++) {\n                for (var j = 0; j < i; j++) {\n                        if(M[i][j] != 0) {\n                                        return false;\n                        }\n                }\n        }\n        return true;\n}", "12": "function countSets(a) {\n        var res = 0;\n        var n = a.length;\n        var m = a[0].length;\n        for (var i = 0; i < n; i++) {\n                var u = 0;\n                var v = 0;\n                for (var j = 0; j < m; j++) {\n                        if (a[i][j]) {\n                                u += 1;\n                        }\n                        else {\n                                v += 1;\n                        }\n                }\n                res += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n        }\n        for (var i = 0; i < m; i++) {\n                u = 0;\n                v = 0;\n                for (var j = 0; j < n; j++) {\n                        if (a[j][i]) {\n                                u += 1;\n                        }\n                        else {\n                                v += 1;\n                        }\n                }\n                res += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n        }\n        return res - (n*m);\n}", "13": "function transpose(mat, tr, N) {\n        for (var i=0; i<N; i++) {\n                for (var j=0; j<N; j++) {\n                        tr[i][j] = mat[j][i];\n                }\n        }\n}\nfunction isSymmetric(mat, N) {\n        var tr = [ [0 for j in range(len(mat[0])) ] for i in range(len(mat)) ];\n        transpose(mat, tr, N);\n        for (var i=0; i<N; i++) {\n                for (var j=0; j<N; j++) {\n                        if (mat[i][j] != tr[i][j]) {\n                                return false;\n                        }\n                }\n        }\n        return true;\n}", "14": "function isSymmetric(mat, N){\n        for (var i=0; i<N; i++){\n                for (var j=0; j<N; j++){\n                        if (mat[i][j] != mat[j][i]){\n                                return false;\n                        }\n                }\n        }\n        return true;\n}", "15": "function findNormal(mat, n){\n        var sum = 0;\n        for (var i = 0; i < n; i++){\n                for (var j = 0; j < n; j++){\n                        sum += mat[i][j] * mat[i][j];\n                }\n        }\n        return Math.floor(Math.sqrt(sum));\n}\nfunction findTrace(mat, n){\n        var sum = 0;\n        for (var i = 0; i < n; i++){\n                sum += mat[i][i];\n        }\n        return sum;\n}", "16": "function maxDet(n){\n        return 2 * n * n * n;\n}\nfunction resMatrix(n){\n        for(var i = 0; i < 3; i++){\n                for(var j = 0; j < 3; j++){\n                        if(i == 0 && j == 2){\n                                document.write(\"0 \");\n                        }\n                        else if(i == 1 && j == 0){\n                                document.write(\"0 \");\n                        }\n                        else if(i == 2 && j == 1){\n                                document.write(\"0 \");\n                        }\n                        else{\n                                document.write(n + \" \");\n                        }\n                }\n                document.write(\"<br>\");\n        }\n}", "17": "function countNegative(M, n, m){\n        let count = 0;\n        for (let i = 0; i < n; i++){\n                for (let j = 0; j < m; j++){\n                        if (M[i][j] < 0){\n                                count += 1;\n                        }\n                        else {\n                                break;\n                        }\n                }\n        }\n        return count;\n}", "18": "function countNegative(M, n, m){\n        let count = 0 \n        let i = 0\n        let j = m - 1 \n        while (j >= 0 && i < n){\n                if (M[i][j] < 0){\n                        count += (j + 1)\n                        i += 1\n                } else {\n                        j -= 1\n                }\n        }\n        return count\n}", "19": "function getLastNegativeIndex(array, start, end, n) {\n        if (start == end) {\n                return start;\n        }\n        mid = start + (end - start) // 2;\n        if (array[mid] < 0) {\n                if (mid + 1 < n && array[mid + 1] >= 0) {\n                        return mid;\n                }\n                return getLastNegativeIndex(array, mid + 1, end, n);\n        } else {\n                return getLastNegativeIndex(array, start, mid - 1, n);\n        }\n}\nfunction countNegative(M, n, m) {\n        count = 0;\n        nextEnd = m - 1;\n        for (i = 0; i < n; i++) {\n                if (M[i][0] >= 0) {\n                        break;\n                }\n                nextEnd = getLastNegativeIndex(M[i], 0, nextEnd, 4);\n                count += nextEnd + 1;\n        }\n        return count;\n}", "20": "function findMaxValue(mat) {\n        let maxValue = 0;\n        for (let a = 0; a < N - 1; a++) {\n                for (let b = 0; b < N - 1; b++) {\n                        for (let d = a + 1; d < N; d++) {\n                                for (let e = b + 1; e < N; e++) {\n                                        if (maxValue < Number(mat[d][e] - mat[a][b])) {\n                                                maxValue = Number(mat[d][e] - mat[a][b]);\n                                        }\n                                }\n                        }\n                }\n        }\n        return maxValue;\n}", "21": "function findMaxValue(mat) {\n        maxValue = -sys.maxsize -1\n        maxArr = [[0 for x in range(N)] for y in range(N)]\n        maxArr[N - 1][N - 1] = mat[N - 1][N - 1]\n        maxv = mat[N - 1][N - 1];\n        for (j = N - 2; j >= 0; j--) {\n                if (mat[N - 1][j] > maxv) {\n                        maxv = mat[N - 1][j]\n                }\n                maxArr[N - 1][j] = maxv\n        }\n        maxv = mat[N - 1][N - 1];\n        for (i = N - 2; i >= 0; i--) {\n                if (mat[i][N - 1] > maxv) {\n                        maxv = mat[i][N - 1]\n                }\n                maxArr[i][N - 1] = maxv\n        }\n        for (i = N - 2; i >= 0; i--) {\n                for (j = N - 2; j >= 0; j--) {\n                        if (maxArr[i + 1][j + 1] - mat[i][j] > maxValue) {\n                                maxValue = (maxArr[i + 1][j + 1] - mat[i][j])\n                        }\n                        maxArr[i][j] = Math.max(mat[i][j],\n                                                Math.max(maxArr[i][j + 1], maxArr[i + 1][j]))\n                }\n        }\n        return maxValue\n}", "22": "function youngify(mat, i, j){\n        downVal = mat[i + 1][j] if (i + 1 < N) else INF\n        rightVal = mat[i][j + 1] if (j + 1 < N) else INF\n        if (downVal == INF && rightVal == INF){\n                return\n        }\n        if (downVal < rightVal){\n                mat[i][j] = downVal\n                mat[i + 1][j] = INF\n                youngify(mat, i + 1, j)\n        }\n        else{\n                mat[i][j] = rightVal\n                mat[i][j + 1] = INF\n                youngify(mat, i, j + 1)\n        }\n}\nfunction extractMin(mat){\n        ret = mat[0][0]\n        mat[0][0] = INF\n        youngify(mat, 0, 0)\n        return ret\n}\nfunction printSorted(mat){\n        console.log(\"Elements of matrix in sorted order n\")\n        i = 0\n        while i < N * N{\n                console.log(extractMin(mat), end = \" \")\n                i += 1\n\n        }\n}", "23": "function printSumSimple(mat, k) {\n        if (k > n) {\n                return;\n        }\n        for (i = 0; i < n - k + 1; i++) {\n                for (j = 0; j < n - k + 1; j++) {\n                        sum = 0;\n                        for (p = i; p < k + i; p++) {\n                                for (q = j; q < k + j; q++) {\n                                        sum += mat[p][q];\n                                }\n                        }\n                        console.log(sum, end = \" \");\n                }\n                console.log();\n        }\n}", "24": "function printSumTricky(mat, k) {\n        var n = mat.length;\n        if (k > n) {\n                return;\n        }\n        var stripSum = [];\n        for (j = 0; j < n; j++) {\n                var Sum = 0;\n                for (i = 0; i < k; i++) {\n                        Sum += mat[i][j];\n                }\n                stripSum[0][j] = Sum;\n                for (i = 1; i < n - k + 1; i++) {\n                        Sum += (mat[i + k - 1][j] - mat[i - 1][j]);\n                        stripSum[i][j] = Sum;\n                }\n        }\n        for (i = 0; i < n - k + 1; i++) {\n                var Sum = 0;\n                for (j = 0; j < k; j++) {\n                        Sum += stripSum[i][j];\n                }\n                console.log(Sum);\n                for (j = 1; j < n - k + 1; j++) {\n                        Sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n                        console.log(Sum);\n                }\n                console.log();\n        }\n}", "25": "function transpose(A, B) {\n        for (i=0; i<N; i++) {\n                for (j=0; j<M; j++) {\n                        B[i][j] = A[j][i];\n                }\n        }\n}", "26": "function transpose(A) {\n  for (i=0; i<N; i++) {\n    for (j=i+1; j<N; j++) {\n      var temp = A[i][j];\n      A[i][j] = A[j][i];\n      A[j][i] = temp;\n    }\n  }\n}", "27": "function pathCountRec(mat, m, n, k){\n        if m < 0 || n < 0{\n                return 0\n        }\n        else if m == 0 && n == 0{\n                return k == mat[m][n]\n        }\n        return (pathCountRec(mat, m-1, n, k-mat[m][n])\n                + pathCountRec(mat, m, n-1, k-mat[m][n]))\n}\nfunction pathCount(mat, k){\n        return pathCountRec(mat, R-1, C-1, k)\n}", "28": "function pathCountDPRecDP(mat, m, n, k){\n        if (m < 0 || n < 0){\n                return 0\n        }\n        else if (m == 0 && n == 0){\n                return k == mat[m][n]\n        }\n        if (dp[m][n][k] != -1){\n                return dp[m][n][k]\n        }\n        dp[m][n][k] = (pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) +\n                                pathCountDPRecDP(mat, m, n - 1, k - mat[m][n]))\n        return dp[m][n][k]\n}\nfunction pathCountDP(mat, k){\n        return pathCountDPRecDP(mat, R - 1, C - 1, k)\n}", "29": "function countMinReversals(expr) {\n        var lenn = expr.length;\n        if (lenn % 2) {\n                return -1;\n        }\n        var s = [];\n        for (var i = 0; i < lenn; i++) {\n                if (expr[i] == '' && s.length) {\n                        if (s[0] == '') {\n                                s.pop(0);\n                        }\n                        else {\n                                s.unshift(expr[i]);\n                        }\n                }\n                else {\n                        s.unshift(expr[i]);\n                }\n        }\n        var red_len = s.length;\n        var n = 0;\n        while (s.length && s[0] == '') {\n                        s.pop(0);\n                        n += 1;\n                }\n        return (red_len / 2 + n % 2);\n}", "30": "function printMinNumberForPattern(arr) {\n  let curr_max = 0;\n  let last_entry = 0;\n  let i = 0;\n  while (i < arr.length) {\n    let noOfNextD = 0;\n    if (arr[i] == \"I\") {\n      let j = i + 1;\n      while (j < arr.length && arr[j] == \"D\") {\n        noOfNextD += 1;\n        j += 1;\n      }\n      if (i == 0) {\n        curr_max = noOfNextD + 2;\n        last_entry += 1;\n        console.log(\"\", last_entry, \"\" curr_max);\n        last_entry = curr_max;\n      } else {\n        curr_max += noOfNextD + 1;\n        last_entry = curr_max;\n        console.log(\"\", last_entry);\n      }\n      for (let k = 0; k < noOfNextD; k++) {\n        last_entry -= 1;\n        console.log(\"\", last_entry);\n        i += 1;\n      }\n    } else if (arr[i] == \"D\") {\n      if (i == 0) {\n        let j = i + 1;\n        while (j < arr.length && arr[j] == \"D\") {\n          noOfNextD += 1;\n          j += 1;\n        }\n        curr_max = noOfNextD + 2;\n        console.log(\"\", curr_max, curr_max - 1);\n        last_entry = curr_max - 1;\n      } else {\n        console.log(\"\", last_entry - 1);\n        last_entry -= 1;\n      }\n    }\n    i += 1;\n  }\n  console.log();\n}", "31": "function printLeast(arr) {\n        min_avail = 1\n        pos_of_I = 0\n        v = []\n        if (arr[0] == 'I'):\n                v.push(1)\n                v.push(2)\n                min_avail = 3\n                pos_of_I = 1\n        else:\n                v.push(2)\n                v.push(1)\n                min_avail = 3\n                pos_of_I = 0\n        for (i = 1; i < arr.length; i++) {\n                if (arr[i] == 'I'):\n                        v.push(min_avail)\n                        min_avail += 1\n                        pos_of_I = i + 1\n                else:\n                        v.push(v[i])\n                        for (j = pos_of_I; j <= i + 1; j++) {\n                                v[j] += 1\n                        }\n                        min_avail += 1\n        }\n        console.log(v.join(' '))\n}", "32": "function PrintMinNumberForPattern(Strr) {\n        var res = '';\n        var stack = [];\n        for (var i = 0; i < Strr.length + 1; i++) {\n                stack.push(i + 1);\n                if (i == Strr.length || Strr[i] == 'I') {\n                        while (stack.length > 0) {\n                                res += stack.pop();\n                                res += ' ';\n                        }\n                }\n        }\n        console.log(res);\n}", "33": "function getMinNumberForPattern(seq){\n   let n = seq.length;\n   if (n >= 9){\n        return \"-1\";\n   }\n   let result = [null] * (n + 1);\n   let count = 1;\n   for (let i = 0; i < n + 1; i++){\n        if (i == n || seq[i] == 'I'){\n                for (let j = i - 1; j >= -2; j--){\n                        result[j + 1] = parseInt('0' + srt(count));\n                        count++;\n                        if (j >= 0 && seq[j] == 'I'){\n                                break;\n                        }\n                }\n        }\n   }\n   return result;\n}", "34": "function subset(ar, n) {\n        res = 0;\n        ar.sort();\n        for (i = 0; i < n; i++) {\n                count = 1;\n                for (i = 0; i < n - 1; i++) {\n                        if (ar[i] == ar[i + 1]) {\n                                count++;\n                        }\n                        else {\n                                break;\n                        }\n                }\n                res = Math.max(res, count);\n        }\n        return res;\n}", "35": "function subset(arr, n) {\n        var mp = {};\n        for (var i = 0; i < 10; i++) {\n                mp[i] = 0;\n        }\n        for (var i = 0; i < n; i++) {\n                mp[arr[i]] += 1;\n        }\n        var res = 0;\n        for (key, value in mp) {\n                res = Math.max(res, value);\n        }\n        return res;\n}", "36": "function areElementsContiguous(arr, n) {\n        arr.sort();\n        for (i = 1; i < n; i++) {\n                if (arr[i] - arr[i-1] > 1) {\n                        return 0;\n                }\n        }\n        return 1;\n}", "37": "function areElementsContiguous(arr, n) {\n        max1 = Math.max(arr);\n        min1 = Math.min(arr);\n        m = max1 - min1 + 1;\n        if (m > n) {\n                return false;\n        }\n        visited = [0] * m;\n        for (var i = 0; i < n; i++) {\n                visited[arr[i] - min1] = true;\n        }\n        for (var i = 0; i < m; i++) {\n                if (visited[i] == false) {\n                        return false;\n                }\n        }\n        return true;\n}", "38": "function areElementsContiguous(arr) {\n        let us = new Set();\n        for (i in arr) us.add(i);\n        let count = 1;\n        let curr_ele = arr[0] - 1;\n        while (curr_ele in us) {\n                count += 1;\n                curr_ele -= 1;\n        }\n        curr_ele = arr[0] + 1;\n        while (curr_ele in us) {\n                count += 1;\n                curr_ele += 1;\n        }\n        return (count == us.size);\n}", "39": "function longest(a, n, k) {\n        var freq = {};\n        var start = 0;\n        var end = 0;\n        var now = 0;\n        var l = 0;\n        for (var i = 0; i < n; i++) {\n                freq[a[i]] += 1;\n                if (freq[a[i]] == 1) {\n                        now += 1;\n                }\n                while (now > k) {\n                        freq[a[l]] -= 1;\n                        if (freq[a[l]] == 0) {\n                                now -= 1;\n                        }\n                        l += 1;\n                }\n                if (i - l + 1 >= end - start + 1) {\n                        end = i;\n                        start = l;\n                }\n        }\n        for (var i = start; i <= end; i++) {\n                console.log(a[i], end = \" \");\n        }\n}", "40": "function findSmallestRange(arr, n, k){\n        i, minval, maxval, minrange, minel, maxel, flag, minind = 0, 0, 0, 0, 0, 0, 0, 0\n        for (i = 0; i < k + 1; i++){\n                ptr[i] = 0\n        }\n        minrange = 10**9\n        while(1){ \n                minind = -1\n                minval = 10**9\n                maxval = -10**9\n                flag = 0\n                for (i = 0; i < k; i++){\n                        if(ptr[i] == n):\n                                flag = 1 \n                                break\n                        if(ptr[i] < n && arr[i][ptr[i]] < minval):\n                                minind = i \n                                minval = arr[i][ptr[i]]\n                        if(ptr[i] < n && arr[i][ptr[i]] > maxval):\n                                maxval = arr[i][ptr[i]]\n                }\n                if(flag){\n                        break\n                }\n                ptr[minind] += 1\n                if((maxval-minval) < minrange){\n                        minel = minval\n                        maxel = maxval\n                        minrange = maxel - minel\n                }\n        }\n        console.log(\"The smallest range is [\" + minel + maxel + \"]\")\n}", "41": "function findLargestd(S, n) {\n        found = false;\n        S.sort();\n        for (i=n-1; i>=0; i--) {\n                for (j=0; j<n; j++) {\n                        if (i==j) {\n                                continue\n                        }\n                        for (k=j+1; k<n; k++) {\n                                if (i==k) {\n                                        continue\n                                }\n                                for (l=k+1; l<n; l++) {\n                                        if (i==l) {\n                                                continue\n                                        }\n                                        if (S[i] == S[j] + S[k] + S[l]) {\n                                                found = true;\n                                                return S[i]                                \n                                        }\n                                }\n                        }\n                }\n        }\n        if (found == false) {\n                return -1\n        }\n}", "42": "function findFourElements(arr, n) {\n  let mp = {};\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      mp[arr[i] + arr[j]] = [i, j];\n    }\n  }\n  let d = -10 ** 9;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      let abs_diff = Math.abs(arr[i] - arr[j]);\n      if (abs_diff in mp) {\n        let p = mp[abs_diff];\n        if (\n          p[0] != i &&\n          p[0] != j &&\n          p[1] != i &&\n          p[1] != j\n        ) {\n          d = Math.max(d, Math.max(arr[i], arr[j]));\n        }\n      }\n    }\n  }\n  return d;\n}", "43": "function leftRotatebyOne(arr, n){\n        temp = arr[0]\n        for(i = 0; i < n - 1; i++){\n                arr[i] = arr[i + 1]\n        }\n        arr[n - 1] = temp\n}\nfunction leftRotate(arr, d, n){\n        for(i = 0; i < d; i++){\n                leftRotatebyOne(arr, n)\n        }\n}\nfunction printArray(arr, size){\n        for(i = 0; i < size; i++){\n                print (arr[i] + \" \")\n        }\n}", "44": "function pushZerosToEnd(arr, n) {\n        count = 0 \n        for (i = 0; i < n; i++) {\n                if (arr[i] != 0) {\n                        arr[count] = arr[i]\n                        count+=1\n                }\n        }\n        while (count < n) {\n                arr[count] = 0\n                count += 1\n        }\n}", "45": "function moveZerosToEnd(arr, n) {\n        count = 0;\n        for (i = 0; i < n; i++) {\n                if (arr[i] != 0) {\n                        arr[count], arr[i] = arr[i], arr[count]\n                        count += 1\n                }\n        }\n}\n\nfunction printArray(arr, n) {\n        for (i = 0; i < n; i++) {\n                document.write(arr[i] + \" \")\n        }\n}", "46": "function pushZerosToEnd(arr, n) {\n        count = 0\n        for (i = 0; i < n; i++) {\n                if (arr[i] != 0) {\n                        arr[count] = arr[i]\n                        count+=1\n                }\n        }\n        while (count < n) {\n                arr[count] = 0\n                count+=1\n        }\n}\nfunction modifyAndRearrangeArr(ar, n) {\n        if (n == 1) {\n                return\n        }\n        for (i = 0; i < n - 1; i++) {\n                if ((arr[i] != 0) && (arr[i] == arr[i + 1])) {\n                        arr[i] = 2 * arr[i]\n                        arr[i + 1] = 0\n                        i+=1\n                }\n        }\n        pushZerosToEnd(arr, n)\n}\nfunction printArray(arr, n) {\n        for (i = 0; i < n; i++) {\n                console.log(arr[i],end=\" \")\n        }\n}", "47": "function shiftAllZeroToLeft(arr, n) {\n        var lastSeenNonZero = 0;\n        for (index in range(0, n)) {\n                if (array[index] != 0) {\n                        array[index], array[lastSeenNonZero] = array[lastSeenNonZero], array[index];\n                        lastSeenNonZero+=1;\n                }\n        }\n}", "48": "function printArray(arr, n) {\n        for (i = 0; i < n; i++) {\n                document.write(arr[i] + \" \");\n        }\n        document.write(\"<br>\");\n}\nfunction RearrangePosNeg(arr, n) {\n        for (i = 1; i < n; i++) {\n                key = arr[i];\n                if (key > 0) {\n                        continue;\n                }\n                j = i - 1;\n                while (j >= 0 && arr[j] > 0) {\n                        arr[j + 1] = arr[j];\n                        j = j - 1;\n                }\n                arr[j + 1] = key;\n        }\n}", "49": "public static void main(String args[])\n\t{\n\t\tint arr[] = { 2, 0, 2, 2, 0, 4, 0, 4, 4 };\n\t\tint n = arr.length;\n\t\tmodifyAndRearrangeArr(arr, n);\n\t\tprintArray(arr, n);\n\t}\n\ndef pushZerosToEnd(arr, n):\n\tcount = 0\n\tfor i in range(n):\n\t\tif arr[i] != 0:\n\t\t\tarr[count] = arr[i]\n\t\t\tcount += 1\n\twhile count < n:\n\t\tarr[count] = 0\n\t\tcount += 1\n\ndef modifyAndRearrangeArr(arr, n):\n\tif n == 1:\n\t\treturn\n\tfor i in range(n - 1):\n\t\tif arr[i] != 0 and arr[i] == arr[i + 1]:\n\t\t\tarr[i] = 2 * arr[i]\n\t\t\tarr[i + 1] = 0\n\t\t\ti += 1\n\tpushZerosToEnd(arr, n)\n\ndef printArray(arr, n):\n\tfor i in range(n):\n\t\tprint(arr[i], end=' ')\n\tprint()\n\narr = [2, 0, 2, 2, 0, 4, 0, 4, 4]\nn = len(arr)\nmodifyAndRearrangeArr(arr, n)\nprintArray(arr, n)"}}, "C - python": {"ID": {"0": 821, "1": 1344, "2": 1428, "3": 1535, "4": 1537, "5": 1694, "6": 1695, "7": 1696, "8": 1795, "9": 1853, "10": 1871, "11": 1998, "12": 2025, "13": 2026, "14": 2079, "15": 2080, "16": 2114, "17": 2120, "18": 2121, "19": 2127, "20": 2129, "21": 2130, "22": 2132, "23": 2308, "24": 2310, "25": 4847, "26": 4855, "27": 7051, "28": 7052, "29": 7068, "30": 7071, "31": 8786, "32": 8795, "33": 9290, "34": 9291, "35": 9359, "36": 9362, "37": 9457, "38": 12639, "39": 12646, "40": 12715, "41": 12716, "42": 12794, "43": 12905, "44": 13140, "45": 13430, "46": 13431, "47": 13432, "48": 13575, "49": 14020}, "c": {"0": "void Kroneckerproduct(int A[][cola], int B[][colb])\n{\n        int C[rowa * rowb][cola * colb];\n        for (int i = 0; i < rowa; i++) {\n                for (int k = 0; k < rowb; k++) {\n                        for (int j = 0; j < cola; j++) {\n                                for (int l = 0; l < colb; l++) {\n                                        C[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n                                        printf(\"%d\\t\", C[i + l + 1][j + k + 1]);\n                                }\n                        }\n                        printf(\"\\n\");\n                }\n        }\n}", "1": "bool areElementsContiguous(int arr[], int n)\n{\n        sort(arr, arr+n);\n        for (int i = 1; i < n; i++)\n                if (arr[i] - arr[i-1] > 1)\n                        return false;\n        return true;\n}", "2": "void leftRotatebyOne(int arr[], int n)\n{\n        int temp = arr[0], i;\n        for (i = 0; i < n - 1; i++)\n                arr[i] = arr[i + 1];\n        arr[n-1] = temp;\n}\nvoid leftRotate(int arr[], int d, int n)\n{\n        int i;\n        for (i = 0; i < d; i++)\n                leftRotatebyOne(arr, n);\n}\nvoid printArray(int arr[], int n)\n{\n        int i;\n        for (i = 0; i < n; i++)\n                printf(\"%d \", arr[i]);\n}", "3": "int findFirstMissing(int array[], int start, int end)\n{\n        if (start > end)\n                return end + 1;\n        if (start != array[start])\n                return start;\n        int mid = (start + end) / 2;\n        if (array[mid] == mid)\n                return findFirstMissing(array, mid+1, end);\n        return findFirstMissing(array, start, mid);\n}", "4": "int FindMaxSum(int arr[], int n)\n{\nint incl = arr[0];\nint excl = 0;\nint excl_new;\nint i;\nfor (i = 1; i < n; i++)\n{\n        excl_new = (incl > excl)? incl: excl;\n        incl = excl + arr[i];\n        excl = excl_new;\n}\nreturn ((incl > excl)? incl : excl);\n}", "5": "bool isMajority(int arr[], int n, int x)\n{\n        int i;\n        int last_index = n%2? (n/2+1): (n/2);\n        for (i = 0; i < last_index; i++)\n        {\n                if (arr[i] == x && arr[i+n/2] == x)\n                        return 1;\n        }\n        return 0;\n}", "6": "int _binarySearch(int arr[], int low, int high, int x)\n{\n        if (high >= low)\n        {\n                int mid = (low + high)/2; \n                if ( (mid == 0 x > arr[mid-1]) && (arr[mid] == x) )\n                        return mid;\n                else if (x > arr[mid])\n                        return _binarySearch(arr, (mid + 1), high, x);\n                else\n                        return _binarySearch(arr, low, (mid -1), x);\n        }\n        return -1;\n}\nbool isMajority(int arr[], int n, int x)\n{\n        int i = _binarySearch(arr, 0, n-1, x);\n        if (i == -1)\n                return false;\n        if (((i + n/2) <= (n -1)) && arr[i + n/2] == x)\n                return true;\n        else\n                return false;\n}", "7": "bool isMajorityElement(int arr[], int n, int key)\n{\n        if (arr[n / 2] == key)\n                return true;\n        else\n                return false;\n}", "8": "void swap(int *xp, int *yp)\n{\n        int temp = *xp;\n        *xp = *yp;\n        *yp = temp;\n}\nvoid selectionSort(int arr[], int n)\n{\n        int i, j, min_idx;\n        for (i = 0; i < n-1; i++)\n        {\n                min_idx = i;\n                for (j = i+1; j < n; j++)\n                if (arr[j] < arr[min_idx])\n                        min_idx = j;\n                swap(&arr[min_idx], &arr[i]);\n        }\n}\nvoid printArray(int arr[], int size)\n{\n        int i;\n        for (i=0; i < size; i++)\n                printf(\"%d \", arr[i]);\n        printf(\"\\n\");\n}", "9": "int MatrixChainOrder(int p[], int n)\n{\n        int m[n][n];\n        int i, j, k, L, q;\n        for (i = 1; i < n; i++)\n                m[i][i] = 0;\n        for (L = 2; L < n; L++) {\n                for (i = 1; i < n - L + 1; i++)\n                {\n                        j = i + L - 1;\n                        m[i][j] = INT_MAX;\n                        for (k = i; k <= j - 1; k++)\n                        {\n                                q = m[i][k] + m[k + 1][j]\n                                        + p[i - 1] * p[k] * p[j];\n                                if (q < m[i][j])\n                                        m[i][j] = q;\n                        }\n                }\n        }\n        return m[1][n - 1];\n}\n", "10": "int max(int a, int b)\n{\n return (a > b) ? a : b;\n}\nint un_kp(int price[], int length[], int Max_len, int n)\n{\n        if (n == 0 Max_len == 0)\n        {\n                return 0;\n        }\n        if (length[n - 1] <= Max_len)\n        {\n                t[n][Max_len]\n                        = max(price[n - 1]\n                                        + un_kp(price, length, Max_len - length[n - 1], n),\n                                un_kp(price, length, Max_len, n - 1));\n        }\n        else\n        {\n                t[n][Max_len]\n                        = un_kp(price, length, Max_len, n - 1);\n        }\n        return t[n][Max_len];\n}", "11": "int multiply(int x, int y)\n{\n if(y == 0)\n        return 0;\n if(y > 0 )\n        return (x + multiply(x, y-1));\n if(y < 0 )\n        return -multiply(x, -y);\n}", "12": "void printPascal(int n)\n{\nint arr[n][n];\nfor (int line = 0; line < n; line++)\n{\n        for (int i = 0; i <= line; i++)\n        {\n        if (line == i i == 0)\n                arr[line][i] = 1;\n        else\n                arr[line][i] = arr[line-1][i-1] + arr[line-1][i];\n        printf(\"%d \", arr[line][i]);\n        }\n        printf(\"\\n\");\n}\n}", "13": "void printPascal(int n)\n{\nfor (int line = 1; line <= n; line++)\n{\nint C = 1; \n        for (int i = 1; i <= line; i++)\n        {\nprintf(\"%d \", C); \n        C = C * (line - i) / i;\n        }\n        printf(\"\\n\");\n}\n}", "14": "int Add(int x, int y)\n{\n        while (y != 0)\n        {\n                int carry = x & y; \n                x = x ^ y;\n                y = carry << 1;\n        }\n        return x;\n}", "15": "int Add(int x, int y)\n{\n        if (y == 0)\n                return x;\n        else\n                return Add( x ^ y, (x & y) << 1);\n}", "16": "unsigned int countSetBits(unsigned int n)\n{\n        unsigned int count = 0;\n        while (n) {\n                count += n & 1;\n                n >>= 1;\n        }\n        return count;\n}", "17": "unsigned int countSetBitsRec(unsigned int num)\n{\n        int nibble = 0;\n        if (0 == num)\n                return num_to_bits[0];\n        nibble = num & 0xf;\n        return num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}", "18": "int countSetBits(int N)\n{\n        int count = 0;\n        for (int i = 0; i < sizeof(int) * 8; i++) {\n                if (N & (1 << i))\n                        count++;\n        }\n        return count;\n}", "19": "bool getParity(unsigned int n)\n{\n        bool parity = 0;\n        while (n)\n        {\n                parity = !parity;\n                n        = n & (n - 1);\n        }        \n        return parity;\n}", "20": "bool isPowerOfTwo(int n)\n{\n if(n==0)\n return false;\n return (ceil(log2(n)) == floor(log2(n)));\n}", "21": "bool isPowerOfTwo(int n)\n{\n if (n == 0)\n        return 0;\n while (n != 1)\n {\n        if (n%2 != 0)\n                return 0;\n        n = n/2;\n }\n return 1;\n}", "22": "bool isPowerOfTwo (int x)\n{\n return x && (!(x&(x-1)));\n}", "23": "void printTwoOdd(int arr[], int size)\n{\n int xor2 = arr[0]; \n int set_bit_no; \n int i;\n int n = size - 2;\n int x = 0, y = 0;\n for(i = 1; i < size; i++)\n        xor2 = xor2 ^ arr[i];\n set_bit_no = xor2 & ~(xor2-1);\n for(i = 0; i < size; i++)\n {\n        if(arr[i] & set_bit_no)\n        x = x ^ arr[i];\n        else\n        y = y ^ arr[i];\n }\n printf(\"\\n The two ODD elements are %d & %d \", x, y);\n}", "24": "bool findPair(int arr[], int size, int n)\n{\n        int i = 0; \n        int j = 1;\n        while (i<size && j<size)\n        {\n                if (i != j && arr[j]-arr[i] == n)\n                {\n                        printf(\"Pair Found: (%d, %d)\", arr[i], arr[j]);\n                        return true;\n                }\n                else if (arr[j]-arr[i] < n)\n                        j++;\n                else\n                        i++;\n        }\n        printf(\"No such pair\");\n        return false;\n}", "25": "int binarySearch(int a[], int item, int low, int high)\n{\n        while (low <= high) {\n                int mid = low + (high - low) / 2;\n                if (item == a[mid])\n                        return mid + 1;\n                else if (item > a[mid])\n                        low = mid + 1;\n                else\n                        high = mid - 1;\n        }\n        return low;\n}\nvoid insertionSort(int a[], int n)\n{\n        int i, loc, j, k, selected;\n        for (i = 1; i < n; ++i) {\n                j = i - 1;\n                selected = a[i];\n                loc = binarySearch(a, selected, 0, j);\n                while (j >= loc) {\n                        a[j + 1] = a[j];\n                        j--;\n                }\n                a[j + 1] = selected;\n        }\n}", "26": "void insertionSort(int arr[], int n)\n{\n        int i, key, j;\n        for (i = 1; i < n; i++) {\n                key = arr[i];\n                j = i - 1;\n                while (j >= 0 && arr[j] > key) {\n                        arr[j + 1] = arr[j];\n                        j = j - 1;\n                }\n                arr[j + 1] = key;\n        }\n}\nvoid printArray(int arr[], int n)\n{\n        int i;\n        for (i = 0; i < n; i++)\n                printf(\"%d \", arr[i]);\n        printf(\"\\n\");\n}", "27": "int max(int a, int b) { return (a > b)? a : b;}\nint cutRod(int price[], int n)\n{\n int val[n+1];\n val[0] = 0;\n int i, j;\n for (i = 1; i<=n; i++)\n {\n        int max_val = INT_MIN;\n        for (j = 0; j < i; j++)\n                max_val = max(max_val, price[j] + val[i-j-1]);\n        val[i] = max_val;\n }\n return val[n];\n}", "28": "int max(int a, int b)\n{\n return (a > b) ? a : b;\n}\nint un_kp(int price[], int length[], int Max_len, int n)\n{\n        if (n == 0 Max_len == 0)\n        {\n                return 0;\n        }\n        if (length[n - 1] <= Max_len)\n        {\n                t[n][Max_len]\n                        = max(price[n - 1]\n                                        + un_kp(price, length, Max_len - length[n - 1], n),\n                                un_kp(price, length, Max_len, n - 1));\n        }\n        else\n        {\n                t[n][Max_len]\n                        = un_kp(price, length, Max_len, n - 1);\n        }\n        return t[n][Max_len];\n}", "29": "int MatrixChainOrder(int p[], int i, int j)\n{\n        if (i == j)\n                return 0;\n        int k;\n        int min = INT_MAX;\n        int count;\n        for (k = i; k < j; k++)\n        {\n                count = MatrixChainOrder(p, i, k)\n                                + MatrixChainOrder(p, k + 1, j)\n                                + p[i - 1] * p[k] * p[j];\n                if (count < min)\n                        min = count;\n        }\n        return min;\n}", "30": "int count( int S[], int m, int n )\n{\n        if (n == 0)\n                return 1;\n        if (n < 0)\n                return 0;\n        if (m <=0 && n >= 1)\n                return 0;\n        return count( S, m - 1, n ) + count( S, m, n-S[m-1] );\n}", "31": "void reverseWords(char* s)\n{\n        char* word_begin = NULL;\n        char* temp = s;\n        while (*temp)\n        {\n                if ((word_begin == NULL) &&\n                                (*temp != ' '))\n                {\n                        word_begin = temp;\n                }\n                if (word_begin && ((*(temp + 1) == ' ') ||\n                        (*(temp + 1) == '\\0')))\n                {\n                        reverse(word_begin, temp);\n                        word_begin = NULL;\n                }\n                temp++;\n        } \n        reverse(s, temp - 1);\n}", "32": "void reverse(char *str)\n{\n if (*str)\n {\n        reverse(str+1);\n        printf(\"%c\", *str);\n }\n}", "33": "float Perimeter(float s, int n)\n{\n        float perimeter = 1;\n        perimeter = n * s;\n        return perimeter;\n}", "34": "float area(float r)\n{\n        return (0.5)*(3.14)*(r * r);\n}\nfloat perimeter(float r)\n{\n        return (3.14)*(r);\n}", "35": "void distance(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2)\n{\n        float x1,y1,z1,d;\n        if (a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2)\n        {\n                x1 = y1 = 0;\n                z1 =-d1 / c1;\n                d = fabs(( c2 * z1 + d2)) / (sqrt(a2 * a2 + b2 * b2 + c2 * c2));\n                printf(\"Perpendicular distance is %f\\n\", d);\n        }\n        else\n                printf(\"Planes are not parallel\");\n        return;\n}", "36": "void shortest_distance(float x1, float y1, float z1, float a, float b, float c, float d)\n{\n        d = fabs((a * x1 + b * y1 + c * z1 + d));\n        float e = sqrt(a * a + b * b + c * c);\n        printf(\"Perpendicular distance is %f\", d/e);\n                return;\n}", "37": "double Area(int b1, int b2, int h)\n{\n        return ((b1 + b2) / 2) * h;\n}", "38": "int averageEven(int n)\n{\n        if (n % 2 != 0) {\n                printf(\"Invalid Input\");\n                return -1;\n        }\n        return (n + 2) / 2;\n}", "39": "int averageOdd(int n)\n{\n        if (n % 2 == 0) {\n                printf(\"Invalid Input\");\n                return -1;\n        }\n        return (n + 1) / 2;\n}", "40": "int TrinomialValue(int dp[MAX][MAX], int n, int k)\n{\n        if (k < 0)\n                k = -k;\n        if (dp[n][k] != 0)\n                return dp[n][k];\n        if (n == 0 && k == 0)\n                return 1;\n        if(k < -n k > n)\n                return 0;\n        return (dp[n][k] = TrinomialValue(dp, n - 1, k - 1)\n                + TrinomialValue(dp, n - 1, k)\n                + TrinomialValue(dp, n - 1, k + 1));\n}\nvoid printTrinomial(int n)\n{\n        int dp[MAX][MAX] = { 0 };\n        for (int i = 0; i < n; i++)\n        {\n                for (int j = -i; j <= 0; j++)\n                        cout << TrinomialValue(dp, i, j) << \" \";\n                for (int j = 1; j <= i; j++)\n                        cout << TrinomialValue(dp, i, j) << \" \";\n                cout << endl;\n        }\n}", "41": "int Series(int n)\n{\n        int i;\n        int sums = 0;\n        for (i = 1; i <= n; i++)\n                sums += (i * i);\n        return sums;\n}", "42": "double Convert(double radian){\n        double pi = 3.14159;\n        return(radian * (180/pi));\n}", "43": "int isPowerOf2(char* str)\n{\n        int len_str = strlen(str);\n        int num = 0;\n        if (len_str == 1 && str[len_str - 1] == '1')\n                return 0;\n        while (len_str != 1 str[len_str - 1] != '1') {\n                if ((str[len_str - 1] - '0') % 2 == 1)\n                        return 0;\n                for (int i = 0, j = 0; i < len_str; i++) {\n                        num = num * 10 + str[i] - '0';\n                        if (num < 2) {\n                                if (i != 0)\n                                        str[j++] = '0';                        \n                                continue;\n                        }\n                        str[j++] = (int)(num / 2) + '0';\n                        num = (num) - (num / 2) * 2;\n                }\n                str[j] = '\\0';\n                len_str = j;\n        }\n        return 1;\n}", "44": "int fact(int n) {\n        if (n == 0)\n                return 1;\n        return n * fact(n - 1);\n}\nint div(int x) {\n        int ans = 0;\n        for (int i = 1; i<= x; i++)\n                if (x % i == 0)\n                        ans += i;\n        return ans;\n}\nint sumFactDiv(int n) {\n        return div(fact(n));\n}", "45": "void printDivisors(int n)\n{ int i;\n        for ( i = 1; i*i < n; i++) {\n                if (n % i == 0)\n                        printf(\"%d \", i);\n        }\n if(i-(n/i)==1)\n        {\n        i--;\n        }\n        for (; i >= 1; i--) {\n                if (n % i == 0)\n                        printf(\"%d \", n / i);\n        }\n}", "46": "void printDivisors(int n)\n{\n        for (int i=1;i<=n;i++)\n                if (n%i==0)\n                        printf(\"%d \",i);\n}", "47": "void printDivisors(int n)\n{\n        for (int i=1; i<=sqrt(n); i++)\n        {\n                if (n%i == 0)\n                {\n                        if (n/i == i)\n                                printf(\"%d \", i);\n                                printf(\"%d %d \", i, n/i);\n                }\n        }\n}", "48": "int reversDigits(int num)\n{\n        static int rev_num = 0;\n        static int base_pos = 1;\n        if (num > 0) {\n                reversDigits(num / 10);\n                rev_num += (num % 10) * base_pos;\n                base_pos *= 10;\n        }\n        return rev_num;\n}", "49": "int multiplyBySevenByEight(unsigned int n)\n{\n        return (n - (n >> 3));\n}"}, "Python": {"0": "def Kroneckerproduct(A, B):\n        rowa = len(A)\n        cola = len(A[0])\n        rowb = len(B)\n        colb = len(B[0])\n        C = [[0 for i in range(rowa * rowb)] for j in range(cola * colb)]\n        for i in range(rowa):\n                for k in range(rowb):\n                        for j in range(cola):\n                                for l in range(colb):\n                                        C[i + l][j + k] = A[i][j] * B[k][l]\n                                        print(C[i + l][j + k], end = '\\t')\n                        print()", "1": "def areElementsContiguous(arr, n):\n        arr.sort()\n        for i in range(1, n):\n                if arr[i] - arr[i-1] > 1:\n                        return False\n        return True", "2": "def leftRotatebyOne(arr, n): \n    temp = arr[0] \n    for i in range(n - 1): \n        arr[i] = arr[i + 1] \n    arr[n-1] = temp \n          \ndef leftRotate(arr, d, n): \n    for i in range(d): \n        leftRotatebyOne(arr, n) \n          \ndef printArray(arr, n): \n    for i in range(n): \n        print(arr[i], end=' ') \n          \narr = [1, 2, 3, 4, 5, 6, 7] \nleftRotate(arr, 2, 7) \nprintArray(arr, 7)", "3": "def findFirstMissing(array, start, end):\n        if start > end:\n                return end + 1\n        if start != array[start]:\n                return start\n        mid = (start + end) // 2\n        if array[mid] == mid:\n                return findFirstMissing(array, mid+1, end)\n        return findFirstMissing(array, start, mid)", "4": "def FindMaxSum(arr, n):\n    incl = arr[0]\n    excl = 0\n    excl_new\n    for i in range(1,n):\n        excl_new = (incl > excl)? incl: excl\n        incl = excl + arr[i]\n        excl = excl_new\n    return ((incl > excl)? incl : excl)", "5": "def isMajority(arr, n, x):\n        last_index = n%2? (n/2+1): (n/2)\n        for i in range(0, last_index):\n                if arr[i] == x and arr[i+n/2] == x:\n                        return 1\n        return 0", "6": "def _binarySearch(arr, low, high, x):\n        if (high >= low):\n                mid = (low + high)/2; \n                if ( (mid == 0) and (x > arr[mid-1]) and (arr[mid] == x) ):\n                        return mid;\n                elif (x > arr[mid]):\n                        return _binarySearch(arr, (mid + 1), high, x);\n                else:\n                        return _binarySearch(arr, low, (mid -1), x);\n        return -1;\n\ndef isMajority(arr, n, x):\n        i = _binarySearch(arr, 0, n-1, x);\n        if (i == -1):\n                return false;\n        if ( ((i + n/2) <= (n -1)) and arr[i + n/2] == x ):\n                return true;\n        else:\n                return false;", "7": "def isMajorityElement(arr, n, key):\n        if (arr[n / 2] == key):\n                return true;\n        else:\n                return false;", "8": "def swap(xp, yp):\n        temp = xp\n        xp = yp\n        yp = temp\n\ndef selectionSort(arr):\n        n = len(arr)\n        for i in range(0, n - 1):\n                min_idx = i\n                for j in range(i + 1, n):\n                        if arr[j] < arr[min_idx]:\n                                min_idx = j\n                swap(arr[min_idx], arr[i])\n\ndef printArray(arr):\n        n = len(arr)\n        for i in range(0, n):\n                print(arr[i])\n\narr = [64, 25, 12, 22, 11]\nselectionSort(arr)\nprint(\"Sorted array:\")\nprintArray(arr)", "9": "def MatrixChainOrder(p, n):\n        m = [[0] * n] * n;\n        for i in range(1, n):\n                m[i][i] = 0;\n        for L in range (2, n):\n                for i in range(1, n - L + 1):\n                        j = i + L - 1;\n                        m[i][j] = INT_MAX;\n                        for k in range(i, j - 1):\n                                q = m[i][k] + m[k + 1][j]\n                                        + p[i - 1] * p[k] * p[j];\n                                if (q < m[i][j]):\n                                        m[i][j] = q;\n        return m[1][n - 1];", "10": "def max(a, b):\n return (a > b) ? a : b;\ndef un_kp(price, length, Max_len, n):\n        if (n == 0 Max_len == 0):\n                return 0;\n        if (length[n - 1] <= Max_len):\n                t[n][Max_len]\n                        = max(price[n - 1]\n                                        + un_kp(price, length, Max_len - length[n - 1], n),\n                                un_kp(price, length, Max_len, n - 1));\n        else:\n                t[n][Max_len]\n                        = un_kp(price, length, Max_len, n - 1);\n        return t[n][Max_len];", "11": "def multiply(x, y):\n    if(y == 0):\n        return 0\n    if(y > 0 ):\n        return (x + multiply(x, y-1))\n    if(y < 0 ):\n        return -multiply(x, -y)", "12": "def printPascal(n): \n    arr = [[0 for x in range(n)] for y in range(n)] \n    for line in range (0, n): \n        for i in range (0, line + 1): \n            if (line == i or i == 0): \n                arr[line][i] = 1\n            else: \n                arr[line][i] = arr[line - 1][i - 1] + arr[line - 1][i] \n            print(arr[line][i], end = \" \") \n        print(\"\")", "13": "def printPascal(n):\n    for line in range(1, n+1):\n        C = 1\n        for i in range(1, line+1):\n            print(C, end=' ')\n            C = C * (line - i) // i\n        print()\n\n\nprintPascal(5)", "14": "def Add(x, y):\n    while y != 0:\n        carry = x & y\n        x = x ^ y\n        y = carry << 1\n    return x", "15": "def add(x, y):\n\tif y == 0:\n\t\treturn x\n\telse:\n\t\treturn add(x ^ y, (x & y) << 1)", "16": "def countSetBits(n):\n        count = 0\n        while (n):\n                count += n & 1\n                n >>= 1\n        return count", "17": "def countSetBitsRec(num):\n        if num == 0:\n                return num_to_bits[0]\n        nibble = num & 0xF\n        return num_to_bits[nibble] + countSetBitsRec(num >> 4)", "18": "def countSetBits(N):\n        count = 0\n        for i in range(0, sizeof(int) * 8):\n                if N & (1 << i):\n                        count += 1\n        return count", "19": "def getParity(n):\n        parity = 0\n        while n:\n                parity = not parity\n                n = n and (n - 1)\n        return parity", "20": "def isPowerOfTwo(n):\n if(n==0):\n      return False;\n return (ceil(log2(n)) == floor(log2(n)));", "21": "def isPowerOfTwo(n):\n if (n == 0):\n        return 0;\n while (n != 1):\n        if (n%2 != 0):\n                return 0;\n        n = n/2;\n return 1;", "22": "def isPowerOfTwo(x):\n     return x and (!(x&(x-1)))", "23": "def printTwoOdd(arr, size):\n    xor2 = arr[0]\n    set_bit_no\n    i\n    n = size - 2\n    x = 0\n    y = 0\n    for i in range(1, size):\n        xor2 = xor2 ^ arr[i]\n    set_bit_no = xor2 & ~(xor2-1)\n    for i in range(0, size):\n        if(arr[i] & set_bit_no)\n            x = x ^ arr[i]\n        else\n            y = y ^ arr[i]\n    print(\"\\n The two ODD elements are %d & %d \", x, y)", "24": "def findPair(arr, size, n):\n        i = 0\n        j = 1\n        while i<size and j<size:\n                if i != j and arr[j]-arr[i] == n:\n                        print(\"Pair Found: (%d, %d)\" % (arr[i], arr[j]))\n                        return True\n                elif arr[j]-arr[i] < n:\n                        j = j + 1\n                else:\n                        i = i + 1\n        print(\"No such pair\")\n        return False", "25": "def binarySearch(a, item, low, high):\n        while (low <= high):\n                mid = low + (high - low) / 2;\n                if (item == a[mid]):\n                        return mid + 1;\n                elif (item > a[mid]):\n                        low = mid + 1;\n                else:\n                        high = mid - 1;\n        return low;\ndef insertionSort(a, n):\n        for i in range (1, n):\n                j = i - 1;\n                selected = a[i];\n                loc = binarySearch(a, selected, 0, j);\n                while (j >= loc):\n                        a[j + 1] = a[j];\n                        j = j - 1;\n                a[j + 1] = selected;\n        return a;", "26": "def insertionSort(arr,n):\n        for i in range(1,n):\n                key = arr[i]\n                j = i - 1\n                while j >= 0 and arr[j] > key:\n                        arr[j + 1] = arr[j]\n                        j = j - 1\n                arr[j + 1] = key\ndef printArray(arr,n):\n        for i in range(0,n):\n                print arr[i],\n        print \"\\n\"\narr = [12, 11, 13, 5, 6]\ninsertionSort(arr,5)\nprint \"Sorted array is: \\n\"\nprintArray(arr,5)", "27": "def max(a, b):\n    if (a > b):\n        return a\n    else:\n        return b\n\ndef cutRod(price, n):\n    val = [0]*(n+1)\n    val[0] = 0\n    for i in range(1, n+1):\n        max_val = -9999999\n        for j in range(i):\n            max_val = max(max_val, price[j] + val[i-j-1])\n        val[i] = max_val\n    return val[n]", "28": "def max(a, b):\n return (a > b) ? a : b;\n\ndef un_kp(price, length, Max_len, n):\n        if (n == 0 Max_len == 0):\n                return 0;\n        if (length[n - 1] <= Max_len):\n                t[n][Max_len]\n                        = max(price[n - 1]\n                                        + un_kp(price, length, Max_len - length[n - 1], n),\n                                un_kp(price, length, Max_len, n - 1));\n        else:\n                t[n][Max_len]\n                        = un_kp(price, length, Max_len, n - 1);\n        return t[n][Max_len];", "29": "def matrix_chain_order(p, i, j):\n        if (i == j):\n                return 0\n        k = 0\n        min = INT_MAX\n        count = 0\n        while (k < j):\n                count = matrix_chain_order(p, i, k) + matrix_chain_order(p, k + 1, j) + p[i - 1] * p[k] * p[j]\n                if (count < min):\n                        min = count\n                k += 1\n        return min", "30": "def count(s, m, n):\n    if (n == 0):\n        return 1\n    if (n < 0):\n        return 0\n    if (m <= 0 and n >= 1):\n        return 0\n    return count( S, m - 1, n ) + count( S, m, n - S[m - 1] )", "31": "def reverseWords(s):\n        word_begin = None\n        temp = s\n        while *temp:\n                if (word_begin == None) and (*temp != ' '):\n                        word_begin = temp\n                if word_begin and ((*(temp + 1) == ' ') or \n                        (*(temp + 1) == '\\0')):\n                        reverse(word_begin, temp)\n                        word_begin = None\n                temp++\n        reverse(s, temp - 1)", "32": "def reverse(str):\n    if str:\n        reverse(str + 1)\n        print(str[0])", "33": "def perimeter(s, n):\n        perimeter = 1\n        perimeter = n * s\n        return perimeter", "34": "def area(r):\n    return 0.5 * 3.14 * (r * r)\n\ndef perimeter(r):\n    return 3.14 * (r)", "35": "def distance(a1, b1, c1, d1, a2, b2, c2, d2):\n        x1,y1,z1,d = (0,0,0,0)\n        if a1/a2 == b1/b2 and b1/b2 == c1/c2:\n                x1 = y1 = 0\n                z1 = -d1/c1\n                d = abs((c2*z1+d2))/(sqrt(a2*a2+b2*b2+c2*c2))\n                print(\"Perpendicular distance is\", d)\n        else:\n                print(\"Planes are not parallel\")\n        return", "36": "def shortest_distance(x1, y1, z1, a, b, c, d):\n    d = abs((a * x1 + b * y1 + c * z1 + d))\n    e = math.sqrt(a * a + b * b + c * c)\n    print(\"Perpendicular distance is {}\".format(d/e))\n    return", "37": "def Area(b1, b2, h):\n        return ((b1 + b2) / 2) * h", "38": "def averageEven(n):\n        if (n % 2 != 0):\n                print(\"Invalid Input\")\n                return -1\n        return (n + 2) / 2", "39": "def averageOdd(n):\n        if n % 2 == 0:\n                print(\"Invalid Input\")\n                return -1\n        return (n + 1) / 2", "40": "def TrinomialValue(dp, n, k):\n        if k < 0:\n                k = -k\n        if dp[n][k] != 0:\n                return dp[n][k]\n        if n == 0 and k == 0:\n                return 1\n        if(k < -n k > n):\n                return 0\n        return (dp[n][k] = TrinomialValue(dp, n - 1, k - 1)\n                + TrinomialValue(dp, n - 1, k)\n                + TrinomialValue(dp, n - 1, k + 1))\ndef printTrinomial(n):\n        dp = [[0] * MAX] * MAX\n        for i in range(0, n):\n                for j in range(-i, 0):\n                        print(TrinomialValue(dp, i, j), end = \" \")\n                for j in range(1, i + 1):\n                        print(TrinomialValue(dp, i, j), end = \" \")\n                print()", "41": "def Series(n):\n        sums = 0\n        for i in range(1, n+1):\n                sums += (i * i)\n        return sums", "42": "def Convert(radian):\n        pi = 3.14159\n        return(radian * (180/pi))", "43": "def isPowerOf2(str):\n        len_str = len(str)\n        num = 0\n        if (len_str == 1 and str[len_str - 1] == '1'):\n                return 0\n        while (len_str != 1 or str[len_str - 1] != '1'):\n                if ((str[len_str - 1] - '0') % 2 == 1):\n                        return 0\n                for i in range(0, len_str):\n                        num = num * 10 + str[i] - '0'\n                        if (num < 2):\n                                if (i != 0):\n                                        str[j++] = '0'                        \n                                continue\n                        str[j++] = (int)(num / 2) + '0'\n                        num = (num) - (num / 2) * 2\n                str[j] = '\\0'\n                len_str = j\n        return 1", "44": "def fact(n):\n        if (n == 0):\n                return 1;\n        return n * fact(n - 1);\ndef div(x):\n        ans = 0;\n        for i in range(1, x + 1):\n                if (x % i == 0):\n                        ans += i;\n        return ans;\ndef sumFactDiv(n):\n        return div(fact(n));", "45": "import math\n\ndef printDivisors(n):\n        for i in range(1, int(math.sqrt(n))):\n                if (n % i == 0):\n                        print(i, end=\" \")\n\n        i = int(math.sqrt(n))\n        if(i-(n/i)==1):\n                i -= 1\n\n        for j in range(i, 0, -1):\n                if (n % j == 0):\n                        print(n / j, end=\" \")", "46": "def printDivisors(n):\n        for i in range(1, n+1):\n                if (n % i == 0):\n                        print(i, end=\" \")", "47": "def printDivisors(n): \n   \n    for i in range(1, int(math.sqrt(n)) + 1): \n       \n        if n % i==0: \n            \n            if n / i == i: \n                print(i ,end=\" \") \n            else: \n                print(i ,end=\" \") \n                print(int(n/i) ,end=\" \")", "48": "def reversDigits(num):\n        rev_num = 0\n        base_pos = 1\n        if (num > 0):\n                reversDigits(num / 10)\n                rev_num += (num % 10) * base_pos\n                base_pos *= 10\n        return rev_num", "49": "def multiplyBySevenByEight(n):\n        return (n - (n >> 3))"}}, "Python - C": {"ID": {"0": 451, "1": 455, "2": 496, "3": 617, "4": 647, "5": 694, "6": 803, "7": 815, "8": 818, "9": 821, "10": 832, "11": 833, "12": 846, "13": 861, "14": 862, "15": 883, "16": 895, "17": 918, "18": 919, "19": 920, "20": 926, "21": 927, "22": 953, "23": 955, "24": 956, "25": 958, "26": 959, "27": 965, "28": 966, "29": 1064, "30": 1072, "31": 1073, "32": 1074, "33": 1075, "34": 1252, "35": 1253, "36": 1344, "37": 1345, "38": 1346, "39": 1366, "40": 1390, "41": 1405, "42": 1406, "43": 1428, "44": 1468, "45": 1469, "46": 1473, "47": 1474, "48": 1478}, "Python": {"0": "def minCost(cost):\n        dist=[0 for i in range(N)]\n        for i in range(N):\n                dist[i] = INF\n        dist[0] = 0\n        for i in range(N):\n                for j in range(i+1,N):\n                        if (dist[j] > dist[i] + cost[i][j]):\n                                dist[j] = dist[i] + cost[i][j]\n        return dist[N-1]", "1": "def numOfways(n,k):\n        p = 1\n        if (k % 2):\n                p = -1\n        return (pow(n - 1, k) +\n                                p * (n - 1)) / n", "2": "def fib(n):\n        if n <= 1:\n                return n\n        return fib(n - 1) + fib(n - 2)\ndef findVertices(n):\n        return fib(n + 2)", "3": "def reverse( head_ref):\n        temp = None\n        current = head_ref\n        while (current != None):\n                temp = current.prev\n                current.prev = current.next\n                current.next = temp\n                current = current.prev\n        if (temp != None):\n                head_ref = temp.prev\n                return head_ref\ndef merge( first, second):\n        if (first == None):\n                return second\n        if (second == None):\n                return first\n        if (first.data < second.data):\n                first.next = merge(first.next, second)\n                first.next.prev = first\n                first.prev = None\n                return first\n        else:\n                second.next = merge(first, second.next)\n                second.next.prev = second\n                second.prev = None\n                return second\ndef sort( head):\n        if (head == None or head.next == None):\n                return head\n        current = head.next\n        while (current != None) :\n                if (current.data < current.prev.data):\n                        break\n                current = current.next\n        if (current == None):\n                return head\n        current.prev.next = None\n        current.prev = None\n        current = reverse(current)\n        return merge(head, current)\ndef push( head_ref, new_data):\n        new_node =Node()\n        new_node.data = new_data\n        new_node.prev = None\n        new_node.next = (head_ref)\n        if ((head_ref) != None):\n                (head_ref).prev = new_node\n        (head_ref) = new_node\n        return head_ref\ndef printList( head):\n        if (head == None):\n                print(\"Doubly Linked list empty\")\n        while (head != None):\n                print(head.data, end= \" \")\n                head = head.next\ndef __init__(self, next = None, prev = None, data = None):\n                self.next = next\n                self.prev = prev\n                self.data = data", "4": "def printlist(head):\n        if (not head):\n                print(\"Empty List\")\n                return\n        while (head != None):\n                print(head.data, end = \" \")\n                if (head.next):\n                        print(end = \"-> \")\n                head = head.next\n        print()\ndef isVowel(x):\n        return (x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U')\ndef arrange(head):\n        newHead = head\n        latestVowel = None\n        curr = head\n        if (head == None):\n                return None\n        if (isVowel(head.data)):\n                latestVowel = head\n        else:\n                while (curr.next != None and\n                        not isVowel(curr.next.data)):\n                        curr = curr.next\n                if (curr.next == None):\n                        return head\n                latestVowel = newHead = curr.next\n                curr.next = curr.next.next\n                latestVowel.next = head\n        while (curr != None and curr.next != None):\n                if (isVowel(curr.next.data)):\n                        if (curr == latestVowel):\n                                latestVowel = curr = curr.next\n                        else:\n                                temp = latestVowel.next\n                                latestVowel.next = curr.next\n                                latestVowel = latestVowel.next\n                                curr.next = curr.next.next\n                                latestVowel.next = temp\n                else:\n                        curr = curr.next\n        return newHead\ndef __init__(self, x):\n                self.data = x\n                self.next = None", "5": "def KthLargestUsingMorrisTraversal(root, k):\n        curr = root\n        Klargest = None\n        count = 0\n        while (curr != None):\n                if (curr.right == None):\n                        count += 1\n                        if (count == k):\n                                Klargest = curr\n                        curr = curr.left\n                else:\n                        succ = curr.right\n                        while (succ.left != None and succ.left != curr):\n                                succ = succ.left\n                        if (succ.left == None):\n                                succ.left = curr\n                                curr = curr.right\n                        else:\n                                succ.left = None\n                                count += 1\n                                if (count == k):\n                                        Klargest = curr\n                                curr = curr.left\n        return Klargest\ndef __init__(self, data):\n                self.data = data\n                self.right = self.left = None", "6": "def sortByRow(mat, n, ascending):\n        for i in range(n):\n                if (ascending): \n                        mat[i].sort()\n                else:\n                        mat[i].sort(reverse=True)\ndef transpose(mat, n):\n        for i in range(n):\n                for j in range(i + 1, n):\n                        temp = mat[i][j]\n                        mat[i][j] = mat[j][i]\n                        mat[j][i] = temp\ndef sortMatRowAndColWise(mat, n):\n        sortByRow(mat, n, True)\n        transpose(mat, n)\n        sortByRow(mat, n, False)\n        transpose(mat, n)\ndef printMat(mat, n):\n        for i in range(n):\n                for j in range(n):\n                        print(mat[i][j] , \" \", end=\"\")\n                print()", "7": "def sortByRow(mat, n):\n        for i in range (n):\n                for j in range(n-1):\n                        if mat[i][j] > mat[i][j + 1]:\n                                temp = mat[i][j]\n                                mat[i][j] = mat[i][j + 1]\n                                mat[i][j + 1] = temp\ndef transpose(mat, n):\n        for i in range (n):\n                for j in range(i + 1, n):\n                        t = mat[i][j]\n                        mat[i][j] = mat[j][i]\n                        mat[j][i] = t\ndef sortMatRowAndColWise(mat, n):\n        sortByRow(mat, n)\n        transpose(mat, n)\n        sortByRow(mat, n)\n        transpose(mat, n)\ndef printMat(mat, n):\n        for i in range(n):\n                for j in range(n):\n                        print(str(mat[i][j] ), end = \" \")\n                print();", "8": "def DoublyEven(n):\n        arr = [[(n*y)+x+1 for x in range(n)]for y in range(n)]\n        for i in range(0,n/4):\n                for j in range(0,n/4):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(0,n/4):\n                for j in range(3 * (n/4),n):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(3 * (n/4),n):\n                for j in range(0,n/4):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(3 * (n/4),n):\n                for j in range(3 * (n/4),n):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(n/4,3 * (n/4)):\n                for j in range(n/4,3 * (n/4)):\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n        for i in range(n):\n                for j in range(n):\n                        print '%2d ' %(arr[i][j]),\n                print", "9": "def Kroneckerproduct( A , B ):\n        C = [[0 for j in range(cola * colb)] for i in range(rowa * rowb)]\n        for i in range(0, rowa):\n                for k in range(0, rowb):\n                        for j in range(0, cola):\n                                for l in range(0, colb):\n                                        C[i + l + 1][j + k + 1] = A[i][j] * B[k][l]\n                                        print (C[i + l + 1][j + k + 1],end=' ')\n                        print (\"\\n\")", "10": "def islowertriangular(M):\n        for i in range(0, len(M)):\n                for j in range(i + 1, len(M)):\n                        if(M[i][j] != 0):\n                                        return False\n        return True", "11": "def isuppertriangular(M):\n        for i in range(1, len(M)):\n                for j in range(0, i):\n                        if(M[i][j] != 0):\n                                        return False\n        return True", "12": "def countSets(a):\n        res = 0\n        for i in range(n):\n                u = 0\n                v = 0\n                for j in range(m):\n                        if a[i][j]:\n                                u += 1\n                        else:\n                                v += 1\n                res += pow(2, u) - 1 + pow(2, v) - 1\n        for i in range(m):\n                u = 0\n                v = 0\n                for j in range(n):\n                        if a[j][i]:\n                                u += 1\n                        else:\n                                v += 1\n                res += pow(2, u) - 1 + pow(2, v) - 1\n        return res - (n*m)", "13": "def transpose(mat, tr, N):\n        for i in range(N):\n                for j in range(N):\n                        tr[i][j] = mat[j][i]\ndef isSymmetric(mat, N):\n        tr = [ [0 for j in range(len(mat[0])) ] for i in range(len(mat)) ]\n        transpose(mat, tr, N)\n        for i in range(N):\n                for j in range(N):\n                        if (mat[i][j] != tr[i][j]):\n                                return False\n        return True", "14": "def isSymmetric(mat, N):\n        for i in range(N):\n                for j in range(N):\n                        if (mat[i][j] != mat[j][i]):\n                                return False\n        return True", "15": "def findNormal(mat, n):\n        sum = 0;\n        for i in range(n):\n                for j in range(n):\n                        sum += mat[i][j] * mat[i][j];\n        return math.floor(math.sqrt(sum));\ndef findTrace(mat, n):\n        sum = 0;\n        for i in range(n):\n                sum += mat[i][i];\n        return sum;", "16": "def maxDet(n):\n        return 2 * n * n * n\ndef resMatrix(n):\n        for i in range(3):\n                for j in range(3):\n                        if i == 0 and j == 2:\n                                print(\"0\", end = \" \")\n                        elif i == 1 and j == 0:\n                                print(\"0\", end = \" \")\n                        elif i == 2 and j == 1:\n                                print(\"0\", end = \" \")\n                        else:\n                                print(n, end = \" \")\n                print(\"\\n\")", "17": "def countNegative(M, n, m):\n        count = 0\n        for i in range(n):\n                for j in range(m):\n                        if M[i][j] < 0:\n                                count += 1\n                        else:\n                                break\n        return count", "18": "def countNegative(M, n, m):\n        count = 0 \n        i = 0\n        j = m - 1 \n        while j >= 0 and i < n:\n                if M[i][j] < 0:\n                        count += (j + 1)\n                        i += 1\n                else:\n                        j -= 1\n        return count", "19": "def getLastNegativeIndex(array, start, end, n):\n        if (start == end):\n                return start\n        mid = start + (end - start) // 2\n        if (array[mid] < 0):\n                if (mid + 1 < n and array[mid + 1] >= 0):\n                        return mid\n                return getLastNegativeIndex(array, mid + 1, end, n)\n        else:\n                return getLastNegativeIndex(array, start, mid - 1, n)\ndef countNegative(M, n, m):\n        count = 0\n        nextEnd = m - 1\n        for i in range(n):\n                if (M[i][0] >= 0):\n                        break\n                nextEnd = getLastNegativeIndex(M[i], 0, nextEnd, 4)\n                count += nextEnd + 1\n        return count", "20": "def findMaxValue(mat):\n        maxValue = 0\n        for a in range(N - 1):\n                for b in range(N - 1):\n                        for d in range(a + 1, N):\n                                for e in range(b + 1, N):\n                                        if maxValue < int (mat[d][e] - mat[a][b]):\n                                                maxValue = int(mat[d][e] - mat[a][b]);\n        return maxValue;", "21": "def findMaxValue(mat):\n        maxValue = -sys.maxsize -1\n        maxArr = [[0 for x in range(N)] for y in range(N)]\n        maxArr[N - 1][N - 1] = mat[N - 1][N - 1]\n        maxv = mat[N - 1][N - 1];\n        for j in range (N - 2, -1, -1):\n                if (mat[N - 1][j] > maxv):\n                        maxv = mat[N - 1][j]\n                maxArr[N - 1][j] = maxv\n        maxv = mat[N - 1][N - 1];\n        for i in range (N - 2, -1, -1):\n                if (mat[i][N - 1] > maxv):\n                        maxv = mat[i][N - 1]\n                maxArr[i][N - 1] = maxv\n        for i in range (N - 2, -1, -1):\n                for j in range (N - 2, -1, -1):\n                        if (maxArr[i + 1][j + 1] - mat[i][j] > maxValue):\n                                maxValue = (maxArr[i + 1][j + 1] - mat[i][j])\n                        maxArr[i][j] = max(mat[i][j],\n                                                max(maxArr[i][j + 1], maxArr[i + 1][j]))\n        return maxValue", "22": "def youngify(mat, i, j):\n        downVal = mat[i + 1][j] if (i + 1 < N) else INF\n        rightVal = mat[i][j + 1] if (j + 1 < N) else INF\n        if (downVal == INF and rightVal == INF):\n                return\n        if (downVal < rightVal):\n                mat[i][j] = downVal\n                mat[i + 1][j] = INF\n                youngify(mat, i + 1, j)\n        else:\n                mat[i][j] = rightVal\n                mat[i][j + 1] = INF\n                youngify(mat, i, j + 1)\ndef extractMin(mat):\n        ret = mat[0][0]\n        mat[0][0] = INF\n        youngify(mat, 0, 0)\n        return ret\ndef printSorted(mat):\n        print(\"Elements of matrix in sorted order n\")\n        i = 0\n        while i < N * N:\n                print(extractMin(mat), end = \" \")\n                i += 1", "23": "def printSumSimple(mat, k):\n        if (k > n):\n                return\n        for i in range(n - k + 1):\n                for j in range(n - k + 1):\n                        sum = 0\n                        for p in range(i, k + i):\n                                for q in range(j, k + j):\n                                        sum += mat[p][q]\n                        print(sum, end = \" \")\n                print()", "24": "def printSumTricky(mat, k):\n        global n\n        if k > n:\n                return\n        stripSum = [[None] * n for i in range(n)]\n        for j in range(n):\n                Sum = 0\n                for i in range(k):\n                        Sum += mat[i][j]\n                stripSum[0][j] = Sum\n                for i in range(1, n - k + 1):\n                        Sum += (mat[i + k - 1][j] - mat[i - 1][j])\n                        stripSum[i][j] = Sum\n        for i in range(n - k + 1):\n                Sum = 0\n                for j in range(k):\n                        Sum += stripSum[i][j]\n                print(Sum, end = \" \")\n                for j in range(1, n - k + 1):\n                        Sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1])\n                        print(Sum, end = \" \")\n                print()", "25": "def transpose(A, B):\n        for i in range(N):\n                for j in range(M):\n                        B[i][j] = A[j][i]", "26": "def transpose(A):\n        for i in range(N):\n                for j in range(i+1, N):\n                        A[i][j], A[j][i] = A[j][i], A[i][j]", "27": "def pathCountRec(mat, m, n, k):\n        if m < 0 or n < 0:\n                return 0\n        elif m == 0 and n == 0:\n                return k == mat[m][n]\n        return (pathCountRec(mat, m-1, n, k-mat[m][n])\n                + pathCountRec(mat, m, n-1, k-mat[m][n]))\ndef pathCount(mat, k):\n        return pathCountRec(mat, R-1, C-1, k)", "28": "def pathCountDPRecDP(mat, m, n, k):\n        if m < 0 or n < 0:\n                return 0\n        elif m == 0 and n == 0:\n                return k == mat[m][n]\n        if (dp[m][n][k] != -1):\n                return dp[m][n][k]\n        dp[m][n][k] = (pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) +\n                                pathCountDPRecDP(mat, m, n - 1, k - mat[m][n]))\n        return dp[m][n][k]\ndef pathCountDP(mat, k):\n        return pathCountDPRecDP(mat, R - 1, C - 1, k)", "29": "def countMinReversals(expr):\n        lenn = len(expr)\n        if (lenn % 2) :\n                return -1\n        s = []\n        for i in range(lenn):\n                if (expr[i] =='' and len(s)):\n                        if (s[0] == '') :\n                                s.pop(0)\n                        else:\n                                s.insert(0, expr[i])\n                else:\n                        s.insert(0, expr[i])\n        red_len = len(s)\n        n = 0\n        while (len(s)and s[0] == '') :\n                        s.pop(0)\n                        n += 1\n        return (red_len // 2 + n % 2)", "30": "def PrintMinNumberForPattern(arr):\n        curr_max = 0\n        last_entry = 0\n        i = 0\n        while i < len(arr):\n                noOfNextD = 0\n                if arr[i] == \"I\":\n                        j = i + 1\n                        while j < len(arr) and arr[j] == \"D\":\n                                noOfNextD += 1\n                                j += 1\n                        if i == 0:\n                                curr_max = noOfNextD + 2\n                                last_entry += 1\n                                print(\"\", last_entry, end = \"\")\n                                print(\"\", curr_max, end = \"\")\n                                last_entry = curr_max\n                        else:\n                                curr_max += noOfNextD + 1\n                                last_entry = curr_max\n                                print(\"\", last_entry, end = \"\")\n                        for k in range(noOfNextD):\n                                last_entry -= 1\n                                print(\"\", last_entry, end = \"\")\n                                i += 1\n                elif arr[i] == \"D\":\n                        if i == 0:\n                                j = i + 1\n                                while j < len(arr) and arr[j] == \"D\":\n                                        noOfNextD += 1\n                                        j += 1\n                                curr_max = noOfNextD + 2\n                                print(\"\", curr_max, curr_max - 1, end = \"\")\n                                last_entry = curr_max - 1\n                        else:\n                                print(\"\", last_entry - 1, end = \"\")\n                                last_entry -= 1\n                i += 1\n        print()", "31": "def printLeast(arr):\n        min_avail = 1\n        pos_of_I = 0\n        v = []\n        if (arr[0] == 'I'):\n                v.append(1)\n                v.append(2)\n                min_avail = 3\n                pos_of_I = 1\n        else:\n                v.append(2)\n                v.append(1)\n                min_avail = 3\n                pos_of_I = 0\n        for i in range(1, len(arr)):\n                if (arr[i] == 'I'):\n                        v.append(min_avail)\n                        min_avail += 1\n                        pos_of_I = i + 1\n                else:\n                        v.append(v[i])\n                        for j in range(pos_of_I, i + 1):\n                                v[j] += 1\n                        min_avail += 1\n        print(*v, sep = ' ')", "32": "def PrintMinNumberForPattern(Strr):\n        res = ''\n        stack = []\n        for i in range(len(Strr) + 1):\n                stack.append(i + 1)\n                if (i == len(Strr) or Strr[i] == 'I'):\n                        while len(stack) > 0:\n                                res += str(stack.pop())\n                                res += ' '\n        print(res)", "33": "def getMinNumberForPattern(seq):\n        n = len(seq)\n        if (n >= 9):\n                return \"-1\"\n        result = [None] * (n + 1)\n        count = 1\n        for i in range(n + 1):\n                if (i == n or seq[i] == 'I'):\n                        for j in range(i - 1, -2, -1):\n                                result[j + 1] = int('0' + str(count))\n                                count += 1\n                                if(j >= 0 and seq[j] == 'I'):\n                                        break\n        return result", "34": "def subset(ar, n):\n        res = 0\n        ar.sort()\n        for i in range(0, n) :\n                count = 1\n                for i in range(n - 1):\n                        if ar[i] == ar[i + 1]:\n                                count+=1\n                        else:\n                                break\n                res = max(res, count)\n        return res", "35": "def subset(arr, n):\n        mp = {i:0 for i in range(10)}\n        for i in range(n):\n                mp[arr[i]] += 1\n        res = 0\n        for key, value in mp.items():\n                res = max(res, value)\n        return res", "36": "def areElementsContiguous(arr, n):\n        arr.sort()\n        for i in range(1,n):\n                if (arr[i] - arr[i-1] > 1) :\n                        return 0\n        return 1", "37": "def areElementsContiguous(arr, n):\n        max1 = max(arr)\n        min1 = min(arr)\n        m = max1 - min1 + 1\n        if (m > n):\n                return False\n        visited = [0] * m\n        for i in range(0,n) :\n                visited[arr[i] - min1] = True\n        for i in range(0, m):\n                if (visited[i] == False):\n                        return False\n        return True", "38": "def areElementsContiguous(arr):\n        us = set()\n        for i in arr: us.add(i)\n        count = 1\n        curr_ele = arr[0] - 1\n        while curr_ele in us:\n                count += 1\n                curr_ele -= 1\n        curr_ele = arr[0] + 1\n        while curr_ele in us:\n                count += 1\n                curr_ele += 1\n        return (count == len(us))", "39": "def longest(a, n, k):\n        freq = collections.defaultdict(int)\n        start = 0\n        end = 0\n        now = 0\n        l = 0\n        for i in range(n):\n                freq[a[i]] += 1\n                if (freq[a[i]] == 1):\n                        now += 1\n                while (now > k) :\n                        freq[a[l]] -= 1\n                        if (freq[a[l]] == 0):\n                                now -= 1\n                        l += 1\n                if (i - l + 1 >= end - start + 1):\n                        end = i\n                        start = l\n        for i in range(start, end + 1):\n                print(a[i], end = \" \")", "40": "def findSmallestRange(arr, n, k):\n        i, minval, maxval, minrange, minel, maxel, flag, minind = 0, 0, 0, 0, 0, 0, 0, 0\n        for i in range(k + 1):\n                ptr[i] = 0\n        minrange = 10**9\n        while(1): \n                minind = -1\n                minval = 10**9\n                maxval = -10**9\n                flag = 0\n                for i in range(k):\n                        if(ptr[i] == n):\n                                flag = 1 \n                                break\n                        if(ptr[i] < n and arr[i][ptr[i]] < minval):\n                                minind = i \n                                minval = arr[i][ptr[i]]\n                        if(ptr[i] < n and arr[i][ptr[i]] > maxval):\n                                maxval = arr[i][ptr[i]]\n                if(flag):\n                        break\n                ptr[minind] += 1\n                if((maxval-minval) < minrange):\n                        minel = minval\n                        maxel = maxval\n                        minrange = maxel - minel\n        print(\"The smallest range is [\", minel, maxel, \"]\")", "41": "def findLargestd(S, n) :\n        found = False\n        S.sort()\n        for i in range(n-1, -1, -1) :\n                for j in range(0, n) :\n                        if (i == j) :\n                                continue\n                        for k in range(j + 1, n) :\n                                if (i == k) :\n                                        continue\n                                for l in range(k+1, n) :\n                                        if (i == l) :\n                                                continue\n                                        if (S[i] == S[j] + S[k] + S[l]) :\n                                                found = True\n                                                return S[i]                                \n        if (found == False) :\n                return -1", "42": "def findFourElements(arr, n):\n        mp = dict()\n        for i in range(n - 1):\n                for j in range(i + 1, n):\n                        mp[arr[i] + arr[j]] =(i, j)\n        d = -10**9\n        for i in range(n - 1):\n                for j in range(i + 1, n):\n                        abs_diff = abs(arr[i] - arr[j])\n                        if abs_diff in mp.keys():\n                                p = mp[abs_diff]\n                                if (p[0] != i and p[0] != j and p[1] != i and p[1] != j):\n                                        d = max(d, max(arr[i], arr[j]))\n        return d", "43": "def leftRotatebyOne(arr, n):\n        temp = arr[0]\n        for i in range(n-1):\n                arr[i] = arr[i + 1]\n        arr[n-1] = temp\ndef leftRotate(arr, d, n):\n        for i in range(d):\n                leftRotatebyOne(arr, n)\ndef printArray(arr, size):\n        for i in range(size):\n                print (\"% d\"% arr[i], end =\" \")", "44": "def pushZerosToEnd(arr, n):\n        count = 0 \n        for i in range(n):\n                if arr[i] != 0:\n                        arr[count] = arr[i]\n                        count+=1\n        while count < n:\n                arr[count] = 0\n                count += 1", "45": "def moveZerosToEnd (arr, n):\n        count = 0;\n        for i in range(0, n):\n                if (arr[i] != 0):\n                        arr[count], arr[i] = arr[i], arr[count]\n                        count+=1\ndef printArray(arr, n):\n        for i in range(0, n):\n                print(arr[i],end=\" \")", "46": "def pushZerosToEnd(arr, n):\n        count = 0\n        for i in range(0, n):\n                if arr[i] != 0:\n                        arr[count] = arr[i]\n                        count+=1\n        while (count < n):\n                arr[count] = 0\n                count+=1\ndef modifyAndRearrangeArr(ar, n):\n        if n == 1:\n                return\n        for i in range(0, n - 1):\n                if (arr[i] != 0) and (arr[i] == arr[i + 1]):\n                        arr[i] = 2 * arr[i]\n                        arr[i + 1] = 0\n                        i+=1\n        pushZerosToEnd(arr, n)\ndef printArray(arr, n):\n        for i in range(0, n):\n                print(arr[i],end=\" \")", "47": "def shiftAllZeroToLeft(arr, n):\n        lastSeenNonZero = 0\n        for index in range(0, n):\n                if (array[index] != 0):\n                        array[index], array[lastSeenNonZero] = array[lastSeenNonZero], array[index]\n                        lastSeenNonZero+=1", "48": "def printArray(arr, n):\n        for i in range(n):\n                print(arr[i], end = \" \")\n        print()\ndef RearrangePosNeg(arr, n):\n        for i in range(1, n):\n                key = arr[i]\n                if (key > 0):\n                        continue\n                j = i - 1\n                while (j >= 0 and arr[j] > 0):\n                        arr[j + 1] = arr[j]\n                        j = j - 1\n                arr[j + 1] = key"}, "c": {"0": "int minCost(int cost[][N], int n) \n{ \n     int dist[N]; \n     for (int i = 0; i < N; i++) \n        dist[i]   = INF; \n     dist[0] = 0; \n       \n     for (int i = 0; i < n; i++) \n        for (int j = i+1; j < n; j++) \n           if (dist[j] > dist[i] + cost[i][j]) \n              dist[j] = dist[i] + cost[i][j]; \n       \n     return dist[n-1]; \n}", "1": "int numOfways(int n, int k) \n{ \n        int p = 1; \n        if (k % 2) \n                p = -1; \n        return (pow(n - 1, k) +  \n                                p * (n - 1)) / n; \n}", "2": "int fib(int n)\n{\n  if (n <= 1)\n    return n;\n  return fib(n-1) + fib(n-2);\n}\n\nint findVertices(int n)\n{\n\treturn fib(n + 2);\n}", "3": "#include <stdio.h>\n#include <stdlib.h>\n \n/* a node of the doubly linked list */\nstruct node\n{\n  int data;\n  struct node *next;\n  struct node *prev;\n};\n \n/* Function to reverse a Doubly Linked List */\nvoid reverse(struct node **head_ref)\n{\n    struct node *temp = NULL;  \n    struct node *current = *head_ref;\n     \n    /* swap next and prev for all nodes of \n       doubly linked list */\n    while (current !=  NULL)\n    {\n       temp = current->prev;  \n       current->prev = current->next;   \n       current->next = temp;              \n       current = current->prev;         \n    }      \n     \n    /* Before changing head, check for the cases like empty \n       list and list with only one node */\n    if(temp != NULL )\n       *head_ref = temp->prev;\n}\n \n/* Function to insert a node at the beginging of \n   the Doubly Linked List */\nvoid push(struct node** head_ref, int new_data)\n{\n    /* allocate node */\n    struct node* new_node =\n            (struct node*) malloc(sizeof(struct node));\n  \n    /* put in the data  */\n    new_node->data  = new_node;\n  \n    /* since we are adding at the begining, \n      prev is always NULL */\n    new_node->prev = NULL;\n  \n    /* link the old list off the new node */\n    new_node->next = (*head_ref);    \n  \n    /* change prev of head node to new node */\n    if((*head_ref) !=  NULL) \n      (*head_ref)->prev = new_node ;    \n  \n    /* move the head to point to the new node */\n    (*head_ref)    = new_node;\n}\n \n/* Function to print nodes in a given doubly linked list \n   This function is same as printList() of singly linked lsits */\nvoid printList(struct node *node)\n{\n  while(node!=NULL)\n  {\n    printf(\"%d \", node->data);\n    node = node->next;\n  }\n}  \n \n/* Driver program to test above functions*/\nint main()\n{\n  /* Start with the empty list */\n  struct node* head = NULL;\n   \n  /* Let us create a sorted linked list to test the functions\n   Created linked list will be 1->2->3->4->5->6->7 */ \n  push(&head, 7);\n  push(&head, 6);\n  push(&head, 5);\n  push(&head, 4);\n  push(&head, 3);\n  push(&head, 2);\n  push(&head, 1);      \n   \n  printf(\"\\n Original Linked list \");\n  printList(head);\n   \n  /* Reverse doubly linked list */\n  reverse(&head);\n   \n  printf(\"\\n Reversed Linked list \");  \n  printList(head);           \n   \n  getchar();\n}", "4": "void printlist(node* head) {\n        if (not head) {\n                printf(\"Empty List\");\n                return;\n        }\n        while (head != NULL) {\n                printf(\"%d\", head->data);\n                if (head->next) {\n                        printf(\"-> \");\n                }\n                head = head->next;\n        }\n        printf();\n}\nbool isVowel(char x) {\n        return (x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u' || x == 'A' || x == 'E' || x == 'I' || x == 'O' || x == 'U');\n}\nnode* arrange(node* head) {\n        node* newHead = head;\n        node* latestVowel = NULL;\n        node* curr = head;\n        if (head == NULL) {\n                return NULL;\n        }\n        if (isVowel(head->data)) {\n                latestVowel = head;\n        }\n        else {\n                while (curr->next != NULL &&\n                        !isVowel(curr->next->data)) {\n                        curr = curr->next;\n                }\n                if (curr->next == NULL) {\n                        return head;\n                }\n                latestVowel = newHead = curr->next;\n                curr->next = curr->next->next;\n                latestVowel->next = head;\n        }\n        while (curr != NULL && curr->next != NULL) {\n                if (isVowel(curr->next->data)) {\n                        if (curr == latestVowel) {\n                                latestVowel = curr = curr->next;\n                        }\n                        else {\n                                temp = latestVowel->next;\n                                latestVowel->next = curr->next;\n                                latestVowel = latestVowel->next;\n                                curr->next = curr->next->next;\n                                latestVowel->next = temp;\n                        }\n                }\n                else {\n                        curr = curr->next;\n                }\n        }\n        return newHead;\n}\nnode* __init__(char x) {\n                node* self = malloc(sizeof(node));\n                self->data = x;\n                self->next = NULL;\n                return self;\n}", "5": "int KthLargestUsingMorrisTraversal(root, k) {\n        curr = root;\n        Klargest = None;\n        count = 0;\n        while (curr != None) {\n                if (curr.right == None) {\n                        count += 1;\n                        if (count == k) {\n                                Klargest = curr;\n                        }\n                        curr = curr.left;\n                }\n                else {\n                        succ = curr.right;\n                        while (succ.left != None && succ.left != curr) {\n                                succ = succ.left;\n                        }\n                        if (succ.left == None) {\n                                succ.left = curr;\n                                curr = curr.right;\n                        }\n                        else {\n                                succ.left = None;\n                                count += 1;\n                                if (count == k) {\n                                        Klargest = curr;\n                                }\n                                curr = curr.left;\n                        }\n                }\n        }\n        return Klargest;\n}", "6": "void sortByRow(int** mat, int n, int ascending) {\n        for (int i = 0; i < n; i++) {\n                if (ascending) {\n                        mat[i].sort();\n                }\n                else {\n                        mat[i].sort(reverse=True);\n                }\n        }\n}\n\nvoid transpose(int** mat, int n) {\n        for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                        int temp = mat[i][j];\n                        mat[i][j] = mat[j][i];\n                        mat[j][i] = temp;\n                }\n        }\n}\n\nvoid sortMatRowAndColWise(int** mat, int n) {\n        sortByRow(mat, n, 1);\n        transpose(mat, n);\n        sortByRow(mat, n, 0);\n        transpose(mat, n);\n}\n\nvoid printMat(int** mat, int n) {\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                        printf(\"%d \", mat[i][j]);\n                }\n                printf(\"\\n\");\n        }\n}", "7": "void sortByRow(int mat[][100], int n){\n        for(int i = 0; i < n; i++){\n                for(int j = 0; j < n - 1; j++){\n                        if(mat[i][j] > mat[i][j + 1]){\n                                int temp = mat[i][j];\n                                mat[i][j] = mat[i][j + 1];\n                                mat[i][j + 1] = temp;\n                        }\n                }\n        }\n}\n\nvoid transpose(int mat[][100], int n){\n        for(int i = 0; i < n; i++){\n                for(int j = i + 1; j < n; j++){\n                        int t = mat[i][j];\n                        mat[i][j] = mat[j][i];\n                        mat[j][i] = t;\n                }\n        }\n}\n\nvoid sortMatRowAndColWise(int mat[][100], int n){\n        sortByRow(mat, n);\n        transpose(mat, n);\n        sortByRow(mat, n);\n        transpose(mat, n);\n}\n\nvoid printMat(int mat[][100], int n){\n        for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                        printf(\"%d \", mat[i][j]);\n                }\n                printf(\"\\n\");\n        }\n}\n\nint main(){\n        int n;\n        scanf(\"%d\", &n);\n\n        int mat[100][100];\n\n        for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                        scanf(\"%d\", &mat[i][j]);\n                }\n        }\n\n        sortMatRowAndColWise(mat, n);\n        printMat(mat, n);\n\n        return 0;\n}", "8": "int DoublyEven(int n) {\n        int arr[n][n];\n        for(int y = 0; y < n; y++) {\n                for(int x = 0; x < n; x++) {\n                        arr[y][x] = (n*y)+x+1;\n                }\n        }\n        for(int i = 0; i < n/4; i++) {\n                for(int j = 0; j < n/4; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for(int i = 0; i < n/4; i++) {\n                for(int j = 3 * (n/4); j < n; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for(int i = 3 * (n/4); i < n; i++) {\n                for(int j = 0; j < n/4; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for(int i = 3 * (n/4); i < n; i++) {\n                for(int j = 3 * (n/4); j < n; j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for(int i = n/4; i < 3 * (n/4); i++) {\n                for(int j = n/4; j < 3 * (n/4); j++) {\n                        arr[i][j] = (n*n + 1) - arr[i][j];\n                }\n        }\n        for(int i = 0; i < n; i++) {\n                for(int j = 0; j < n; j++) {\n                        printf(\"%2d \", arr[i][j]);\n                }\n                printf(\"\\n\");\n        }\n}", "9": "#include <stdio.h>\n#define rowa 3\n#define cola 3\n#define rowb 3\n#define colb 3\n\nvoid Kroneckerproduct(int a[rowa][cola], int b[rowb][colb]){\n\n        int c[rowa * rowb][cola * colb];\n        for (int i = 0; i < rowa; i++)\n        {\n                for (int k = 0; k < rowb; k++)\n                {\n                        for (int j = 0; j < cola; j++)\n                        {\n                                for (int l = 0; l < colb; l++)\n                                {\n                                        c[i + l + 1][j + k + 1] = a[i][j] * b[k][l];\n                                        printf (\"%d \", c[i + l + 1][j + k + 1]);\n                                }\n                        printf (\"\\n\");\n                }\n        }\n}", "10": "int islowertriangular(int M[][], int len) {\n        for (int i = 0; i < len; i++) {\n                for (int j = i + 1; j < len; j++) {\n                        if (M[i][j] != 0) {\n                                return 0;\n                        }\n                }\n        }\n        return 1;\n}", "11": "int isuppertriangular(int M[][]) {\n        for (int i = 1; i < len(M); i++) {\n                for (int j = 0; j < i; j++) {\n                        if (M[i][j] != 0) {\n                                return false;\n                        }\n                }\n        }\n        return true;\n}", "12": "int countSets(int a[][m]){\n        res = 0;\n        for (i = 0; i < n; i++){\n                u = 0;\n                v = 0;\n                for (j = 0; j < m; j++){\n                        if (a[i][j]){\n                                u += 1;\n                        }\n                        else{\n                                v += 1;\n                        }\n                }\n                res += pow(2, u) - 1 + pow(2, v) - 1;\n        }\n        for (i = 0; i < m; i++){\n                u = 0;\n                v = 0;\n                for (j = 0; j < n; j++){\n                        if (a[j][i]){\n                                u += 1;\n                        }\n                        else{\n                                v += 1;\n                        }\n                }\n                res += pow(2, u) - 1 + pow(2, v) - 1;\n        }\n        return res - (n*m);\n}", "13": "void transpose(int mat[][3], int tr[][3], int N)\n{\n        int i, j;\n        for (i = 0; i < N; i++)\n        {\n                for (j = 0; j < N; j++)\n                {\n                        tr[i][j] = mat[j][i];\n                }\n        }\n}\nint isSymmetric(int mat[][3], int N)\n{\n        int tr[3][3];\n        transpose(mat, tr, N);\n        int i, j;\n        for (i = 0; i < N; i++)\n        {\n                for (j = 0; j < N; j++)\n                {\n                        if (mat[i][j] != tr[i][j])\n                        {\n                                return 0;\n                        }\n                }\n        }\n        return 1;\n}", "14": "int isSymmetric(int mat[N][N], int N) \n{ \n    for (int i = 0; i < N; i++) \n        for (int j = 0; j < N; j++) \n            if (mat[i][j] != mat[j][i]) \n                return false; \n    return true; \n}", "15": "int findNormal(int** mat, int n){\n        int sum = 0;\n        for (int i = 0; i < n; i++){\n                for (int j = 0; j < n; j++){\n                        sum += mat[i][j] * mat[i][j];\n                }\n        }\n        return (int) sqrt(sum);\n}\nint findTrace(int** mat, int n){\n        int sum = 0;\n        for (int i = 0; i < n; i++){\n                sum += mat[i][i];\n        }\n        return sum;\n}", "16": "#include <stdio.h>\n\nint maxDet(int n){\n        return 2 * n * n * n;\n}\n\nvoid resMatrix(int n){\n        int i, j;\n        for (i = 0; i < 3; i++) {\n                for (j = 0; j < 3; j++) {\n                        if (i == 0 && j == 2) {\n                                printf(\"0 \");\n                        }\n                        else if (i == 1 && j == 0) {\n                                printf(\"0 \");\n                        }\n                        else if (i == 2 && j == 1) {\n                                printf(\"0 \");\n                        }\n                        else {\n                                printf(\"%d \", n);\n                        }\n                }\n                printf(\"\\n\");\n        }\n}\n\nint main() {\n        int n;\n        printf(\"Enter the number of rows and columns: \");\n        scanf(\"%d\", &n);\n        printf(\"The determinant of the given matrix is: %d\\n\", maxDet(n));\n        printf(\"The result matrix is: \\n\");\n        resMatrix(n);\n        return 0;\n}", "17": "int countNegative(int M[][], int n, int m) {\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                        if (M[i][j] < 0) {\n                                count++;\n                        } else {\n                                break;\n                        }\n                }\n        }\n        return count;\n}", "18": "int countNegative(int **M, int n, int m){\n        int count = 0; \n        int i = 0;\n        int j = m - 1; \n        while (j >= 0 && i < n){\n                if (M[i][j] < 0){\n                        count += (j + 1);\n                        i += 1;\n                }\n                else{\n                        j -= 1;\n                }\n        }\n        return count;\n}", "19": "int getLastNegativeIndex(int array[], int start, int end, int n)\n{\n        if (start == end)\n        {\n                return start;\n        }\n        int mid = start + (end - start) / 2;\n        if (array[mid] < 0)\n        {\n                if (mid + 1 < n && array[mid + 1] >= 0)\n                {\n                        return mid;\n                }\n                return getLastNegativeIndex(array, mid + 1, end, n);\n        }\n        else\n        {\n                return getLastNegativeIndex(array, start, mid - 1, n);\n        }\n}\nint countNegative(int M[][4], int n, int m)\n{\n        int count = 0;\n        int nextEnd = m - 1;\n        for (int i = 0; i < n; i++)\n        {\n                if (M[i][0] >= 0)\n                {\n                        break;\n                }\n                nextEnd = getLastNegativeIndex(M[i], 0, nextEnd, 4);\n                count += nextEnd + 1;\n        }\n        return count;\n}", "20": "int findMaxValue(int** mat, int N) {\n        int maxValue = 0;\n        for (int a = 0; a < N - 1; a++) {\n                for (int b = 0; b < N - 1; b++) {\n                        for (int d = a + 1; d < N; d++) {\n                                for (int e = b + 1; e < N; e++) {\n                                        if (maxValue < (int) (mat[d][e] - mat[a][b])) {\n                                                maxValue = (int) (mat[d][e] - mat[a][b]);\n                                        }\n                                }\n                        }\n                }\n        }\n        return maxValue;\n}", "21": "int findMaxValue(int** mat, int N){\n        int maxValue = -sys.maxsize -1\n        int[][] maxArr = new int[N][N];\n        maxArr[N - 1][N - 1] = mat[N - 1][N - 1]\n        int maxv = mat[N - 1][N - 1];\n        for (int j = (N - 2, -1, -1); j>=0; j--) {\n                if (mat[N - 1][j] > maxv) {\n                        maxv = mat[N - 1][j]\n                }\n                maxArr[N - 1][j] = maxv\n        }\n        maxv = mat[N - 1][N - 1];\n        for (int i = (N - 2, -1, -1); i>=0; i--) {\n                if (mat[i][N - 1] > maxv) {\n                        maxv = mat[i][N - 1]\n                }\n                maxArr[i][N - 1] = maxv\n        }\n        for (int i = (N - 2, -1, -1); i>=0; i--) {\n                for (int j = (N - 2, -1, -1); j>=0; j--) {\n                        if (maxArr[i + 1][j + 1] - mat[i][j] > maxValue) {\n                                maxValue = (maxArr[i + 1][j + 1] - mat[i][j])\n                        }\n                        maxArr[i][j] = max(mat[i][j],\n                                                max(maxArr[i][j + 1], maxArr[i + 1][j]))\n                }\n        }\n        return maxValue\n}", "22": "int youngify(int** mat, int i, int j, int N){\n        int downVal = mat[i + 1][j] if (i + 1 < N) else INF;\n        int rightVal = mat[i][j + 1] if (j + 1 < N) else INF;\n        if (downVal == INF && rightVal == INF){\n                return;\n        }\n        if (downVal < rightVal){\n                mat[i][j] = downVal;\n                mat[i + 1][j] = INF;\n                youngify(mat, i + 1, j, N);\n        }\n        else{\n                mat[i][j] = rightVal;\n                mat[i][j + 1] = INF;\n                youngify(mat, i, j + 1, N);\n        }\n}\nint extractMin(int** mat, int N){\n        int ret = mat[0][0];\n        mat[0][0] = INF;\n        youngify(mat, 0, 0, N);\n        return ret;\n}\nvoid printSorted(int** mat, int N){\n        printf(\"Elements of matrix in sorted order n\");\n        int i = 0;\n        while (i < N * N){\n                printf(\"%d \", extractMin(mat, N));\n                i += 1;\n        }\n}", "23": "#include <stdio.h>\n#include <stdlib.h>\n\n#define n 4\n\nvoid printSumSimple(int mat[n][n], int k);\n\nint main()\n{\n        int mat[n][n];\n        int k = 2;\n        int i, j;\n        for (i = 0; i < n; i++)\n                for (j = 0; j < n; j++)\n                        scanf(\"%d\", &mat[i][j]);\n        printSumSimple(mat, k);\n}\n\nvoid printSumSimple(int mat[n][n], int k)\n{\n        if (k > n)\n                return;\n        int i, j, p, q;\n        for (i = 0; i <= n - k; i++) {\n                for (j = 0; j <= n - k; j++) {\n                        int sum = 0;\n                        for (p = i; p < k + i; p++) {\n                                for (q = j; q < k + j; q++) {\n                                        sum += mat[p][q];\n                                }\n                        }\n                        printf(\"%d \", sum);\n                }\n                printf(\"\\n\");\n        }\n}", "24": "int printSumTricky(int mat[][], int k, int n) {\n        if k > n:\n                return;\n        int stripSum[n][n];\n        for (int j = 0; j < n; j++) {\n                int Sum = 0;\n                for (int i = 0; i < k; i++) {\n                        Sum += mat[i][j];\n                }\n                stripSum[0][j] = Sum;\n                for (int i = 1; i < n - k + 1; i++) {\n                        Sum += (mat[i + k - 1][j] - mat[i - 1][j]);\n                        stripSum[i][j] = Sum;\n                }\n        }\n        for (int i = 0; i < n - k + 1; i++) {\n                int Sum = 0;\n                for (int j = 0; j < k; j++) {\n                        Sum += stripSum[i][j];\n                }\n                printf(\"%d \", Sum);\n                for (int j = 1; j < n - k + 1; j++) {\n                        Sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n                        printf(\"%d \", Sum);\n                }\n                printf(\"\\n\");\n        }\n}", "25": "void transpose(int A[][M], int B[][N]) \n{ \n    for (int i = 0; i < N; i++) \n        for (int j = 0; j < M; j++) \n            B[i][j] = A[j][i]; \n}", "26": "int transpose(int A[][], int N) {\n        for (int i = 0; i < N; i++) {\n                for (int j = i + 1; j < N; j++) {\n                        swap(A[i][j], A[j][i]);\n                }\n        }\n}", "27": "int pathCountRec(int** mat, int m, int n, int k)\n{\n        if (m < 0 || n < 0)\n                return 0;\n        else if (m == 0 && n == 0)\n                return k == mat[m][n];\n        return (pathCountRec(mat, m-1, n, k-mat[m][n])\n                + pathCountRec(mat, m, n-1, k-mat[m][n]));\n}\nint pathCount(int** mat, int k)\n{\n        return pathCountRec(mat, R-1, C-1, k);\n}", "28": "int pathCountDPRecDP(int mat[][], int m, int n, int k)\n{\n        if (m < 0 || n < 0)\n                return 0;\n        if ((m == 0 && n == 0) && k == mat[m][n])\n                return 1;\n        if (dp[m][n][k] != -1)\n                return dp[m][n][k];\n        dp[m][n][k] = (pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) +\n                                pathCountDPRecDP(mat, m, n - 1, k - mat[m][n]));\n        return dp[m][n][k];\n}\nint pathCountDP(int mat[][], int k)\n{\n        return pathCountDPRecDP(mat, R - 1, C - 1, k);\n}", "29": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid countMinReversals(char expr[]){\n        int lenn = strlen(expr);\n        if (lenn % 2) {\n                printf(\"%d\\n\",-1);\n                return;\n        }\n        char* s = malloc(sizeof(char)*lenn);\n        int top = -1;\n        for (int i = 0; i < lenn; i++) {\n                if (expr[i] =='' && top != -1) {\n                        if (s[top] == '') {\n                                top--;\n                        }\n                        else{\n                                top++;\n                                s[top] = expr[i];\n                        }\n                }\n                else{\n                        top++;\n                        s[top] = expr[i];\n                }\n        }\n        int red_len = top + 1;\n        int n = 0;\n        while (top != -1 && s[top] == '') {\n                        top--;\n                        n += 1;\n        }\n        printf(\"%d\\n\",(red_len // 2 + n % 2));\n}", "30": "int PrintMinNumberForPattern(int arr_size, char* arr)\n{\n        int curr_max = 0;\n        int last_entry = 0;\n        int i = 0;\n        while (i < arr_size)\n        {\n                int noOfNextD = 0;\n                if (arr[i] == 'I')\n                {\n                        int j = i + 1;\n                        while ((j < arr_size) && (arr[j] == 'D'))\n                        {\n                                noOfNextD += 1;\n                                j += 1;\n                        }\n                        if (i == 0)\n                        {\n                                curr_max = noOfNextD + 2;\n                                last_entry += 1;\n                                printf(\"%d %d\", last_entry, curr_max);\n                                last_entry = curr_max;\n                        }\n                        else\n                        {\n                                curr_max += noOfNextD + 1;\n                                last_entry = curr_max;\n                                printf(\"%d\", last_entry);\n                        }\n                        for (int k = 0; k < noOfNextD; k++)\n                        {\n                                last_entry -= 1;\n                                printf(\" %d\", last_entry);\n                                i += 1;\n                        }\n                }\n                else if (arr[i] == 'D')\n                {\n                        if (i == 0)\n                        {\n                                int j = i + 1;\n                                while ((j < arr_size) && (arr[j] == 'D'))\n                                {\n                                        noOfNextD += 1;\n                                        j += 1;\n                                }\n                                curr_max = noOfNextD + 2;\n                                printf(\"%d %d\", curr_max, curr_max - 1);\n                                last_entry = curr_max - 1;\n                        }\n                        else\n                        {\n                                printf(\" %d\", last_entry - 1);\n                                last_entry -= 1;\n                        }\n                }\n                i += 1;\n        }\n        printf(\"\\n\");\n        return 0;\n}", "31": "#include <stdio.h>\n\nvoid printLeast(char* arr) {\n        int min_avail = 1;\n        int pos_of_I = 0;\n        int v[100];\n        if (arr[0] == 'I') {\n                v[0] = 1;\n                v[1] = 2;\n                min_avail = 3;\n                pos_of_I = 1;\n        }\n        else {\n                v[0] = 2;\n                v[1] = 1;\n                min_avail = 3;\n                pos_of_I = 0;\n        }\n        for (int i = 1; i < strlen(arr); i++) {\n                if (arr[i] == 'I') {\n                        v[i] = min_avail;\n                        min_avail += 1;\n                        pos_of_I = i + 1;\n                }\n                else {\n                        v[i] = v[i];\n                        for (int j = pos_of_I; j < i + 1; j++) {\n                                v[j] += 1;\n                        }\n                        min_avail += 1;\n                }\n        }\n        for (int i = 0; i < strlen(arr); i++) {\n                printf(\"%d \", v[i]);\n        }\n}", "32": "void PrintMinNumberForPattern(char* str)\n{\n\tint len = strlen(str);\n\tint* stack = (int*)malloc(sizeof(int)*(len + 1));\n\n\tint top = -1;\n\n\tint i;\n\n\tfor (i = 0; i <= len; i++)\n\t{\n\t\tstack[++top] = i + 1;\n\n\t\tif (i == len || str[i] == 'I')\n\t\t{\n\t\t\twhile (top != -1)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", stack[top--]);\n\t\t\t}\n\t\t}\n\t}\n}", "33": "int getMinNumberForPattern(char seq[]){\n        int n = strlen(seq);\n        if (n >= 9){\n                return -1;\n        }\n        int result[n+1];\n        int count = 1;\n        for (int i = 0; i < n+1; i++){\n                if (i == n || seq[i] == 'I'){\n                        for (int j = i-1; j > -2; j--){\n                                result[j+1] = 0 + count;\n                                count++;\n                                if (j >= 0 && seq[j] == 'I')\n                                        break;\n                                }\n                        }\n                }\n        return result;\n}", "34": "int subset(int ar[], int n) \n{ \n    int res = 0; \n    sort(ar, ar+n); \n    for (int i = 0; i < n; i++) \n    { \n        int count = 1; \n        for (int j = i+1; j < n; j++) \n        { \n            if (ar[i] == ar[j]) \n                count++; \n            else\n                break; \n        } \n        res = max(res, count); \n    } \n    return res; \n}", "35": "int subset(int arr[], int n) {\n        int mp[10] = {0};\n        for(int i = 0; i < n; i++) {\n                mp[arr[i]] += 1;\n        }\n        int res = 0;\n        for(auto it : mp) {\n                res = max(res, it.second);\n        }\n        return res;\n}", "36": "int areElementsContiguous(int arr[], int n)\n{\n    sort(arr, arr + n);\n \n    for (int i = 1; i < n; i++)\n        if (arr[i] - arr[i-1] > 1)\n           return 0;\n \n    return 1;\n}", "37": "bool areElementsContiguous(int arr[], int n)\n{\n        int max1 = max(arr);\n        int min1 = min(arr);\n        int m = max1 - min1 + 1;\n        if (m > n)\n                return false;\n        bool visited[m];\n        for (int i = 0; i < n; i++)\n                visited[arr[i] - min1] = true;\n        for (int i = 0; i < m; i++)\n                if (visited[i] == false)\n                        return false;\n        return true;\n}", "38": "bool areElementsContiguous(int arr[], int n) \n{ \n    unordered_set<int> us; \n    for (int i = 0; i < n; i++) \n        us.insert(arr[i]); \n    int count = 1; \n    int curr_ele = arr[0] - 1; \n    while (us.find(curr_ele) != us.end()) { \n        count++; \n        curr_ele--; \n    } \n    curr_ele = arr[0] + 1; \n    while (us.find(curr_ele) != us.end()) { \n        count++; \n        curr_ele++; \n    } \n    return (count == us.size()); \n}", "39": "int longest(int a[], int n, int k) {\n        int freq[MAX_CHARS] = {0};\n        int start = 0;\n        int end = 0;\n        int now = 0;\n        int l = 0;\n        for (int i = 0; i < n; i++) {\n                freq[a[i]]++;\n                if (freq[a[i]] == 1) {\n                        now += 1;\n                }\n                while (now > k) {\n                        freq[a[l]]--;\n                        if (freq[a[l]] == 0) {\n                                now -= 1;\n                        }\n                        l++;\n                }\n                if (i - l + 1 >= end - start + 1) {\n                        end = i;\n                        start = l;\n                }\n        }\n        for (int i = start; i <= end; i++) {\n                printf(\"%d\", a[i]);\n        }\n}", "40": "#include <stdio.h>\n#define SIZE 10\n\nint main()\n{\n    int arr[SIZE], n, k;\n    int i, minval, maxval, minrange, minel, maxel, flag, minind;\n\n    printf(\"Enter size of array: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter array elements: \");\n    for(i=0; i<n; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    for(i=0; i<n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    minrange = 99999;\n    minind = -1;\n    minval = 99999;\n    maxval = -99999;\n    flag = 0;\n    for(i=0; i<n; i++)\n    {\n        if(ptr[i] == n)\n        {\n            flag = 1;\n            break;\n        }\n        if(ptr[i] < n && arr[i][ptr[i]] < minval)\n        {\n            minind = i;\n            minval = arr[i][ptr[i]];\n        }\n        if(ptr[i] < n && arr[i][ptr[i]] > maxval)\n        {\n            maxval = arr[i][ptr[i]];\n        }\n    }\n    if(flag)\n    {\n        break;\n    }\n    ptr[minind] += 1;\n    if((maxval-minval) < minrange)\n    {\n        minel = minval;\n        maxel = maxval;\n        minrange = maxel - minel;\n    }\n\n    printf(\"The smallest range is [%d, %d]\", minel, maxel);\n\n    return 0;\n}", "41": "int findLargestd(int S[], int n) {\n        found = false;\n        for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                        if (i == j) {\n                                continue\n                        }\n                        for (int k = 0; k < n; k++) {\n                                if (i == k) {\n                                        continue\n                                }\n                                for (int l = 0; l < n; l++) {\n                                        if (i == l) {\n                                                continue\n                                        }\n                                        if (S[i] == S[j] + S[k] + S[l]) {\n                                                found = true;\n                                                return S[i];\n                                        }\n                                }\n                        }\n                }\n        }\n        if (found == false) {\n                return -1;\n        }\n}", "42": "int findFourElements(int arr[], int n)\n{\n    int mp[10000];\n    for(int i=0;i<n-1;i++)\n    {\n        for(int j=i+1;j<n;j++)\n        {\n            mp[arr[i]+arr[j]]=(i,j);\n        }\n    }\n    int d=-10^9;\n    for(int i=0;i<n-1;i++)\n    {\n        for(int j=i+1;j<n;j++)\n        {\n            int abs_diff=abs(arr[i]-arr[j]);\n            if(abs_diff in mp.keys())\n            {\n                p=mp[abs_diff];\n                if((p[0]!=i && p[0]!=j && p[1]!=i && p[1]!=j))\n                {\n                    d=max(d,max(arr[i],arr[j]));\n                }\n            }\n        }\n    }\n    return d;\n}", "43": "#include <stdio.h> \nint temp;\nvoid leftRotatebyOne(int arr[], int n) \n{ \n    temp = arr[0]; \n    for (int i = 0; i < n - 1; i++) \n        arr[i] = arr[i + 1]; \n    arr[n - 1] = temp; \n} \nvoid leftRotate(int arr[], int d, int n) \n{ \n    for (int i = 0; i < d; i++) \n        leftRotatebyOne(arr, n); \n} \nvoid printArray(int arr[], int n) \n{ \n    for (int i = 0; i < n; i++) \n        printf(\"%d \", arr[i]); \n} \nint main() \n{ \n    int arr[] = { 1, 2, 3, 4, 5, 6, 7 }; \n    leftRotate(arr, 2, 7); \n    printArray(arr, 7); \n    return 0; \n}", "44": "void pushZerosToEnd(int arr[], int n)\n{\n    int count = 0;  \n    for (int i = 0; i < n; i++)\n        if (arr[i] != 0)\n            arr[count++] = arr[i]; \n    while (count < n)\n        arr[count++] = 0;\n}", "45": "void moveZerosToEnd(int arr[], int n) \n{ \n    int count = 0; \n  \n    for (int i = 0; i < n; i++) \n        if (arr[i] != 0) \n            swap(arr[count++], arr[i]); \n} \n  \nvoid printArray(int arr[], int n) \n{ \n    for (int i = 0; i < n; i++) \n        cout << arr[i] << \" \"; \n}", "46": "void pushZerosToEnd(int arr[], int n){\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n                if(arr[i] != 0){\n                        arr[count] = arr[i];\n                        count++;\n                }\n        }\n        while (count < n) {\n                arr[count] = 0;\n                count++;\n        }\n}\nvoid modifyAndRearrangeArr(int arr[], int n){\n        if (n == 1) {\n                return;\n        }\n        for (int i = 0; i < n - 1; i++) {\n                if ((arr[i] != 0) && (arr[i] == arr[i + 1])) {\n                        arr[i] = 2 * arr[i];\n                        arr[i + 1] = 0;\n                        i++;\n                }\n        }\n        pushZerosToEnd(arr, n);\n}\nvoid printArray(int arr[], int n){\n        for (int i = 0; i < n; i++) {\n                printf(\"%d \", arr[i]);\n        }\n}", "47": "void shiftAllZeroToLeft(int arr[], int n) \n{ \n    int lastSeenNonZero = 0; \n    for (int index = 0; index < n; ++index)  \n    { \n        if (arr[index] != 0) \n        { \n            arr[index], arr[lastSeenNonZero] = arr[lastSeenNonZero], arr[index]; \n            lastSeenNonZero+=1; \n        } \n    } \n}", "48": "void printArray(int arr[], int n) \n{ \n    for (int i = 0; i < n; i++) \n        printf(\"%d \", arr[i]); \n    printf(\"\\n\"); \n} \n  \nvoid RearrangePosNeg(int arr[], int n) \n{ \n    for (int i = 1; i < n; i++) { \n        int key = arr[i]; \n        if (key > 0) \n            continue; \n        int j = i - 1; \n        while (j >= 0 && arr[j] > 0) { \n            arr[j + 1] = arr[j]; \n            j = j - 1; \n        } \n        arr[j + 1] = key; \n    } \n}"}}, "Java - C#": {"ID": {"0": 451, "1": 455, "2": 496, "3": 617, "4": 647, "5": 649, "6": 803, "7": 815, "8": 818, "9": 821, "10": 832, "11": 833, "12": 846, "13": 861, "14": 862, "15": 883, "16": 895, "17": 918, "18": 919, "19": 920, "20": 926, "21": 927, "22": 953, "23": 955, "24": 956, "25": 958, "26": 959, "27": 965, "28": 966, "29": 1045, "30": 1064, "31": 1065, "32": 1072, "33": 1073, "34": 1074, "35": 1075, "36": 1132, "37": 1252, "38": 1253, "39": 1344, "40": 1345, "41": 1346, "42": 1366, "43": 1390, "44": 1405, "45": 1406, "46": 1428, "47": 1468, "48": 1469, "49": 1473}, "Java": {"0": "static int minCost(int cost[][])\n        {\n                int dist[] = new int[N];\n                for (int i=0; i<N; i++)\n                dist[i] = INF;\n                dist[0] = 0;\n                for (int i=0; i<N; i++)\n                for (int j=i+1; j<N; j++)\n                        if (dist[j] > dist[i] + cost[i][j])\n                                dist[j] = dist[i] + cost[i][j];\n                return dist[N-1];\n        }", "1": "static int numOfways(int n, int k)\n        {\n                int p = 1;\n                if (k % 2 != 0)\n                        p = -1;\n                return (int)(Math.pow(n - 1, k)\n                                        + p * (n - 1)) / n;\n        }", "2": "static int fib(int n)\n        {\n                if (n <= 1)\n                        return n;\n                return fib(n - 1) + fib(n - 2);\n        }\nstatic int findVertices (int n)\n        {\n                return fib(n + 2);\n        }", "3": "static Node reverse( Node head_ref)\n{\n        Node temp = null;\n        Node current = head_ref;\n        while (current != null)\n        {\n                temp = current.prev;\n                current.prev = current.next;\n                current.next = temp;\n                current = current.prev;\n        }\n        if (temp != null)\n                head_ref = temp.prev;\n                return head_ref;\n}\nstatic Node merge(Node first, Node second)\n{\n        if (first == null)\n                return second;\n        if (second == null)\n                return first;\n        if (first.data < second.data)\n        {\n                first.next = merge(first.next, second);\n                first.next.prev = first;\n                first.prev = null;\n                return first;\n        }\n        else\n        {\n                second.next = merge(first, second.next);\n                second.next.prev = second;\n                second.prev = null;\n                return second;\n        }\n}\nstatic Node sort(Node head)\n{\n        if (head == null head.next == null)\n                return head;\n        Node current = head.next;\n        while (current != null)\n        {\n                if (current.data < current.prev.data)\n                        break;\n                current = current.next;\n        }\n        if (current == null)\n                return head;\n        current.prev.next = null;\n        current.prev = null;\n        current = reverse(current);\n        return merge(head, current);\n}\nstatic Node push( Node head_ref, int new_data)\n{\n        Node new_node = new Node();\n        new_node.data = new_data;\n        new_node.prev = null;\n        new_node.next = (head_ref);\n        if ((head_ref) != null)\n                (head_ref).prev = new_node;\n        (head_ref) = new_node;\n        return head_ref;\n}\nstatic void printList( Node head)\n{\n        if (head == null)\n                System.out.println(\"Doubly Linked list empty\");\n        while (head != null)\n        {\n                System.out.print(head.data + \" \");\n                head = head.next;\n        }\n}", "4": "static Node newNode(char key)\n{\n        Node temp = new Node();\n        temp.data = key;\n        temp.next = null;\n        return temp;\n}\nstatic void printlist(Node head)\n{\n        if (head == null)\n        {\n                System.out.println(\"Empty List\");\n                return;\n        }\n        while (head != null)\n        {\n                System.out.print(head.data +\" \");\n                if (head.next != null)\n                System.out.print(\"-> \");\n                head = head.next;\n        }\n        System.out.println();\n}\nstatic boolean isVowel(char x)\n{\n        return (x == 'a' x == 'e' x == 'i' x == 'o' x == 'u');\n}\nstatic Node arrange(Node head)\n{\n        Node newHead = head;\n        Node latestVowel;\n        Node curr = head;\n        if (head == null)\n                return null;\n        if (isVowel(head.data) == true)\n                latestVowel = head;\n        else\n        {\n                while (curr.next != null &&\n                        !isVowel(curr.next.data))\n                        curr = curr.next;\n                if (curr.next == null)\n                        return head;\n                latestVowel = newHead = curr.next;\n                curr.next = curr.next.next;\n                latestVowel.next = head;\n        }\n        while (curr != null && curr.next != null)\n        {\n                if (isVowel(curr.next.data) == true)\n                {\n                        if (curr == latestVowel)\n                        {\n                                latestVowel = curr = curr.next;\n                        }\n                        else\n                        {\n                                Node temp = latestVowel.next;\n                                latestVowel.next = curr.next;\n                                latestVowel = latestVowel.next;\n                                curr.next = curr.next.next;\n                                latestVowel.next = temp;\n                        }\n                }\n                else\n                {\n                        curr = curr.next;\n                }\n        }\n        return newHead;\n}", "5": "static Node newNode(int data)\n{\n        Node temp = new Node();\n        temp.data = data;\n        temp.right = null;\n        temp.left = null;\n        return temp;\n}\nstatic Node KthLargestUsingMorrisTraversal(Node root, int k)\n{\n        Node curr = root;\n        Node Klargest = null;\n        int count = 0;\n        while (curr != null)\n        {\n                if (curr.right == null)\n                {\n                        if (++count == k)\n                                Klargest = curr;\n                        curr = curr.left;\n                }\n                else\n                {\n                        Node succ = curr.right;\n                        while (succ.left != null && succ.left != curr)\n                                succ = succ.left;\n                        if (succ.left == null)\n                        {\n                                succ.left = curr;\n                                curr = curr.right;\n                        }\n                        else\n                        {\n                                succ.left = null;\n                                if (++count == k)\n                                        Klargest = curr;\n                                curr = curr.left;\n                        }\n                }\n        }\n        return Klargest;\n}", "6": "static void sortByRow(Integer mat[][], int n, boolean ascending)\n        {\n                for (int i = 0; i < n; i++)\n                {\n                        if (ascending)\n                                Arrays.sort(mat[i]);\n                        else\n                                Arrays.sort(mat[i],Collections.reverseOrder());\n                }        \n        }\nstatic void transpose(Integer mat[][], int n)\n        {\n                for (int i = 0; i < n; i++)\n                        for (int j = i + 1; j < n; j++)\n                        {\n                                int temp = mat[i][j];\n                                mat[i][j] = mat[j][i];\n                                mat[j][i] = temp;\n                        }\n        }\nstatic void sortMatRowAndColWise(Integer mat[][], int n)\n        {\n                sortByRow(mat, n, true);\n                transpose(mat, n);\n                sortByRow(mat, n, false);\n                transpose(mat, n);\n        }\nstatic void printMat(Integer mat[][], int n)\n        {\n                for (int i = 0; i < n; i++)\n                {\n                        for (int j = 0; j < n; j++)\n                                System.out.print(mat[i][j] + \" \");\n                        System.out.println();\n                }\n        }", "7": "static void sortByRow(int mat[][], int n)\n        {\n                for (int i = 0; i < n; i++)\n                        Arrays.sort(mat[i]);\n        }\nstatic void transpose(int mat[][], int n)\n        {\n                for (int i = 0; i < n; i++)\n                        for (int j = i + 1; j < n; j++)\n                                {\n                                int temp=mat[i][j];\n                                mat[i][j]=mat[j][i];\n                                mat[j][i]=temp;\n                                }\n        }\nstatic void sortMatRowAndColWise(int mat[][],int n)\n        {\n                sortByRow(mat, n);\n                transpose(mat, n);\n                sortByRow(mat, n);\n                transpose(mat, n);\n        }\nstatic void printMat(int mat[][], int n)\n        {\n                for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < n; j++)\n                                System.out.print(mat[i][j] + \" \");\n                        System.out.println();\n                }\n        }", "8": "static void doublyEven(int n)\n        {\n                int[][] arr = new int[n][n];\n                int i, j;\n                for ( i = 0; i < n; i++)\n                        for ( j = 0; j < n; j++)\n                                arr[i][j] = (n*i) + j + 1;\n                for ( i = 0; i < n/4; i++)\n                        for ( j = 0; j < n/4; j++)\n                                arr[i][j] = (n*n + 1) - arr[i][j];\n                for ( i = 0; i < n/4; i++)\n                        for ( j = 3 * (n/4); j < n; j++)\n                                arr[i][j] = (n*n + 1) - arr[i][j];\n                for ( i = 3 * n/4; i < n; i++)\n                        for ( j = 0; j < n/4; j++)\n                                arr[i][j] = (n*n+1) - arr[i][j];\n                for ( i = 3 * n/4; i < n; i++)\n                        for ( j = 3 * n/4; j < n; j++)\n                                arr[i][j] = (n*n + 1) - arr[i][j];\n                for ( i = n/4; i < 3 * n/4; i++)\n                        for ( j = n/4; j < 3 * n/4; j++)\n                                arr[i][j] = (n*n + 1) - arr[i][j];\n                for (i = 0; i < n; i++)\n                {\n                        for ( j = 0; j < n; j++)\n                                System.out.print(arr[i][j]+\" \");\n                        System.out.println();\n                }\n        }", "9": "static void Kroneckerproduct(int A[][], int B[][])\n        {\n                int[][] C= new int[rowa * rowb][cola * colb];\n                for (int i = 0; i < rowa; i++)\n                {\n                        for (int k = 0; k < rowb; k++)\n                        {\n                                for (int j = 0; j < cola; j++)\n                                {\n                                        for (int l = 0; l < colb; l++)\n                                        {\n                                                C[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n                                                System.out.print( C[i + l + 1][j + k + 1]+\" \");\n                                        }\n                                }\n                                System.out.println();\n                        }\n                }\n        }", "10": "boolean isLowerTriangularMatrix(int mat[][])\n        {\n                for (int i = 0; i < N; i++)\n                        for (int j = i + 1; j < N; j++)\n                                if (mat[i][j] != 0)\n                                        return false;\n                return true;\n        }", "11": "public static Boolean isUpperTriangularMatrix(int mat[][])\n        {\n                for (int i = 1; i < N ; i++)\n                        for (int j = 0; j < i; j++)\n                                if (mat[i][j] != 0)\n                                        return false;\n                return true;\n        }", "12": "static long countSets(int a[][]) {\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n        int u = 0, v = 0;\n        for (int j = 0; j < m; j++) {\n                if (a[i][j] == 1)\n                u++;\n                else\n                v++;\n        }\n        res += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n        }\n        for (int i = 0; i < m; i++) {\n        int u = 0, v = 0;\n        for (int j = 0; j < n; j++) {\n                if (a[j][i] == 1)\n                u++;\n                else\n                v++;\n        }\n        res += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n        }\n        return res - (n * m);\n}", "13": "static void transpose(int mat[][], int tr[][], int N)\n{\n        for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                        tr[i][j] = mat[j][i];\n}\nstatic boolean isSymmetric(int mat[][], int N)\n{\n        int tr[][] = new int[N][MAX];\n        transpose(mat, tr, N);\n        for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                        if (mat[i][j] != tr[i][j])\n                                return false;\n        return true;\n}", "14": "static boolean isSymmetric(int mat[][], int N)\n{\n        for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                        if (mat[i][j] != mat[j][i])\n                                return false;\n        return true;\n}", "15": "static int findNormal(int mat[][], int n)\n{\n        int sum = 0;\n        for (int i=0; i<n; i++)\n                for (int j=0; j<n; j++)\n                        sum += mat[i][j]*mat[i][j];\n        return (int)Math.sqrt(sum);\n}\nstatic int findTrace(int mat[][], int n)\n{\n        int sum = 0;\n        for (int i=0; i<n; i++)\n                sum += mat[i][i];\n        return sum;\n}", "16": "static int maxDet(int n)\n{\n        return (2 * n * n * n);\n}\nvoid resMatrix(int n)\n{\n        for (int i = 0; i < 3; i++)\n        {\n                for (int j = 0; j < 3; j++)\n                {\n                        if (i == 0 && j == 2)\n                                System.out.print(\"0 \");\n                        else if (i == 1 && j == 0)\n                                System.out.print(\"0 \");\n                        else if (i == 2 && j == 1)\n                                System.out.print(\"0 \");\n                        else\n                                System.out.print(n +\" \");\n                }\n                System.out.println(\"\");\n        }\n}", "17": "static int countNegative(int M[][], int n, int m)\n        {\n                int count = 0;\n                for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < m; j++) {\n                                if (M[i][j] < 0)\n                                        count += 1;\n                                else\n                                        break;\n                        }\n                }\n                return count;\n        }", "18": "static int countNegative(int M[][], int n, int m)\n        {\n                int count = 0;\n                int i = 0;\n                int j = m - 1;\n                while (j >= 0 && i < n) {\n                        if (M[i][j] < 0) {\n                                count += j + 1;\n                                i += 1;\n                        }\n                        else\n                                j -= 1;\n                }\n                return count;\n        }", "19": "static int getLastNegativeIndex(int array[], int start, int end)\n        {\n                if (start == end) {\n                        return start;\n                }\n                int mid = start + (end - start) / 2;\n                if (array[mid] < 0) {\n                        if (mid + 1 < array.length && array[mid + 1] >= 0) {\n                                return mid;\n                        }\n                        return getLastNegativeIndex(array, mid + 1, end);\n                }\n                else {\n                        return getLastNegativeIndex(array, start, mid - 1);\n                }\n        }\nstatic int countNegative(int M[][], int n, int m)\n        {\n                int count = 0;\n                int nextEnd = m - 1;\n                for (int i = 0; i < n; i++) {\n                        if (M[i][0] >= 0) {\n                                break;\n                        }\n                        nextEnd = getLastNegativeIndex(M[i], 0, nextEnd);\n                        count += nextEnd + 1;\n                }\n                return count;\n        }", "20": "static int findMaxValue(int N,int mat[][])\n        {\n                int maxValue = Integer.MIN_VALUE;\n                for (int a = 0; a < N - 1; a++)\n                for (int b = 0; b < N - 1; b++)\n                        for (int d = a + 1; d < N; d++)\n                        for (int e = b + 1; e < N; e++)\n                                if (maxValue < (mat[d][e] - mat[a][b]))\n                                        maxValue = mat[d][e] - mat[a][b];\n                return maxValue;\n        }", "21": "static int findMaxValue(int N,int mat[][])\n        {\n                int maxValue = Integer.MIN_VALUE;\n                int maxArr[][] = new int[N][N];\n                maxArr[N-1][N-1] = mat[N-1][N-1];\nint maxv = mat[N-1][N-1]; \n                for (int j = N - 2; j >= 0; j--)\n                {\n                        if (mat[N-1][j] > maxv)\n                                maxv = mat[N - 1][j];\n                        maxArr[N-1][j] = maxv;\n                }\nmaxv = mat[N - 1][N - 1]; \n                for (int i = N - 2; i >= 0; i--)\n                {\n                        if (mat[i][N - 1] > maxv)\n                                maxv = mat[i][N - 1];\n                        maxArr[i][N - 1] = maxv;\n                }\n                for (int i = N-2; i >= 0; i--)\n                {\n                        for (int j = N-2; j >= 0; j--)\n                        {\n                                if (maxArr[i+1][j+1] - mat[i][j] > maxValue)\n                                        maxValue = maxArr[i + 1][j + 1] - mat[i][j];\n                                maxArr[i][j] = Math.max(mat[i][j],\n                                                                Math.max(maxArr[i][j + 1], maxArr[i + 1][j]) );\n                        }\n                }\n                return maxValue;\n        }", "22": "static void youngify(int mat[][], int i, int j)\n        {\n                int downVal = (i + 1 < N) ?\n                                        mat[i + 1][j] : INF;\n                int rightVal = (j + 1 < N) ?\n                                        mat[i][j + 1] : INF;\n                if (downVal == INF && rightVal == INF)\n                {\n                        return;\n                }\n                if (downVal < rightVal)\n                {\n                        mat[i][j] = downVal;\n                        mat[i + 1][j] = INF;\n                        youngify(mat, i + 1, j);\n                }\n                else\n                {\n                        mat[i][j] = rightVal;\n                        mat[i][j + 1] = INF;\n                        youngify(mat, i, j + 1);\n                }\n        }\nstatic int extractMin(int mat[][])\n        {\n                int ret = mat[0][0];\n                mat[0][0] = INF;\n                youngify(mat, 0, 0);\n                return ret;\n        }\nstatic void printSorted(int mat[][])\n        {\n                System.out.println(\"Elements of matrix in sorted order n\");\n                for (int i = 0; i < N * N; i++)\n                {\n                        System.out.print(extractMin(mat) + \" \");\n                }\n        }", "23": "static void printSumSimple(int mat[][], int k)\n        {\n                if (k > n) return;\n                for (int i = 0; i < n-k+1; i++)\n                {\n                        for (int j = 0; j < n-k+1; j++)\n                        {\n                                int sum = 0;\n                                for (int p = i; p < k+i; p++)\n                                        for (int q = j; q < k+j; q++)\n                                                sum += mat[p][q];\n                                System.out.print(sum+ \" \");\n                        }\n                        System.out.println();\n                }\n        }", "24": "static void printSumTricky(int mat[][], int k) {\n        if (k > n)\n        return;\n        int stripSum[][] = new int[n][n];\n        for (int j = 0; j < n; j++) {\n        int sum = 0;\n        for (int i = 0; i < k; i++)\n                sum += mat[i][j];\n        stripSum[0][j] = sum;\n        for (int i = 1; i < n - k + 1; i++) {\n                sum += (mat[i + k - 1][j] - mat[i - 1][j]);\n                stripSum[i][j] = sum;\n        }\n        }\n        for (int i = 0; i < n - k + 1; i++) {\n        int sum = 0;\n        for (int j = 0; j < k; j++)\n                sum += stripSum[i][j];\n        System.out.print(sum + \" \");\n        for (int j = 1; j < n - k + 1; j++) {\n                sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n                System.out.print(sum + \" \");\n        }\n        System.out.println();\n        }\n}", "25": "static void transpose(int A[][], int B[][])\n        {\n                int i, j;\n                for (i = 0; i < N; i++)\n                        for (j = 0; j < M; j++)\n                                B[i][j] = A[j][i];\n        }", "26": "static void transpose(int A[][])\n        {\n                for (int i = 0; i < N; i++)\n                        for (int j = i+1; j < N; j++)\n                        {\n                                int temp = A[i][j];\n                                A[i][j] = A[j][i];\n                                A[j][i] = temp;\n                        }\n        }", "27": "static int pathCountRec(int mat[][], int m, int n, int k) {\n                if (m < 0 n < 0) {\n                        return 0;\n                }\n                if (m == 0 && n == 0 && (k == mat[m][n])) {\n                        return 1;\n                }\n                return pathCountRec(mat, m - 1, n, k - mat[m][n])\n                                + pathCountRec(mat, m, n - 1, k - mat[m][n]);\n        }\nstatic int pathCount(int mat[][], int k) {\n                return pathCountRec(mat, R - 1, C - 1, k);\n        }", "28": "static int pathCountDPRecDP(int [][]mat, int m, int n, int k)\n        {\n                if (m < 0 n < 0) return 0;\n                if (m==0 && n==0) return (k == mat[m][n] ? 1 : 0);\n                if (dp[m][n][k] != -1) return dp[m][n][k];\n                dp[m][n][k] = pathCountDPRecDP(mat, m-1, n, k-mat[m][n]) +\n                                        pathCountDPRecDP(mat, m, n-1, k-mat[m][n]);\n                return dp[m][n][k];\n        }\nstatic int pathCountDP(int [][]mat, int k)\n        {\n                for(int i=0;i<R;i++)\n                        for(int j=0;j<C;j++)\n                                for(int l=0;l<MAX_K;l++)\n                                dp[i][j][l]=-1;\n                return pathCountDPRecDP(mat, R-1, C-1, k);\n        }", "29": "static boolean check(int A[], int N) {\n                Stack<Integer> S = new Stack<Integer>();\n                int B_end = 0;\n                for (int i = 0; i < N; i++) {\n                        if (!S.empty()) {\n                                int top = S.peek();\n                                while (top == B_end + 1) {\n                                        B_end = B_end + 1;\n                                        S.pop();\n                                        if (S.empty()) {\n                                                break;\n                                        }\n                                        top = S.peek();\n                                }\n                                if (S.empty()) {\n                                        S.push(A[i]);\n                                } else {\n                                        top = S.peek();\n                                        if (A[i] < top) {\n                                                S.push(A[i]);\n} \n                                        else {\n                                                return false;\n                                        }\n                                }\n                        } else {\n                                S.push(A[i]);\n                        }\n                }\n                return true;\n        }", "30": "static int countMinReversals(String expr)\n        {\n                int len = expr.length();\n                if (len%2 != 0)\n                return -1;\n                Stack<Character> s=new Stack<>();\n                for (int i=0; i<len; i++)\n                {\n                        char c = expr.charAt(i);\n                        if (c =='}' && !s.empty())\n                        {\n                                if (s.peek()=='{')\n                                        s.pop();\n                                else\n                                        s.push(c);\n                        }\n                        else\n                                s.push(c);\n                }\n                int red_len = s.size();\n                int n = 0;\n                while (!s.empty() && s.peek() == '{')\n                {\n                        s.pop();\n                        n++;\n                }\n                return (red_len/2 + n%2);\n        }", "31": "static int countMinReversals(String expr)\n        {\n                int len = expr.length();\n                int ans;\n                if (len % 2 != 0) {\n                        return -1;\n                }\n                int left_brace = 0, right_brace = 0;\n                for (int i = 0; i < len; i++) {\n                        char ch = expr.charAt(i);\n                        if (ch == '{') {\n                                left_brace++;\n                        }\n                        else {\n                                if (left_brace == 0) {\n                                        right_brace++;\n                                }\n                                else {\n                                        left_brace--;\n                                }\n                        }\n                }\n                ans = (int)(Math.ceil((0.0 + left_brace) / 2)\n                                        + Math.ceil((0.0 + right_brace) / 2));\n                return ans;\n        }", "32": "static void PrintMinNumberForPattern(String arr)\n        {\n                int curr_max = 0;\n                int last_entry = 0;\n                int j;\n                for (int i = 0; i < arr.length(); i++)\n                {\n                        int noOfNextD = 0;\n                        switch (arr.charAt(i))\n                        {\n                                case 'I':\n                                        j = i + 1;\n                                        while (j < arr.length() && arr.charAt(j) == 'D')\n                                        {\n                                                noOfNextD++;\n                                                j++;\n                                        }\n                                        if (i == 0)\n                                        {\n                                                curr_max = noOfNextD + 2;\n                                                System.out.print(\" \" + ++last_entry);\n                                                System.out.print(\" \" + curr_max);\n                                                last_entry = curr_max;\n                                        }\n                                        else\n                                        {\n                                                curr_max = curr_max + noOfNextD + 1;\n                                                last_entry = curr_max;\n                                                System.out.print(\" \" + last_entry);\n                                        }\n                                        for (int k = 0; k < noOfNextD; k++)\n                                        {\n                                                System.out.print(\" \" + --last_entry);\n                                                i++;\n                                        }\n                                        break;\n                                case 'D':\n                                        if (i == 0)\n                                        {\n                                                j = i + 1;\n                                                while (j < arr.length()&&arr.charAt(j) == 'D')\n                                                {\n                                                        noOfNextD++;\n                                                        j++;\n                                                }\n                                                curr_max = noOfNextD + 2;\n                                                System.out.print(\" \" + curr_max + \" \" + (curr_max - 1));\n                                                last_entry = curr_max - 1;\n                                        }\n                                        else\n                                        {\n                                                System.out.print(\" \" + (last_entry - 1));\n                                                last_entry--;\n                                        }\n                                        break;\n                        }\n                }\n                System.out.println();\n        }", "33": "static void printLeast(String arr)\n        {\n                        int min_avail = 1, pos_of_I = 0;\n                        ArrayList<Integer> al = new ArrayList<>();\n                        if (arr.charAt(0) == 'I')\n                        {\n                                al.add(1);\n                                al.add(2);\n                                min_avail = 3;\n                                pos_of_I = 1;\n                        }\n                        else\n                        {\n                                al.add(2);\n                                al.add(1);\n                                min_avail = 3;\n                                pos_of_I = 0;\n                        }\n                        for (int i = 1; i < arr.length(); i++)\n                        {\n                                if (arr.charAt(i) == 'I')\n                                {\n                                        al.add(min_avail);\n                                        min_avail++;\n                                        pos_of_I = i + 1;\n                                }\n                                else\n                                {\n                                        al.add(al.get(i));\n                                        for (int j = pos_of_I; j <= i; j++)\n                                                        al.set(j, al.get(j) + 1);\n                                        min_avail++;\n                                }\n                        }\n                        for (int i = 0; i < al.size(); i++)\n                                System.out.print(al.get(i) + \" \");\n                        System.out.println();\n        }", "34": "static void PrintMinNumberForPattern(String seq) {\n                String result = \"\";\n                Stack<Integer> stk = new Stack<Integer>();\n                for (int i = 0; i <= seq.length(); i++) {\n                        stk.push(i + 1);\n                        if (i == seq.length() || seq.charAt(i) == 'I') {\n                                while (!stk.empty()) {\n                                        result += String.valueOf(stk.peek());\n                                        result += \" \";\n                                        stk.pop();\n                                }\n                        }\n                }\n                System.out.println(result);\n        }", "35": "static String getMinNumberForPattern(String seq)\n        {\n                int n = seq.length();\n                if (n >= 9)\n                        return \"-1\";\n                char result[] = new char[n + 1];\n                int count = 1;\n                for (int i = 0; i <= n; i++)\n                {\n                        if (i == n || seq.charAt(i) == 'I')\n                        {\n                                for (int j = i - 1; j >= -1; j--)\n                                {\n                                        result[j + 1] = (char) ((int) '0' + count++);\n                                        if (j >= 0 && seq.charAt(j) == 'I')\n                                                break;\n                                }\n                        }\n                }\n                return new String(result);\n        }", "36": "public int compare(Key k1, Key k2)\n        {\n                if (k1.freq < k2.freq)\n                        return 1;\n                else if (k1.freq > k2.freq)\n                        return -1;\n                return 0;\n        }\nstatic void rearrangeString(String str)\n        {\n                int n = str.length();\n                int[] count = new int[MAX_CHAR];\n                for (int i = 0; i < n; i++)\n                        count[str.charAt(i) - 'a']++;\n                PriorityQueue<Key> pq\n                        = new PriorityQueue<>(new KeyComparator());\n                for (char c = 'a'; c <= 'z'; c++) {\n                        int val = c - 'a';\n                        if (count[val] > 0)\n                                pq.add(new Key(count[val], c));\n                }\n                str = \"\";\n                Key prev = new Key(-1, '#');\n                while (pq.size() != 0) {\n                        Key k = pq.peek();\n                        pq.poll();\n                        str = str + k.ch;\n                        if (prev.freq > 0)\n                                pq.add(prev);\n                        (k.freq)--;\n                        prev = k;\n                }\n                if (n != str.length())\n                        System.out.println(\" Not valid String \");\n                else\n                        System.out.println(str);\n        }", "37": "public static int subset(int ar[], int n)\n        {\n                int res = 0;\n                Arrays.sort(ar);\n                for (int i = 0; i < n; i++) {\n                        int count = 1;\n                        for (; i < n - 1; i++) {\n                                if (ar[i] == ar[i + 1])\n                                        count++;\n                                else\n                                        break;\n                        }\n                        res = Math.max(res, count);\n                }\n                return res;\n        }", "38": "static int subset(int arr[], int n)\n{\n        HashMap<Integer, Integer> mp = new HashMap<>();\n        for (int i = 0; i < n; i++)\n                mp.put(arr[i],mp.get(arr[i]) == null?1:mp.get(arr[i])+1);\n        int res = 0;\n        for (Map.Entry<Integer,Integer> entry : mp.entrySet())\n        res = Math.max(res, entry.getValue());\n        return res;\n}", "39": "static boolean areElementsContiguous(int arr[], int n)\n        {\n        Arrays.sort(arr);\n        for (int i = 1; i < n; i++)\n                if (arr[i] - arr[i-1] > 1)\n                        return false;\n        return true; \n        }", "40": "static boolean areElementsContiguous(int arr[], int n)\n        {\n                int max = Integer.MIN_VALUE;\n                int min = Integer.MAX_VALUE;\n                for(int i = 0; i < n; i++)\n                {\n                        max = Math.max(max, arr[i]);\n                        min = Math.min(min, arr[i]);\n                }\n                int m = max - min + 1;\n                if (m > n)\n                        return false;\n                boolean visited[] = new boolean[n];\n                for (int i = 0; i < n; i++) \n                visited[arr[i] - min] = true;\n                for (int i = 0; i < m; i++)\n                if (visited[i] == false)\n                                return false;\n                return true;\n        }", "41": "static Boolean areElementsContiguous(int arr[], int n)\n        {\n                HashSet<Integer> us = new HashSet<Integer>();\n                for (int i = 0; i < n; i++)\n                        us.add(arr[i]);\n                int count = 1;\n                int curr_ele = arr[0] - 1;\n                while (us.contains(curr_ele) == true) {\n                        count++;\n                        curr_ele--;\n                }\n                curr_ele = arr[0] + 1;\n                while (us.contains(curr_ele) == true) {\n                        count++;\n                        curr_ele++;\n                }\n                return (count == (us.size()));\n        }", "42": "static void longest(int a[], int n, int k)\n{\n        int[] freq = new int[7];\n        int start = 0, end = 0, now = 0, l = 0;\n        for (int i = 0; i < n; i++)\n        {\n                freq[a[i]]++;\n                if (freq[a[i]] == 1)\n                        now++;\n                while (now > k)\n                {\n                        freq[a[l]]--;\n                        if (freq[a[l]] == 0)\n                                now--;\n                        l++;\n                }\n                if (i - l + 1 >= end - start + 1)\n                {\n                        end = i;\n                        start = l;\n                }\n        }\n        for (int i = start; i <= end; i++)\n                System.out.print(a[i]+\" \");\n}", "43": "static void findSmallestRange(int arr[][], int n, int k)\n        {\n                int i, minval, maxval, minrange, minel = 0, maxel = 0, flag, minind;\n                for (i = 0; i <= k; i++) {\n                        ptr[i] = 0;\n                }\n                minrange = Integer.MAX_VALUE;\n                while (true) {\n                        minind = -1;\n                        minval = Integer.MAX_VALUE;\n                        maxval = Integer.MIN_VALUE;\n                        flag = 0;\n                        for (i = 0; i < k; i++) {\n                                if (ptr[i] == n) {\n                                        flag = 1;\n                                        break;\n                                }\n                                if (ptr[i] < n && arr[i][ptr[i]] < minval) {\nminind = i; \n                                        minval = arr[i][ptr[i]];\n                                }\n                                if (ptr[i] < n && arr[i][ptr[i]] > maxval) {\n                                        maxval = arr[i][ptr[i]];\n                                }\n                        }\n                        if (flag == 1) {\n                                break;\n                        }\n                        ptr[minind]++;\n                        if ((maxval - minval) < minrange) {\n                                minel = minval;\n                                maxel = maxval;\n                                minrange = maxel - minel;\n                        }\n                }\n                System.out.printf(\"The smallest range is [%d, %d]\\n\", minel, maxel);\n        }", "44": "static int findLargestd(int []S, int n)\n{\n        boolean found = false;\n        Arrays.sort(S);\n        for (int i = n - 1; i >= 0; i--)\n        {\n                for (int j = 0; j < n; j++)\n                {\n                        if (i == j)\n                                continue;\n                        for (int k = j + 1; k < n; k++)\n                        {\n                                if (i == k)\n                                        continue;\n                                for (int l = k + 1; l < n; l++)\n                                {\n                                        if (i == l)\n                                                continue;\n                                        if (S[i] == S[j] + S[k] + S[l])\n                                        {\n                                                found = true;\n                                                return S[i];\n                                        }\n                                }\n                        }\n                }\n        }\n        if (found == false)\n                return Integer.MAX_VALUE;\n        return -1;\n}", "45": "int getI()\n        {\n                return i;\n        }\nint getJ()\n        {\n                return j;\n        }\nstatic int findFourElements(int[] arr, int n)\n        {\n                HashMap<Integer, Indexes> map = new HashMap<>();\n                for (int i = 0; i < n - 1; i++)\n                {\n                        for (int j = i + 1; j < n; j++)\n                        {\n                                map.put(arr[i] + arr[j], new Indexes(i, j));\n                        }\n                }\n                int d = Integer.MIN_VALUE;\n                for (int i = 0; i < n - 1; i++)\n                {\n                        for (int j = i + 1; j < n; j++)\n                        {\n                                int abs_diff = Math.abs(arr[i] - arr[j]);\n                                if (map.containsKey(abs_diff))\n                                {\n                                        Indexes indexes = map.get(abs_diff);\n                                        if (indexes.getI() != i && indexes.getI() != j &&\n                                        indexes.getJ() != i && indexes.getJ() != j)\n                                        {\n                                                d = Math.max(d, Math.max(arr[i], arr[j]));\n                                        }\n                                }\n                        }\n                }\n                return d;\n        }", "46": "void leftRotatebyOne(int arr[], int n)\n        {\n                int i, temp;\n                temp = arr[0];\n                for (i = 0; i < n - 1; i++)\n                        arr[i] = arr[i + 1];\n                arr[n-1] = temp;\n        }\nvoid leftRotate(int arr[], int d, int n)\n        {\n                for (int i = 0; i < d; i++)\n                        leftRotatebyOne(arr, n);\n        }\nvoid printArray(int arr[], int n)\n        {\n                for (int i = 0; i < n; i++)\n                        System.out.print(arr[i] + \" \");\n        }", "47": "static void pushZerosToEnd(int arr[], int n)\n        {\nint count = 0; \n                for (int i = 0; i < n; i++)\n                        if (arr[i] != 0)\narr[count++] = arr[i]; \n                while (count < n)\n                        arr[count++] = 0;\n        }", "48": "static void moveZerosToEnd(int arr[], int n) {\n        int count = 0;\n        int temp;\n        for (int i = 0; i < n; i++) {\n        if ((arr[i] != 0)) {\n                temp = arr[count];\n                arr[count] = arr[i];\n                arr[i] = temp;\n                count = count + 1;\n        }\n        }\n}\nstatic void printArray(int arr[], int n) {\n        for (int i = 0; i < n; i++)\n        System.out.print(arr[i] + \" \");\n}", "49": "static void pushZerosToEnd(int arr[], int n)\n        {\n                int count = 0;\n                for (int i = 0; i < n; i++)\n                        if (arr[i] != 0)\n                                arr[count++] = arr[i];\n                while (count < n)\n                        arr[count++] = 0;\n        }\nstatic void modifyAndRearrangeArr(int arr[], int n)\n        {\n                if (n == 1)\n                        return;\n                for (int i = 0; i < n - 1; i++) {\n                        if ((arr[i] != 0) && (arr[i] == arr[i + 1]))\n                        {\n                                arr[i] = 2 * arr[i];\n                                arr[i + 1] = 0;\n                                i++;\n                        }\n                }\n                pushZerosToEnd(arr, n);\n        }\nstatic void printArray(int arr[], int n)\n        {\n                for (int i = 0; i < n; i++)\n                        System.out.print(arr[i] + \" \");\n                System.out.println();\n        }"}, "c#": {"0": "static int minCost(int cost[][])\n        {\n                int dist[] = new int[N];\n                for (int i=0; i<N; i++)\n                dist[i] = INF;\n                dist[0] = 0;\n                for (int i=0; i<N; i++)\n                for (int j=i+1; j<N; j++)\n                        if (dist[j] > dist[i] + cost[i][j])\n                                dist[j] = dist[i] + cost[i][j];\n                return dist[N-1];\n        }", "1": "static int numOfWays(int n, int k)\n        {\n                int p = 1;\n                if (k % 2 != 0)\n                        p = -1;\n                return (int)(Math.Pow(n - 1, k)\n                                        + p * (n - 1)) / n;\n        }", "2": "static int Fib(int n)\n        {\n                if (n <= 1)\n                        return n;\n                return Fib(n - 1) + Fib(n - 2);\n        }\nstatic int FindVertices (int n)\n        {\n                return Fib(n + 2);\n        }", "3": "static Node reverse(Node head_ref)\n{\n        Node temp = null;\n        Node current = head_ref;\n        while (current != null)\n        {\n                temp = current.prev;\n                current.prev = current.next;\n                current.next = temp;\n                current = current.prev;\n        }\n        if (temp != null)\n                head_ref = temp.prev;\n        return head_ref;\n}\nstatic Node merge(Node first, Node second)\n{\n        if (first == null)\n                return second;\n        if (second == null)\n                return first;\n        if (first.data < second.data)\n        {\n                first.next = merge(first.next, second);\n                first.next.prev = first;\n                first.prev = null;\n                return first;\n        }\n        else\n        {\n                second.next = merge(first, second.next);\n                second.next.prev = second;\n                second.prev = null;\n                return second;\n        }\n}\nstatic Node sort(Node head)\n{\n        if (head == null head.next == null)\n                return head;\n        Node current = head.next;\n        while (current != null)\n        {\n                if (current.data < current.prev.data)\n                        break;\n                current = current.next;\n        }\n        if (current == null)\n                return head;\n        current.prev.next = null;\n        current.prev = null;\n        current = reverse(current);\n        return merge(head, current);\n}\nstatic Node push( Node head_ref, int new_data)\n{\n        Node new_node = new Node();\n        new_node.data = new_data;\n        new_node.prev = null;\n        new_node.next = (head_ref);\n        if ((head_ref) != null)\n                (head_ref).prev = new_node;\n        (head_ref) = new_node;\n        return head_ref;\n}\nstatic void printList( Node head)\n{\n        if (head == null)\n                System.out.println(\"Doubly Linked list empty\");\n        while (head != null)\n        {\n                System.out.print(head.data + \" \");\n                head = head.next;\n        }\n}", "4": "static Node newNode(char key)\n{\n        Node temp = new Node();\n        temp.data = key;\n        temp.next = null;\n        return temp;\n}\nstatic void printlist(Node head)\n{\n        if (head == null)\n        {\n                System.out.println(\"Empty List\");\n                return;\n        }\n        while (head != null)\n        {\n                System.out.print(head.data +\" \");\n                if (head.next != null)\n                System.out.print(\"-> \");\n                head = head.next;\n        }\n        System.out.println();\n}\nstatic boolean isVowel(char x)\n{\n        return (x == 'a' x == 'e' x == 'i' x == 'o' x == 'u');\n}\nstatic Node arrange(Node head)\n{\n        Node newHead = head;\n        Node latestVowel;\n        Node curr = head;\n        if (head == null)\n                return null;\n        if (isVowel(head.data) == true)\n                latestVowel = head;\n        else\n        {\n                while (curr.next != null &&\n                        !isVowel(curr.next.data))\n                        curr = curr.next;\n                if (curr.next == null)\n                        return head;\n                latestVowel = newHead = curr.next;\n                curr.next = curr.next.next;\n                latestVowel.next = head;\n        }\n        while (curr != null && curr.next != null)\n        {\n                if (isVowel(curr.next.data) == true)\n                {\n                        if (curr == latestVowel)\n                        {\n                                latestVowel = curr = curr.next;\n                        }\n                        else\n                        {\n                                Node temp = latestVowel.next;\n                                latestVowel.next = curr.next;\n                                latestVowel = latestVowel.next;\n                                curr.next = curr.next.next;\n                                latestVowel.next = temp;\n                        }\n                }\n                else\n                {\n                        curr = curr.next;\n                }\n        }\n        return newHead;\n}", "5": "static Node KthLargestUsingMorrisTraversal(Node root, int k)\n{\n        Node curr = root;\n        Node Klargest = null;\n        int count = 0;\n        while (curr != null)\n        {\n                if (curr.right == null)\n                {\n                        if (++count == k)\n                                Klargest = curr;\n                        curr = curr.left;\n                }\n                else\n                {\n                        Node succ = curr.right;\n                        while (succ.left != null && succ.left != curr)\n                                succ = succ.left;\n                        if (succ.left == null)\n                        {\n                                succ.left = curr;\n                                curr = curr.right;\n                        }\n                        else\n                        {\n                                succ.left = null;\n                                if (++count == k)\n                                        Klargest = curr;\n                                curr = curr.left;\n                        }\n                }\n        }\n        return Klargest;\n}", "6": "static void sortByRow(int[][] mat, int n, bool ascending)\n        {\n                for (int i = 0; i < n; i++)\n                {\n                        if (ascending)\n                                Array.Sort(mat[i]);\n                        else\n                                Array.Sort(mat[i],Collections.ReverseOrder());\n                }        \n        }\nstatic void transpose(int[][] mat, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        for (int j = i + 1; j < n; j++)\n                        {\n                                int temp = mat[i][j];\n                                mat[i][j] = mat[j][i];\n                                mat[j][i] = temp;\n                        }\n        }\nstatic void sortMatRowAndColWise(int[][] mat, int n)\n        {\n                sortByRow(mat, n, true);\n                transpose(mat, n);\n                sortByRow(mat, n, false);\n                transpose(mat, n);\n        }\nstatic void printMat(int[][] mat, int n)\n        {\n                for (int i = 0; i < n; i++)\n                {\n                        for (int j = 0; j < n; j++)\n                                Console.Write(mat[i][j] + \" \");\n                        Console.WriteLine();\n                }\n        }", "7": "static void sortByRow(int[,] mat, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        Array.Sort(mat, i*n, n);\n        }\nstatic void transpose(int[,] mat, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        for (int j = i + 1; j < n; j++)\n                                {\n                                int temp=mat[i,j];\n                                mat[i,j]=mat[j,i];\n                                mat[j,i]=temp;\n                                }\n        }\nstatic void sortMatRowAndColWise(int[,] mat,int n)\n        {\n                sortByRow(mat, n);\n                transpose(mat, n);\n                sortByRow(mat, n);\n                transpose(mat, n);\n        }\nstatic void printMat(int[,] mat, int n)\n        {\n                for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < n; j++)\n                                System.out.print(mat[i,j] + \" \");\n                        System.out.println();\n                }\n        }", "8": "static void doublyEven(int n)\n        {\n                int[][] arr = new int[n][n];\n                int i, j;\n                for ( i = 0; i < n; i++)\n                        for ( j = 0; j < n; j++)\n                                arr[i][j] = (n*i) + j + 1;\n                for ( i = 0; i < n/4; i++)\n                        for ( j = 0; j < n/4; j++)\n                                arr[i][j] = (n*n + 1) - arr[i][j];\n                for ( i = 0; i < n/4; i++)\n                        for ( j = 3 * (n/4); j < n; j++)\n                                arr[i][j] = (n*n + 1) - arr[i][j];\n                for ( i = 3 * n/4; i < n; i++)\n                        for ( j = 0; j < n/4; j++)\n                                arr[i][j] = (n*n+1) - arr[i][j];\n                for ( i = 3 * n/4; i < n; i++)\n                        for ( j = 3 * n/4; j < n; j++)\n                                arr[i][j] = (n*n + 1) - arr[i][j];\n                for ( i = n/4; i < 3 * n/4; i++)\n                        for ( j = n/4; j < 3 * n/4; j++)\n                                arr[i][j] = (n*n + 1) - arr[i][j];\n                for (i = 0; i < n; i++)\n                {\n                        for ( j = 0; j < n; j++)\n                                System.out.print(arr[i][j]+\" \");\n                        System.out.println();\n                }\n        }", "9": "static void Kroneckerproduct(int A[][], int B[][])\n        {\n                int[][] C= new int[rowa * rowb][cola * colb];\n                for (int i = 0; i < rowa; i++)\n                {\n                        for (int k = 0; k < rowb; k++)\n                        {\n                                for (int j = 0; j < cola; j++)\n                                {\n                                        for (int l = 0; l < colb; l++)\n                                        {\n                                                C[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n                                                System.out.print( C[i + l + 1][j + k + 1]+\" \");\n                                        }\n                                }\n                                System.out.println();\n                        }\n                }\n        }", "10": "bool IsLowerTriangularMatrix(int[][] mat)\n{\n        for (int i = 0; i < N; i++)\n                for (int j = i + 1; j < N; j++)\n                        if (mat[i][j] != 0)\n                                return false;\n        return true;\n}", "11": "public static bool isUpperTriangularMatrix(int[][] mat)\n{\n        for (int i = 1; i < N ; i++)\n                for (int j = 0; j < i; j++)\n                        if (mat[i][j] != 0)\n                                return false;\n        return true;\n}", "12": "static long CountSets(int[][] a) {\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n        int u = 0, v = 0;\n        for (int j = 0; j < m; j++) {\n                if (a[i][j] == 1)\n                u++;\n                else\n                v++;\n        }\n        res += Math.Pow(2, u) - 1 + Math.Pow(2, v) - 1;\n        }\n        for (int i = 0; i < m; i++) {\n        int u = 0, v = 0;\n        for (int j = 0; j < n; j++) {\n                if (a[j][i] == 1)\n                u++;\n                else\n                v++;\n        }\n        res += Math.Pow(2, u) - 1 + Math.Pow(2, v) - 1;\n        }\n        return res - (n * m);\n}", "13": "static void transpose(int[][] mat, int[][] tr, int N)\n{\n        for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                        tr[i][j] = mat[j][i];\n}\nstatic bool isSymmetric(int[][] mat, int N)\n{\n        int[][] tr = new int[N][MAX];\n        transpose(mat, tr, N);\n        for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                        if (mat[i][j] != tr[i][j])\n                                return false;\n        return true;\n}", "14": "static bool isSymmetric(int mat[][], int N)\n{\n        for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                        if (mat[i][j] != mat[j][i])\n                                return false;\n        return true;\n}", "15": "static int findNormal(int[,] mat, int n)\n{\n        int sum = 0;\n        for (int i=0; i<n; i++)\n                for (int j=0; j<n; j++)\n                        sum += mat[i,j]*mat[i,j];\n        return (int)Math.Sqrt(sum);\n}\nstatic int findTrace(int[,] mat, int n)\n{\n        int sum = 0;\n        for (int i=0; i<n; i++)\n                sum += mat[i,i];\n        return sum;\n}", "16": "static int maxDet(int n)\n{\n        return (2 * n * n * n);\n}\nvoid resMatrix(int n)\n{\n        for (int i = 0; i < 3; i++)\n        {\n                for (int j = 0; j < 3; j++)\n                {\n                        if (i == 0 && j == 2)\n                                System.out.print(\"0 \");\n                        else if (i == 1 && j == 0)\n                                System.out.print(\"0 \");\n                        else if (i == 2 && j == 1)\n                                System.out.print(\"0 \");\n                        else\n                                System.out.print(n +\" \");\n                }\n                System.out.println(\"\");\n        }\n}", "17": "static int CountNegative(int[,] M, int n, int m)\n        {\n                int count = 0;\n                for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < m; j++) {\n                                if (M[i, j] < 0)\n                                        count += 1;\n                                else\n                                        break;\n                        }\n                }\n                return count;\n        }", "18": "static int CountNegative(int M[][], int n, int m)\n        {\n                int count = 0;\n                int i = 0;\n                int j = m - 1;\n                while (j >= 0 && i < n) {\n                        if (M[i][j] < 0) {\n                                count += j + 1;\n                                i += 1;\n                        }\n                        else\n                                j -= 1;\n                }\n                return count;\n        }", "19": "static int getLastNegativeIndex(int array[], int start, int end)\n{\n        if (start == end) \n        {\n                return start;\n        }\n        int mid = start + (end - start) / 2;\n        if (array[mid] < 0) \n        {\n                if (mid + 1 < array.Length && array[mid + 1] >= 0) \n                {\n                        return mid;\n                }\n                return getLastNegativeIndex(array, mid + 1, end);\n        }\n        else \n        {\n                return getLastNegativeIndex(array, start, mid - 1);\n        }\n}\n\nstatic int countNegative(int M[][], int n, int m)\n{\n        int count = 0;\n        int nextEnd = m - 1;\n        for (int i = 0; i < n; i++) \n        {\n                if (M[i][0] >= 0) \n                {\n                        break;\n                }\n                nextEnd = getLastNegativeIndex(M[i], 0, nextEnd);\n                count += nextEnd + 1;\n        }\n        return count;\n}", "20": "static int findMaxValue(int N, int[][] mat)\n        {\n                int maxValue = Int32.MinValue;\n                for (int a = 0; a < N - 1; a++)\n                for (int b = 0; b < N - 1; b++)\n                        for (int d = a + 1; d < N; d++)\n                        for (int e = b + 1; e < N; e++)\n                                if (maxValue < (mat[d][e] - mat[a][b]))\n                                        maxValue = mat[d][e] - mat[a][b];\n                return maxValue;\n        }", "21": "static int findMaxValue(int N,int mat[][])\n        {\n                int maxValue = Integer.MinValue;\n                int maxArr[][] = new int[N][N];\n                maxArr[N-1][N-1] = mat[N-1][N-1];\n                for (int j = N - 2; j >= 0; j--)\n                {\n                        if (mat[N-1][j] > maxv)\n                                maxv = mat[N - 1][j];\n                        maxArr[N-1][j] = maxv;\n                }\n                for (int i = N - 2; i >= 0; i--)\n                {\n                        if (mat[i][N - 1] > maxv)\n                                maxv = mat[i][N - 1];\n                        maxArr[i][N - 1] = maxv;\n                }\n                for (int i = N-2; i >= 0; i--)\n                {\n                        for (int j = N-2; j >= 0; j--)\n                        {\n                                if (maxArr[i+1][j+1] - mat[i][j] > maxValue)\n                                        maxValue = maxArr[i + 1][j + 1] - mat[i][j];\n                                maxArr[i][j] = Math.max(mat[i][j],\n                                                                Math.max(maxArr[i][j + 1], maxArr[i + 1][j]) );\n                        }\n                }\n                return maxValue;\n        }", "22": "static void youngify(int[,] mat, int i, int j)\n        {\n                int downVal = (i + 1 < N) ?\n                                        mat[i + 1, j] : INF;\n                int rightVal = (j + 1 < N) ?\n                                        mat[i, j + 1] : INF;\n                if (downVal == INF && rightVal == INF)\n                {\n                        return;\n                }\n                if (downVal < rightVal)\n                {\n                        mat[i, j] = downVal;\n                        mat[i + 1, j] = INF;\n                        youngify(mat, i + 1, j);\n                }\n                else\n                {\n                        mat[i, j] = rightVal;\n                        mat[i, j + 1] = INF;\n                        youngify(mat, i, j + 1);\n                }\n        }\nstatic int extractMin(int[,] mat)\n        {\n                int ret = mat[0, 0];\n                mat[0, 0] = INF;\n                youngify(mat, 0, 0);\n                return ret;\n        }\nstatic void printSorted(int[,] mat)\n        {\n                System.out.println(\"Elements of matrix in sorted order n\");\n                for (int i = 0; i < N * N; i++)\n                {\n                        System.out.print(extractMin(mat) + \" \");\n                }\n        }", "23": "static void printSumSimple(int[,] mat, int k)\n{\n        if (k > n) return;\n        for (int i = 0; i < n - k + 1; i++)\n        {\n                for (int j = 0; j < n - k + 1; j++)\n                {\n                        int sum = 0;\n                        for (int p = i; p < k + i; p++)\n                                for (int q = j; q < k + j; q++)\n                                        sum += mat[p, q];\n                        System.out.print(sum + \" \");\n                }\n                System.out.println();\n        }\n}", "24": "static void printSumTricky(int[][] mat, int k) {\n        if (k > n)\n        return;\n        int[][] stripSum = new int[n][n];\n        for (int j = 0; j < n; j++) {\n        int sum = 0;\n        for (int i = 0; i < k; i++)\n                sum += mat[i][j];\n        stripSum[0][j] = sum;\n        for (int i = 1; i < n - k + 1; i++) {\n                sum += (mat[i + k - 1][j] - mat[i - 1][j]);\n                stripSum[i][j] = sum;\n        }\n        }\n        for (int i = 0; i < n - k + 1; i++) {\n        int sum = 0;\n        for (int j = 0; j < k; j++)\n                sum += stripSum[i][j];\n        System.out.print(sum + \" \");\n        for (int j = 1; j < n - k + 1; j++) {\n                sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n                System.out.print(sum + \" \");\n        }\n        System.out.println();\n        }\n}", "25": "static void transpose(int[,] A, int[,] B)\n        {\n                int i, j;\n                for (i = 0; i < N; i++)\n                        for (j = 0; j < M; j++)\n                                B[i,j] = A[j,i];\n        }", "26": "static void transpose(int A[][])\n        {\n                for (int i = 0; i < N; i++)\n                        for (int j = i+1; j < N; j++)\n                        {\n                                int temp = A[i][j];\n                                A[i][j] = A[j][i];\n                                A[j][i] = temp;\n                        }\n        }", "27": "public static int pathCountRec(int[][] mat, int m, int n, int k)\n{\n    if (m < 0 || n < 0)\n    {\n        return 0;\n    }\n    if (m == 0 && n == 0 && (k == mat[m][n]))\n    {\n        return 1;\n    }\n    return pathCountRec(mat, m - 1, n, k - mat[m][n])\n            + pathCountRec(mat, m, n - 1, k - mat[m][n]);\n}\npublic static int pathCount(int[][] mat, int k)\n{\n    return pathCountRec(mat, R - 1, C - 1, k);\n}", "28": "static int pathCountDPRecDP(int [][]mat, int m, int n, int k)\n        {\n                if (m < 0 n < 0) return 0;\n                if (m==0 && n==0) return (k == mat[m][n] ? 1 : 0);\n                if (dp[m][n][k] != -1) return dp[m][n][k];\n                dp[m][n][k] = pathCountDPRecDP(mat, m-1, n, k-mat[m][n]) +\n                                        pathCountDPRecDP(mat, m, n-1, k-mat[m][n]);\n                return dp[m][n][k];\n        }\nstatic int pathCountDP(int [][]mat, int k)\n        {\n                for(int i=0;i<R;i++)\n                        for(int j=0;j<C;j++)\n                                for(int l=0;l<MAX_K;l++)\n                                dp[i][j][l]=-1;\n                return pathCountDPRecDP(mat, R-1, C-1, k);\n        }", "29": "static bool check(int[] A, int N) {\n        Stack<int> S = new Stack<int>();\n        int B_end = 0;\n        for (int i = 0; i < N; i++) {\n                if (S.Count != 0) {\n                        int top = S.Peek();\n                        while (top == B_end + 1) {\n                                B_end = B_end + 1;\n                                S.Pop();\n                                if (S.Count == 0) {\n                                        break;\n                                }\n                                top = S.Peek();\n                        }\n                        if (S.Count == 0) {\n                                S.Push(A[i]);\n                        } else {\n                                top = S.Peek();\n                                if (A[i] < top) {\n                                        S.Push(A[i]);\n                                } else {\n                                        return false;\n                                }\n                        }\n                } else {\n                        S.Push(A[i]);\n                }\n        }\n        return true;\n}", "30": "static int countMinReversals(String expr)\n        {\n                int len = expr.length();\n                if (len%2 != 0)\n                return -1;\n                Stack<Character> s=new Stack<>();\n                for (int i=0; i<len; i++)\n                {\n                        char c = expr.charAt(i);\n                        if (c =='}' && !s.empty())\n                        {\n                                if (s.peek()=='{')\n                                        s.pop();\n                                else\n                                        s.push(c);\n                        }\n                        else\n                                s.push(c);\n                }\n                int red_len = s.size();\n                int n = 0;\n                while (!s.empty() && s.peek() == '{')\n                {\n                        s.pop();\n                        n++;\n                }\n                return (red_len/2 + n%2);\n        }", "31": "static int countMinReversals(String expr)\n        {\n                int len = expr.length();\n                int ans;\n                if (len % 2 != 0) {\n                        return -1;\n                }\n                int left_brace = 0, right_brace = 0;\n                for (int i = 0; i < len; i++) {\n                        char ch = expr.charAt(i);\n                        if (ch == '{') {\n                                left_brace++;\n                        }\n                        else {\n                                if (left_brace == 0) {\n                                        right_brace++;\n                                }\n                                else {\n                                        left_brace--;\n                                }\n                        }\n                }\n                ans = (int)(Math.ceil((0.0 + left_brace) / 2)\n                                        + Math.ceil((0.0 + right_brace) / 2));\n                return ans;\n        }", "32": "static void PrintMinNumberForPattern(string arr)\n        {\n                int curr_max = 0;\n                int last_entry = 0;\n                int j;\n                for (int i = 0; i < arr.Length; i++)\n                {\n                        int noOfNextD = 0;\n                        switch (arr[i])\n                        {\n                                case 'I':\n                                        j = i + 1;\n                                        while (j < arr.Length && arr[j] == 'D')\n                                        {\n                                                noOfNextD++;\n                                                j++;\n                                        }\n                                        if (i == 0)\n                                        {\n                                                curr_max = noOfNextD + 2;\n                                                Console.Write(\" \" + ++last_entry);\n                                                Console.Write(\" \" + curr_max);\n                                                last_entry = curr_max;\n                                        }\n                                        else\n                                        {\n                                                curr_max = curr_max + noOfNextD + 1;\n                                                last_entry = curr_max;\n                                                Console.Write(\" \" + last_entry);\n                                        }\n                                        for (int k = 0; k < noOfNextD; k++)\n                                        {\n                                                Console.Write(\" \" + --last_entry);\n                                                i++;\n                                        }\n                                        break;\n                                case 'D':\n                                        if (i == 0)\n                                        {\n                                                j = i + 1;\n                                                while (j < arr.Length&&arr[j] == 'D')\n                                                {\n                                                        noOfNextD++;\n                                                        j++;\n                                                }\n                                                curr_max = noOfNextD + 2;\n                                                Console.Write(\" \" + curr_max + \" \" + (curr_max - 1));\n                                                last_entry = curr_max - 1;\n                                        }\n                                        else\n                                        {\n                                                Console.Write(\" \" + (last_entry - 1));\n                                                last_entry--;\n                                        }\n                                        break;\n                        }\n                }\n                Console.WriteLine();\n        }", "33": "static void printLeast(String arr)\n        {\n                        int min_avail = 1, pos_of_I = 0;\n                        List<int> al = new List<int>();\n                        if (arr[0] == 'I')\n                        {\n                                al.Add(1);\n                                al.Add(2);\n                                min_avail = 3;\n                                pos_of_I = 1;\n                        }\n                        else\n                        {\n                                al.Add(2);\n                                al.Add(1);\n                                min_avail = 3;\n                                pos_of_I = 0;\n                        }\n                        for (int i = 1; i < arr.Length; i++)\n                        {\n                                if (arr[i] == 'I')\n                                {\n                                        al.Add(min_avail);\n                                        min_avail++;\n                                        pos_of_I = i + 1;\n                                }\n                                else\n                                {\n                                        al.Add(al[i]);\n                                        for (int j = pos_of_I; j <= i; j++)\n                                                        al[j] = al[j] + 1;\n                                        min_avail++;\n                                }\n                        }\n                        for (int i = 0; i < al.Count; i++)\n                                Console.Write(al[i] + \" \");\n                        Console.WriteLine();\n        }", "34": "static void PrintMinNumberForPattern(String seq) {\n                String result = \"\";\n                Stack<Integer> stk = new Stack<Integer>();\n                for (int i = 0; i <= seq.length(); i++) {\n                        stk.Push(i + 1);\n                        if (i == seq.Length() || seq.charAt(i) == 'I') {\n                                while (stk.Count != 0) {\n                                        result += String.valueOf(stk.Peek());\n                                        result += \" \";\n                                        stk.Pop();\n                                }\n                        }\n                }\n                Console.WriteLine(result);\n        }", "35": "static string GetMinNumberForPattern(string seq)\n        {\n                int n = seq.Length;\n                if (n >= 9)\n                        return \"-1\";\n                char[] result = new char[n + 1];\n                int count = 1;\n                for (int i = 0; i <= n; i++)\n                {\n                        if (i == n || seq[i] == 'I')\n                        {\n                                for (int j = i - 1; j >= -1; j--)\n                                {\n                                        result[j + 1] = (char) ((int) '0' + count++);\n                                        if (j >= 0 && seq[j] == 'I')\n                                                break;\n                                }\n                        }\n                }\n                return new string(result);\n        }", "36": "public int compare(Key k1, Key k2)\n        {\n                if (k1.freq < k2.freq)\n                        return 1;\n                else if (k1.freq > k2.freq)\n                        return -1;\n                return 0;\n        }\nstatic void rearrangeString(String str)\n        {\n                int n = str.length();\n                int[] count = new int[MAX_CHAR];\n                for (int i = 0; i < n; i++)\n                        count[str.charAt(i) - 'a']++;\n                PriorityQueue<Key> pq\n                        = new PriorityQueue<>(new KeyComparator());\n                for (char c = 'a'; c <= 'z'; c++) {\n                        int val = c - 'a';\n                        if (count[val] > 0)\n                                pq.add(new Key(count[val], c));\n                }\n                str = \"\";\n                Key prev = new Key(-1, '#');\n                while (pq.size() != 0) {\n                        Key k = pq.peek();\n                        pq.poll();\n                        str = str + k.ch;\n                        if (prev.freq > 0)\n                                pq.add(prev);\n                        (k.freq)--;\n                        prev = k;\n                }\n                if (n != str.length())\n                        System.out.println(\" Not valid String \");\n                else\n                        System.out.println(str);\n        }", "37": "public static int Subset(int[] ar, int n)\n        {\n                int res = 0;\n                Array.Sort(ar);\n                for (int i = 0; i < n; i++) {\n                        int count = 1;\n                        for (; i < n - 1; i++) {\n                                if (ar[i] == ar[i + 1])\n                                        count++;\n                                else\n                                        break;\n                        }\n                        res = Math.Max(res, count);\n                }\n                return res;\n        }", "38": "static int subset(int arr[], int n)\n{\n        HashMap<Integer, Integer> mp = new HashMap<>();\n        for (int i = 0; i < n; i++)\n                mp.put(arr[i],mp.get(arr[i]) == null?1:mp.get(arr[i])+1);\n        int res = 0;\n        for (Map.Entry<Integer,Integer> entry : mp.entrySet())\n        res = Math.max(res, entry.getValue());\n        return res;\n}", "39": "public static bool areElementsContiguous(int[] arr, int n)\n{\n        Array.Sort(arr);\n        for (int i = 1; i < n; i++)\n                if (arr[i] - arr[i-1] > 1)\n                        return false;\n        return true; \n}", "40": "static bool AreElementsContiguous(int[] arr, int n)\n        {\n                int max = int.MinValue;\n                int min = int.MaxValue;\n                for(int i = 0; i < n; i++)\n                {\n                        max = Math.Max(max, arr[i]);\n                        min = Math.Min(min, arr[i]);\n                }\n                int m = max - min + 1;\n                if (m > n)\n                        return false;\n                bool[] visited = new bool[n];\n                for (int i = 0; i < n; i++) \n                visited[arr[i] - min] = true;\n                for (int i = 0; i < m; i++)\n                if (visited[i] == false)\n                                return false;\n                return true;\n        }", "41": "static bool areElementsContiguous(int[] arr, int n)\n        {\n                HashSet<int> us = new HashSet<int>();\n                for (int i = 0; i < n; i++)\n                        us.Add(arr[i]);\n                int count = 1;\n                int curr_ele = arr[0] - 1;\n                while (us.Contains(curr_ele) == true) {\n                        count++;\n                        curr_ele--;\n                }\n                curr_ele = arr[0] + 1;\n                while (us.Contains(curr_ele) == true) {\n                        count++;\n                        curr_ele++;\n                }\n                return (count == (us.Count));\n        }", "42": "static void longest(int[] a, int n, int k)\n{\n        int[] freq = new int[7];\n        int start = 0, end = 0, now = 0, l = 0;\n        for (int i = 0; i < n; i++)\n        {\n                freq[a[i]]++;\n                if (freq[a[i]] == 1)\n                        now++;\n                while (now > k)\n                {\n                        freq[a[l]]--;\n                        if (freq[a[l]] == 0)\n                                now--;\n                        l++;\n                }\n                if (i - l + 1 >= end - start + 1)\n                {\n                        end = i;\n                        start = l;\n                }\n        }\n        for (int i = start; i <= end; i++)\n                Console.Write(a[i]+\" \");\n}", "43": "static void findSmallestRange(int[][] arr, int n, int k)\n        {\n                int i, minval, maxval, minrange, minel = 0, maxel = 0, flag, minind;\n                for (i = 0; i <= k; i++) {\n                        ptr[i] = 0;\n                }\n                minrange = int.MaxValue;\n                while (true) {\n                        minind = -1;\n                        minval = int.MaxValue;\n                        maxval = int.MinValue;\n                        flag = 0;\n                        for (i = 0; i < k; i++) {\n                                if (ptr[i] == n) {\n                                        flag = 1;\n                                        break;\n                                }\n                                if (ptr[i] < n && arr[i][ptr[i]] < minval) {\nminind = i; \n                                        minval = arr[i][ptr[i]];\n                                }\n                                if (ptr[i] < n && arr[i][ptr[i]] > maxval) {\n                                        maxval = arr[i][ptr[i]];\n                                }\n                        }\n                        if (flag == 1) {\n                                break;\n                        }\n                        ptr[minind]++;\n                        if ((maxval - minval) < minrange) {\n                                minel = minval;\n                                maxel = maxval;\n                                minrange = maxel - minel;\n                        }\n                }\n                Console.WriteLine(\"The smallest range is [{0}, {1}]\\n\", minel, maxel);\n        }", "44": "public static int findLargest(int []S, int n)\n{\n        bool found = false;\n        Array.Sort(S);\n        for (int i = n - 1; i >= 0; i--)\n        {\n                for (int j = 0; j < n; j++)\n                {\n                        if (i == j)\n                                continue;\n                        for (int k = j + 1; k < n; k++)\n                        {\n                                if (i == k)\n                                        continue;\n                                for (int l = k + 1; l < n; l++)\n                                {\n                                        if (i == l)\n                                                continue;\n                                        if (S[i] == S[j] + S[k] + S[l])\n                                        {\n                                                found = true;\n                                                return S[i];\n                                        }\n                                }\n                        }\n                }\n        }\n        if (found == false)\n                return int.MaxValue;\n        return -1;\n}", "45": "int getI(){\n        return i;\n}\nint getJ(){\n        return j;\n}\nstatic int findFourElements(int[] arr, int n){\n        HashMap<Integer, Indexes> map = new HashMap<>();\n        for (int i = 0; i < n - 1; i++){\n                for (int j = i + 1; j < n; j++){\n                        map.put(arr[i] + arr[j], new Indexes(i, j));\n                }\n        }\n        int d = Integer.MIN_VALUE;\n        for (int i = 0; i < n - 1; i++){\n                for (int j = i + 1; j < n; j++){\n                        int abs_diff = Math.abs(arr[i] - arr[j]);\n                        if (map.containsKey(abs_diff)){\n                                Indexes indexes = map.get(abs_diff);\n                                if (indexes.getI() != i && indexes.getI() != j &&\n                                indexes.getJ() != i && indexes.getJ() != j){\n                                        d = Math.max(d, Math.max(arr[i], arr[j]));\n                                }\n                        }\n                }\n        }\n        return d;\n}", "46": "public static void leftRotatebyOne(int[] arr, int n)\n        {\n                int i, temp;\n                temp = arr[0];\n                for (i = 0; i < n - 1; i++)\n                        arr[i] = arr[i + 1];\n                arr[n-1] = temp;\n        }\npublic static void leftRotate(int[] arr, int d, int n)\n        {\n                for (int i = 0; i < d; i++)\n                        leftRotatebyOne(arr, n);\n        }\npublic static void printArray(int[] arr, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        Console.Write(arr[i] + \" \");\n        }", "47": "static void pushZerosToEnd(int arr[], int n)\n        {\nint count = 0; \n                for (int i = 0; i < n; i++)\n                        if (arr[i] != 0)\narr[count++] = arr[i]; \n                while (count < n)\n                        arr[count++] = 0;\n        }", "48": "static void moveZerosToEnd(int[] arr, int n) {\n        int count = 0;\n        int temp;\n        for (int i = 0; i < n; i++) {\n        if ((arr[i] != 0)) {\n                temp = arr[count];\n                arr[count] = arr[i];\n                arr[i] = temp;\n                count = count + 1;\n        }\n        }\n}\nstatic void printArray(int[] arr, int n) {\n        for (int i = 0; i < n; i++)\n        System.out.print(arr[i] + \" \");\n}", "49": "static void pushZerosToEnd(int arr[], int n)\n        {\n                int count = 0;\n                for (int i = 0; i < n; i++)\n                        if (arr[i] != 0)\n                                arr[count++] = arr[i];\n                while (count < n)\n                        arr[count++] = 0;\n        }\nstatic void modifyAndRearrangeArr(int arr[], int n)\n        {\n                if (n == 1)\n                        return;\n                for (int i = 0; i < n - 1; i++) {\n                        if ((arr[i] != 0) && (arr[i] == arr[i + 1]))\n                        {\n                                arr[i] = 2 * arr[i];\n                                arr[i + 1] = 0;\n                                i++;\n                        }\n                }\n                pushZerosToEnd(arr, n);\n        }\nstatic void printArray(int arr[], int n)\n        {\n                for (int i = 0; i < n; i++)\n                        System.out.print(arr[i] + \" \");\n                System.out.println();\n        }"}}, "C# - Java": {"ID": {"0": 451, "1": 455, "2": 496, "3": 617, "4": 647, "5": 694, "6": 815, "7": 818, "8": 821, "9": 832, "10": 833, "11": 846, "12": 861, "13": 862, "14": 883, "15": 895, "16": 918, "17": 919, "18": 920, "19": 926, "20": 927, "21": 953, "22": 955, "23": 956, "24": 958, "25": 959, "26": 965, "27": 966, "28": 1064, "29": 1065, "30": 1072, "31": 1073, "32": 1074, "33": 1075, "34": 1252, "35": 1253, "36": 1344, "37": 1345, "38": 1346, "39": 1366, "40": 1390, "41": 1405, "42": 1406, "43": 1428, "44": 1468, "45": 1469, "46": 1473, "47": 1478, "48": 1480, "49": 1481}, "C#": {"0": "static int minCost(int [,]cost)\n        {\n                int []dist = new int[N];\n                for (int i = 0; i < N; i++)\n                        dist[i] = INF;\n                dist[0] = 0;\n                for (int i = 0; i < N; i++)\n                        for (int j = i + 1; j < N; j++)\n                                if (dist[j] > dist[i] + cost[i,j])\n                                        dist[j] = dist[i] + cost[i,j];\n                return dist[N-1];\n        }", "1": "static int numOfways(int n, int k)\n        {\n                int p = 1;\n                if (k % 2 != 0)\n                        p = -1;\n                return (int)(Math.Pow(n - 1, k)\n                                        + p * (n - 1)) / n;\n        }", "2": "static int fib(int n)\n        {\n                if (n <= 1)\n                        return n;\n                return fib(n - 1) + fib(n - 2);\n        }\nstatic int findVertices (int n)\n        {\n                return fib(n + 2);\n        }", "3": "static Node reverse( Node head_ref)\n{\n        Node temp = null;\n        Node current = head_ref;\n        while (current != null)\n        {\n                temp = current.prev;\n                current.prev = current.next;\n                current.next = temp;\n                current = current.prev;\n        }\n        if (temp != null)\n                head_ref = temp.prev;\n                return head_ref;\n}\nstatic Node merge(Node first, Node second)\n{\n        if (first == null)\n                return second;\n        if (second == null)\n                return first;\n        if (first.data < second.data)\n        {\n                first.next = merge(first.next, second);\n                first.next.prev = first;\n                first.prev = null;\n                return first;\n        }\n        else\n        {\n                second.next = merge(first, second.next);\n                second.next.prev = second;\n                second.prev = null;\n                return second;\n        }\n}\nstatic Node sort(Node head)\n{\n        if (head == null head.next == null)\n                return head;\n        Node current = head.next;\n        while (current != null)\n        {\n                if (current.data < current.prev.data)\n                        break;\n                current = current.next;\n        }\n        if (current == null)\n                return head;\n        current.prev.next = null;\n        current.prev = null;\n        current = reverse(current);\n        return merge(head, current);\n}\nstatic Node push( Node head_ref, int new_data)\n{\n        Node new_node = new Node();\n        new_node.data = new_data;\n        new_node.prev = null;\n        new_node.next = (head_ref);\n        if ((head_ref) != null)\n                (head_ref).prev = new_node;\n        (head_ref) = new_node;\n        return head_ref;\n}\nstatic void printList( Node head)\n{\n        if (head == null)\n                Console.WriteLine(\"Doubly Linked list empty\");\n        while (head != null)\n        {\n                Console.Write(head.data + \" \");\n                head = head.next;\n        }\n}", "4": "static Node newNode(char key)\n        {\n                Node temp = new Node();\n                temp.data = key;\n                temp.next = null;\n                return temp;\n        }\nstatic void printlist(Node head)\n        {\n                if (head == null)\n                {\n                        Console.WriteLine(\"Empty List\");\n                        return;\n                }\n                while (head != null)\n                {\n                        Console.Write(head.data +\" \");\n                        if (head.next != null)\n                                Console.Write(\"-> \");\n                        head = head.next;\n                }\n                Console.WriteLine();\n        }\nstatic bool isVowel(char x)\n        {\n                return (x == 'a' x == 'e' x == 'i' x == 'o' x == 'u');\n        }\nstatic Node arrange(Node head)\n        {\n                Node newHead = head;\n                Node latestVowel;\n                Node curr = head;\n                if (head == null)\n                        return null;\n                if (isVowel(head.data) == true)\n                        latestVowel = head;\n                else\n                {\n                        while (curr.next != null &&\n                                !isVowel(curr.next.data))\n                                curr = curr.next;\n                        if (curr.next == null)\n                                return head;\n                        latestVowel = newHead = curr.next;\n                        curr.next = curr.next.next;\n                        latestVowel.next = head;\n                }\n                while (curr != null && curr.next != null)\n                {\n                        if (isVowel(curr.next.data) == true)\n                        {\n                                if (curr == latestVowel)\n                                {\n                                        latestVowel = curr = curr.next;\n                                }\n                                else\n                                {\n                                        Node temp = latestVowel.next;\n                                        latestVowel.next = curr.next;\n                                        latestVowel = latestVowel.next;\n                                        curr.next = curr.next.next;\n                                        latestVowel.next = temp;\n                                }\n                        }\n                        else\n                        {\n                                curr = curr.next;\n                        }\n                }\n                return newHead;\n        }", "5": "static Node newNode(int data)\n{\n        Node temp = new Node();\n        temp.data = data;\n        temp.right = null;\n        temp.left = null;\n        return temp;\n}\nstatic Node KthLargestUsingMorrisTraversal(Node root, int k)\n{\n        Node curr = root;\n        Node Klargest = null;\n        int count = 0;\n        while (curr != null)\n        {\n                if (curr.right == null)\n                {\n                        if (++count == k)\n                                Klargest = curr;\n                        curr = curr.left;\n                }\n                else\n                {\n                        Node succ = curr.right;\n                        while (succ.left != null && succ.left != curr)\n                                succ = succ.left;\n                        if (succ.left == null)\n                        {\n                                succ.left = curr;\n                                curr = curr.right;\n                        }\n                        else\n                        {\n                                succ.left = null;\n                                if (++count == k)\n                                        Klargest = curr;\n                                curr = curr.left;\n                        }\n                }\n        }\n        return Klargest;\n}", "6": "static void sortByRow(int [,]mat, int n)\n        {\n        for (int i = 0; i < n ; i++)\n                {\n                for(int j = 0; j < n - 1; j++)\n                {\n                        if(mat[i, j] > mat[i, j + 1])\n                        {\n                                var temp = mat[i, j];\n                                mat[i, j] = mat[i, j + 1];\n                                mat[i, j + 1] = temp;\n                        }\n                }\n                }\n        }\nstatic void transpose(int [,]mat, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        for (int j = i + 1; j < n; j++)\n                                {\n                                        var temp = mat[i, j];\n                                        mat[i, j] = mat[j, i];\n                                        mat[j, i] = temp;\n                                }\n        }\nstatic void sortMatRowAndColWise(int [,]mat, int n)\n        {\n                sortByRow(mat, n);\n                transpose(mat, n);\n                sortByRow(mat, n);\n                transpose(mat, n);\n        }\nstatic void printMat(int [,]mat, int n)\n        {\n                for (int i = 0; i < n; i++)\n                {\n                        for (int j = 0; j < n; j++)\n                                Console.Write(mat[i, j] + \" \");\n                        Console.Write(\"\\n\");\n                }\n        }", "7": "public static void doublyEven(int n)\n{\n        int[,] arr = new int[n,n];\n        int i, j;\n        for (i = 0; i < n; i++)\n        {\n                for (j = 0; j < n; j++)\n                {\n                        arr[i, j] = (n * i) + j + 1;\n                }\n        }\n        for (i = 0; i < n / 4; i++)\n        {\n                for (j = 0; j < n / 4; j++)\n                {\n                        arr[i, j] = (n * n + 1) - arr[i, j];\n                }\n        }\n        for (i = 0; i < n / 4; i++)\n        {\n                for (j = 3 * (n / 4); j < n; j++)\n                {\n                        arr[i, j] = (n * n + 1) - arr[i, j];\n                }\n        }\n        for (i = 3 * n / 4; i < n; i++)\n        {\n                for (j = 0; j < n / 4; j++)\n                {\n                        arr[i, j] = (n * n + 1) - arr[i, j];\n                }\n        }\n        for (i = 3 * n / 4; i < n; i++)\n        {\n                for (j = 3 * n / 4; j < n; j++)\n                {\n                        arr[i, j] = (n * n + 1) - arr[i, j];\n                }\n        }\n        for (i = n / 4; i < 3 * n / 4; i++)\n        {\n                for (j = n / 4; j < 3 * n / 4; j++)\n                {\n                        arr[i, j] = (n * n + 1) - arr[i, j];\n                }\n        }\n        for (i = 0; i < n; i++)\n        {\n                for (j = 0; j < n; j++)\n                {\n                        Console.Write(arr[i, j] + \" \" + \" \");\n                }\n                Console.WriteLine();\n        }\n}", "8": "static void Kroneckerproduct(int [,]A, int [,]B)\n        {\n                int [,]C= new int[rowa * rowb, cola * colb];\n                for (int i = 0; i < rowa; i++)\n                {\n                        for (int k = 0; k < rowb; k++)\n                        {\n                                for (int j = 0; j < cola; j++)\n                                {\n                                        for (int l = 0; l < colb; l++)\n                                        {\n                                                C[i + l + 1, j + k + 1] = A[i, j] *\n                                                                                                B[k, l];\n                                                Console.Write( C[i + l + 1, j + k + 1] + \" \");\n                                        }\n                                }\n                                Console.WriteLine();\n                        }\n                }\n        }", "9": "bool isLowerTriangularMatrix(int[, ] mat)\n        {\n                for (int i = 0; i < N; i++)\n                        for (int j = i + 1; j < N; j++)\n                                if (mat[i, j] != 0)\n                                        return false;\n                return true;\n        }", "10": "public static bool isUpperTriangularMatrix(int [,]mat)\n        {\n                for (int i = 1; i < N ; i++)\n                        for (int j = 0; j < i; j++)\n                                if (mat[i, j] != 0)\n                                        return false;\n                return true;\n        }", "11": "static long countSets(int [,]a)\n        {\n                long res = 0;\n                for (int i = 0; i < n; i++)\n                {\n                        int u = 0, v = 0;\n                        for (int j = 0; j < m; j++)\n                        {\n                                if (a[i,j] == 1)\n                                        u++;\n                                else\n                                        v++;\n                        }\n                        res += (long)(Math.Pow(2, u) - 1\n                                        + Math.Pow(2, v)) - 1;\n                }\n                for (int i = 0; i < m; i++)\n                {\n                        int u = 0, v = 0;\n                        for (int j = 0; j < n; j++)\n                        {\n                                if (a[j,i] == 1)\n                                        u++;\n                                else\n                                        v++;\n                        }\n                        res += (long)(Math.Pow(2, u) - 1\n                                        + Math.Pow(2, v)) - 1;\n                }\n                return res - (n * m);\n        }", "12": "static void transpose(int [,]mat, int [,]tr, int N)\n        {\n                for (int i = 0; i < N; i++)\n                        for (int j = 0; j < N; j++)\n                                tr[i,j] = mat[j,i];\n        }\nstatic bool isSymmetric(int [,]mat, int N)\n        {\n                int [,]tr = new int[N,MAX];\n                transpose(mat, tr, N);\n                for (int i = 0; i < N; i++)\n                        for (int j = 0; j < N; j++)\n                                if (mat[i,j] != tr[i,j])\n                                        return false;\n                return true;\n        }", "13": "static bool isSymmetric(int [,]mat, int N)\n        {\n                for (int i = 0; i < N; i++)\n                        for (int j = 0; j < N; j++)\n                                if (mat[i, j] != mat[j, i])\n                                        return false;\n                return true;\n        }", "14": "static int findNormal(int [,]mat, int n)\n        {\n                int sum = 0;\n                for (int i = 0; i < n; i++)\n                        for (int j = 0; j < n; j++)\n                                sum += mat[i,j] * mat[i,j];\n                return (int)Math.Sqrt(sum);\n        }\nstatic int findTrace(int [,]mat, int n)\n        {\n                int sum = 0;\n                for (int i = 0; i < n; i++)\n                        sum += mat[i,i];\n                return sum;\n        }", "15": "static int maxDet(int n)\n{\n        return (2 * n * n * n);\n}\nvoid resMatrix(int n)\n{\n        for (int i = 0; i < 3; i++)\n        {\n                for (int j = 0; j < 3; j++)\n                {\n                        if (i == 0 && j == 2)\n                                Console.Write(\"0 \");\n                        else if (i == 1 && j == 0)\n                                Console.Write(\"0 \");\n                        else if (i == 2 && j == 1)\n                                Console.Write(\"0 \");\n                        else\n                                Console.Write(n +\" \");\n                }\n                Console.WriteLine(\"\");\n        }\n}", "16": "static int countNegative(int[, ] M, int n, int m)\n        {\n                int count = 0;\n                for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < m; j++) {\n                                if (M[i, j] < 0)\n                                        count += 1;\n                                else\n                                        break;\n                        }\n                }\n                return count;\n        }", "17": "static int countNegative(int[, ] M, int n, int m)\n        {\n                int count = 0;\n                int i = 0;\n                int j = m - 1;\n                while (j >= 0 && i < n) {\n                        if (M[i, j] < 0) {\n                                count += j + 1;\n                                i += 1;\n                        }\n                        else\n                                j -= 1;\n                }\n                return count;\n        }", "18": "static int getLastNegativeIndex(int []array, int start, int end)\n        {\n                if (start == end)\n                {\n                        return start;\n                }\n                int mid = start + (end - start) / 2;\n                if (array[mid] < 0)\n                {\n                        if (mid + 1 < array.GetLength(0) && array[mid + 1] >= 0)\n                        {\n                                return mid;\n                        }\n                        return getLastNegativeIndex(array, mid + 1, end);\n                }\n                else\n                {\n                        return getLastNegativeIndex(array, start, mid - 1);\n                }\n        }\nstatic int countNegative(int [,]M, int n, int m)\n        {\n                int count = 0;\n                int nextEnd = m - 1;\n                for (int i = 0; i < n; i++)\n                {\n                        if (M[i, 0] >= 0)\n                        {\n                                break;\n                        }\n                        nextEnd = getLastNegativeIndex(GetRow(M, i), 0, nextEnd);\n                        count += nextEnd + 1;\n                }\n                return count;\n        }\npublic static int[] GetRow(int[,] matrix, int row)\n        {\n                var rowLength = matrix.GetLength(1);\n                var rowVector = new int[rowLength];\n                for (var i = 0; i < rowLength; i++)\n                        rowVector[i] = matrix[row, i];\n                return rowVector;\n        }", "19": "static int findMaxValue(int N, int [,]mat)\n        {\n                int maxValue = int.MinValue;\n                for (int a = 0; a< N - 1; a++)\n                for (int b = 0; b < N - 1; b++)\n                        for (int d = a + 1; d < N; d++)\n                        for (int e = b + 1; e < N; e++)\n                                if (maxValue < (mat[d, e] - mat[a, b]))\n                                        maxValue = mat[d, e] -\n                                                        mat[a, b];\n                return maxValue;\n        }", "20": "static int findMaxValue(int N, int [,]mat)\n        {\n                int maxValue = int.MinValue;\n                int [,]maxArr = new int[N, N];\n                maxArr[N - 1, N - 1] = mat[N - 1,N - 1];\n                int maxv = mat[N - 1, N - 1];\n                for (int j = N - 2; j >= 0; j--)\n                {\n                        if (mat[N - 1, j] > maxv)\n                                maxv = mat[N - 1, j];\n                        maxArr[N - 1, j] = maxv;\n                }\n                maxv = mat[N - 1,N - 1];\n                for (int i = N - 2; i >= 0; i--)\n                {\n                        if (mat[i, N - 1] > maxv)\n                                maxv = mat[i,N - 1];\n                        maxArr[i,N - 1] = maxv;\n                }\n                for (int i = N - 2; i >= 0; i--)\n                {\n                        for (int j = N - 2; j >= 0; j--)\n                        {\n                                if (maxArr[i + 1,j + 1] - mat[i, j] > maxValue)\n                                        maxValue = maxArr[i + 1,j + 1] -\n                                                                                mat[i, j];\n                                maxArr[i,j] = Math.Max(mat[i, j],\n                                                        Math.Max(maxArr[i, j + 1], maxArr[i + 1, j]) );\n                        }\n                }\n                return maxValue;\n        }", "21": "static void youngify(int [,]mat, int i, int j)\n        {\n                int downVal = (i + 1 < N) ?\n                                        mat[i + 1,j] : INF;\n                int rightVal = (j + 1 < N) ?\n                                        mat[i,j + 1] : INF;\n                if (downVal == INF && rightVal == INF)\n                {\n                        return;\n                }\n                if (downVal < rightVal)\n                {\n                        mat[i,j] = downVal;\n                        mat[i + 1,j] = INF;\n                        youngify(mat, i + 1, j);\n                }\n                else\n                {\n                        mat[i, j] = rightVal;\n                        mat[i, j + 1] = INF;\n                        youngify(mat, i, j + 1);\n                }\n        }\nstatic int extractMin(int [,]mat)\n        {\n                int ret = mat[0,0];\n                mat[0, 0] = INF;\n                youngify(mat, 0, 0);\n                return ret;\n        }\nstatic void printSorted(int [,]mat)\n        {\n                        Console.WriteLine(\"Elements of matrix in sorted order n\");\n                for (int i = 0; i < N * N; i++)\n                {\n                        Console.Write(extractMin(mat) + \" \");\n                }\n        }", "22": "static void printSumSimple(int [,]mat, int k)\n        {\n                if (k > n) return;\n                for (int i = 0; i < n-k+1; i++)\n                {\n                        for (int j = 0; j < n-k+1; j++)\n                        {\n                                int sum = 0;\n                                for (int p = i; p < k+i; p++)\n                                        for (int q = j; q < k+j; q++)\n                                                sum += mat[p,q];\n                                Console.Write(sum+ \" \");\n                        }\n                        Console.WriteLine();\n                }\n        }", "23": "static void printSumTricky(int [,]mat, int k)\n        {\n                if (k > n)\n                return;\n                int [,]stripSum = new int[n,n];\n                for (int j = 0; j < n; j++)\n                {\n                        int sum = 0;\n                        for (int i = 0; i < k; i++)\n                                sum += mat[i,j];\n                        stripSum[0,j] = sum;\n                        for (int i = 1; i < n - k + 1; i++)\n                        {\n                                sum += (mat[i + k - 1,j] - mat[i - 1,j]);\n                                stripSum[i,j] = sum;\n                        }\n                }\n                for (int i = 0; i < n - k + 1; i++)\n                {\n                        int sum = 0;\n                        for (int j = 0; j < k; j++)\n                                sum += stripSum[i,j];\n                        Console.Write(sum + \" \");\n                        for (int j = 1; j < n - k + 1; j++)\n                        {\n                                sum += (stripSum[i,j + k - 1] - stripSum[i,j - 1]);\n                                Console.Write(sum + \" \");\n                        }\n                        Console.WriteLine();\n                }\n        }", "24": "static void transpose(int [,]A, int [,]B)\n        {\n                int i, j;\n                for (i = 0; i < N; i++)\n                        for (j = 0; j < M; j++)\n                                B[i,j] = A[j,i];\n        }", "25": "static void transpose(int [,]A)\n        {\n                for (int i = 0; i < N; i++)\n                        for (int j = i+1; j < N; j++)\n                        {\n                                int temp = A[i,j];\n                                A[i,j] = A[j,i];\n                                A[j,i] = temp;\n                        }\n        }", "26": "public static int pathCountRec(int[][] mat, int m, int n, int k)\n        {\n                if (m < 0 n < 0)\n                {\n                        return 0;\n                }\n                if (m == 0 && n == 0 && (k == mat[m][n]))\n                {\n                        return 1;\n                }\n                return pathCountRec(mat, m - 1, n, k - mat[m][n])\n                                + pathCountRec(mat, m, n - 1, k - mat[m][n]);\n        }\npublic static int pathCount(int[][] mat, int k)\n        {\n                return pathCountRec(mat, R - 1, C - 1, k);\n        }", "27": "static int pathCountDPRecDP(int [,]mat, int m, int n, int k)\n        {\n                if (m < 0 n < 0) return 0;\n                if (m == 0 && n == 0)\n                        return (k == mat[m, n] ? 1 : 0);\n                if (dp[m, n, k] != -1) return dp[m, n, k];\n                dp[m, n, k] = pathCountDPRecDP(mat, m - 1, n, k - mat[m, n]) +\n                                        pathCountDPRecDP(mat, m, n - 1, k - mat[m, n]);\n                return dp[m, n, k];\n        }\nstatic int pathCountDP(int [,]mat, int k)\n        {\n                for(int i = 0; i < R; i++)\n                        for(int j = 0; j < C; j++)\n                                for(int l = 0; l < MAX_K; l++)\n                                dp[i, j, l] = -1;\n                return pathCountDPRecDP(mat, R - 1, C - 1, k);\n        }", "28": "public static int countMinReversals(string expr)\n{\n        int len = expr.Length;\n        if (len % 2 != 0)\n        {\n                return -1;\n        }\n        Stack<char> s = new Stack<char>();\n        for (int i = 0; i < len; i++)\n        {\n                char c = expr[i];\n                if (c == '}' && s.Count > 0)\n                {\n                        if (s.Peek() == '{')\n                        {\n                                s.Pop();\n                        }\n                        else\n                        {\n                                s.Push(c);\n                        }\n                }\n                else\n                {\n                        s.Push(c);\n                }\n        }\n        int red_len = s.Count;\n        int n = 0;\n        while (s.Count > 0 && s.Peek() == '{')\n        {\n                s.Pop();\n                n++;\n        }\n        return (red_len / 2 + n % 2);\n}", "29": "static int countMinReversals(String expr)\n        {\n                int len = expr.Length;\n                int ans;\n                if (len % 2 != 0) {\n                        return -1;\n                }\n                int left_brace = 0, right_brace = 0;\n                for (int i = 0; i < len; i++) {\n                        char ch = expr[i];\n                        if (ch == '{') {\n                                left_brace++;\n                        }\n                        else {\n                                if (left_brace == 0) {\n                                        right_brace++;\n                                }\n                                else {\n                                        left_brace--;\n                                }\n                        }\n                }\n                ans = (int)(Math.Ceiling((0.0 + left_brace) / 2)\n                                        + Math.Ceiling((0.0 + right_brace) / 2));\n                return ans;\n        }", "30": "static void PrintMinNumberForPattern(String arr)\n        {\n                int curr_max = 0;\n                int last_entry = 0;\n                int j;\n                for (int i = 0; i < arr.Length; i++)\n                {\n                        int noOfNextD = 0;\n                        switch (arr[i])\n                        {\n                                case 'I':\n                                        j = i + 1;\n                                        while (j < arr.Length && arr[j] == 'D')\n                                        {\n                                                noOfNextD++;\n                                                j++;\n                                        }\n                                        if (i == 0)\n                                        {\n                                                curr_max = noOfNextD + 2;\n                                                Console.Write(\" \" + ++last_entry);\n                                                Console.Write(\" \" + curr_max);\n                                                last_entry = curr_max;\n                                        }\n                                        else\n                                        {\n                                                curr_max = curr_max + noOfNextD + 1;\n                                                last_entry = curr_max;\n                                                Console.Write(\" \" + last_entry);\n                                        }\n                                        for (int k = 0; k < noOfNextD; k++)\n                                        {\n                                                Console.Write(\" \" + --last_entry);\n                                                i++;\n                                        }\n                                        break;\n                                case 'D':\n                                        if (i == 0)\n                                        {\n                                                j = i + 1;\n                                                while (j < arr.Length&&arr[j] == 'D')\n                                                {\n                                                        noOfNextD++;\n                                                        j++;\n                                                }\n                                                curr_max = noOfNextD + 2;\n                                                Console.Write(\" \" + curr_max + \" \" + (curr_max - 1));\n                                                last_entry = curr_max - 1;\n                                        }\n                                        else\n                                        {\n                                                Console.Write(\" \" + (last_entry - 1));\n                                                last_entry--;\n                                        }\n                                        break;\n                        }\n                }\n                Console.WriteLine();\n        }", "31": "static void printLeast(String arr)\n{\n        int min_avail = 1, pos_of_I = 0;\n        List<int> al = new List<int>();\n        if (arr[0] == 'I')\n        {\n                al.Add(1);\n                al.Add(2);\n                min_avail = 3;\n                pos_of_I = 1;\n        }\n        else\n        {\n                al.Add(2);\n                al.Add(1);\n                min_avail = 3;\n                pos_of_I = 0;\n        }\n        for (int i = 1; i < arr.Length; i++)\n        {\n                if (arr[i] == 'I')\n                {\n                        al.Add(min_avail);\n                        min_avail++;\n                        pos_of_I = i + 1;\n                }\n                else\n                {\n                        al.Add(al[i]);\n                        for (int j = pos_of_I; j <= i; j++)\n                                al[j] = al[j] + 1;\n                        min_avail++;\n                }\n        }\n        for (int i = 0; i < al.Count; i++)\n                Console.Write(al[i] + \" \");\n        Console.WriteLine();\n}", "32": "static void PrintMinNumberForPattern(String seq) {\n                String result = \"\";\n                Stack stk = new Stack();\n                for (int i = 0; i <= seq.Length; i++) {\n                        stk.Push(i + 1);\n                        if (i == seq.Length seq[i] == 'I') {\n                                while (stk.Count!=0) {\n                                        result += String.Join(\"\",stk.Peek());\n                                        result += \" \";\n                                        stk.Pop();\n                                }\n                        }\n                }\n                Console.WriteLine(result);\n        }", "33": "static String getMinNumberForPattern(String seq)\n{\n        int n = seq.Length;\n        if (n >= 9)\n                return \"-1\";\n        char []result = new char[n + 1];\n        int count = 1;\n        for (int i = 0; i <= n; i++)\n        {\n                if (i == n seq[i] == 'I')\n                {\n                        for (int j = i - 1; j >= -1; j--)\n                        {\n                                result[j + 1] = (char) ((int) '0' + count++);\n                                if (j >= 0 && seq[j] == 'I')\n                                        break;\n                        }\n                }\n        }\n        return new String(result);\n}", "34": "public static int subset(int []ar, int n)\n        {\n                int res = 0;\n                Array.Sort(ar);\n                for (int i = 0; i < n; i++) {\n                        int count = 1;\n                        for ( ; i < n - 1; i++) {\n                                if (ar[i] == ar[i + 1])\n                                        count++;\n                                else\n                                        break;\n                        }\n                        res = Math.Max(res, count);\n                }\n                return res;\n        }", "35": "static int subset(int []arr, int n)\n{\n        Dictionary<int,\n                        int> mp = new Dictionary<int,\n                                                                                int>();\n        for (int i = 0 ; i < n; i++)\n        {\n                if(mp.ContainsKey(arr[i]))\n                {\n                        var val = mp[arr[i]];\n                        mp.Remove(arr[i]);\n                        mp.Add(arr[i], val + 1);\n                }\n                else\n                {\n                        mp.Add(arr[i], 1);\n                }\n        }\n        int res = 0;\n        foreach(KeyValuePair<int, int> entry in mp)\n                res = Math.Max(res, entry.Value);\n        return res;\n}", "36": "static bool areElementsContiguous(int []arr, int n)\n        {\n        Array.Sort(arr);\n        for (int i = 1; i < n; i++)\n                if (arr[i] - arr[i - 1] > 1)\n                        return false;\n        return true;\n        }", "37": "static bool areElementsContiguous( int []arr, int n)\n        {\n                int max = int.MinValue;\n                int min = int.MaxValue;\n                for(int i = 0; i < n; i++)\n                {\n                        max = Math.Max(max, arr[i]);\n                        min = Math.Min(min, arr[i]);\n                }\n                int m = max - min + 1;\n                if (m > n)\n                        return false;\n                bool []visited = new bool[n];\n                for (int i = 0; i < n; i++)\n                        visited[arr[i] - min] = true;\n                for (int i = 0; i < m; i++)\n                        if (visited[i] == false)\n                                return false;\n                return true;\n        }", "38": "public static bool? areElementsContiguous(int[] arr, int n)\n        {\n                HashSet<int> us = new HashSet<int>();\n                for (int i = 0; i < n; i++)\n                {\n                        us.Add(arr[i]);\n                }\n                int count = 1;\n                int curr_ele = arr[0] - 1;\n                while (us.Contains(curr_ele) == true)\n                {\n                        count++;\n                        curr_ele--;\n                }\n                curr_ele = arr[0] + 1;\n                while (us.Contains(curr_ele) == true)\n                {\n                        count++;\n                        curr_ele++;\n                }\n                return (count == (us.Count));\n        }", "39": "static void longest(int []a, int n, int k)\n{\n        int[] freq = new int[7];\n        int start = 0, end = 0, now = 0, l = 0;\n        for (int i = 0; i < n; i++)\n        {\n                freq[a[i]]++;\n                if (freq[a[i]] == 1)\n                        now++;\n                while (now > k)\n                {\n                        freq[a[l]]--;\n                        if (freq[a[l]] == 0)\n                                now--;\n                        l++;\n                }\n                if (i - l + 1 >= end - start + 1)\n                {\n                        end = i;\n                        start = l;\n                }\n        }\n        for (int i = start; i <= end; i++)\n                Console.Write(a[i]+\" \");\n}", "40": "static void findSmallestRange(int[, ] arr, int n, int k)\n        {\n                int i, minval, maxval, minrange,\n                        minel = 0, maxel = 0, flag, minind;\n                for (i = 0; i <= k; i++) {\n                        ptr[i] = 0;\n                }\n                minrange = int.MaxValue;\n                while (true) {\n                        minind = -1;\n                        minval = int.MaxValue;\n                        maxval = int.MinValue;\n                        flag = 0;\n                        for (i = 0; i < k; i++) {\n                                if (ptr[i] == n) {\n                                        flag = 1;\n                                        break;\n                                }\n                                if (ptr[i] < n && arr[i, ptr[i]] < minval) {\nminind = i; \n                                        minval = arr[i, ptr[i]];\n                                }\n                                if (ptr[i] < n && arr[i, ptr[i]] > maxval) {\n                                        maxval = arr[i, ptr[i]];\n                                }\n                        }\n                        if (flag == 1) {\n                                break;\n                        }\n                        ptr[minind]++;\n                        if ((maxval - minval) < minrange) {\n                                minel = minval;\n                                maxel = maxval;\n                                minrange = maxel - minel;\n                        }\n                }\n                Console.WriteLine(\"The smallest range is\" + \"[{0}, {1}]\\n\", minel, maxel);\n        }", "41": "static int findLargestd(int []S, int n)\n{\n        bool found = false;\n        Array.Sort(S);\n        for (int i = n - 1; i >= 0; i--)\n        {\n                for (int j = 0; j < n; j++)\n                {\n                        if (i == j)\n                                continue;\n                        for (int k = j + 1; k < n; k++)\n                        {\n                                if (i == k)\n                                        continue;\n                                for (int l = k + 1; l < n; l++)\n                                {\n                                        if (i == l)\n                                                continue;\n                                        if (S[i] == S[j] + S[k] + S[l])\n                                        {\n                                                found = true;\n                                                return S[i];\n                                        }\n                                }\n                        }\n                }\n        }\n        if (found == false)\n                return int.MaxValue;\n        return -1;\n}", "42": "public int getI()\n        {\n                return i;\n        }\npublic int getJ()\n        {\n                return j;\n        }\nstatic int findFourElements(int[] arr, int n)\n        {\n                Dictionary<int, Indexes> map =\n                                        new Dictionary<int, Indexes>();\n                for (int i = 0; i < n - 1; i++)\n                {\n                        for (int j = i + 1; j < n; j++)\n                        {\n                                map.Add(arr[i] + arr[j],\n                                                new Indexes(i, j));\n                        }\n                }\n                int d = int.MinValue;\n                for (int i = 0; i < n - 1; i++)\n                {\n                        for (int j = i + 1; j < n; j++)\n                        {\n                                int abs_diff = Math.Abs(arr[i] - arr[j]);\n                                if (map.ContainsKey(abs_diff))\n                                {\n                                        Indexes indexes = map[abs_diff];\n                                        if (indexes.getI() != i &&\n                                                indexes.getI() != j &&\n                                                indexes.getJ() != i &&\n                                                indexes.getJ() != j)\n                                        {\n                                                d = Math.Max(d, Math.Max(arr[i], arr[j]));\n                                        }\n                                }\n                        }\n                }\n                return d;\n        }", "43": "static void leftRotatebyOne(int[] arr, int n)\n        {\n                int i, temp = arr[0];\n                for (i = 0; i < n - 1; i++)\n                        arr[i] = arr[i + 1];\n                arr[n-1] = temp;\n        }\nstatic void leftRotate(int[] arr, int d, int n)\n        {\n                for (int i = 0; i < d; i++)\n                        leftRotatebyOne(arr, n);\n        }\nstatic void printArray(int[] arr, int size)\n        {\n                for (int i = 0; i < size; i++)\n                        Console.Write(arr[i] + \" \");\n        }", "44": "static void pushZerosToEnd(int []arr, int n)\n        {\n                int count = 0;\n                for (int i = 0; i < n; i++)\n                if (arr[i] != 0)\n                arr[count++] = arr[i];\n                while (count < n)\n                arr[count++] = 0;\n        }", "45": "static void moveZerosToEnd(int[] arr, int n)\n        {\n                int count = 0;\n                int temp;\n                for (int i = 0; i < n; i++)\n                {\n                        if ((arr[i] != 0))\n                        {\n                                temp = arr[count];\n                                arr[count] = arr[i];\n                                arr[i] = temp;\n                                count = count + 1;\n                        }\n                }\n        }\nstatic void printArray(int[] arr, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        Console.Write(arr[i] + \" \");\n        }", "46": "static void pushZerosToEnd(int[] arr, int n)\n        {\n                int count = 0;\n                for (int i = 0; i < n; i++)\n                        if (arr[i] != 0)\n                                arr[count++] = arr[i];\n                while (count < n)\n                        arr[count++] = 0;\n        }\nstatic void modifyAndRearrangeArr(int[] arr, int n)\n        {\n                if (n == 1)\n                        return;\n                for (int i = 0; i < n - 1; i++) {\n                        if ((arr[i] != 0) && (arr[i] == arr[i + 1])) {\n                                arr[i] = 2 * arr[i];\n                                arr[i + 1] = 0;\n                                i++;\n                        }\n                }\n                pushZerosToEnd(arr, n);\n        }\nstatic void printArray(int[] arr, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        Console.Write(arr[i] + \" \");\n                Console.WriteLine();\n        }", "47": "static void printArray(int[] arr, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        Console.Write(arr[i] + \" \");\n                Console.WriteLine();\n        }\nstatic void RearrangePosNeg(int[] arr, int n)\n        {\n                int key, j;\n                for (int i = 1; i < n; i++) {\n                        key = arr[i];\n                        if (key > 0)\n                                continue;\n                        j = i - 1;\n                        while (j >= 0 && arr[j] > 0) {\n                                arr[j + 1] = arr[j];\n                                j = j - 1;\n                        }\n                        arr[j + 1] = key;\n                }\n        }", "48": "static void printArray(int[] A, int size)\n        {\n                for (int i = 0; i < size; i++)\n                        Console.Write(A[i] + \" \");\n                Console.WriteLine(\"\");\n        }\nstatic void reverse(int[] arr, int l, int r)\n        {\n                if (l < r) {\n                        arr = swap(arr, l, r);\n                        reverse(arr, ++l, --r);\n                }\n        }\nstatic void merge(int[] arr, int l, int m, int r)\n        {\nint i = l; \nint j = m + 1; \n                while (i <= m && arr[i] < 0)\n                        i++;\n                while (j <= r && arr[j] < 0)\n                        j++;\n                reverse(arr, i, m);\n                reverse(arr, m + 1, j - 1);\n                reverse(arr, i, j - 1);\n        }\nstatic void RearrangePosNeg(int[] arr, int l, int r)\n        {\n                if (l < r) {\n                        int m = l + (r - l) / 2;\n                        RearrangePosNeg(arr, l, m);\n                        RearrangePosNeg(arr, m + 1, r);\n                        merge(arr, l, m, r);\n                }\n        }\nstatic int[] swap(int[] arr, int i, int j)\n        {\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n                return arr;\n        }", "49": "public static void RearrangePosNeg(int[] arr)\n {\n        int i = 0;\n        int j = arr.Length - 1;\n        while(true)\n        {\n        while(arr[i]<0 && i<arr.Length)\n                i++;\n        while(arr[j]>0 && j>=0)\n                j--;\n        if(i<j)\n        {\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n        }\n        else\n                break;\n        }\n }"}, "Java": {"0": "static int minCost(int [][]cost)\n        {\n                int []dist = new int[N];\n                for (int i = 0; i < N; i++)\n                        dist[i] = INF;\n                dist[0] = 0;\n                for (int i = 0; i < N; i++)\n                        for (int j = i + 1; j < N; j++)\n                                if (dist[j] > dist[i] + cost[i][j])\n                                        dist[j] = dist[i] + cost[i][j];\n                return dist[N-1];\n        }", "1": "public static int numOfways(int n, int k)\n        {\n                int p = 1;\n                if (k % 2 != 0)\n                        p = -1;\n                return (int)(Math.pow(n - 1, k)\n                                        + p * (n - 1)) / n;\n        }", "2": "public static int fib(int n)\n        {\n                if (n <= 1)\n                        return n;\n                return fib(n - 1) + fib(n - 2);\n        }\npublic static int findVertices (int n)\n        {\n                return fib(n + 2);\n        }", "3": "static Node reverse( Node head_ref)\n{\n        Node temp = null;\n        Node current = head_ref;\n        while (current != null)\n        {\n                temp = current.prev;\n                current.prev = current.next;\n                current.next = temp;\n                current = current.prev;\n        }\n        if (temp != null)\n                head_ref = temp.prev;\n                return head_ref;\n}\nstatic Node merge(Node first, Node second)\n{\n        if (first == null)\n                return second;\n        if (second == null)\n                return first;\n        if (first.data < second.data)\n        {\n                first.next = merge(first.next, second);\n                first.next.prev = first;\n                first.prev = null;\n                return first;\n        }\n        else\n        {\n                second.next = merge(first, second.next);\n                second.next.prev = second;\n                second.prev = null;\n                return second;\n        }\n}\nstatic Node sort(Node head)\n{\n        if (head == null head.next == null)\n                return head;\n        Node current = head.next;\n        while (current != null)\n        {\n                if (current.data < current.prev.data)\n                        break;\n                current = current.next;\n        }\n        if (current == null)\n                return head;\n        current.prev.next = null;\n        current.prev = null;\n        current = reverse(current);\n        return merge(head, current);\n}\nstatic Node push( Node head_ref, int new_data)\n{\n        Node new_node = new Node();\n        new_node.data = new_data;\n        new_node.prev = null;\n        new_node.next = (head_ref);\n        if ((head_ref) != null)\n                (head_ref).prev = new_node;\n        (head_ref) = new_node;\n        return head_ref;\n}\nstatic void printList( Node head)\n{\n        if (head == null)\n                System.out.println(\"Doubly Linked list empty\");\n        while (head != null)\n        {\n                System.out.print(head.data + \" \");\n                head = head.next;\n        }\n}", "4": "public static Node newNode(char key) {\n                Node temp = new Node();\n                temp.data = key;\n                temp.next = null;\n                return temp;\n        }\npublic static void printlist(Node head) {\n                if (head == null) {\n                        System.out.println(\"Empty List\");\n                        return;\n                }\n                while (head != null) {\n                        System.out.print(head.data +\" \");\n                        if (head.next != null)\n                                System.out.print(\"-> \");\n                        head = head.next;\n                }\n                System.out.println();\n        }\npublic static boolean isVowel(char x) {\n                return (x == 'a' x == 'e' x == 'i' x == 'o' x == 'u');\n        }\npublic static Node arrange(Node head) {\n                Node newHead = head;\n                Node latestVowel;\n                Node curr = head;\n                if (head == null)\n                        return null;\n                if (isVowel(head.data) == true)\n                        latestVowel = head;\n                else {\n                        while (curr.next != null &&\n                                !isVowel(curr.next.data))\n                                curr = curr.next;\n                        if (curr.next == null)\n                                return head;\n                        latestVowel = newHead = curr.next;\n                        curr.next = curr.next.next;\n                        latestVowel.next = head;\n                }\n                while (curr != null && curr.next != null) {\n                        if (isVowel(curr.next.data) == true) {\n                                if (curr == latestVowel) {\n                                        latestVowel = curr = curr.next;\n                                } else {\n                                        Node temp = latestVowel.next;\n                                        latestVowel.next = curr.next;\n                                        latestVowel = latestVowel.next;\n                                        curr.next = curr.next.next;\n                                        latestVowel.next = temp;\n                                }\n                        } else {\n                                curr = curr.next;\n                        }\n                }\n                return newHead;\n        }", "5": "public static Node newNode(int data) {\n        Node temp = new Node();\n        temp.data = data;\n        temp.right = null;\n        temp.left = null;\n        return temp;\n}\npublic static Node KthLargestUsingMorrisTraversal(Node root, int k) {\n        Node curr = root;\n        Node Klargest = null;\n        int count = 0;\n        while (curr != null) {\n                if (curr.right == null) {\n                        if (++count == k)\n                                Klargest = curr;\n                        curr = curr.left;\n                }\n                else {\n                        Node succ = curr.right;\n                        while (succ.left != null && succ.left != curr)\n                                succ = succ.left;\n                        if (succ.left == null) {\n                                succ.left = curr;\n                                curr = curr.right;\n                        }\n                        else {\n                                succ.left = null;\n                                if (++count == k)\n                                        Klargest = curr;\n                                curr = curr.left;\n                        }\n                }\n        }\n        return Klargest;\n}", "6": "public static void sortByRow(int [][]mat, int n)\n        {\n        for (int i = 0; i < n ; i++)\n                {\n                for(int j = 0; j < n - 1; j++)\n                {\n                        if(mat[i][j] > mat[i][j + 1])\n                        {\n                                var temp = mat[i][j];\n                                mat[i][j] = mat[i][j + 1];\n                                mat[i][j + 1] = temp;\n                        }\n                }\n                }\n        }\npublic static void transpose(int [][]mat, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        for (int j = i + 1; j < n; j++)\n                                {\n                                        var temp = mat[i][j];\n                                        mat[i][j] = mat[j][i];\n                                        mat[j][i] = temp;\n                                }\n        }\npublic static void sortMatRowAndColWise(int [][]mat, int n)\n        {\n                sortByRow(mat, n);\n                transpose(mat, n);\n                sortByRow(mat, n);\n                transpose(mat, n);\n        }\npublic static void printMat(int [][]mat, int n)\n        {\n                for (int i = 0; i < n; i++)\n                {\n                        for (int j = 0; j < n; j++)\n                                System.out.print(mat[i][j] + \" \");\n                        System.out.print(\"\\n\");\n                }\n        }", "7": "public static void doublyEven(int n)\n{\n        int[][] arr = new int[n][n];\n        int i, j;\n        for (i = 0; i < n; i++)\n        {\n                for (j = 0; j < n; j++)\n                {\n                        arr[i][j] = (n * i) + j + 1;\n                }\n        }\n        for (i = 0; i < n / 4; i++)\n        {\n                for (j = 0; j < n / 4; j++)\n                {\n                        arr[i][j] = (n * n + 1) - arr[i][j];\n                }\n        }\n        for (i = 0; i < n / 4; i++)\n        {\n                for (j = 3 * (n / 4); j < n; j++)\n                {\n                        arr[i][j] = (n * n + 1) - arr[i][j];\n                }\n        }\n        for (i = 3 * n / 4; i < n; i++)\n        {\n                for (j = 0; j < n / 4; j++)\n                {\n                        arr[i][j] = (n * n + 1) - arr[i][j];\n                }\n        }\n        for (i = 3 * n / 4; i < n; i++)\n        {\n                for (j = 3 * n / 4; j < n; j++)\n                {\n                        arr[i][j] = (n * n + 1) - arr[i][j];\n                }\n        }\n        for (i = n / 4; i < 3 * n / 4; i++)\n        {\n                for (j = n / 4; j < 3 * n / 4; j++)\n                {\n                        arr[i][j] = (n * n + 1) - arr[i][j];\n                }\n        }\n        for (i = 0; i < n; i++)\n        {\n                for (j = 0; j < n; j++)\n                {\n                        System.out.print(arr[i][j] + \" \" + \" \");\n                }\n                System.out.println();\n        }\n}", "8": "public static void kroneckerproduct(int[][] A, int[][] B) {\n        int[][] C = new int[A.length * B.length][A[0].length * B[0].length];\n        for (int i = 0; i < A.length; i++) {\n                for (int k = 0; k < B.length; k++) {\n                        for (int j = 0; j < A[0].length; j++) {\n                                for (int l = 0; l < B[0].length; l++) {\n                                        C[i + l + 1][j + k + 1] = A[i][j] *\n                                                                                                B[k][l];\n                                        System.out.print(C[i + l + 1][j + k + 1] + \" \");\n                                }\n                        }\n                        System.out.println();\n                }\n        }\n}", "9": "public static boolean isLowerTriangularMatrix(int[][] mat) \n    { \n        for (int i = 0; i < N; i++) \n            for (int j = i + 1; j < N; j++) \n                if (mat[i][j] != 0) \n                    return false; \n        return true; \n    }", "10": "public static boolean isUpperTriangularMatrix(int [][]mat)\n        {\n                for (int i = 1; i < N ; i++)\n                        for (int j = 0; j < i; j++)\n                                if (mat[i][j] != 0)\n                                        return false;\n                return true;\n        }", "11": "static long countSets(int [][]a)\n        {\n                long res = 0;\n                for (int i = 0; i < n; i++)\n                {\n                        int u = 0, v = 0;\n                        for (int j = 0; j < m; j++)\n                        {\n                                if (a[i][j] == 1)\n                                        u++;\n                                else\n                                        v++;\n                        }\n                        res += (long)(Math.Pow(2, u) - 1\n                                        + Math.Pow(2, v)) - 1;\n                }\n                for (int i = 0; i < m; i++)\n                {\n                        int u = 0, v = 0;\n                        for (int j = 0; j < n; j++)\n                        {\n                                if (a[j][i] == 1)\n                                        u++;\n                                else\n                                        v++;\n                        }\n                        res += (long)(Math.Pow(2, u) - 1\n                                        + Math.Pow(2, v)) - 1;\n                }\n                return res - (n * m);\n        }", "12": "public static void transpose(int [][]mat, int [][]tr, int N)\n        {\n                for (int i = 0; i < N; i++)\n                        for (int j = 0; j < N; j++)\n                                tr[i][j] = mat[j][i];\n        }\npublic static boolean isSymmetric(int [][]mat, int N)\n        {\n                int [][]tr = new int[N][MAX];\n                transpose(mat, tr, N);\n                for (int i = 0; i < N; i++)\n                        for (int j = 0; j < N; j++)\n                                if (mat[i][j] != tr[i][j])\n                                        return false;\n                return true;\n        }", "13": "static boolean isSymmetric(int [][]mat, int N)\n        {\n                for (int i = 0; i < N; i++)\n                        for (int j = 0; j < N; j++)\n                                if (mat[i][j] != mat[j][i])\n                                        return false;\n                return true;\n        }", "14": "public static int findNormal(int[][] mat, int n) {\n        int sum = 0;\n        for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                        sum += mat[i][j] * mat[i][j];\n        return (int)Math.sqrt(sum);\n}\n\npublic static int findTrace(int[][] mat, int n) {\n        int sum = 0;\n        for (int i = 0; i < n; i++)\n                sum += mat[i][i];\n        return sum;\n}", "15": "static int maxDet(int n)\n{\n        return (2 * n * n * n);\n}\nvoid resMatrix(int n)\n{\n        for (int i = 0; i < 3; i++)\n        {\n                for (int j = 0; j < 3; j++)\n                {\n                        if (i == 0 && j == 2)\n                                System.out.print(\"0 \");\n                        else if (i == 1 && j == 0)\n                                System.out.print(\"0 \");\n                        else if (i == 2 && j == 1)\n                                System.out.print(\"0 \");\n                        else\n                                System.out.print(n +\" \");\n                }\n                System.out.println(\"\");\n        }\n}", "16": "static int countNegative(int[][] M, int n, int m)\n        {\n                int count = 0;\n                for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < m; j++) {\n                                if (M[i][j] < 0)\n                                        count += 1;\n                                else\n                                        break;\n                        }\n                }\n                return count;\n        }", "17": "public static int countNegative(int[][] M, int n, int m)\n        {\n                int count = 0;\n                int i = 0;\n                int j = m - 1;\n                while (j >= 0 && i < n) {\n                        if (M[i][j] < 0) {\n                                count += j + 1;\n                                i += 1;\n                        }\n                        else\n                                j -= 1;\n                }\n                return count;\n        }", "18": "public static int getLastNegativeIndex(int []array, int start, int end)\n        {\n                if (start == end)\n                {\n                        return start;\n                }\n                int mid = start + (end - start) / 2;\n                if (array[mid] < 0)\n                {\n                        if (mid + 1 < array.length && array[mid + 1] >= 0)\n                        {\n                                return mid;\n                        }\n                        return getLastNegativeIndex(array, mid + 1, end);\n                }\n                else\n                {\n                        return getLastNegativeIndex(array, start, mid - 1);\n                }\n        }\npublic static int countNegative(int [][]M, int n, int m)\n        {\n                int count = 0;\n                int nextEnd = m - 1;\n                for (int i = 0; i < n; i++)\n                {\n                        if (M[i][0] >= 0)\n                        {\n                                break;\n                        }\n                        nextEnd = getLastNegativeIndex(M[i], 0, nextEnd);\n                        count += nextEnd + 1;\n                }\n                return count;\n        }", "19": "static int findMaxValue(int N, int [][]mat)\n        {\n                int maxValue = Integer.MIN_VALUE;\n                for (int a = 0; a< N - 1; a++)\n                for (int b = 0; b < N - 1; b++)\n                        for (int d = a + 1; d < N; d++)\n                        for (int e = b + 1; e < N; e++)\n                                if (maxValue < (mat[d][e] - mat[a][b]))\n                                        maxValue = mat[d][e] -\n                                                        mat[a][b];\n                return maxValue;\n        }", "20": "static int findMaxValue(int N, int [][]mat)\n        {\n                int maxValue = Integer.MIN_VALUE;\n                int [][]maxArr = new int[N][N];\n                maxArr[N - 1][N - 1] = mat[N - 1][N - 1];\n                int maxv = mat[N - 1][N - 1];\n                for (int j = N - 2; j >= 0; j--)\n                {\n                        if (mat[N - 1][j] > maxv)\n                                maxv = mat[N - 1][j];\n                        maxArr[N - 1][j] = maxv;\n                }\n                maxv = mat[N - 1][N - 1];\n                for (int i = N - 2; i >= 0; i--)\n                {\n                        if (mat[i][N - 1] > maxv)\n                                maxv = mat[i][N - 1];\n                        maxArr[i][N - 1] = maxv;\n                }\n                for (int i = N - 2; i >= 0; i--)\n                {\n                        for (int j = N - 2; j >= 0; j--)\n                        {\n                                if (maxArr[i + 1][j + 1] - mat[i][j] > maxValue)\n                                        maxValue = maxArr[i + 1][j + 1] -\n                                                                                mat[i][j];\n                                maxArr[i][j] = Math.max(mat[i][j],\n                                                        Math.max(maxArr[i][j + 1], maxArr[i + 1][j]) );\n                        }\n                }\n                return maxValue;\n        }", "21": "static void youngify(int [][]mat, int i, int j)\n        {\n                int downVal = (i + 1 < N) ?\n                                        mat[i + 1][j] : INF;\n                int rightVal = (j + 1 < N) ?\n                                        mat[i][j + 1] : INF;\n                if (downVal == INF && rightVal == INF)\n                {\n                        return;\n                }\n                if (downVal < rightVal)\n                {\n                        mat[i][j] = downVal;\n                        mat[i + 1][j] = INF;\n                        youngify(mat, i + 1, j);\n                }\n                else\n                {\n                        mat[i][j] = rightVal;\n                        mat[i][j + 1] = INF;\n                        youngify(mat, i, j + 1);\n                }\n        }\nstatic int extractMin(int [][]mat)\n        {\n                int ret = mat[0][0];\n                mat[0][0] = INF;\n                youngify(mat, 0, 0);\n                return ret;\n        }\nstatic void printSorted(int [][]mat)\n        {\n                        System.out.println(\"Elements of matrix in sorted order n\");\n                for (int i = 0; i < N * N; i++)\n                {\n                        System.out.println(extractMin(mat) + \" \");\n                }\n        }", "22": "static void printSumSimple(int [][]mat, int k)\n        {\n                if (k > n) return;\n                for (int i = 0; i < n-k+1; i++)\n                {\n                        for (int j = 0; j < n-k+1; j++)\n                        {\n                                int sum = 0;\n                                for (int p = i; p < k+i; p++)\n                                        for (int q = j; q < k+j; q++)\n                                                sum += mat[p][q];\n                                System.out.print(sum+ \" \");\n                        }\n                        System.out.println();\n                }\n        }", "23": "static void printSumTricky(int [][]mat, int k)\n        {\n                if (k > n)\n                return;\n                int [][]stripSum = new int[n][n];\n                for (int j = 0; j < n; j++)\n                {\n                        int sum = 0;\n                        for (int i = 0; i < k; i++)\n                                sum += mat[i][j];\n                        stripSum[0][j] = sum;\n                        for (int i = 1; i < n - k + 1; i++)\n                        {\n                                sum += (mat[i + k - 1][j] - mat[i - 1][j]);\n                                stripSum[i][j] = sum;\n                        }\n                }\n                for (int i = 0; i < n - k + 1; i++)\n                {\n                        int sum = 0;\n                        for (int j = 0; j < k; j++)\n                                sum += stripSum[i][j];\n                        System.out.print(sum + \" \");\n                        for (int j = 1; j < n - k + 1; j++)\n                        {\n                                sum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n                                System.out.print(sum + \" \");\n                        }\n                        System.out.println();\n                }\n        }", "24": "public static void transpose(int [][] A, int [][] B){\n        for(int i = 0; i < A.length; i++){\n                for(int j = 0; j < A[0].length; j++){\n                        B[i][j] = A[j][i];\n                }\n        }\n}", "25": "public static void transpose(int [][]A)\n        {\n                for (int i = 0; i < N; i++)\n                        for (int j = i+1; j < N; j++)\n                        {\n                                int temp = A[i][j];\n                                A[i][j] = A[j][i];\n                                A[j][i] = temp;\n                        }\n        }", "26": "public static int pathCountRec(int[][] mat, int m, int n, int k)\n        {\n                if (m < 0 n < 0)\n                {\n                        return 0;\n                }\n                if (m == 0 && n == 0 && (k == mat[m][n]))\n                {\n                        return 1;\n                }\n                return pathCountRec(mat, m - 1, n, k - mat[m][n])\n                                + pathCountRec(mat, m, n - 1, k - mat[m][n]);\n        }\npublic static int pathCount(int[][] mat, int k)\n        {\n                return pathCountRec(mat, R - 1, C - 1, k);\n        }", "27": "static int pathCountDPRecDP(int [][]mat, int m, int n, int k)\n        {\n                if (m < 0 n < 0) return 0;\n                if (m == 0 && n == 0)\n                        return (k == mat[m][n] ? 1 : 0);\n                if (dp[m][n][k] != -1) return dp[m][n][k];\n                dp[m][n][k] = pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) +\n                                        pathCountDPRecDP(mat, m, n - 1, k - mat[m][n]);\n                return dp[m][n][k];\n        }\nstatic int pathCountDP(int [][]mat, int k)\n        {\n                for(int i = 0; i < R; i++)\n                        for(int j = 0; j < C; j++)\n                                for(int l = 0; l < MAX_K; l++)\n                                dp[i][j][l] = -1;\n                return pathCountDPRecDP(mat, R - 1, C - 1, k);\n        }", "28": "public static int countMinReversals(String expr)\n{\n        int len = expr.length();\n        if (len % 2 != 0)\n        {\n                return -1;\n        }\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < len; i++)\n        {\n                char c = expr.charAt(i);\n                if (c == '}' && s.size() > 0)\n                {\n                        if (s.peek() == '{')\n                        {\n                                s.pop();\n                        }\n                        else\n                        {\n                                s.push(c);\n                        }\n                }\n                else\n                {\n                        s.push(c);\n                }\n        }\n        int red_len = s.size();\n        int n = 0;\n        while (s.size() > 0 && s.peek() == '{')\n        {\n                s.pop();\n                n++;\n        }\n        return (red_len / 2 + n % 2);\n}", "29": "public static int countMinReversals(String expr) {\n        int len = expr.length();\n        int ans;\n        if (len % 2 != 0) {\n                return -1;\n        }\n        int left_brace = 0, right_brace = 0;\n        for (int i = 0; i < len; i++) {\n                char ch = expr[i];\n                if (ch == '{') {\n                        left_brace++;\n                }\n                else {\n                        if (left_brace == 0) {\n                                right_brace++;\n                        }\n                        else {\n                                left_brace--;\n                        }\n                }\n        }\n        ans = (int)(Math.ceil((0.0 + left_brace) / 2)\n                                + Math.ceil((0.0 + right_brace) / 2));\n        return ans;\n}", "30": "static void printMinNumberForPattern(String arr)\n        {\n                int curr_max = 0;\n                int last_entry = 0;\n                int j;\n                for (int i = 0; i < arr.length(); i++)\n                {\n                        int noOfNextD = 0;\n                        switch (arr.charAt(i))\n                        {\n                                case 'I':\n                                        j = i + 1;\n                                        while (j < arr.length() && arr.charAt(j) == 'D')\n                                        {\n                                                noOfNextD++;\n                                                j++;\n                                        }\n                                        if (i == 0)\n                                        {\n                                                curr_max = noOfNextD + 2;\n                                                System.out.print(\" \" + ++last_entry);\n                                                System.out.print(\" \" + curr_max);\n                                                last_entry = curr_max;\n                                        }\n                                        else\n                                        {\n                                                curr_max = curr_max + noOfNextD + 1;\n                                                last_entry = curr_max;\n                                                System.out.print(\" \" + last_entry);\n                                        }\n                                        for (int k = 0; k < noOfNextD; k++)\n                                        {\n                                                System.out.print(\" \" + --last_entry);\n                                                i++;\n                                        }\n                                        break;\n                                case 'D':\n                                        if (i == 0)\n                                        {\n                                                j = i + 1;\n                                                while (j < arr.length()&&arr.charAt(j) == 'D')\n                                                {\n                                                        noOfNextD++;\n                                                        j++;\n                                                }\n                                                curr_max = noOfNextD + 2;\n                                                System.out.print(\" \" + curr_max + \" \" + (curr_max - 1));\n                                                last_entry = curr_max - 1;\n                                        }\n                                        else\n                                        {\n                                                System.out.print(\" \" + (last_entry - 1));\n                                                last_entry--;\n                                        }\n                                        break;\n                        }\n                }\n                System.out.println();\n        }", "31": "static void printLeast(String arr)\n{\n        int min_avail = 1, pos_of_I = 0;\n        List<int> al = new ArrayList<int>();\n        if (arr.charAt(0) == 'I')\n        {\n                al.add(1);\n                al.add(2);\n                min_avail = 3;\n                pos_of_I = 1;\n        }\n        else\n        {\n                al.add(2);\n                al.add(1);\n                min_avail = 3;\n                pos_of_I = 0;\n        }\n        for (int i = 1; i < arr.length(); i++)\n        {\n                if (arr.charAt(i) == 'I')\n                {\n                        al.add(min_avail);\n                        min_avail++;\n                        pos_of_I = i + 1;\n                }\n                else\n                {\n                        al.add(al.get(i));\n                        for (int j = pos_of_I; j <= i; j++)\n                                al.set(j, al.get(j) + 1);\n                        min_avail++;\n                }\n        }\n        for (int i = 0; i < al.size(); i++)\n                System.out.print(al.get(i) + \" \");\n        System.out.println();\n}", "32": "public static void printMinNumberForPattern(String seq) {\n                String result = \"\";\n                Stack stk = new Stack();\n                for (int i = 0; i <= seq.length(); i++) {\n                        stk.push(i + 1);\n                        if (i == seq.length() || seq.charAt(i) == 'I') {\n                                while (stk.size() != 0) {\n                                        result += stk.peek();\n                                        result += \" \";\n                                        stk.pop();\n                                }\n                        }\n                }\n                System.out.println(result);\n        }", "33": "static String getMinNumberForPattern(String seq)\n{\n        int n = seq.length();\n        if (n >= 9)\n                return \"-1\";\n        char []result = new char[n + 1];\n        int count = 1;\n        for (int i = 0; i <= n; i++)\n        {\n                if (i == n || seq.charAt(i) == 'I')\n                {\n                        for (int j = i - 1; j >= -1; j--)\n                        {\n                                result[j + 1] = (char) ((int) '0' + count++);\n                                if (j >= 0 && seq.charAt(j) == 'I')\n                                        break;\n                        }\n                }\n        }\n        return new String(result);\n}", "34": "public static int subset(int []ar, int n)\n        {\n                int res = 0;\n                Arrays.sort(ar);\n                for (int i = 0; i < n; i++) {\n                        int count = 1;\n                        for ( ; i < n - 1; i++) {\n                                if (ar[i] == ar[i + 1])\n                                        count++;\n                                else\n                                        break;\n                        }\n                        res = Math.max(res, count);\n                }\n                return res;\n        }", "35": "static int subset(int []arr, int n)\n{\n        Map<Integer,\n               Integer> mp = new HashMap<Integer,\n                                                                 Integer>();\n        for (int i = 0 ; i < n; i++)\n        {\n                if(mp.containsKey(arr[i]))\n                {\n                        var val = mp.get(arr[i]);\n                        mp.remove(arr[i]);\n                        mp.add(arr[i], val + 1);\n                }\n                else\n                {\n                        mp.add(arr[i], 1);\n                }\n        }\n        int res = 0;\n        for(Map.Entry<Integer, Integer> entry : mp.entrySet())\n                res = Math.max(res, entry.getValue());\n        return res;\n}", "36": "public static boolean areElementsContiguous(int []arr, int n)\n    {\n    Arrays.sort(arr);\n    for (int i = 1; i < n; i++)\n            if (arr[i] - arr[i - 1] > 1)\n                    return false;\n    return true;\n    }", "37": "public static boolean areElementsContiguous(int[] arr, int n) {\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++) {\n                max = Math.max(max, arr[i]);\n                min = Math.min(min, arr[i]);\n        }\n        int m = max - min + 1;\n        if (m > n)\n                return false;\n        boolean []visited = new boolean[n];\n        for (int i = 0; i < n; i++)\n                visited[arr[i] - min] = true;\n        for (int i = 0; i < m; i++)\n                if (visited[i] == false)\n                        return false;\n        return true;\n}", "38": "public static boolean areElementsContiguous(int[] arr, int n)\n        {\n                HashSet<Integer> us = new HashSet<Integer>();\n                for (int i = 0; i < n; i++)\n                {\n                        us.add(arr[i]);\n                }\n                int count = 1;\n                int curr_ele = arr[0] - 1;\n                while (us.contains(curr_ele) == true)\n                {\n                        count++;\n                        curr_ele--;\n                }\n                curr_ele = arr[0] + 1;\n                while (us.contains(curr_ele) == true)\n                {\n                        count++;\n                        curr_ele++;\n                }\n                return (count == (us.size()));\n        }", "39": "public static void longest(int []a, int n, int k)\n{\n        int[] freq = new int[7];\n        int start = 0, end = 0, now = 0, l = 0;\n        for (int i = 0; i < n; i++)\n        {\n                freq[a[i]]++;\n                if (freq[a[i]] == 1)\n                        now++;\n                while (now > k)\n                {\n                        freq[a[l]]--;\n                        if (freq[a[l]] == 0)\n                                now--;\n                        l++;\n                }\n                if (i - l + 1 >= end - start + 1)\n                {\n                        end = i;\n                        start = l;\n                }\n        }\n        for (int i = start; i <= end; i++)\n                System.out.print(a[i]+\" \");\n}", "40": "    static void findSmallestRange(int[][] arr, int n, int k) {\n        int i, minval, maxval, minrange,\n                minel = 0, maxel = 0, flag, minind;\n        for (i = 0; i <= k; i++) {\n                ptr[i] = 0;\n        }\n        minrange = Integer.MAX_VALUE;\n        while (true) {\n                minind = -1;\n                minval = Integer.MAX_VALUE;\n                maxval = Integer.MIN_VALUE;\n                flag = 0;\n                for (i = 0; i < k; i++) {\n                        if (ptr[i] == n) {\n                                flag = 1;\n                                break;\n                        }\n                        if (ptr[i] < n && arr[i][ptr[i]] < minval) {\n                                minind = i;\n                                minval = arr[i][ptr[i]];\n                        }\n                        if (ptr[i] < n && arr[i][ptr[i]] > maxval) {\n                                maxval = arr[i][ptr[i]];\n                        }\n                }\n                if (flag == 1) {\n                        break;\n                }\n                ptr[minind]++;\n                if ((maxval - minval) < minrange) {\n                        minel = minval;\n                        maxel = maxval;\n                        minrange = maxel - minel;\n                }\n        }\n        System.out.println(\"The smallest range is\" + \"[\" + minel + \", \" + maxel + \"]\\n\");\n}", "41": "static int findLargest(int []S, int n)\n{\n        boolean found = false;\n        Arrays.sort(S);\n        for (int i = n - 1; i >= 0; i--)\n        {\n                for (int j = 0; j < n; j++)\n                {\n                        if (i == j)\n                                continue;\n                        for (int k = j + 1; k < n; k++)\n                        {\n                                if (i == k)\n                                        continue;\n                                for (int l = k + 1; l < n; l++)\n                                {\n                                        if (i == l)\n                                                continue;\n                                        if (S[i] == S[j] + S[k] + S[l])\n                                        {\n                                                found = true;\n                                                return S[i];\n                                        }\n                                }\n                        }\n                }\n        }\n        if (found == false)\n                return Integer.MAX_VALUE;\n        return -1;\n}", "42": "public static int findFourElements(int[] arr, int n) {\n        HashMap<Integer, Indexes> map = new HashMap<Integer, Indexes>();\n        for (int i = 0; i < n - 1; i++) {\n                for (int j = i + 1; j < n; j++) {\n                        map.put(arr[i] + arr[j], new Indexes(i, j));\n                }\n        }\n        int d = Integer.MIN_VALUE;\n        for (int i = 0; i < n - 1; i++) {\n                for (int j = i + 1; j < n; j++) {\n                        int abs_diff = Math.abs(arr[i] - arr[j]);\n                        if (map.containskey(abs_diff)) {\n                                Indexes indexes = map.get(abs_diff);\n                                if (indexes.getI() != i &&\n                                                indexes.getI() != j &&\n                                                indexes.getJ() != i &&\n                                                indexes.getJ() != j) {\n                                        d = Math.max(d, Math.max(arr[i], arr[j]));\n                                }\n                        }\n                }\n        }\n        return d;\n}", "43": "static void leftRotatebyOne(int[] arr, int n)\n        {\n                int i, temp = arr[0];\n                for (i = 0; i < n - 1; i++)\n                        arr[i] = arr[i + 1];\n                arr[n-1] = temp;\n        }\nstatic void leftRotate(int[] arr, int d, int n)\n        {\n                for (int i = 0; i < d; i++)\n                        leftRotatebyOne(arr, n);\n        }\nstatic void printArray(int[] arr, int size)\n        {\n                for (int i = 0; i < size; i++)\n                        System.out.print(arr[i] + \" \");\n        }", "44": "static void pushZerosToEnd(int []arr, int n)\n        {\n                int count = 0;\n                for (int i = 0; i < n; i++)\n                if (arr[i] != 0)\n                arr[count++] = arr[i];\n                while (count < n)\n                arr[count++] = 0;\n        }", "45": "static void moveZerosToEnd(int[] arr, int n)\n        {\n                int count = 0;\n                int temp;\n                for (int i = 0; i < n; i++)\n                {\n                        if ((arr[i] != 0))\n                        {\n                                temp = arr[count];\n                                arr[count] = arr[i];\n                                arr[i] = temp;\n                                count = count + 1;\n                        }\n                }\n        }\nstatic void printArray(int[] arr, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        System.out.print(arr[i] + \" \");\n        }", "46": "public static void pushZerosToEnd(int[] arr, int n)\n        {\n                int count = 0;\n                for (int i = 0; i < n; i++)\n                        if (arr[i] != 0)\n                                arr[count++] = arr[i];\n                while (count < n)\n                        arr[count++] = 0;\n        }\npublic static void modifyAndRearrangeArr(int[] arr, int n)\n        {\n                if (n == 1)\n                        return;\n                for (int i = 0; i < n - 1; i++) {\n                        if ((arr[i] != 0) && (arr[i] == arr[i + 1])) {\n                                arr[i] = 2 * arr[i];\n                                arr[i + 1] = 0;\n                                i++;\n                        }\n                }\n                pushZerosToEnd(arr, n);\n        }\npublic static void printArray(int[] arr, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        System.out.print(arr[i] + \" \");\n                System.out.println();\n        }", "47": "public static void printArray(int[] arr, int n)\n        {\n                for (int i = 0; i < n; i++)\n                        System.out.print(arr[i] + \" \");\n                System.out.println();\n        }\npublic static void RearrangePosNeg(int[] arr, int n)\n        {\n                int key, j;\n                for (int i = 1; i < n; i++) {\n                        key = arr[i];\n                        if (key > 0)\n                                continue;\n                        j = i - 1;\n                        while (j >= 0 && arr[j] > 0) {\n                                arr[j + 1] = arr[j];\n                                j = j - 1;\n                        }\n                        arr[j + 1] = key;\n                }\n        }", "48": "static void printArray(int[] A, int size)\n        {\n                for (int i = 0; i < size; i++)\n                        System.out.print(A[i] + \" \");\n                System.out.println(\"\");\n        }\nstatic void reverse(int[] arr, int l, int r)\n        {\n                if (l < r) {\n                        arr = swap(arr, l, r);\n                        reverse(arr, ++l, --r);\n                }\n        }\nstatic void merge(int[] arr, int l, int m, int r)\n        {\nint i = l; \nint j = m + 1; \n                while (i <= m && arr[i] < 0)\n                        i++;\n                while (j <= r && arr[j] < 0)\n                        j++;\n                reverse(arr, i, m);\n                reverse(arr, m + 1, j - 1);\n                reverse(arr, i, j - 1);\n        }\nstatic void RearrangePosNeg(int[] arr, int l, int r)\n        {\n                if (l < r) {\n                        int m = l + (r - l) / 2;\n                        RearrangePosNeg(arr, l, m);\n                        RearrangePosNeg(arr, m + 1, r);\n                        merge(arr, l, m, r);\n                }\n        }\nstatic int[] swap(int[] arr, int i, int j)\n        {\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n                return arr;\n        }", "49": "public static void rearrangePosNeg(int[] arr)\n {\n        int i = 0;\n        int j = arr.Length - 1;\n        while(true)\n        {\n        while(arr[i]<0 && i<arr.Length)\n                i++;\n        while(arr[j]>0 && j>=0)\n                j--;\n        if(i<j)\n        {\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n        }\n        else\n                break;\n        }\n }"}}}